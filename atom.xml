<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>放码过来</title>
  <icon>https://www.gravatar.com/avatar/771a5b96a1b55228dbb1eeb23619ef45</icon>
  <subtitle>技术宅 huangyuan@huangyuanlove.com</subtitle>
  <link href="https://blog.huangyuanlove.com/atom.xml" rel="self"/>
  
  <link href="https://blog.huangyuanlove.com/"/>
  <updated>2024-06-26T06:42:35.749Z</updated>
  <id>https://blog.huangyuanlove.com/</id>
  
  <author>
    <name>HuangYuan_xuan</name>
    <email>huangyuan@huangyuanlove.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kotlin中的Unit和Nothing 关键字</title>
    <link href="https://blog.huangyuanlove.com/2024/06/14/kotlin%E4%B8%AD%E7%9A%84Unit%E5%92%8CNothing-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://blog.huangyuanlove.com/2024/06/14/kotlin%E4%B8%AD%E7%9A%84Unit%E5%92%8CNothing-%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2024-06-14T02:05:54.000Z</published>
    <updated>2024-06-26T06:42:35.749Z</updated>
    
    <content type="html"><![CDATA[<p>让我们先从 kotlin 的类型继承关系开始：众所周知，kotlin 中所有东西都有类型，对象、函数等等，就连 Unit，Nothing 也有对应的类型。我们来看一下kotlin 中的类型层次结构。</p><span id="more"></span><h3 id="从顶部开始"><a href="#从顶部开始" class="headerlink" title="从顶部开始"></a>从顶部开始</h3><p>所有类型的 Kotlin 对象都被组织成子类型&#x2F;超类型关系的层次结构。该层次结构的“顶部”是抽象类Any。例如，String 和 Int 类型都是的子类型Any。</p><pre><code class="mermaid" >graph BTString-->AnyInt-->Any</code></pre><p>这里的 Any 相当于 java 中的 Object，同样的，如果我们声明一个类，没有显式指定继承自哪个类，那这个类就是 Any 的直接子类。<br>如果该类指定了父类，那么 Any 会是该类的最终父类(祖先)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>(name:String):Person(name)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span></span>(name:String):Person(name)<br></code></pre></td></tr></table></figure><pre><code class="mermaid" >graph BTPerson --> AnyStudent-->PersonTeacher-->Person</code></pre><p>如果一个类实现了多个接口，那么它就会有多个直接父类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Run</span></span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fly</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> : <span class="hljs-type">Run</span>,<span class="hljs-type">Fly</span></span><br></code></pre></td></tr></table></figure><pre><code class="mermaid" >graph BTRun --> AnyFly --> AnyBird-->RunBird-->Fly</code></pre><p>Kotlin 类型检查器强制执行子类型&#x2F;父类型关系，我们可以将子类型存储到超类型变量中，反过来则不行，这和 java 是一样的逻辑。<br>另外，kotlin 中还有可空类型，上面我们提到的类型都是非空类型，可空类型只是在可空类型后面加了一个 <strong>?</strong>,</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> name :String =<span class="hljs-literal">null</span> <span class="hljs-comment">//错误：Null can not be a value of a non-null type String</span><br><span class="hljs-keyword">val</span> name :String? =<span class="hljs-literal">null</span> <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">var</span> s: String? = <span class="hljs-literal">null</span><br><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&quot;a&quot;</span><br>s = s2<br>s = <span class="hljs-literal">null</span><br>s2 = s<span class="hljs-comment">//错误：Type mismatch.Required:String， Found:String?</span><br><br></code></pre></td></tr></table></figure><p>从这个角度来看，我们可以认为(仅仅是可以认为)非空类型是对应可空类型的子类，因为非空类型可以赋值给对应的可空类型，反之则不行。</p><pre><code class="mermaid" >graph BTAny --> Any?String? --> Any?String-->AnyString-->String?</code></pre><h3 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h3><p>Kotlin中的Unit即相当于Java中的void关键字，用于表示返回空结果的函数。但这里有一些不一样的地方，当 Unit 用于函数返回值时，是可以省略不写的，但kotlin 还是会认为返回了 Unit。其次，Unit 是一个真实存在的类型，并且是一个单例的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun1</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun1&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun2</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun2&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Unit</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun3</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun3&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun4</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun3&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Unit</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> <span class="hljs-built_in">Unit</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;kotlin.Unit&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们发现，上面这几种写法，效果是一样的。但这里有一个点需要注意一下：<br>对于<code>unitFun2()</code>这个函数，跟在函数名后面的<code>Unit</code>表示返回值类型，而函数体里面的<code>return Unit</code>中的 Unit 是一个单例对象。虽然看起来什么也没有返回，但它确实返回的一个单例对象。<br>回到我们上面提到的可空类型上，一个比较边缘的 case:Unit?类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> nullableUnit:<span class="hljs-built_in">Unit</span>? = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>这个东西我从来没有使用过，是 kotlin 类型一致性的结果</p><pre><code class="mermaid" >graph BTAny --> Any?Unit? --> Any?Unit-->AnyUnit-->Unit?</code></pre><p>那 Unit 这个东西有什么用呢？为啥不沿用 java 中的 void ？<br>扔物线大佬在他的文章中给出了具体的回答：去特殊化，<code>Unit</code>去掉了无返回值的函数的特殊性，消除了有返回值和无返回值的函数的本质区别，这样很多事做起来就会更简单了。<br>例：有返回值的函数在重写时没有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">make</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-comment">// 合法</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Apple <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewWorldMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-comment">// 非法</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>    world.refresh();<br>  &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewWorldMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>    world.refresh();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//只能去写一行 return null 来手动实现接近于「什么都不返回」的效果</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maker</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: Any<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleMaker</span> : <span class="hljs-type">Maker</span></span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: Apple &#123;<br>    <span class="hljs-keyword">return</span> Apple()<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewWorldMaker</span> : <span class="hljs-type">Maker</span></span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span> &#123;<br>    world.refresh()<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maker</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: T<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleMaker</span> : <span class="hljs-type">Maker</span>&lt;<span class="hljs-type">Apple</span>&gt;</span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: Apple &#123;<br>    <span class="hljs-keyword">return</span> Apple()<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewWorldMaker</span> : <span class="hljs-type">Maker</span>&lt;<span class="hljs-type">Unit</span>&gt;</span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span> &#123;<br>    world.refresh()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例：函数类型的函数参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runTask</span><span class="hljs-params">(task: () -&gt; <span class="hljs-type">Any</span>)</span></span> &#123;<br>  <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = task()) &#123;<br>    <span class="hljs-built_in">Unit</span> -&gt; println(<span class="hljs-string">&quot;result is Unit&quot;</span>)<br>    String -&gt; println(<span class="hljs-string">&quot;result is a String: <span class="hljs-variable">$result</span>&quot;</span>)<br>    <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;result is an unknown type&quot;</span>)<br>  &#125;<br>&#125;<br><br>...<br><br>runTask &#123; &#125; <span class="hljs-comment">// () -&gt; Unit</span><br>runTask &#123; println(<span class="hljs-string">&quot;完成！&quot;</span>) &#125; <span class="hljs-comment">// () -&gt; String</span><br>runTask &#123; <span class="hljs-number">1</span> &#125; <span class="hljs-comment">// () -&gt; Int</span><br></code></pre></td></tr></table></figure><h3 id="Nothing"><a href="#Nothing" class="headerlink" title="Nothing"></a>Nothing</h3><p>这里抛出一个引子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fail</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Something went wrong&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的返回值是什么？它真的有返回值么？如果有，是什么类型？<br>实际上这个方法的返回值类型是<code>Nothing</code><br>kotlin中有这么一个方法:<code>TODO</code>,注意，这里的 TODO 是一个方法，而不是<code>//todo</code>这一个</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Nothing</span> = <span class="hljs-keyword">throw</span> NotImplementedError()<br></code></pre></td></tr></table></figure><p>我们来看一下 Nothing 定义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Nothing has no instances. You can use Nothing to represent &quot;a value that never exists&quot;: for example,</span><br><span class="hljs-comment"> * if a function has the return type of Nothing, it means that it never returns (always throws an exception).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nothing</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>()<br></code></pre></td></tr></table></figure><p>这个类无法创建出任何实例，所以所有 Nothing 类型的变量或者函数，都找不到可用的值。那这个东西有啥用？正如它的注释所说， 它可以作为函数「永不返回」的提示，也就是总是抛出异常。<br>那这个东西有啥用？<br>第一个作用就是作为函数「永不返回」的提示<br>第二个作用就是作为泛型对象的临时空白填充，比如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> emptyList: List&lt;<span class="hljs-built_in">Nothing</span>&gt; = listOf()<br><span class="hljs-keyword">var</span> apples: List&lt;Apple&gt; = emptyList<br><span class="hljs-keyword">var</span> users: List&lt;User&gt; = emptyList<br><span class="hljs-keyword">var</span> phones: List&lt;Phone&gt; = emptyList<br><span class="hljs-keyword">var</span> images: List&lt;Image&gt; = emptyList<br></code></pre></td></tr></table></figure><p>既省事，又省内存。当然也可以用在 Set、Map 中<br>第三个作用：语法的完整化<br>Nothing 的「是所有类型的子类型」这个特点，还帮助了 Kotlin 语法的完整化。在 Kotlin 的下层逻辑里，throw 这个关键字是有返回值的，它的返回值类型就是 Nothing。虽然说由于抛异常这件事已经跳出了程序的正常逻辑，所以 throw 返回不返回值、返回值类型是不是 Nothing 对于它本身都不重要，但它让类似 <code>TODO()</code>函数的写法成为了合法的。</p><pre><code class="mermaid" >graph BTString --> AnyInt --> AnyUnit --> AnyPerson --> AnyNothing --> PersonNothing --> UnitNothing --> IntNothing --> String</code></pre><p>参考<br><a href="http://natpryce.com/articles/000818.html">A Whirlwind Tour of the Kotlin Type Hierarchy</a><br><a href="https://rengwuxian.com/kotlin-unit/">Unit 为啥还能当函数参数？面向实用的 Kotlin Unit 详解</a><br><a href="https://rengwuxian.com/kotlin-nothing/">这玩意真的有用吗？对，是的！Kotlin 的 Nothing 详解</a></p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>泛型</p><ul><li><input type='checkbox' disabled='true' checked>逆变</input></li><li><input type='checkbox' disabled='true' checked>协变</input></li><li><input type='checkbox' disabled='true' checked>类型投影</input></li><li><input type='checkbox' disabled='true' checked>星投影</input></li><li><input type='checkbox' disabled='true' checked>泛型约束</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li><li><input type='checkbox' disabled='true' checked>object:匿名内部类、单例模式、伴生对象</input></li><li><input type='checkbox' disabled='true' checked>Unit、Nothing</input></li></ul></li><li><p>委托</p><ul><li><input type='checkbox' disabled='true' checked>委托类</input></li><li><input type='checkbox' disabled='true' checked>委托属性</input></li><li><input type='checkbox' disabled='true' checked>自定义委托</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>inline,noinline,crossinline</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;让我们先从 kotlin 的类型继承关系开始：众所周知，kotlin 中所有东西都有类型，对象、函数等等，就连 Unit，Nothing 也有对应的类型。我们来看一下kotlin 中的类型层次结构。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin中的 object 关键字</title>
    <link href="https://blog.huangyuanlove.com/2024/05/31/kotlin%E4%B8%AD%E7%9A%84-object-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://blog.huangyuanlove.com/2024/05/31/kotlin%E4%B8%AD%E7%9A%84-object-%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2024-05-31T01:45:56.000Z</published>
    <updated>2024-06-13T09:13:49.726Z</updated>
    
    <content type="html"><![CDATA[<p>kotlin 中的<code>object</code>关键字用处比较广泛，在官方文档<a href="https://book.kotlincn.net/text/object-declarations.html">对象表达式与对象声明</a>有详细的介绍，比如：创建匿名对象、创建匿名内部类并继承某个类，实现多个接口、使用匿名对象作为返回和值类型、从匿名对象访问变量、单例模式、数据对象、伴生对象等，不过文章是从<code>对象表达式</code>和<code>对象声明</code>角度来区分的。</p><span id="more"></span><h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>对象表达式可以用来创建匿名类，就是不用<code>class</code>来声明的类，当这个类只用一次的时候是很有帮助的。我们可以从头开始定义匿名类，也可以从现有类继承，还可以实现接口。匿名类的实例也称为匿名对象，因为它们是由表达式而不是名称定义的。</p><h4 id="创建匿名类"><a href="#创建匿名类" class="headerlink" title="创建匿名类"></a>创建匿名类</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> helloWorld = <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> hello = <span class="hljs-string">&quot;Hello&quot;</span><br>        <span class="hljs-keyword">val</span> world = <span class="hljs-string">&quot;World&quot;</span><br>        <span class="hljs-comment">//object expressions extend Any, so `override` is required on `toString()`</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-variable">$hello</span> <span class="hljs-variable">$world</span>&quot;</span><br>        &#125;<br>    &#125;<br>    println(helloWorld)<br>    println(helloWorld.javaClass.simpleName)<br>    println(helloWorld.javaClass.name)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这种方式在某种意义上和 js 中创建对象差不多，<code>helloWorld</code>这个实例的<code>helloWorld.javaClass.simpleName</code>是空的。当然了匿名类也是类，只是没有名字而已，当然做了继承其他类，实现其他接口。注意，同样只能单继承多实现，并且父类构造函数需要参数时可以传适当的构造参数。<br>比如这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnClickListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span>  <span class="hljs-title">OnLongClickListener</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLongClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span><br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnScroll</span></span>&#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onScroll</span><span class="hljs-params">(direction: <span class="hljs-type">Int</span>)</span></span><br>&#125;<br><span class="hljs-keyword">val</span> viewListener = <span class="hljs-keyword">object</span> : OnScroll(),OnLongClickListener, OnClickListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onScroll</span><span class="hljs-params">(direction: <span class="hljs-type">Int</span>)</span></span> &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;view clicked&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLongClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以直接当成参数传入调用的方法，都是一样的。本质上都是创建了一个对象。</p><h4 id="使用匿名对象作为返回值或类型"><a href="#使用匿名对象作为返回值或类型" class="headerlink" title="使用匿名对象作为返回值或类型"></a>使用匿名对象作为返回值或类型</h4><p>当匿名对象被用作局部或私有但非内联声明（函数或属性）的类型时，其所有成员都可通过该函数或属性访问：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span>= <span class="hljs-keyword">object</span> &#123;<br>       <span class="hljs-keyword">val</span> x = <span class="hljs-string">&quot;x&quot;</span><br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      println(getObject().x)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果方法供或者属性是 public 或者 private inline 时，它的实际类型可能如下：</p><ul><li>如果没有明确声明类型，则是<code>Any</code></li><li>如果只有一个父类或者一个接口，则是改父类或者接口类型</li><li>如果有一个父类和多个接口，则是方法明确返回的类型<br>比如<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC</span> </span>&#123;<br>    <span class="hljs-comment">// 返回值类型是 Any; 不能在其他方法中访问 x</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> x: String = <span class="hljs-string">&quot;x&quot;</span><br>    &#125;<br><br>    <span class="hljs-comment">// 返回值类型是 AA; 不能在其他方法中访问 x</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObjectAA</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span>: AA &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">funFromA</span><span class="hljs-params">()</span></span> &#123;&#125;<br>        <span class="hljs-keyword">val</span> x: String = <span class="hljs-string">&quot;x&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-comment">//这里会报错，访问不到 x 属性</span><br>            println(getObject().x)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回值类型是 BB; 不能在其他方法中访问 x</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObjectBB</span><span class="hljs-params">()</span></span>: BB = <span class="hljs-keyword">object</span>: AA, BB &#123; <span class="hljs-comment">// explicit return type is required</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">funFromA</span><span class="hljs-params">()</span></span> &#123;&#125;<br>        <span class="hljs-keyword">val</span> x: String = <span class="hljs-string">&quot;x&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-comment">//这里会报错，访问不到 x 属性</span><br>            println(getObject().x)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名对象访问变量"><a href="#匿名对象访问变量" class="headerlink" title="匿名对象访问变量"></a>匿名对象访问变量</h4>对象表达式中的代码可以访问来自包含它的作用域的变量：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AAA</span></span>&#123;<br>    <span class="hljs-keyword">val</span> x = <span class="hljs-string">&quot;x&quot;</span><br>    <span class="hljs-keyword">val</span> y = <span class="hljs-string">&quot;y&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> xx = x<span class="hljs-comment">//不报错</span><br>        <span class="hljs-keyword">val</span> yy = y<span class="hljs-comment">//不报错</span><br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AAAA</span></span>&#123;<br>        <span class="hljs-keyword">val</span> xx = x <span class="hljs-comment">//报错</span><br>    &#125;<br>    <span class="hljs-keyword">object</span> BBBB&#123;<br>        <span class="hljs-keyword">val</span> xx = x<span class="hljs-comment">//报错</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><h4 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h4><p>在Kotlin当中，要实现<code>单例模式</code>其实非常简单，我们直接用<code>object</code>修饰类即可,当然这个单例类也是可以有父类的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MyViewListener : OnClickListener, OnLongClickListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;view clicked&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLongClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;view long clicked&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;test&quot;</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调用的时候直接<code>类名.方法名</code>即可。这里有个注意点：对象声明不能在局部作用域（即不能直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中。</p><h4 id="数据对象-data-object"><a href="#数据对象-data-object" class="headerlink" title="数据对象(data object)"></a>数据对象(data object)</h4><p>当我们想要打印<code>object</code>对象声明时，字符串表示同时包含其名称和对象的哈希：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MyObject<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(MyObject) <span class="hljs-comment">// MyObject@3ac3fd8b</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以还用<code>data</code>关键字来修饰它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">object</span>  MyDataObject&#123;<br>    <span class="hljs-keyword">val</span> x = <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，编译器会为这个对象生成<code>toString()</code>方法，该方法只会返回对象名字。还有成对出现的<code>equals()/hashCode()</code>.这里有一点需要注意：<br>被重写的<code>equals()</code>方法会将所有相同名字的<code>data object</code>都返回<code>true</code>,这个解释不是太严谨，因为绝大部分情况下，<code>data object</code>是单例的，在运行时只会有一个对象，但我们可以通过平台相关的方法创建另外一个实例对象，比如 jvm 上的反射、序列化和反序列化等。因此，在比较<code>data object</code>是否相同时，请使用<code>==</code>而不是<code>===</code></p><h5 id="data-class-和-data-object-的不同"><a href="#data-class-和-data-object-的不同" class="headerlink" title="data class 和 data object 的不同"></a>data class 和 data object 的不同</h5><p>虽然数据类和数据对象经常一起使用，并且有一些相同点，但有些函数在<code>data object</code>中是不会生成的</p><ul><li>没有<code>copy()</code>方法，因为<code>data object</code>用作单例对象，所以不会生成该方法。如果允许创建另外个实例对象，则违反了该模式。</li><li>没有<code>componentN()</code>方法，该方法的一个简单的用法就是用于结构对象，允许一次性获取对象的所有属性值，并将它们作为单独的参数传递给函数或构造器。但由于<code>data object</code>没有属性，生成这些方法是没有意义的。</li></ul><h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><p>在<code>kotlin</code>中并没有<code>static</code>关键字,那么我们如何实现静态方法的效果？我们可以使用<code>companion</code>和<code>object</code>关键字达到这个效果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">MyClassOne</span></span>&#123;<br>    <span class="hljs-keyword">object</span> A&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createA</span><span class="hljs-params">()</span></span>: MyClassOne = MyClassOne()<br>    &#125;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> AA&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createAA</span><span class="hljs-params">()</span></span>: MyClassOne = MyClassOne()<br>    &#125;<br>&#125;<br>MyClassOne.A.createA()<br>MyClassOne.createAA()<br></code></pre></td></tr></table></figure><p>但是看反编译之后的代码，编译器还是为我们创建了<code>A</code>和<code>AA</code>两个类。如果在<code>jvm</code>平台，我们可以使用<code>@JvmStatic</code>注解，将伴生对象的成员生成为真正的静态方法和字段。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassOneJVMStatic</span></span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> AAA &#123;<br>        <span class="hljs-meta">@JvmStatic</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: MyClassOneJVMStatic = MyClassOneJVMStatic()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，对于上面<code>MyClassOne</code>中的<code>AA</code>是可以省略名字的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassTwo</span></span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: MyClassTwo = MyClassTwo()<br>    &#125;<br>&#125;<br>MyClassTwo.Companion.create()<span class="hljs-comment">//正确，但会提示Companion是不必要的</span><br>MyClassTwo.create()<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p>请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: T<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> : Factory&lt;MyClass&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: MyClass = MyClass()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> f: Factory&lt;MyClass&gt; = MyClass<br></code></pre></td></tr></table></figure><h3 id="对象表达式和对象声明之间的语义差异"><a href="#对象表达式和对象声明之间的语义差异" class="headerlink" title="对象表达式和对象声明之间的语义差异"></a>对象表达式和对象声明之间的语义差异</h3><p>对象表达式和对象声明之间有一个重要的语义差别：</p><ul><li>对象表达式是在使用他们的地方立即执行（及初始化）的。</li><li>对象声明是在第一次被访问到时延迟初始化的。</li><li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配 。</li></ul><p>参考：<br><a href="https://book.kotlincn.net/text/object-declarations.html">对象表达式与对象声明</a><br><a href="https://kotlinlang.org/docs/object-declarations.html">Object expressions and declarations</a><br><a href="https://book.kotlincn.net/text/java-to-kotlin-interop.html#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5">静态字段</a></p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>泛型</p><ul><li><input type='checkbox' disabled='true' checked>逆变</input></li><li><input type='checkbox' disabled='true' checked>协变</input></li><li><input type='checkbox' disabled='true' checked>类型投影</input></li><li><input type='checkbox' disabled='true' checked>星投影</input></li><li><input type='checkbox' disabled='true' checked>泛型约束</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li><li><input type='checkbox' disabled='true' checked>object:匿名内部类、单例模式、伴生对象</input></li></ul></li><li><p>委托</p><ul><li><input type='checkbox' disabled='true' checked>委托类</input></li><li><input type='checkbox' disabled='true' checked>委托属性</input></li><li><input type='checkbox' disabled='true' checked>自定义委托</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>Unit</li><li>Nothing</li><li>inline,noinline,crossinline</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;kotlin 中的&lt;code&gt;object&lt;/code&gt;关键字用处比较广泛，在官方文档&lt;a href=&quot;https://book.kotlincn.net/text/object-declarations.html&quot;&gt;对象表达式与对象声明&lt;/a&gt;有详细的介绍，比如：创建匿名对象、创建匿名内部类并继承某个类，实现多个接口、使用匿名对象作为返回和值类型、从匿名对象访问变量、单例模式、数据对象、伴生对象等，不过文章是从&lt;code&gt;对象表达式&lt;/code&gt;和&lt;code&gt;对象声明&lt;/code&gt;角度来区分的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin委托</title>
    <link href="https://blog.huangyuanlove.com/2024/05/27/kotlin%E5%A7%94%E6%89%98/"/>
    <id>https://blog.huangyuanlove.com/2024/05/27/kotlin%E5%A7%94%E6%89%98/</id>
    <published>2024-05-27T02:30:07.000Z</published>
    <updated>2024-05-30T08:55:33.981Z</updated>
    
    <content type="html"><![CDATA[<p>经常在 Kotlin 的源码三方库中看到<code>by</code>关键字，这种写法就是委托，主要有两个应用场景，一个是委托类，另一个是委托属性，每个场景中又有不同的用法，我们可以对比 Java 的委托来学习 Kotlin 的委托。</p><span id="more"></span><h3 id="委托-类委托、接口委托"><a href="#委托-类委托、接口委托" class="headerlink" title="委托(类委托、接口委托)"></a>委托(类委托、接口委托)</h3><p>其实我们在 Java 和 Android 中经常会用到委托，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Delegated</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Base</span>&#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Base</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseImpl</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>            <span class="hljs-built_in">this</span>.x = x;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Base</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Base base;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Derived</span><span class="hljs-params">(Base base)</span> &#123;<br>            <span class="hljs-built_in">this</span>.base = base;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            base.print();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们有一个接口<code>Base</code>，一个实现类<code>BaseImpl</code>。假如我们想要在实现类中添加一些方法，但又不想重新写一遍接口实现，第一种我们可以继承<code>BaseImpl</code>,另外一种就是实现接口<code>Base</code>，传入一个实现类的实例，将所有的接口请求都交给实现类的实例来完成。<br>虽然官方说<strong>委托模式已经证明是实现继承的一个很好的替代方式(The Delegation pattern has proven to be a good alternative to implementation inheritance)</strong>,但选择权还是在大家手上，看情况而定，没有银弹。<br>那么在 kotlin 中应该怎么写呢？如果我们用 java 的思想来写，无非就是换换关键字，然后一坨模板代码，其实在 kotlin 中是可以通过<code>by</code>关键字零模板代码支持的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseImpl</span></span>(<span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span>) : Base &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> &#123;<br>        println(x)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span></span>(b: Base) : Base <span class="hljs-keyword">by</span> b<br></code></pre></td></tr></table></figure><p><code>Derived</code>的超类型列表中的<code>by</code>子句表示<code>b</code>将会在<code>Derived</code>中内部存储， 并且编译器将生成转发给<code>b</code>的所有<code>Base</code>的方法。<br>这个就是 kotlin 中的委托，有的地方也叫委托类或者委托接口。<br>这里有一点需要注意下，覆盖(override)是符合预期的：编译器会使用 override 覆盖的实现而不是委托对象中的.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessageLine</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseImpl</span></span>(<span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span>) : Base &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span> &#123; println(x) &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessageLine</span><span class="hljs-params">()</span></span> &#123; println(x) &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived2</span></span>(b: Base) : Base <span class="hljs-keyword">by</span> b &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span> &#123; println(<span class="hljs-string">&quot;abc&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> b = BaseImpl(<span class="hljs-number">10</span>)<br>    Derived2(b).printMessage()<br>    Derived2(b).printMessageLine()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在<code>Derived2</code>中覆写了<code>printMessage</code>这个方法，那么在调用的时候，就是用的我们覆写的方法。</p><h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> p: String <span class="hljs-keyword">by</span> Delegate()<br>&#125;<br></code></pre></td></tr></table></figure><p>语法是：<code>val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</code>。在<code>by</code>后面的表达式是该<code>委托</code>， 因为属性对应的<code>get()</code>（与<code>set()</code>）会被委托给它的<code>getValue()</code>与<code>setValue()</code>方法。 属性的委托不必实现接口，但是需要提供一个<code>getValue()</code>函数（对于<code>var</code>属性还有<code>setValue()</code>）。<br>先从最简单的委托开始，最后再看自定义委托。</p><h4 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h4><p>借用官网的一个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>   <span class="hljs-keyword">var</span> newName: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>   <span class="hljs-meta">@Deprecated(<span class="hljs-string">&quot;Use &#x27;newName&#x27; instead&quot;</span>, ReplaceWith(<span class="hljs-string">&quot;newName&quot;</span>)</span>)<br>   <span class="hljs-keyword">var</span> oldName: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">this</span>::newName<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">val</span> myClass = MyClass()<br>   <span class="hljs-comment">// 通知：&#x27;oldName: Int&#x27; is deprecated.</span><br>   <span class="hljs-comment">// Use &#x27;newName&#x27; instead</span><br>   myClass.oldName = <span class="hljs-number">42</span><br>   println(myClass.newName) <span class="hljs-comment">// 42</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一种最简单的委托方式。通过查看对应的 java 代码，发现其实就是对同一个成员变量的读写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> newName;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNewName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.newName;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNewName</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>      <span class="hljs-built_in">this</span>.newName = var1;<br>   &#125;<br><br>   <span class="hljs-comment">/** <span class="hljs-doctag">@deprecated</span> */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOldName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.newName;<br>   &#125;<br><br>   <span class="hljs-comment">/** <span class="hljs-doctag">@deprecated</span> */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOldName</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>      <span class="hljs-built_in">this</span>.newName = var1;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MyClass</code>中的四个方法都是对<code>newName</code>这个字段的读写。</p><p>除此之外，委托属性可以是：</p><ul><li>顶层属性</li><li>同一个类的成员或扩展属性</li><li>另一个类的成员或扩展属性</li></ul><p>比如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> topLevelInt: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassWithDelegate</span></span>(<span class="hljs-keyword">val</span> anotherClassInt: <span class="hljs-built_in">Int</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>(<span class="hljs-keyword">var</span> memberInt: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> anotherClassInstance: ClassWithDelegate) &#123;<br>    <span class="hljs-keyword">var</span> delegatedToMember: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">this</span>::memberInt<span class="hljs-comment">//同一个类的成员</span><br>    <span class="hljs-keyword">var</span> delegatedToTopLevel: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> ::topLevelInt<span class="hljs-comment">//顶层属性</span><br><br>    <span class="hljs-keyword">val</span> delegatedToAnotherClass: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> anotherClassInstance::anotherClassInt<span class="hljs-comment">//另一个类的成员</span><br>&#125;<br><span class="hljs-keyword">var</span> MyClass.extDelegated: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> ::topLevelInt<span class="hljs-comment">//顶层属性</span><br></code></pre></td></tr></table></figure><p>这种委托方式在我们做版本升级修改字段时是挺常用的,将旧字段委托给新字段，并将旧字段标记为过时。</p><h4 id="懒加载委托"><a href="#懒加载委托" class="headerlink" title="懒加载委托"></a>懒加载委托</h4><p>这种方式就是当我们首次访问这个属性的时候才会去初始化这个属性，从而避免不必要的资源消耗，和我们用 java 写单例模式的懒加载是一样的。<br>只会在首次访问的时候初始化这个属性，然后缓存起来，下次访问时直接返回。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> lazyValue: String <span class="hljs-keyword">by</span> lazy &#123;<br>    println(<span class="hljs-string">&quot;computed!&quot;</span>)<br>    <span class="hljs-string">&quot;Hello&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(lazyValue)<br>    println(lazyValue)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 lazy 是一个高阶函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">lazy</span><span class="hljs-params">(initializer: () -&gt; <span class="hljs-type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">lazy</span><span class="hljs-params">(mode: <span class="hljs-type">LazyThreadSafetyMode</span>, initializer: () -&gt; <span class="hljs-type">T</span>)</span></span>: Lazy&lt;T&gt; =<br>    <span class="hljs-keyword">when</span> (mode) &#123;<br>        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)<br>        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)<br>        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到，lazy接收一个 mode 参数，如果没有传入的话，默认是<code>SynchronizedLazyImpl</code>线程安全的：该值只在一个线程中计算，但所有线程都会看到相同的值。如果初始化委托的同步锁不是必需的，这样可以让多个线程同时执行，那么将<code>LazyThreadSafetyMode.PUBLICATION</code>作为参数传给 lazy()。<br>如果我们确定初始化将总是发生在与属性使用位于相同的线程， 那么可以使用<code>LazyThreadSafetyMode.NONE</code>模式。它不会有任何线程安全的保证以及相关的开销。<br>所以这个参数的选择也要看具体应用场景。</p><h4 id="可观察委托"><a href="#可观察委托" class="headerlink" title="可观察委托"></a>可观察委托</h4><p>如果我们想要观察属性值的变化，可以使用<code>Delegates.observable()</code>，它接受两个参数：初始值与修改时处理程序（handler）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">ObservableItem</span></span>&#123;<br>    <span class="hljs-keyword">var</span> name :String <span class="hljs-keyword">by</span> Delegates.observable(<span class="hljs-string">&quot;initialValue&quot;</span>)&#123;<br>        prop,old,new-&gt;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$prop</span>  <span class="hljs-variable">$old</span> -&gt; <span class="hljs-variable">$new</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们给<code>name</code>赋值的时候，就会触发传入的处理程序，但这里我们只能观察到赋值，但并不能做拦截，如果想要截获取值并<strong>否决</strong>,可以使用<code>vetoable()</code></p><h4 id="可否决委托"><a href="#可否决委托" class="headerlink" title="可否决委托"></a>可否决委托</h4><p>如果我们想在观察属性值变化的同时决定是否使用新的值，可以使用<code>Delegates.vetoable</code>,同样的，它也接受两个参数：它接受两个参数：初始值与修改时处理程序（handler）。只不过这里的 handler 需要返回一个布尔值，告诉程序是否使用新值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VetoableItem</span></span>&#123;<br>    <span class="hljs-keyword">var</span> name :String <span class="hljs-keyword">by</span> Delegates.vetoable(<span class="hljs-string">&quot;initialValue&quot;</span>)&#123;<br>        prop,old,new-&gt;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$prop</span>  <span class="hljs-variable">$old</span> -&gt; <span class="hljs-variable">$new</span>&quot;</span>)<br>        new.length &gt; <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> vetoableItem = VetoableItem()<br>    println(vetoableItem.name)<br>    vetoableItem.name = <span class="hljs-string">&quot;123&quot;</span><br>    println(vetoableItem.name)<br>    vetoableItem.name = <span class="hljs-string">&quot;1234&quot;</span><br>    println(vetoableItem.name)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">// initialValue</span><br><span class="hljs-comment">// var com.huangyuanlove.VetoableItem.name: kotlin.String  initialValue -&gt; 123</span><br><span class="hljs-comment">// initialValue</span><br><span class="hljs-comment">// var com.huangyuanlove.VetoableItem.name: kotlin.String  initialValue -&gt; 1234</span><br><span class="hljs-comment">// 1234</span><br></code></pre></td></tr></table></figure><p>在这里，只有当<code>new</code>的长度大于 3 时，我们才会将<code>new</code>赋值给<code>name</code>，</p><h4 id="将属性储存在映射中"><a href="#将属性储存在映射中" class="headerlink" title="将属性储存在映射中"></a>将属性储存在映射中</h4><p>一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者执行其他“动态”任务的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapItem</span></span>(map: Map&lt;String,Any?&gt;)&#123;<br>    <span class="hljs-keyword">val</span> name: String <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">val</span> age:<span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">val</span> address:String <span class="hljs-keyword">by</span> map<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">val</span> map:Map&lt;String,Any?&gt; = mapOf(<br>    <span class="hljs-string">&quot;name&quot;</span> to <span class="hljs-string">&quot;xuan&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span> to <span class="hljs-number">18</span>,<br>  )<br>  <span class="hljs-keyword">val</span> mapItem = MapItem(map)<br>  println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mapItem.age&#125;</span>&quot;</span>)<br>  println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mapItem.age&#125;</span>  <span class="hljs-subst">$&#123;mapItem.address&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意，假如我们传入的<code>map</code>里面没有对应属性，当程序运行时，这个属性没有被使用是没问题的，比如上面打印<code>name</code>和<code>age</code>。但是当我们使用这个属性的时候，就是上面打印<code>address</code>,会抛出异常<code>Key address is missing in the map.</code>.另外一方面，我们将传入的 map 的值声明为了可空，这就意味着在调用出传入了空值，比如<code>&quot;address&quot; to null,</code>,代码是可以运行的，但对<code>address</code>这个属性做处理的时候会报空指针异常，这些都是需要额外注意的地方。<br>还有一点需要注意，如果是对于<code>var</code>属性，需要将<code>Map</code>替换成<code>MutableMap</code>,但是这样的话它们两个可是双向绑定的哟，比如下面这种</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutableMapItem</span></span>(map:MutableMap&lt;String,Any?&gt;)&#123;<br>    <span class="hljs-keyword">var</span> name: String <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">var</span> address: String <span class="hljs-keyword">by</span> map<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">val</span> map:MutableMap&lt;String,Any?&gt; = mutableMapOf(<br>        <span class="hljs-string">&quot;name&quot;</span> to <span class="hljs-string">&quot;xuan&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span> to <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&quot;address&quot;</span> to <span class="hljs-string">&quot;beijing&quot;</span><br>    )<br>    <span class="hljs-keyword">val</span> mutableMapItem = MutableMapItem(map)<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mutableMapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mutableMapItem.age&#125;</span> <span class="hljs-subst">$&#123;mutableMapItem.address&#125;</span>&quot;</span>)<br>    println(map)<br>    mutableMapItem.name = <span class="hljs-string">&quot;huang&quot;</span><br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mutableMapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mutableMapItem.age&#125;</span> <span class="hljs-subst">$&#123;mutableMapItem.address&#125;</span>&quot;</span>)<br>    println(map)<br>    mutableMapItem.name = <span class="hljs-string">&quot;yuan&quot;</span><br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mutableMapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mutableMapItem.age&#125;</span> <span class="hljs-subst">$&#123;mutableMapItem.address&#125;</span>&quot;</span>)<br>    println(map)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">// xuan  18 beijing</span><br><span class="hljs-comment">// &#123;name=xuan, age=18, address=beijing&#125;</span><br><span class="hljs-comment">// huang  18 beijing</span><br><span class="hljs-comment">// &#123;name=huang, age=18, address=beijing&#125;</span><br><span class="hljs-comment">// yuan  18 beijing</span><br><span class="hljs-comment">// &#123;name=yuan, age=18, address=beijing&#125;</span><br></code></pre></td></tr></table></figure><h4 id="局部属性委托"><a href="#局部属性委托" class="headerlink" title="局部属性委托"></a>局部属性委托</h4><p>可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">(computeFoo: () -&gt; <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> memoizedFoo <span class="hljs-keyword">by</span> lazy(computeFoo)<br>    <span class="hljs-keyword">val</span> someCondition = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">if</span> (someCondition &amp;&amp; memoizedFoo&gt;<span class="hljs-number">0</span> ) &#123;<br>        println(memoizedFoo+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>memoizedFoo</code>变量只会在第一次访问时计算。 如果<code>someCondition</code>失败，那么该变量根本不会计算。</p><h4 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h4><p>先看一下自定义委托的要求有哪些，示例是这样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Owner</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> varResource: Resource <span class="hljs-keyword">by</span> ResourceDelegate()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceDelegate</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> resource: Resource = Resource()) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: Resource &#123;<br>        <span class="hljs-keyword">return</span> resource<br>    &#125;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">Any</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">is</span> Resource) &#123;<br>            resource = value<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下</p><ol><li>对于<code>var</code>修饰的属性，我们必须要有<code>getValue</code>、<code>setValue</code>这两个方法，同时，这两个方法必须用<code>operator</code>关键字修饰。</li><li>由于<code>varResource</code>是<code>Owner</code>,因此<code>getValue</code>、<code>setValue</code>这两个方法中的<code>thisRef</code>的类型，必须要是<code>Owner</code>或者是<code>Owner的父类</code>。一般来说，这三处的类型是一致的，当我们不确定委托属性会处于哪个类的时候，就可以将<code>thisRef</code>的类型定义为<code>Any?</code>。</li><li>由于委托的属性是<code>Resource</code>类型，那么对于自定义委托中的<code>getValue</code>、<code>setValue</code>参数及返回值需要是<code>String类型或者是它的父类</code></li></ol><p>我们可以把上面的代码当成模板代码，都是这样写就好了。如果觉得麻烦，可以使用标准库中的接口<code>ReadOnlyProperty</code>和<code>ReadWriteProperty</code>将委托创建为匿名对象，而无需创建新类。它们提供所需的方法:<code>getValue()</code>在<code>ReadOnlyProperty</code>中声明；<code>ReadWriteProperty</code>扩展了它并添加了<code>setValue()</code>。这意味着可以在需要<code>ReadOnlyProperty</code>时传递 <code>ReadWriteProperty</code>。<br>比如像这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resourceDelegate</span><span class="hljs-params">(resource: <span class="hljs-type">Resource</span>= Resource()</span></span>) :ReadWriteProperty&lt;Owner,Resource&gt; =<br>    <span class="hljs-keyword">object</span>:ReadWriteProperty&lt;Owner,Resource&gt;&#123;<br>        <span class="hljs-keyword">var</span> curValue = resource<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: Resource=curValue<br>        <br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">Resource</span>)</span></span> &#123;<br>            curValue = value<br>        &#125;<br><br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Owner</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> readOnlyResource: Resource <span class="hljs-keyword">by</span> resourceDelegate()  <span class="hljs-comment">// ReadWriteProperty as val</span><br>    <span class="hljs-keyword">var</span> readWriteResource: Resource <span class="hljs-keyword">by</span> resourceDelegate()<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="提供委托"><a href="#提供委托" class="headerlink" title="提供委托"></a>提供委托</h4><p>通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数， 那么会调用该函数来创建属性委托实例。比如在初始化之前检查一致性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceDelegate</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">ReadOnlyProperty</span>&lt;<span class="hljs-type">MyUI, T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">MyUI</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: T &#123; ... &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceLoader</span>&lt;<span class="hljs-type">T</span>&gt;</span>(id: ResourceID&lt;T&gt;) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDelegate</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            thisRef: <span class="hljs-type">MyUI</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            prop: <span class="hljs-type">KProperty</span>&lt;*&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: ReadOnlyProperty&lt;MyUI, T&gt; &#123;<br>        checkProperty(thisRef, prop.name)<br>        <span class="hljs-comment">// 创建委托</span><br>        <span class="hljs-keyword">return</span> ResourceDelegate()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkProperty</span><span class="hljs-params">(thisRef: <span class="hljs-type">MyUI</span>, name: <span class="hljs-type">String</span>)</span></span> &#123; …… &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUI</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">bindResource</span><span class="hljs-params">(id: <span class="hljs-type">ResourceID</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: ResourceLoader&lt;T&gt; &#123; …… &#125;<br><br>    <span class="hljs-keyword">val</span> image <span class="hljs-keyword">by</span> bindResource(ResourceID.image_id)<br>    <span class="hljs-keyword">val</span> text <span class="hljs-keyword">by</span> bindResource(ResourceID.text_id)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>provideDelegate</code>的参数与<code>getValue</code>的相同：</p><ul><li><code>thisRef</code>必须与<code>属性所有者</code>类型（对于扩展属性必须是被扩展的类型）相同或者是它的超类型；</li><li><code>property</code>必须是类型<code>KProperty&lt;*&gt;</code>或其超类型。</li></ul><hr><p>参考：</p><p><a href="https://book.kotlincn.net/text/delegation.html">委托</a><br><a href="https://kotlinlang.org/docs/delegation.html">Delegation</a></p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>泛型</p><ul><li><input type='checkbox' disabled='true' checked>逆变</input></li><li><input type='checkbox' disabled='true' checked>协变</input></li><li><input type='checkbox' disabled='true' checked>类型投影</input></li><li><input type='checkbox' disabled='true' checked>星投影</input></li><li><input type='checkbox' disabled='true' checked>泛型约束</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li></ul></li><li><p>委托</p><ul><li><input type='checkbox' disabled='true' checked>委托类</input></li><li><input type='checkbox' disabled='true' checked>委托属性</input></li><li><input type='checkbox' disabled='true' checked>自定义委托</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>object</li><li>Unit</li><li>Nothing</li><li>inline,noinline,crossinline</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;经常在 Kotlin 的源码三方库中看到&lt;code&gt;by&lt;/code&gt;关键字，这种写法就是委托，主要有两个应用场景，一个是委托类，另一个是委托属性，每个场景中又有不同的用法，我们可以对比 Java 的委托来学习 Kotlin 的委托。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin泛型:逆变与协变</title>
    <link href="https://blog.huangyuanlove.com/2024/04/30/kotlin%E6%B3%9B%E5%9E%8B-%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/"/>
    <id>https://blog.huangyuanlove.com/2024/04/30/kotlin%E6%B3%9B%E5%9E%8B-%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/</id>
    <published>2024-04-30T02:59:38.000Z</published>
    <updated>2024-05-28T02:46:59.952Z</updated>
    
    <content type="html"><![CDATA[<p>泛型中涉及到的概念也不少,型变(Variance)、逆变(Contravariance)、协变(Covariance)、不变(Invariant).在 kotlin 中还有三个关键字<code>in</code>、<code>out</code>、<code>where</code>、<code>reified</code>等,在java中同样也有<code>? extends</code>、<code>? super</code>、<code>?</code><br>这些概念是啥意思嘞？引用点概念说明</p><blockquote><p>型变(Variance)、协变(Covariance)、逆变(Contravariance)和不变(Invariant)是相关但不同的概念.</p></blockquote><blockquote><p>型变是指泛型类型参数在子类型关系中的行为.它描述了一个泛型类型是否允许类型参数的子类型关系与泛型类型参数的子类型关系保持一致.在泛型中,可以有三种型变类型：协变、逆变和不变.</p></blockquote><blockquote><p>协变是指如果一个泛型类型的子类型关系与其类型参数的子类型关系保持一致,则该泛型类型是协变的.简而言之,如果子类型的泛型参数是父类型泛型参数的子类型,就可以说该泛型类型是协变的.</p></blockquote><blockquote><p>逆变是指如果一个泛型类型的子类型关系与其类型参数的子类型关系相反,则该泛型类型是逆变的.简而言之,如果子类型的泛型参数是父类型泛型参数的超类型,就可以说该泛型类型是逆变的.</p></blockquote><blockquote><p>不变是指一个泛型类型的子类型关系与其类型参数无关,即类型参数的子类型关系与泛型类型的子类型关系无关.在不变的情况下,不能将父类型的对象赋值给子类型的对象,也不能将子类型的对象赋值给父类型的对象.</p></blockquote><blockquote><p>因此,可以说协变和逆变是型变的两种具体形式,而不变则是型变的一种特殊情况.</p></blockquote><blockquote><p>总结起来,协变、逆变和不变描述了泛型类型参数与泛型类型之间子类型关系的不同行为.协变和逆变是对子类型关系的具体约束,而不变则是没有任何子类型关系的约束.它们之间是互相排斥的关系,不是包含关系.</p></blockquote><p>一脸懵了吧😳?问题不大,结合代码具体看一下就差不多了</p><p>我们还是结合 java 和 kotlin 对比来看一下</p><h3 id="Java中的泛型"><a href="#Java中的泛型" class="headerlink" title="Java中的泛型"></a>Java中的泛型</h3><p>我们先用Java代码来看一下,假如我们有如下三个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Poodle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dog</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 java 的多态性,我们可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animalDog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><span class="hljs-type">Animal</span> <span class="hljs-variable">animalBird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>ArrayList&lt;Animal&gt; animalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>animalList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>());<br>animalList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br></code></pre></td></tr></table></figure><p>这么写是没问题的,我们可以把子类添加到父类列表中,但当我们在<code>animalList</code>中获取数据时返回的是<code>Animal</code>类型,如果用到子类的特性,还需要使用<code>instanceof</code>来判断一下类型.<br>但如果我们这么写是不行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">ArrayList&lt;Animal&gt; animalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br></code></pre></td></tr></table></figure><p>因为 java 的泛型具有不变性,在Java 里面认为<code>ArrayList&lt;Animal&gt;</code>和<code>ArrayList&lt;Dog&gt;</code>没啥关系.<br>同样的,当我们想要用方法重载时也会遇到这种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">animal</span><span class="hljs-params">(ArrayList&lt;Dog&gt; dogs)</span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">animal</span><span class="hljs-params">(ArrayList&lt;Bird&gt; birds)</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们这么写的话会报错,IDE 会提示我们相应的信息</p><blockquote><p>animal(ArrayList<Dog>)’ clashes with ‘animal(ArrayList<Bird>)’; both methods have same erasure</p></blockquote><p>两个方法的参数有相同的擦除类型,编译后会被认为是同一个方法.<br>同样的,我们在<strong>捕获泛型异常</strong>时也会有类似的报错信息.</p><h3 id="Java中的泛型擦除"><a href="#Java中的泛型擦除" class="headerlink" title="Java中的泛型擦除"></a>Java中的泛型擦除</h3><p>面试常见的八股文,我们来复习一下,这部分可以跳过不看.<br>比如我们在C#中有如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params">String[] args</span>)</span>&#123; <br>        test&lt;<span class="hljs-built_in">string</span>&gt;(); <br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>&lt;<span class="hljs-title">T</span>&gt;()</span>&#123; <br>        Console.WriteLine(<span class="hljs-keyword">typeof</span>(T)); <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>这里的泛型 T 类型string 是可以在运行时获取到的,并且在这里是一个真实可用的类型.<br>但在Java是不行的,由于向上兼容历史代码的原因 Java 采用了<code>Code sharing</code>的策略,使得泛型只存在于源码阶段,编译过后的Class文件并不存在泛型,虚拟机并不知道泛型的存在,所以说Java中的泛型是一种伪泛型,这种参数类型只存在于源码阶段在编译后并不存在的机制我们叫做<strong>泛型擦除</strong>.为了保持泛型继承或实现关系的正确性,java 中还有一种策略：<strong>桥方法生成(Bridge Method Generation)</strong>:<br>一个简单的例子来说明桥方法生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(T shape)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing shape: &quot;</span> + shape.toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(String shape)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing circle: &quot;</span> + shape);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类型擦除后,编译器会生成桥方法来保持泛型继承关系的正确性.在这个示例中,编译器会生成一个桥方法,使得Circle类的方法签名与父类的方法签名保持一致,但返回类型被擦除为父类的类型参数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(String shape)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing circle: &quot;</span> + shape);<br>    &#125;<br><br>    <span class="hljs-comment">// 生成的桥方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Object shape)</span> &#123;<br>        draw((String) shape);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过生成的桥方法,即draw(Object shape),在类型擦除后仍然能够正确地调用泛型方法.这样,即使在编译器看不到具体的泛型类型信息,仍然可以通过桥方法来调用正确的方法实现.<br>感兴趣的话可以搜一下关键字:泛型擦除、桥方法生成、Code sharin、Code specialization</p><h3 id="Java-中的泛型通配符"><a href="#Java-中的泛型通配符" class="headerlink" title="Java 中的泛型通配符"></a>Java 中的泛型通配符</h3><p>假如我们真的有像上面那种赋值需求怎么搞？java 给我们提供了<code>泛型通配符</code>: <strong>? extends</strong> 和 <strong>? super</strong> 来解决这个问题.<br>啰嗦一下：在继承关系上,一般情况下将父类放在上方,子类放在下方.比如上面定义的类</p><pre><code class="mermaid" >graph TBA(Animal)A10(Dog)A11(Bird)A20(Poodle)A-->A10A-->A11A10-->A20</code></pre><h4 id="extends"><a href="#extends" class="headerlink" title="? extends"></a>? extends</h4><p>我们可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt; arrayList ;<br>arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Bird&gt;();<br>arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br>arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();<br></code></pre></td></tr></table></figure><p>这里的<code>? extends</code>叫做<strong>上界通配符</strong>,可以使 Java 泛型具有<strong>协变性 Covariance</strong>,协变就是允许上面的赋值是合法的.<br>不过这里的<code>extends</code>和我们定义<code>class</code>时继承某个类用的<code>extends</code>有一点点不一样,除了上界所有的直接子类、间接子类还包含它本身,并且上界也可以是 interface.<br>在上面的例子中,<code>ArrayList&lt;? extends Animal&gt;</code>表示列表中可以存放 Animal 及其子类、间接子类的类型.也就是确认了它的上限能到哪一层.<br>但我们在使用的泛型通配符之后,在使用上会有一些小问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<span class="hljs-comment">//error</span><br>arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>());<span class="hljs-comment">//error</span><br>arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>());<span class="hljs-comment">//error</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span>  arrayList.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure><p>由于<code>arrayList</code>中存放的可以是<strong>Animal 及其子类、间接子类的类型</strong>,所以我们并不确定是哪种类型,因此我们无法向列表中添加元素,但可以确定的是,将列表中的元素赋值给 Animal类型的变量是没问题的.<br>像这种只能从列表中读取数据提供,但不能向列表中写入的情况我们称之为<code>生产者</code></p><h4 id="super"><a href="#super" class="headerlink" title="? super"></a>? super</h4><p>我们可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-built_in">super</span> Dog&gt; list ;<br>list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br>list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();<br>list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Poodle&gt;();<span class="hljs-comment">//error</span><br><br></code></pre></td></tr></table></figure><p>这里的<code>? super</code>叫做<strong>下界通配符</strong>,可以使Java泛型具<strong>逆变性 Contravariance</strong>,逆变就是允许上面的赋值是合法的.<br>通过代码我们可以看到下界通配符确定了列表的下限,也就是确认了下限在哪一层,我们可以将该层及以上的类型赋值给 list.同样的,我们在使用上也有一点点小问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Poodle</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>());<span class="hljs-comment">//error</span><br><br><span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>因为list 中存放的肯定是<strong>Dog或者其父类、间接父类</strong>,根据里氏替换原则,任何使用父类的地方可以被它的子类替换,所以我们可以向 list 中添加<strong>Dog或其子类、间接子类</strong>.但是当我们从 list 中取数据的时候,由于不知道 list 中存放的具体是什么类型,在 java 中 Object 是所有类型的父类,所以这里取到的数据返回的<strong>Object</strong>类型.</p><p>一般情况下,我们获取到Object可以通过<code>className</code>或者<code>instanceof</code>来判断具体类型,但我们就先忽略吧.<br>像这种只写入而不读取的泛型类型声明情况称之为<strong>消费者 Consumer</strong>.</p><h4 id="无边界通配符"><a href="#无边界通配符" class="headerlink" title="无边界通配符"></a>无边界通配符</h4><p>还有一种无边界通配符,用单问号表示：List&lt;?&gt;,也就是没有任何限定,相当于<code>? extends Object</code>.需要注意的是,它和不使用类型的 List 还是有区别的：</p><ul><li>List&lt;?&gt; list表示的是列表保存某个特定类型的对象,但我们不能向其中添加任何元素,因为我们不清楚 list 中保存的是那种类型</li><li>没有泛型参数的 List 表示该列表持有的元素类型是 Object,因此可以添加任何类型的对象,但编译器会有警告信息.</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>小小的总结一下：<br>利用<code>? extends</code>形式的通配符可以实现泛型的向上转型,也就是支持协变.但使用上通配符后编译器为了保证运行时的安全,会限定对其写的操作,开放读的操作也就是<strong>只能读取不能修改</strong><br>利用<code>? super T</code>形式的通配符可以实现泛型的向下转型,也就是支持逆变,与上通配符相反,下边界通配符通常限定读的操作,开放写的操作,也就是<strong>只能修改不能读取</strong></p><p>Joshua Bloch 在其著作《Effective Java》第三版 中很好地解释了该问题 (第 31 条：“利用有限制通配符来提升 API 的灵活性”). 他称那些你只能从中读取的对象为生产者, 并称那些只能向其写入的对象为消费者.他建议：</p><blockquote><p>为了灵活性最大化,在表示生产者或消费者的输入参数上使用通配符类型.</p></blockquote><p>他还提出了以下助记符：PECS 代表生产者-Extends、消费者-Super(Producer-Extends, Consumer-Super).</p><h3 id="kotlin-中的泛型通配符"><a href="#kotlin-中的泛型通配符" class="headerlink" title="kotlin 中的泛型通配符"></a>kotlin 中的泛型通配符</h3><p>理清楚了 java 中的泛型通配符,接着我们看一下 kotlin 中的通配符,相对于 Java 的通配符提出了一种新的定义：<strong>声明处型变(declaration-site variance)<strong>与</strong>类型投影(type projections)</strong><br>先从 kotlin 中的通配符说起：<br>和 java 泛型一样，kotlin 中的泛型也是不变的，同样的，也提供了相应的关键字来支持<strong>协变</strong>和<strong>逆变</strong></p><ul><li>使用关键字<code>out</code>来支持协变，等同于 Java 中的上界通配符<code>? extends</code>。</li><li>使用关键字<code>in</code>来支持逆变，等同于 Java 中的下界通配符<code>? super</code>。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> outList: MutableList&lt;<span class="hljs-keyword">out</span> TestMain.Animal&gt; = mutableListOf()<br><span class="hljs-keyword">val</span> outListItem: TestMain.Animal = outList[<span class="hljs-number">0</span>]<br><br><br><span class="hljs-keyword">val</span> inList: MutableList&lt;<span class="hljs-keyword">in</span> TestMain.Animal&gt; = mutableListOf()<br>inList.add(TestMain.Dog())<br>inList.add(TestMain.Bird())<br>inList.add(TestMain.Poodle())<br><span class="hljs-keyword">val</span> inListItem: Any? = inList[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>无非是换了个写法而已，没多大差别.不过需要注意一下，kotlin 同时支持使用处型变和声明处型变。<br>举一个用烂了的例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span>&lt;<span class="hljs-type">out T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> T<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(t)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> producer: Producer&lt;TestMain.Animal&gt; = Producer()<br><span class="hljs-keyword">val</span> animal: TestMain.Animal = producer.produce()<br><br><span class="hljs-keyword">val</span> consumer: Consumer&lt;TestMain.Animal&gt; = Consumer()<br>consumer.consume(TestMain.Dog())<br></code></pre></td></tr></table></figure><p>如果我们确认泛型参数只用来输入或者输出，可以在声明处直接添加<code>in</code>或者<code>out</code>.当然也可以在使用处添加声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer1</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T? &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(t)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> producer1: Producer1&lt;<span class="hljs-keyword">out</span> TestMain.Animal&gt; = Producer1()<br><span class="hljs-keyword">val</span> animal1: TestMain.Animal? = producer1.produce()<br><br><span class="hljs-keyword">val</span> consumer1: Consumer1&lt;<span class="hljs-keyword">in</span> TestMain.Animal&gt; = Consumer1()<br>consumer1.consume(TestMain.Dog())<br></code></pre></td></tr></table></figure><p>这里也就是经常说的 <strong>消费者 in, 生产者 out</strong></p><h4 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h4><p>这个东西可以理解为就是一个概念，根据官方描述是这样的:<br>将类型参数<code>T</code>声明为<code>out</code>非常简单，并且能避免使用处子类型化的麻烦，但是有些类实际上不能限制为只返回<code>T</code>！一个很好的例子是<code>Array</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: T &#123; …… &#125;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">set</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>, value: <span class="hljs-type">T</span>)</span></span> &#123; …… &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该类在<code>T</code>上既不能是协变的也不能是逆变的。这造成了一些不灵活性。考虑下述函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Any</span>&gt;, to: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Any</span>&gt;)</span></span> &#123;<br>    assert(from.size == to.size)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> from.indices)<br>        to[i] = from[i]<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数应该将项目从一个数组复制到另一个数组。让我们尝试在实践中应用它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> ints: Array&lt;<span class="hljs-built_in">Int</span>&gt; = arrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">val</span> any = Array&lt;Any&gt;(<span class="hljs-number">3</span>) &#123; <span class="hljs-string">&quot;&quot;</span> &#125; <br>copy(ints, any)<br><span class="hljs-comment">//   ^ 其类型为 Array&lt;Int&gt; 但此处期望 Array&lt;Any&gt;</span><br></code></pre></td></tr></table></figure><p>这里我们遇到同样熟悉的问题：<code>Array&lt;T&gt;</code>在<code>T</code>上是<strong>不型变</strong>的，因此<code>Array&lt;Int&gt;</code> 与 <code>Array&lt;Any&gt;</code> 都不是另一个的子类型。为什么？ 再次重复，因为<code>copy</code>可能有非预期行为，例如它可能尝试写一个<code>String</code>到<code>from</code>，并且如果我们实际上传递一个<code>Int</code>的数组，以后会抛<code>ClassCastException</code>异常。<br>如果需要禁止<code>copy</code>功能写入<code>from</code>，可以执行以下操作:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Any</span>&gt;, to: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Any</span>&gt;)</span></span> &#123; …… &#125;<br></code></pre></td></tr></table></figure><p>这就是类型投影：意味着<code>from</code>不仅仅是一个数组，而是一个<code>受限制</code>的<strong>（投影的）</strong>数组。 只可以调用返回类型为类型参数<code>T</code>的方法，如上，这意味着只能调用<code>get()</code>。 这就是使用处型变的用法，并且是对应于 Java 的 <code>Array&lt;? extends Object&gt;</code>, 但更简单。</p><p>你也可以使用<code>in</code>投影一个类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fill</span><span class="hljs-params">(dest: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">String</span>&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123; …… &#125;<br></code></pre></td></tr></table></figure><p><code>Array&lt;in String&gt;</code> 对应于 Java 的<code>Array&lt;? super String&gt;</code>，也就是说，你可以传递一个<code>CharSequence</code>数组或一个<code>Object</code>数组给<code>fill()</code>函数。<br><strong>以上信息来自 <a href="(https://book.kotlincn.net/text/generics.html)">kotlin 中文网</a></strong></p><h4 id="星投影"><a href="#星投影" class="headerlink" title="星投影"></a>星投影</h4><p>有时你想说，你对类型参数一无所知，但仍然希望以安全的方式使用它。 这里的安全方式是定义泛型类型的这种投影，该泛型类型的每个具体实例化都会是该投影的子类型。</p><p>Kotlin 为此提供了所谓的<strong>星投影</strong>语法：</p><ul><li>对于<code>Foo &lt;out T : TUpper&gt;</code>，其中<code>T</code>是一个具有上界<code>TUpper</code>的协变类型参数，<code>Foo &lt;*&gt;</code>等价于<code>Foo &lt;out TUpper&gt;</code>。 意味着当<code>T</code>未知时，你可以安全地从<code>Foo &lt;*&gt;</code>读取<code>TUpper</code>的值。</li><li>对于<code>Foo &lt;in T&gt;</code>，其中<code>T</code>是一个逆变类型参数，<code>Foo &lt;*&gt;</code>等价于<code>Foo &lt;in Nothing&gt;</code>。 意味着当<code>T</code>未知时， 没有什么可以以安全的方式写入<code>Foo &lt;*&gt;</code>。</li><li>对于<code>Foo &lt;T : TUpper&gt;</code>，其中<code>T</code>是一个具有上界<code>TUpper</code>的不型变类型参数,<code>Foo&lt;*&gt;</code>对于读取值时等价于<code>Foo&lt;out TUpper&gt;</code> 而对于写值时等价于<code>Foo&lt;in Nothing&gt;</code>。</li></ul><p>如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。 例如，如果类型被声明为 interface Function &lt;in T, out U&gt;，可以使用以下星投影：</p><ul><li><code>Function&lt;*, String&gt;</code> 表示<code>Function&lt;in Nothing, String&gt;</code>。</li><li><code>Function&lt;Int, *&gt;</code> 表示<code>Function&lt;Int, out Any?&gt;</code>。</li><li><code>Function&lt;*, *&gt;</code> 表示<code>Function&lt;in Nothing, out Any?&gt;</code>。</li></ul><p><strong>以上信息来自 <a href="(https://book.kotlincn.net/text/generics.html)">kotlin 中文网</a></strong></p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">singletonList</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; &#123;<br>    <span class="hljs-comment">// ……</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">basicToString</span><span class="hljs-params">()</span></span>: String &#123; <span class="hljs-comment">// 扩展函数</span><br>    <span class="hljs-comment">// ……</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要调用泛型函数，在调用处函数名之后指定类型参数即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> l = singletonList&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>可以省略能够从上下文中推断出来的类型参数，所以以下示例同样适用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> l = singletonList(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>能够替换给定类型参数的所有可能类型的集合可以由<strong>泛型约束</strong>限制。<br>最常见的约束类型是上界，与Java的<code>extends</code>关键字对应：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="hljs-title">sort</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;  …… &#125;<br></code></pre></td></tr></table></figure><p>冒号之后指定的类型是上界，表明只有<code>Comparable&lt;T&gt;</code>的子类型可以替代<code>T</code>。 例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">sort(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span><br>sort(listOf(HashMap&lt;<span class="hljs-built_in">Int</span>, String&gt;())) <span class="hljs-comment">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span><br></code></pre></td></tr></table></figure><p>默认的上界（如果没有声明）是 Any?。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，需要一个单独的 where-子句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">copyWhenGreater</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;, threshold: <span class="hljs-type">T</span>)</span></span>: List&lt;String&gt;<br>    <span class="hljs-keyword">where</span> T : CharSequence,<br>          T : Comparable&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所传递的类型必须同时满足<code>where</code>子句的所有条件。在上述示例中，类型<code>T</code>必须<strong>既实现了 CharSequence 也实现了 Comparable</strong>。<br>这里需要注意的是，where 子句后面的第一个类型可以是接口也可以是抽象类、实现类，后续的类型只能是接口。在 Java 中也一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAbstractClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyInterface</span> &amp; MyAbstractClass&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>&#123; <span class="hljs-comment">//errpr</span><br>    t.test();<br>&#125;<br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">MyAbstractClass</span> &amp; MyInterface &gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>&#123;<br>    t.test();<br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>原因就是 java 中不可以多继承但可以多实现</p><h4 id="UnsafeVariance"><a href="#UnsafeVariance" class="headerlink" title="@UnsafeVariance"></a>@UnsafeVariance</h4><p>差点忘了这东西，这个注解就是告诉编译器我知道我在做什么，并且保证不会出问题，忽略协变和逆变的约束就好了<br>比如 kotlin 中的<code>Collection</code>这个类中的<code>contains</code>、<code>containsAll</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-type">out E</span>&gt; : <span class="hljs-type">Iterable</span>&lt;<span class="hljs-type">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contains</span><span class="hljs-params">(element: @<span class="hljs-type">UnsafeVariance</span> <span class="hljs-type">E</span>)</span></span>: <span class="hljs-built_in">Boolean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;@<span class="hljs-type">UnsafeVariance</span> <span class="hljs-type">E</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于协变的类型，通常我们是不允许将泛型类型作为传入参数的类型的，或者说，对于协变类型，我们通常是不允许其涉及泛型参数的部分被改变的。<br>这也很容易解&gt;释为什么 MutableCollection 是不变的，而 Collection 是协变的，因为在 Kotlin 当中，前者是可被修改的，后者是不可被修改的。<br>逆变的情形正好相反，即不可以将泛型参数作为方法的返回值。</p></blockquote><p>比如这种情形，为了让编译器放过一马，我们就可以用 @UnsafeVariance 来告诉编译器：“我知道我在干啥，保证不会出错，你不用担心”。<br><strong>以上信息来自<a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></strong></p><h4 id="reified-关键字"><a href="#reified-关键字" class="headerlink" title="reified 关键字"></a>reified 关键字</h4><p>由于存在类型擦除，导致我们无法在运行时获取泛型的具体类型，有些操作无法实现，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">testOne</span><span class="hljs-params">(Object param)</span>&#123;<br>    <span class="hljs-keyword">if</span>(param <span class="hljs-keyword">instanceof</span> T)&#123;<br>        System.out.println(<span class="hljs-string">&quot;T&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，在 kotlin 中也不行。<br>但在 java 中我们通常会传入一个<code>Class&lt;T&gt;</code>来做相应的操作，在 kotlin 中同样也可以，不过 kotlin 中有一个更简单的方法:使用<code>reified</code>配合<code>inline</code>来实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">printIfTypeMatch</span><span class="hljs-params">(item: <span class="hljs-type">Any</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (item <span class="hljs-keyword">is</span> T) &#123; <span class="hljs-comment">// 👈 这里就不会在提示错误了</span><br>        println(item)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们经常用的 gson解析数据、反序列化的时候经常遇到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">fromJson</span><span class="hljs-params">(String json, Class&lt;T&gt; classOfT)</span> <span class="hljs-keyword">throws</span> JsonSyntaxException &#123; <br>    <br>&#125; <br></code></pre></td></tr></table></figure><p>这里就是通过多传入一个<code>Class&lt;T&gt;</code>来解决这个问题，在 kotlin 中我们可以通过扩展来变化一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> Gson.<span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">String</span>)</span></span>: T&#123; <br>     <span class="hljs-keyword">return</span> fromJson(json, T::<span class="hljs-keyword">class</span>.java) <br> &#125; <br></code></pre></td></tr></table></figure><p>我们给 Gson 添加了一个扩展方法，在这个方法中，通过<code>inline</code>和<code>reified</code>关键字将泛型<code>T</code>变成了一个真实可用的类型，这两个关键字缺一不可。这里就简单的认为内联方法(inline)是将方法在编译时复制到调用处，使得泛型 T 的类型在编译时就可以确定。当然这么理解不是特别正确。后面学到<code>inline</code>、<code>noinline</code>、<code>crossinline</code>这几个关键字的时候再说吧</p><p>参考：</p><p><a href="https://book.kotlincn.net/text/generics.html">泛型：in、out、where</a><br><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a><br><a href="https://ethanhua.github.io/2018/01/09/genericity/">深入理解Java和Kotlin中的泛型</a><br><a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>泛型</p><ul><li><input type='checkbox' disabled='true' checked>逆变</input></li><li><input type='checkbox' disabled='true' checked>协变</input></li><li><input type='checkbox' disabled='true' checked>类型投影</input></li><li><input type='checkbox' disabled='true' checked>星投影</input></li><li><input type='checkbox' disabled='true' checked>泛型约束</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>object</li><li>Unit</li><li>Nothing</li><li>inline,noinline,crossinline</li></ul></li><li><p>委托</p><ul><li>委托类</li><li>委托属性</li><li>自定义委托</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;泛型中涉及到的概念也不少,型变(Variance)、逆变(Contravariance)、协变(Covariance)、不变(Invariant).在 kotlin 中还有三个关键字&lt;code&gt;in&lt;/code&gt;、&lt;code&gt;out&lt;/code&gt;、&lt;code&gt;where&lt;/</summary>
      
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin作用域函数:run、let、also、apply、with</title>
    <link href="https://blog.huangyuanlove.com/2024/04/28/kotlin%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0-run%E3%80%81let%E3%80%81also%E3%80%81apply%E3%80%81with/"/>
    <id>https://blog.huangyuanlove.com/2024/04/28/kotlin%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0-run%E3%80%81let%E3%80%81also%E3%80%81apply%E3%80%81with/</id>
    <published>2024-04-28T08:23:11.000Z</published>
    <updated>2024-04-30T02:54:43.487Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始学习 kotlin 的时候，对于这些作用域函数一头雾水，搞不明白为什么要弄出来这么多东西。现在来看看他们具体的区别以及适用的场景。<br>Kotlin 标准库包含几个函数，它们的唯一目的是在对象的上下文中执行代码块。 当对一个对象调用这样的函数并提供一个<code>lambda表达式</code>时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。这些函数称为作用域函数。 共有以下五种：<code>let</code>、<code>run</code>、<code>with</code>、<code>apply</code>以及<code>also</code>。<br>废话不多说，先把从 kotlin 官方上扒拉下来的结论放这里</p><span id="more"></span><p><a href="https://book.kotlincn.net/text/scope-functions.html">作用域函数中文版</a><br><a href="https://kotlinlang.org/docs/scope-functions.html">作用域函数英文版</a></p><h3 id="总结在前面"><a href="#总结在前面" class="headerlink" title="总结在前面"></a>总结在前面</h3><p>文章太长太啰嗦，直接看这里的结论：</p><table><thead><tr><th>函数</th><th>对象引用</th><th>返回值</th><th>是否是扩展函数</th></tr></thead><tbody><tr><td>let</td><td>it</td><td>Lambda表达式结果</td><td>是</td></tr><tr><td>run</td><td>this</td><td>Lambda表达式结果</td><td>是</td></tr><tr><td>run</td><td>-</td><td>Lambda表达式结果</td><td>不是：调用无需上下文对象</td></tr><tr><td>with</td><td>this</td><td>Lambda表达式结果</td><td>不是：把上下文对象当做参数</td></tr><tr><td>apply</td><td>this</td><td>上下文对象</td><td>是</td></tr><tr><td>also</td><td>it</td><td>上下文对象</td><td>是</td></tr></tbody></table><p>以下是根据预期目的选择作用域函数的简短指南：</p><ul><li>对一个非空（non-null）对象执行 lambda 表达式：let</li><li>将表达式作为变量引入为局部作用域中：let</li><li>对象配置：apply</li><li>对象配置并且计算结果：run</li><li>在需要表达式的地方运行语句：非扩展的 run</li><li>附加效果：also</li><li>一个对象的一组函数调用：with<br>不同作用域函数的使用场景存在重叠，可以根据项目或团队中使用的特定约定来选择使用哪些函数。</li></ul><p><font color='red'>虽然作用域函数可以让代码更加简洁，但是要避免过度使用它们：这会使代码难以阅读并可能导致错误。 我们还建议避免嵌套作用域函数，同时链式调用它们时要小心：因为很容易混淆当前上下文对象与<code>this</code>或<code>it</code>的值。</font></p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假如我们有这么一个数据类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> price: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changePrice</span><span class="hljs-params">(price: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.price = price<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> book = Book(<span class="hljs-string">&quot;book name&quot;</span>, <span class="hljs-number">68</span>)<br></code></pre></td></tr></table></figure><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">run</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">run</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> <span class="hljs-title">with</span><span class="hljs-params">(receiver: <span class="hljs-type">T</span>, block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure><p>我们把看起来相近的作用域函数的声明放在一块对比着看，看到这里就清楚了的就不要往下看了，看了也是浪费时间。</p><h4 id="also"><a href="#also" class="headerlink" title="also"></a>also</h4><p>函数声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T<br></code></pre></td></tr></table></figure><p><code>also</code>函数是对泛型 T 的扩展函数，接收一个参数类型为T、无返回值(返回值为Unit类型)的函数，且<code>also</code>函数的返回值就是调用者。</p><ul><li>上下文对象作为 lambda 表达式的参数（it）来访问。</li><li>返回值是上下文对象本身。</li></ul><p>对于执行一些将上下文对象作为参数的操作很有用。 对于需要引用对象而不是其属性与函数的操作，或者不想屏蔽来自外部作用域的 this 引用时，请使用 also。<br>当你在代码中看到 also 时，可以将其理解为<strong>并且用该对象执行以下操作</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> alsoResult = book.also &#123;<br>    it.changePrice(<span class="hljs-number">20</span>)<br>    it.name = <span class="hljs-string">&quot;alsoResult&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;alsoResult <span class="hljs-variable">$alsoResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里打印结果是<code>alsoResult Book(name=alsoResult, price=20)</code>,看源码的话，可以简单的里面为调用了一下传入的函数，然后返回了调用者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    block(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>函数声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T<br></code></pre></td></tr></table></figure><p>可以看得出来<code>apply</code>是泛型 T 的扩展函数，接收一个带有 T 类型接收者的无参、无返回值的函数，并且<code>apply</code>函数返回值就是 T 类型，也就是调用者的类型。因为这里参数中的 T 是作为接收者类型，而不是参数，所以在传入的函数中需要用<code>this</code>而非<code>it</code>来指代调用者。<br>用法和<code>also</code>相差无几，只不过一个是接收者类型，一个是参数。</p><ul><li>上下文对象 作为接收者（this）来访问。</li><li>返回值 是上下文对象本身。</li></ul><p>对于不返回值且主要在接收者（this）对象的成员上运行的代码块使用它。apply最常见的使用场景是用于对象配置。这样的调用可以理解为<strong>将以下赋值操作应用于对象</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> applyResult = book.apply &#123;<br>    changePrice(<span class="hljs-number">200</span>)<br>    name = <span class="hljs-string">&quot;applyResult&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;applyResult <span class="hljs-variable">$applyResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里打印的结果是<code>applyResult Book(name=applyResult, price=200)</code>.<br>源码也和<code>also</code>几乎一样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    block(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>函数类型声明如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure><p>可以看到，let 是对泛型 T 的扩展函数，该扩展函数接收一个函数参数，并且函数参数的接收一个 T 类型的参数，且返回值是 R 类型，也是<code>let</code>这个扩展函数的返回值类型。</p><ul><li>上下文对象作为 lambda 表达式的参数（it）来访问。</li><li>返回值是 lambda 表达式的结果。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>    it.changePrice(<span class="hljs-number">100</span>)<br>    it.name = <span class="hljs-string">&quot;letResult&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;letResult <span class="hljs-variable">$letResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里传入的是一个 Lambda 表达式，前面说过，对于单参数值的Lambda 表达式，参数会被隐式声明为<code>it</code>,当然我们也可以指定一个具名意义的变量，比如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letResult = book.let &#123; bookEntry: Book -&gt;<br>    bookEntry.changePrice(<span class="hljs-number">100</span>)<br>    bookEntry.name = <span class="hljs-string">&quot;letResult&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里打印的结果是<code>letResult kotlin.Unit</code>。因为对于 Lambda 表达式来讲，如果最后一条语句是非赋值语句，则返回该语句的值；如果是赋值语句，则返回 Unit。<br>我们可以这么写来返回我们需要的值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>    it<span class="hljs-comment">//返回值就是传入的 book 对象</span><br>&#125;<br><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>    <span class="hljs-number">1</span><span class="hljs-comment">//返回值就是1</span><br>&#125;<br><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>     <span class="hljs-keyword">return</span><span class="hljs-symbol">@let</span> <span class="hljs-number">1</span><span class="hljs-comment">//之前的文章中说过的显示指定返回值，是 1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从另外一个角度看，<code>let</code>和 <code>also</code>、<code>apply</code>也差不多，只不过多了一个返回值类型，返回值就是传入的 Lambda 表达式的返回值<br>源码也差不了多少</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block(<span class="hljs-keyword">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>let 可用于在调用链的结果上调用一个或多个函数。</li><li>let 经常用于执行包含非空值代码块。如需对非空对象执行操作， 可对其使用安全调用操作符<code>?.</code>并调用 let 在 lambda 表达式中执行操作。</li></ul><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p><code>run</code>这个函数给了两种方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">run</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">run</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure><p>先看第一种，看起来就是把<code>let</code>中函数参数中的 T 类型参数改成了接收者类型，也是返回 R 类型；这和<code>apply</code>与<code>also</code>的区别是一样的。</p><ul><li>上下文对象 作为接收者（this）来访问。</li><li>返回值 是 lambda 表达式结果。</li></ul><p>当 lambda 表达式同时初始化对象并计算返回值时，run 很有用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> runResult = book.run &#123;<br>    name = <span class="hljs-string">&quot;runResult&quot;</span><br>    changePrice(<span class="hljs-number">110</span>)<br>    <span class="hljs-keyword">this</span> <span class="hljs-comment">//作为返回值</span><br>&#125;<br>println(<span class="hljs-string">&quot;runResult <span class="hljs-variable">$runResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>源码是这样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">run</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block()<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> otherRunResult =  run &#123;<br>    Book(<span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-number">120</span>) <span class="hljs-comment">//作为返回值</span><br>&#125;<br>println(<span class="hljs-string">&quot;otherRunResult <span class="hljs-variable">$otherRunResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">run</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block()<br>&#125;<br></code></pre></td></tr></table></figure><p>这也没啥好说的，只不过是这里并没有输入参数，只是可以使你在需要表达式的地方就可以执行一个语句。</p><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>函数声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> <span class="hljs-title">with</span><span class="hljs-params">(receiver: <span class="hljs-type">T</span>, block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure><p><code>with</code>并不是扩展函数，需要传入一个T 类型的receiver，可以在 block 中访问这个receiver的方法和属性，</p><ul><li>上下文对象作为接收者（this）使用。</li><li>返回值是 lambda 表达式结果。</li></ul><p>建议当不需要使用 lambda 表达式结果时，使用 with 来调用上下文对象上的函数。 在代码中，with 可以理解为<strong>对于这个对象，执行以下操作.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> withResult = with(book) &#123;<br>    changePrice(<span class="hljs-number">300</span>)<br>    name = <span class="hljs-string">&quot;withResult&quot;</span><br>    <span class="hljs-keyword">this</span> <span class="hljs-comment">//作为返回值</span><br>&#125;<br>println(<span class="hljs-string">&quot;withResult <span class="hljs-variable">$withResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里的打印结果是<code>withResult Book(name=withResult, price=300)</code></p><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>这里再搬运一个总结的表格</p><table>    <tr>         <th >函数名</th>         <th >作用</th>         <th >应用场景</th>         <th >备注</th>     </tr>    <tr>      <td>let</td>      <td rowspan="2">定义一个变量在特定作用域内<br/>统一做判空处理</td>      <td rowspan="2">明确一个变量所处特定的作用域范围内可使用<br/>针对一个可空对象统一做判空处理</td>      <td rowspan="2">区别在于返回值<br/>let函数：返回值=最后一行|return的表达式<br/>also函数：返回值=传入对象本身</td>    </tr>    <tr>      <td>also</td>    </tr>    <tr>      <td>with</td>      <td>调用同一个对象的多个方法|属性时，可以省去对象名，直接调用方法、访问属性</td>      <td>需要多次调用同一个对象的属性|方法</td>      <td>返回值=最后一行|return表达式</td>    </tr>    <tr>      <td>run</td>      <td rowspan="2">结合了let 函数和 with 函数的作用</td>      <td>1.调用同一个对象的多个方法/属性时可以省去对象名重复，直接调用方法名 /属性即可<br/>2.定义一个变量在特定作用域内<br/>3.统一做判空处</</td>      <td>优点:避免了let函数必须使用it参数替代对象弥补了with函数无法判空的缺点</td>    </tr>    <tr>      <td>apply</td>      <td>对象实例初始化时需要对对象中的属性进行赋值且返回该对象</td>      <td>二者区别在于返回值:<br/>run函数返回最后一行的值|表达式<br/>apply函数返回传入的对象的本身</td>    <tr></table><h3 id="另外一个角度的选择"><a href="#另外一个角度的选择" class="headerlink" title="另外一个角度的选择"></a>另外一个角度的选择</h3><h4 id="it-or-this"><a href="#it-or-this" class="headerlink" title="it or this"></a>it or this</h4><p>每个作用域函数都使用以下两种方式之一来引用上下文对象</p><ol><li>作为 lambda 表达式的接收者 （this）</li><li>作为 lambda 表达式的参数（it）</li></ol><p>两者都提供了同样的功能，<code>run</code>、<code>with</code>以及<code>apply</code>通过关键字<code>this</code>将上下文对象引用为<code>lambda</code>表达式的接收者。 因此，在它们的<code>lambda表达式</code>中可以像在普通的类函数中一样访问上下文对象。在大多数场景，当你访问接收者对象时你可以省略<code>this</code>， 来让你的代码更简短。 相对地，如果省略了<code>this</code>，就很难区分接收者对象的成员及外部对象或函数。因此，对于主要对对象的成员进行操作（调用其函数或赋值其属性）的lambda表达式， 建议将上下文对象作为接收者（this）。<br>反过来，<code>let</code>及<code>also</code>将上下文对象引用为<code>lambda表达式参数</code>。如果没有指定参数名，对象可以用隐式默认名称<code>it</code>访问。<code>it</code>比<code>this</code>简短，带有<code>it</code>的表达式通常更易读。不过，当调用对象函数或属性时，不能像<code>this</code>这样隐式地访问对象。 因此，当上下文对象在作用域中主要用作函数调用中的参数时，通过<code>it</code>访问上下文对象会更好。 在代码块中使用多个变量时，<code>it</code>也更好一些。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>根据返回结果，作用域函数可以分为以下两类：</p><p>apply 及 also 返回上下文对象。<br>let、run 及 with 返回 lambda 表达式结果.<br>apply 及 also 的返回值是上下文对象本身。因此，它们可以作为辅助步骤包含在调用链中：可以继续在同一个对象上一个接一个地进行链式函数调用。</p><h3 id="写在最后的注意事项"><a href="#写在最后的注意事项" class="headerlink" title="写在最后的注意事项"></a>写在最后的注意事项</h3><p>在最开始的红色部分也提高过尽量不要嵌套使用作用域函数，警惕引发的上下文混淆。看下面的代码猜一下打印结果是什么。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> length = <span class="hljs-number">0</span><br>    <span class="hljs-string">&quot;hello&quot;</span>.apply &#123;<br>        println(<span class="hljs-string">&quot;this is apply <span class="hljs-variable">$length</span>&quot;</span>)<br>        println(<span class="hljs-string">&quot;this is apply <span class="hljs-subst">$&#123;this.length&#125;</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-string">&quot;hello&quot;</span>.let &#123;<br>        println(<span class="hljs-string">&quot;this is let <span class="hljs-variable">$it</span>&quot;</span>)<br>        <span class="hljs-string">&quot;world&quot;</span>.also &#123;<br>            println(<span class="hljs-string">&quot;this is run <span class="hljs-variable">$it</span>&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerFunc</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-string">&quot;hi&quot;</span>.apply &#123;<br>            println(<span class="hljs-string">&quot;this is innerFunc apply <span class="hljs-variable">$length</span>&quot;</span>)<br>            println(<span class="hljs-string">&quot;this is innerFunc apply <span class="hljs-subst">$&#123;this.length&#125;</span>&quot;</span>)<br><br>        &#125;<br>    &#125;<br>    innerFunc()<br>&#125;<br></code></pre></td></tr></table></figure><p>结果是如下：</p><blockquote><p>this is apply 0<br>this is apply 5<br>this is let hello<br>this is run world<br>this is innerFunc apply 0<br>this is innerFunc apply 2</p></blockquote><p>这里我们在写代码的时候，IDE 给了提示:<strong>Implicit parameter ‘it’ of enclosing lambda is shadowed</strong><br><img src="/image/kotlin/scope_func_implicit_param.png" alt="Implicit parameter &#39;it&#39; of enclosing lambda is shadowed "><br>我们可以通过修改隐式 it 的名字来避免这个问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-string">&quot;hello&quot;</span>.let &#123;<br>    println(<span class="hljs-string">&quot;this is let <span class="hljs-variable">$it</span>&quot;</span>)<br>    <span class="hljs-string">&quot;world&quot;</span>.also &#123; world-&gt;<br>        println(<span class="hljs-string">&quot;this is run <span class="hljs-variable">$world</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但最好还是避免这种嵌套调用的情况</p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>object</li><li>Unit</li><li>Nothing</li><li>inline,noinline,crossinline</li></ul></li><li><p>泛型</p><ul><li>逆变</li><li>协变</li></ul></li><li><p>委托</p><ul><li>委托类</li><li>委托属性</li><li>自定义委托</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;刚开始学习 kotlin 的时候，对于这些作用域函数一头雾水，搞不明白为什么要弄出来这么多东西。现在来看看他们具体的区别以及适用的场景。&lt;br&gt;Kotlin 标准库包含几个函数，它们的唯一目的是在对象的上下文中执行代码块。 当对一个对象调用这样的函数并提供一个&lt;code&gt;lambda表达式&lt;/code&gt;时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。这些函数称为作用域函数。 共有以下五种：&lt;code&gt;let&lt;/code&gt;、&lt;code&gt;run&lt;/code&gt;、&lt;code&gt;with&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt;以及&lt;code&gt;also&lt;/code&gt;。&lt;br&gt;废话不多说，先把从 kotlin 官方上扒拉下来的结论放这里&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的函数类型及 Lambda 表达式</title>
    <link href="https://blog.huangyuanlove.com/2024/04/23/Kotlin%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8F%8A-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blog.huangyuanlove.com/2024/04/23/Kotlin%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8F%8A-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2024-04-23T03:41:47.000Z</published>
    <updated>2024-04-28T03:46:21.614Z</updated>
    
    <content type="html"><![CDATA[<p>继续上次在扩展函数中遗留下的问题：函数类型。总所周知，在Kotlin 中函数是一等公民。那么什么是高阶函数嘞？到处翻了翻，发现差不多是这么个意思：<strong>接受一个或多个函数作为参数，或者返回一个函数。</strong>在 Kotlin 协程中的 launch、async函数以及各种各样的框架中到处都是高阶函数的影子，称高阶函数是 Kotlin函数式编程、各大框架的基石也不过分。</p><span id="more"></span><p>不得不说，这里面概念挺多的，有的时候我们会用，但并不知道叫什么名字。有的知道名字但不知道是什么东西。</p><ul><li>高阶函数</li><li>扩展函数</li><li>Lambda</li><li>SAM转换</li><li>带接收者的函数类型</li><li>带有接收者的函数字面值</li></ul><p>问题不大，慢慢整，慢慢理解，多读几遍文档，参考一下别人的看法，也就熟悉了。</p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>这里想表达的并不是说kotlin 中的函数分类，比如什么内联函数、扩展函数、标准函数、高阶函数等等这种分类，而是说在函数作为返回值或者参数的时候，我们怎么确认这个函数就是我们想要的类型，或者说如何使用编程语言来描述一个函数。比如我们在调用函数的时候传入的参数，我们会讲这个函数需要一个 Int 类型的参数，那如果我们调用的函数需要另外一个函数作为参数我们应该怎么表示嘞？这里就引出了函数类型。<br>举个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionA</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Unit</span>&#123;<br>    println(<span class="hljs-string">&quot;functionA&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionA1</span><span class="hljs-params">(name:<span class="hljs-type">String</span>)</span></span>:<span class="hljs-built_in">Unit</span>&#123;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionA11</span><span class="hljs-params">(name:<span class="hljs-type">String</span>)</span></span>:String&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi <span class="hljs-variable">$name</span>&quot;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们应该如何描述上面的三个方法嘞？</p><blockquote><p>functionA,不需要参数，返回值为 Unit<br>functionA1, 需要一个String 类型的参数，返回值为 Unit<br>functionA11,需要一个String 类型的参数，返回值为 String</p></blockquote><p>那么在 kotlin 编程语言中又是如何描述的？<br><img src="/image/kotlin/kotlin_function0%3CUnit%3E.png"><br><img src="/image/kotlin/kotlin_function1%3CString,Unit%3E.png"><br><img src="/image/kotlin/kotlin_function1%3CString,String%3E.png"></p><p>上面的图是将鼠标悬停在变量上就会出现，当然也可以选中变量或者表达式，按 ctrl+shift+p来显示类型</p><p>可以看到在<code>kotlin</code>中是用<code>KFunction0&lt;Unit&gt;</code>、<code>KFunction1&lt;String, Unit&gt;</code>、<code>KFunction1&lt;String, String&gt;</code>这种形式来描述一个函数。这里的 KFunction 后面的数字表示这个函数的参数个数，尖括号中的类型表示参数的类型，最后一个类型表示函数的返回值类型。比如<code>KFunction1&lt;String, Unit&gt;</code>表示这个函数需要<code>1</code>个<code>String</code>类型的参数，返回值类型为<code>Unit</code>。而<code>KFunction1&lt;String, String&gt;</code>表示这个函数需要<code>1</code>个<code>String</code>类型的参数，返回值为<code>String</code>。<br>如果函数是挂起函数(被suspend修饰)，则对应的类型为<code> KSuspendFunction0&lt;Unit&gt;</code>,以此类推。<br>那么如果是高阶函数嘞？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionC</span><span class="hljs-params">(method:()-&gt;<span class="hljs-type">String</span>)</span></span>:String&#123;<br>    <span class="hljs-keyword">return</span> method()<br>&#125;<br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span>  <span class="hljs-title">suspendFunctionC</span><span class="hljs-params">(method: () -&gt; <span class="hljs-type">String</span>)</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> method()<br>&#125;<br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span>  <span class="hljs-title">suspendFunctionC1</span><span class="hljs-params">(method:<span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">String</span>)</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> method()<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的方法，我们可以看到</p><blockquote><p><code>functionC</code>对应的描述是<code>KFunction1&lt;() -&gt; String, String&gt;</code><br><code>suspendFunctionC</code>对应的描述是<code> KSuspendFunction1&lt;() -&gt; String, String&gt;</code><br><code>suspendFunctionC1</code>对应的描述是<code> KSuspendFunction1&lt;suspend () -&gt; String, String&gt;</code>。</p></blockquote><p>对于扩展函数也一样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">A1</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-keyword">this</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">A11</span><span class="hljs-params">()</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;    <br><span class="hljs-keyword">val</span> stringA1 = String::A1 <span class="hljs-comment">// KFunction1&lt;String, Unit&gt;</span><br><span class="hljs-keyword">val</span> stringA11 = String::A11 <span class="hljs-comment">// KFunction1&lt;String, String&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>，我们还可以使用<code>typealias</code>给函数类型取一个别名<br><code>typealias ClickHandler = (Button, ClickEvent) -&gt; Unit</code></p><h3 id="带接收者的函数类型"><a href="#带接收者的函数类型" class="headerlink" title="带接收者的函数类型"></a>带接收者的函数类型</h3><p>一种特殊的函数类型，它允许您在函数类型中指定一个接收者对象，使得在函数体内可以直接访问该接收者对象的成员函数和属性。这种函数类型的语法是在函数类型声明之前添加接收者类型。<br>带接收者的函数类型的语法如下：</p><blockquote><p>接收者类型.() -&gt; 返回类型</p></blockquote><p>通过使用带接收者的函数类型，我们可以创建具有接收者的函数变量、函数参数或函数返回类型，以便在调用函数时可以直接操作接收者对象。这样可以实现一种类似扩展函数的效果。举个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String)<br><br><span class="hljs-comment">// 带接收者的函数类型</span><br><span class="hljs-keyword">val</span> greeting: Person.() -&gt; String = &#123;<br>    <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>!&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 扩展函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Person.<span class="hljs-title">greet</span><span class="hljs-params">()</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>!&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person: Person = Person(<span class="hljs-string">&quot;huang&quot;</span>)<br><br>    <span class="hljs-comment">// 使用带接收者的函数类型调用函数</span><br>    <span class="hljs-keyword">val</span> message1 = person.greeting()<br><br>    <span class="hljs-comment">// 使用扩展函数调用函数</span><br>    <span class="hljs-keyword">val</span> message2 = person.greet()<br><br>    println(message1) <span class="hljs-comment">// 输出: Hello, huang!</span><br>    println(message2) <span class="hljs-comment">// 输出: Hello, huang!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结起来，带接收者的函数类型更适合在函数类型的声明和传递中使用，以提供特定上下文的函数操作。而扩展函数则更适合在已有类上添加新的函数，使得在调用该类时可以使用这些额外的函数。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>先小小的总结一下：</p><ul><li>所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型：(A, B) -&gt; C 表示接受类型分别为 A 与 B 两个参数并返回一个 C 类型值的函数类型。 参数类型列表可以为空，如 () -&gt; A。Unit 返回类型不可省略。</li><li>函数类型可以有一个额外的接收者类型，它在表示法中的点之前指定： 类型 A.(B) -&gt; C 表示可以在 A 的接收者对象上以一个 B 类型参数来调用并返回一个 C 类型值的函数。 <code>带有接收者的函数字面值</code>通常与这些类型一起使用。</li><li>挂起函数属于函数类型的特殊种类，它的表示法中有一个 suspend 修饰符 ，例如 suspend () -&gt; Unit 或者 suspend A.(B) -&gt; C。</li><li>如需将函数类型指定为可空，请使用圆括号，如下所示： ((Int, Int) -&gt; Int)?。</li></ul><p>这样我们在看其他框架的时候就知道框架中的高阶函数怎么调用了：</p><blockquote><p>当参数类型为<code>() -&gt; String</code>时，我们需要传入一个没有参数且返回值为String类型的函数，对应的类型是<code>KFunction0&lt;String&gt;</code></p></blockquote><h3 id="函数实例化"><a href="#函数实例化" class="headerlink" title="函数实例化"></a>函数实例化</h3><p>既然函数也是对象，那么理所当然的可以被实例化。我们可以使用以下几种方式获取函数类型的实例</p><ul><li>使用函数字面值的代码块<ul><li>lambda 表达式: { a, b -&gt; a + b },</li><li>匿名函数: fun(s: String): Int { return s.toIntOrNull() ?: 0 }</li></ul></li><li>使用已有声明的可调用引用<ul><li>顶层、局部、成员、扩展函数：::isOdd、 String::toInt，</li><li>顶层、成员、扩展属性：List<Int>::size，</li><li>构造函数：::Regex</li></ul></li><li>使用实现函数类型接口的自定义类的实例：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntTransformer</span>: <span class="hljs-type"></span></span>(<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = TODO()<br>&#125;<br><span class="hljs-keyword">val</span> intFunction: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = IntTransformer()<br></code></pre></td></tr></table></figure></li></ul><h3 id="有无Receiver的函数相互转化"><a href="#有无Receiver的函数相互转化" class="headerlink" title="有无Receiver的函数相互转化"></a>有无Receiver的函数相互转化</h3><p>带与不带接收者的函数类型非字面值可以互换，其中接收者可以替代第一个参数，反之亦然。例如，(A, B) -&gt; C 类型的值可以传给或赋值给期待 A.(B) -&gt; C 类型值的地方，反之亦然。这也是为什么<code>String.A1()</code>明明没有声明需要参数，为啥和上面的<code>functionA1</code>方法是相同的类型嘞？可以这么认为:Kotlin中的扩展函数将接收者本身当做第一个参数传入，要不然为啥在<code>String.A1()</code>里面可以使用<code>this</code>来代替调用者本身嘞？<br>那既然这样的话，也就是说这两者是可以互换的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">d</span><span class="hljs-params">(block :(<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>   block(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br>d(String::A1)<br>d(::functionA1)<br></code></pre></td></tr></table></figure><p>需要注意的是，这里仅针对在引用和调用时可以互相转换，比如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sayHi: (String) -&gt; <span class="hljs-built_in">Unit</span> = &#123; name:String-&gt;  println(<span class="hljs-string">&quot;hi <span class="hljs-variable">$name</span>&quot;</span>) &#125;<br>sayHi.invoke(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br>sayHi(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br><br><span class="hljs-keyword">val</span> sayHello: String.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; println(<span class="hljs-string">&quot;hello <span class="hljs-variable">$this</span>&quot;</span>) &#125;<br>sayHello.invoke(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br>sayHello(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br><span class="hljs-string">&quot;huangyuan&quot;</span>.sayHello()<br><br><span class="hljs-keyword">val</span> sayHiRef:(String)-&gt;<span class="hljs-built_in">Unit</span> =sayHi<br><span class="hljs-keyword">val</span> sayHiRef1: String.() -&gt; <span class="hljs-built_in">Unit</span> = sayHi<br></code></pre></td></tr></table></figure><p>但是如果将 sayHello 和sayHi这两个函数等号右边互换一下则会报错。</p><p>需要注意的是这里还有一个概念：<code>带接收者的函数字面值</code>（Function Literals with Receiver），也称为带接收者的 Lambda 表达式，是一种特殊的 Lambda 表达式。它允许在 Lambda 表达式中访问特定类型的对象的成员，就像在该对象的成员函数中一样。通过使用带接收者的函数字面值，可以在 Lambda 表达式中以更简洁的方式操作特定类型的对象。上面对<code>sayHello</code>的定义就属于这种形式。<br>也就是说：带有接收者的函数类型，例如 A.(B) -&gt; C，可以用特殊形式的函数字面值实例化—-带有接收者的函数字面值。<br>这里解释一下：所谓的字面量，就是不用变量名称直接用相对应的值写出来。比如“hello world”就是一个字符串字面量、12.23是一个 Double 的字面量、4是一个 Int 的字面量。</p><h3 id="函数类型实例调用"><a href="#函数类型实例调用" class="headerlink" title="函数类型实例调用"></a>函数类型实例调用</h3><p>既然能获取到函数类型的实例，那么肯定就可以调用了。<br>这里调用方式有两种，一种是通过<code>invoke()</code>，比如<code>func.invoke()</code>,或者直接在引用后面加上括号<code>func()</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> functionOne: <span class="hljs-built_in">Int</span>.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; println(<span class="hljs-string">&quot;aaFunRefRec <span class="hljs-variable">$this</span>  &quot;</span>) &#125;<br>functionOne.invoke(<span class="hljs-number">10001</span>)<br>functionOne(<span class="hljs-number">10001</span>)<br><br><span class="hljs-keyword">val</span> functionTwo: <span class="hljs-built_in">Int</span>.(String) -&gt; <span class="hljs-built_in">Unit</span> = &#123; println(<span class="hljs-string">&quot;other <span class="hljs-variable">$this</span>  &quot;</span>) &#125;<br>functionTwo.invoke(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;other&quot;</span>)<br>functionTwo(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;other&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>我们在使用Java语言开发Android 应用的时候可能已经体验过 Lambda 表达式了，最常见的就是给 View 设置点击监听的时候<br><img src="/image/kotlin/replace_with_lambda_tip.png" alt="replace_with_lambda_tip"><br>当我们点击了之后，代码就成了这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">llShowMoreDialog.setOnClickListener(v -&gt; showToast(<span class="hljs-string">&quot;点击了&quot;</span>));<br></code></pre></td></tr></table></figure><p>目前在 java 中只能简化成这样的，kotlin 中还可以进一步简化，后面再说。这里先看看Lambda表达式语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<br></code></pre></td></tr></table></figure><ul><li>lambda 表达式总是括在花括号中。</li><li>完整语法形式的参数声明放在花括号内，并有可选的类型标注。</li><li>函数体跟在一个 -&gt; 之后。</li><li>如果推断出的该 lambda 的返回类型不是 Unit，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。</li></ul><p>如果Lambda 表达式的参数可以推断出来，我们可以省略一些类型，比如上面的 sum 函数可以省略为</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum1 = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<br><span class="hljs-keyword">val</span> sum2: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x, y -&gt; x + y &#125;<br></code></pre></td></tr></table></figure><p>我们在写 Android 时经常会用到给某个控件设置点击事件，就像上面的例子一样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener(<span class="hljs-keyword">object</span> :View.OnClickListener&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;view?.id&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;)<br>view.setOnClickListener &#123; println(<span class="hljs-string">&quot;click <span class="hljs-variable">$it</span> &quot;</span>) &#125;<br></code></pre></td></tr></table></figure><h4 id="SAM转换"><a href="#SAM转换" class="headerlink" title="SAM转换"></a>SAM转换</h4><p>那么它是怎么从上面使用匿名内部类变成下面样子的？这里就要提一下<code>SAM转换</code>了：SAM是Single Abstract Method的缩写，意思就是只有一个抽象方法的类或者接口。但在Kotlin和Java 8里，SAM代表着只有一个抽象方法的接口。只要是符合SAM要求的接口，编译器就能进行SAM转换，也就是我们可以使用Lambda表达式，来简写接口类的参数。<br>需要注意的是，Java 8中的SAM有明确的名称，叫做<code>函数式接口(FunctionalInterface)</code>。FunctionalInterface的限制如下，缺一不可：</p><ul><li>必须是接口，抽象类不行；</li><li>该接口有且仅有一个抽象的方法，抽象方法个数必须是1，默认实现的方法可以有多个。</li></ul><p>同样的，在kotlin中也有限制：</p><ul><li>必须是函数接口，也就是声明为<code>fun interface</code></li><li>只能包含一个抽象方法，并且不能包含默认方法</li></ul><p>因此,kotlin 编译器会将该方法自动转化为<code>fun setOnClickListener(l: ((View!) -&gt; Unit)?)</code>，我们才得以使用 Lambda表达式来简化代码。可以将代码写成这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener(&#123;view:View?-&gt; println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;view?.id&#125;</span>&quot;</span>)&#125;)<br></code></pre></td></tr></table></figure><p>这种情况下，由于 kotlin 支持类型推导，所以我们可以将<code>View?</code>也省略掉，接着还会触发一个被称之为<code>单个参数的隐式名称</code>的东西，原话是这么说的</p><blockquote><p>If the compiler can parse the signature without any parameters, the parameter does not need to be declared and -&gt; can be omitted. 该参数会隐式声明为 it<br>因此，我们得到了这样子的代码</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener(&#123;println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;it?.id&#125;</span>&quot;</span>)&#125;)<br></code></pre></td></tr></table></figure><p>按照 Kotlin 惯例，如果函数的最后一个参数是函数，那么作为相应参数传入的 lambda 表达式可以放在圆括号之外：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener()&#123;println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;it?.id&#125;</span>&quot;</span>)&#125;<br></code></pre></td></tr></table></figure><p>这种语法也称为<code>拖尾lambda(trailing lambda)</code>表达式。<br>如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以完全省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener&#123;println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;it?.id&#125;</span>&quot;</span>)&#125;<br></code></pre></td></tr></table></figure><p>这就是我们最终得到的代码样子</p><h4 id="从lambda表达式中返回一个值"><a href="#从lambda表达式中返回一个值" class="headerlink" title="从lambda表达式中返回一个值"></a>从lambda表达式中返回一个值</h4><p>这里有两种方式，一种是隐式返回：如果我们什么都不做，将返回最后一个表达式的值。<br>另外一种就是使用限定的返回语法从lambda显式返回一个值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ints.filter &#123;<br>    <span class="hljs-keyword">val</span> shouldFilter = it &gt; <span class="hljs-number">0</span><br>    shouldFilter<br>&#125;<br><br>ints.filter &#123;<br>    <span class="hljs-keyword">val</span> shouldFilter = it &gt; <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span><span class="hljs-symbol">@filter</span> shouldFilter<br>&#125;<br></code></pre></td></tr></table></figure><p>这两种方式是等价的。<br>那么这个标签 <strong>@filter</strong>是怎么来的呢？<br>在 Kotlin 中任何表达式都可以用标签来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@。 要为一个表达式加标签，我们只要在其前加标签即可.<br>比如我们在嵌套函数中，标签限定的 return 允许我们从外层函数返回，比如从 Lambda 表达式中返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// 非局部直接返回到 foo() 的调用者</span><br>        print(it)<br>    &#125;<br>    println(<span class="hljs-string">&quot;this point is unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach <span class="hljs-symbol">lit@</span>&#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@lit</span> <span class="hljs-comment">// 局部返回到该 lambda 表达式的调用者——forEach 循环</span><br>        print(it)<br>    &#125;<br>    print(<span class="hljs-string">&quot; done with explicit label&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下使用<strong>隐式标签</strong>更方便，因为该标签与接受该 lambda 的函数同名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@forEach</span> <span class="hljs-comment">// 局部返回到该 lambda 表达式的调用者——forEach 循环</span><br>        print(it)<br>    &#125;<br>    print(<span class="hljs-string">&quot; done with implicit label&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>官方这里也给了一个提示：<strong>注意，这种非局部的返回只支持传给内联函数的 lambda 表达式</strong>，这个问题后面再说把，就是<code>inline</code>、<code>noinline</code>、<code>crossinline</code>这三个关键字带来的优化以及滥用的坏处。<br>另外这里还有一个小 tip：如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">map.forEach &#123; (_, value) -&gt; println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span>!&quot;</span>) &#125;<br></code></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>上文中的 Lambda 表达式缺少指定返回类型的能力，虽然大部分情况下返回值类型可以推导出来，但如果确实需要指定，我们可以使用<strong>匿名函数</strong>，<br>它看起来非常像一个常规函数声明，除了其名称省略了。其函数体既可以是表达式也可以是代码块：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = x + y<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure><p>如果参数类型可以推断出来，则参数类型可以省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ints.filter(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(item)</span></span> = item &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><hr><p>对于上面的内容<br>函数式（SAM）接口 英文版: <a href="https://kotlinlang.org/docs/fun-interfaces.html">Functional (SAM) interfaces</a><br>函数式（SAM）接口 中文版: <a href="https://book.kotlincn.net/text/fun-interfaces.html">函数式（SAM）接口</a><br>高阶函数和Lambda 英文版: <a href="https://kotlinlang.org/docs/lambdas.html">Higher-order functions and lambdas</a><br>高阶函数和Lambda 中文版: <a href="https://book.kotlincn.net/text/lambdas.html">高阶函数与 lambda 表达式</a><br>返回与跳转 中文版: <a href="https://book.kotlincn.net/text/returns.html">返回与跳转</a><br>返回与跳转 英文版: <a href="https://kotlinlang.org/docs/returns.html">Returns and jumps</a></p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>object</li><li>Unit</li><li>Nothing</li><li>with、let、run、apply、also</li><li>inline,noinline,crossinline</li></ul></li><li><p>泛型</p><ul><li>逆变</li><li>协变</li></ul></li><li><p>委托</p><ul><li>委托类</li><li>委托属性</li><li>自定义委托</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;继续上次在扩展函数中遗留下的问题：函数类型。总所周知，在Kotlin 中函数是一等公民。那么什么是高阶函数嘞？到处翻了翻，发现差不多是这么个意思：&lt;strong&gt;接受一个或多个函数作为参数，或者返回一个函数。&lt;/strong&gt;在 Kotlin 协程中的 launch、async函数以及各种各样的框架中到处都是高阶函数的影子，称高阶函数是 Kotlin函数式编程、各大框架的基石也不过分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的函数类型及扩展函数</title>
    <link href="https://blog.huangyuanlove.com/2024/04/22/Kotlin%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%8F%8A%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/"/>
    <id>https://blog.huangyuanlove.com/2024/04/22/Kotlin%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%8F%8A%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/</id>
    <published>2024-04-22T09:28:13.000Z</published>
    <updated>2024-04-28T03:12:44.861Z</updated>
    
    <content type="html"><![CDATA[<p>继续kotlin 的学习，之前只是学了点皮毛中的皮毛，会了一些简单语法而已。最后面列了一个大纲，认真的学习一下。<br>今天的内容是<strong>扩展</strong>。gradle：8.5，插件：id ‘org.jetbrains.kotlin.jvm’ version ‘1.9.23’</p><span id="more"></span><h3 id="简介和使用"><a href="#简介和使用" class="headerlink" title="简介和使用"></a>简介和使用</h3><p>kotlin 中扩展可以给已有的类添加额外的方法和属性，看起来就像是修改了类的源码一样，而不是像 java 一样需要继承该类然后添加自己的方法。扩展又分为扩展函数和扩展属性。<br>那么如何使用嘞？其实和声明普通函数几乎一致，只是多了一个叫做”接收者”的东西，也就是文档中的Receiver，说白了，其实就是限制这个接收者类型才能使用这个方法，也就是我们要对这个类型 <strong>“添加”</strong> 一个方法。<br>比如我们想要给字符串类型添加一个获取最后一个元素的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">lastChar</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Char</span>?&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(length - <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的方法声明表示：对<code>String</code>类型定义一个无参的<code>lastChar</code>方法，返回值是<code>Char?</code>，使用的时候就像使用 String 类中的方法一样使用就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;kotlin&quot;</span><br>    println(s.lastChar())<br>&#125;<br></code></pre></td></tr></table></figure><p>那么扩展属性怎么使用嘞？和扩展函数差不多：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> String.firstChar:<span class="hljs-built_in">Char</span>?<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.isEmpty()) <span class="hljs-literal">null</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>可以简单的认为上面的声明是这样:对<code>String</code>类型顶一个<code>firstChar</code>属性，类型是<code>Char?</code>,使用时和使用 String 类中的属性一样就好了:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;kotlin&quot;</span><br>    println(s.lastChar())<br>    println(s.firstChar)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思考：Java中如何使用？"><a href="#思考：Java中如何使用？" class="headerlink" title="思考：Java中如何使用？"></a>思考：Java中如何使用？</h3><p>接下来思考一下在 java 中如何调用嘞？得先看看 kotlin 是如何实现扩展的。最简单的方法，看反编译后的字节码文件：<br>顶部菜单中 tools–&gt;kotlin–&gt;Show Kotlin Bytecode，然后点Decompile就可以看到了<br><img src="/image/kotlin/show_kotlin_bytecode.png" alt="decompile kotlin bytecode"><br>代码大致如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainKt</span> &#123;<br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Character <span class="hljs-title function_">lastChar</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String $<span class="hljs-built_in">this</span>$lastChar)</span> &#123;<br>      Intrinsics.checkNotNullParameter($<span class="hljs-built_in">this</span>$lastChar, <span class="hljs-string">&quot;&lt;this&gt;&quot;</span>);<br>      <span class="hljs-keyword">return</span> ((CharSequence)$<span class="hljs-built_in">this</span>$lastChar).length() == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : $<span class="hljs-built_in">this</span>$lastChar.charAt($<span class="hljs-built_in">this</span>$lastChar.length() - <span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Character <span class="hljs-title function_">getFirstChar</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String $<span class="hljs-built_in">this</span>$firstChar)</span> &#123;<br>      Intrinsics.checkNotNullParameter($<span class="hljs-built_in">this</span>$firstChar, <span class="hljs-string">&quot;&lt;this&gt;&quot;</span>);<br>      <span class="hljs-keyword">return</span> ((CharSequence)$<span class="hljs-built_in">this</span>$firstChar).length() == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : $<span class="hljs-built_in">this</span>$firstChar.charAt(<span class="hljs-number">0</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;kotlin&quot;</span>;<br>      <span class="hljs-type">Character</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> lastChar(s);<br>      System.out.println(var1);<br>      var1 = getFirstChar(s);<br>      System.out.println(var1);<br>   &#125;<br><br>   <span class="hljs-comment">// $FF: synthetic method</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      main();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到反编译之后的代码只是添加了两个静态方法而已，这样的话，在 Java 中我们就可以这么使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        System.out.println( MainKt.lastChar(s));<br>        System.out.println( MainKt.getFirstChar(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思考：作用域，继承与重载"><a href="#思考：作用域，继承与重载" class="headerlink" title="思考：作用域，继承与重载"></a>思考：作用域，继承与重载</h3><p>接下来思考另外一个问题：作用域，或者说我们可以在哪里声明、在哪里调用扩展函数？<br>上面的例子中都是声明为了顶级函数(top level),我们可以在任意地方使用对应的类型进行调用，如果声明在类里面会怎么样？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">isEmail</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.contains(<span class="hljs-string">&quot;@&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">val</span> email = <span class="hljs-string">&quot;a@a.com&quot;</span><br>        println(email.isEmail())<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> email = <span class="hljs-string">&quot;a@a.com&quot;</span><br>    println(email.isEmail())<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在类里面定义的扩展函数，只能在类里面调用，在类外是无法使用的。但是，我们可以在继承Example的类中使用，比如这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubExample</span> :<span class="hljs-type">Example</span></span>()&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subTest</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">val</span> email = <span class="hljs-string">&quot;a@a&quot;</span><br>        println(email.isEmail())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么问题来了，如果对<code>Example</code>定义一个扩展函数，那么在子类SubExample中能调用么？答案是可以的，但是不能覆写，因为kotlin中的函数默认是<code>final</code>不能被覆写的，同时定义扩展函数时又不能被<code>open</code>修饰，从语法上讲，这是扩展函数不能被覆写的原因。看反编译之后的代码，定义为顶级函数的扩展函数是 static 的，因此也不能被覆写。<br>那么在 Java 中能不能用嘞？遇事不决先看反编译后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmail</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String $<span class="hljs-built_in">this</span>$isEmail)</span> &#123;<br>      Intrinsics.checkNotNullParameter($<span class="hljs-built_in">this</span>$isEmail, <span class="hljs-string">&quot;&lt;this&gt;&quot;</span>);<br>      <span class="hljs-keyword">return</span> StringsKt.contains$<span class="hljs-keyword">default</span>((CharSequence)$<span class="hljs-built_in">this</span>$isEmail, (CharSequence)<span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>, (Object)<span class="hljs-literal">null</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a@a.com&quot;</span>;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.isEmail(email);<br>      System.out.println(var2);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话就可以通过<code>Example</code>实例来调用了。同样注意到在<code>Example</code>类中定义的扩展函数<code>isEmail</code>被 final 修饰了，因此也无法通过继承来覆写该方法。</p><h3 id="思考：扩展函数如何引用？"><a href="#思考：扩展函数如何引用？" class="headerlink" title="思考：扩展函数如何引用？"></a>思考：扩展函数如何引用？</h3><p>嘿嘿嘿,我们知道函数是可以通过双冒号引用的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHi</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hi <span class="hljs-variable">$name</span>&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">referenceMethod</span><span class="hljs-params">(method: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    method(<span class="hljs-string">&quot;xuan&quot;</span>)<br>    method.invoke(<span class="hljs-string">&quot;yuan&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    referenceMethod(::sayHi)<br>    referenceMethod &#123; name -&gt; println(<span class="hljs-string">&quot;hello <span class="hljs-variable">$name</span>&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么扩展函数应该如何引用嘞？这里先学怎么用，后面再学函数类型吧<br>如果我们将扩展函数定义为顶级函数，那么在应用的时候和引用这个类本身的成员函数没啥区别,比如在一开始我们对 String 定义的扩展函数 lastChar,我们可以这么引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> lastCharFun1 = String::lastChar<br></code></pre></td></tr></table></figure><p>但是，如果我们将扩展函数定义在类里面又该如何应对？应对不了，没法引用。<br>为什么？思考一个问题，扩展函数属于哪个类？实际上可以认为扩展函数谁都不属于，只是加了一个限定，限定哪个类型的对象可以调用这个函数。<br>另外一个问题，语法上引用类的成员函数是类名双冒号函数名，那引用扩展函数也是这样，但是把扩展函数定义在其他类中，我们应该用哪个类名？干脆不能引用就好了。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解了扩展函数、扩展属性 及其作用域。了解了在 Java 层面如何实现的以及 Java 中如何使用。翻看 kotlin 源码，有很多都是基于扩展来实现的，比如 String、比如一些数字类型 Float、Double 等。</p><p>到此，扩展就差不多了，应该还会有一些小细节上的问题，但问题应该不大。接下来应该会学习一下遗留下来的问题：函数类型以及lambda 表达式</p><hr><p>已学习：</p><ul><li>扩展<ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li></ul><p>未学习：</p><ul><li><p>Lambda表达式</p><ul><li>SAM 转换</li><li>函数类型</li></ul></li><li><p>函数类型</p><ul><li>带有接收者的函数类型</li></ul></li><li><p>关键字</p><ul><li>object</li><li>Unit</li><li>Nothing</li><li>with、let、run、apply、also</li></ul></li><li><p>泛型</p><ul><li>逆变</li><li>协变</li></ul></li><li><p>委托</p><ul><li>委托类</li><li>委托属性</li><li>自定义委托</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;继续kotlin 的学习，之前只是学了点皮毛中的皮毛，会了一些简单语法而已。最后面列了一个大纲，认真的学习一下。&lt;br&gt;今天的内容是&lt;strong&gt;扩展&lt;/strong&gt;。gradle：8.5，插件：id ‘org.jetbrains.kotlin.jvm’ version ‘1.9.23’&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit流程分析</title>
    <link href="https://blog.huangyuanlove.com/2024/04/07/Retrofit%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://blog.huangyuanlove.com/2024/04/07/Retrofit%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2024-04-07T07:35:44.000Z</published>
    <updated>2024-04-08T06:31:54.409Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中介绍了《在kotlin协程中使用自定义CallAdapter处理错误》，既然选择了它，当然得先全面了解一下。<br>先下载一下源码，搭建一下环境，也没啥好说的，我下载的是2.11.0 版本的代码，使用的 IDEA2023.3.6。这都是小事情，只要能有代码跳转功能就好。首次配置需要下载相应依赖，时间会长一些，这不重要。等配置完成后，找到 simple module，有各种各样的示例代码。是可以直接运行的。</p><span id="more"></span><h2 id="创建Retrofit对象"><a href="#创建Retrofit对象" class="headerlink" title="创建Retrofit对象"></a>创建Retrofit对象</h2><p>我们先从如何创建的<code>Retrofit</code>对象开始<br>先看一下我们可以设置哪些参数，撸一下源码，找一下<code>Retrofit.Builder</code>类</p><h3 id="设置OkHttpClient"><a href="#设置OkHttpClient" class="headerlink" title="设置OkHttpClient"></a>设置<code>OkHttpClient</code></h3><p>这里的<code>OkHttpClient</code>实现了<code>Call.Factory</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">client</span><span class="hljs-params">(OkHttpClient client)</span> &#123;<br>  <span class="hljs-keyword">return</span> callFactory(Objects.requireNonNull(client, <span class="hljs-string">&quot;client == null&quot;</span>));<br>&#125;<br><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">callFactory</span><span class="hljs-params">(okhttp3.Call.Factory factory)</span> &#123;<br>  <span class="hljs-built_in">this</span>.callFactory = Objects.requireNonNull(factory, <span class="hljs-string">&quot;factory == null&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="设置-baseUrl"><a href="#设置-baseUrl" class="headerlink" title="设置 baseUrl"></a>设置 baseUrl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">baseUrl</span><span class="hljs-params">(URL baseUrl)</span> &#123;<br>  Objects.requireNonNull(baseUrl, <span class="hljs-string">&quot;baseUrl == null&quot;</span>);<br>  <span class="hljs-keyword">return</span> baseUrl(HttpUrl.get(baseUrl.toString()));<br>&#125;<br><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">baseUrl</span><span class="hljs-params">(String baseUrl)</span> &#123;<br>  Objects.requireNonNull(baseUrl, <span class="hljs-string">&quot;baseUrl == null&quot;</span>);<br>  <span class="hljs-keyword">return</span> baseUrl(HttpUrl.get(baseUrl));<br>&#125;<br><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">baseUrl</span><span class="hljs-params">(HttpUrl baseUrl)</span> &#123;<br>  Objects.requireNonNull(baseUrl, <span class="hljs-string">&quot;baseUrl == null&quot;</span>);<br>  List&lt;String&gt; pathSegments = baseUrl.pathSegments();<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;&quot;</span>.equals(pathSegments.get(pathSegments.size() - <span class="hljs-number">1</span>))) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;baseUrl must end in /: &quot;</span> + baseUrl);<br>  &#125;<br>  <span class="hljs-built_in">this</span>.baseUrl = baseUrl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">addConverterFactory</span><span class="hljs-params">(Converter.Factory factory)</span> &#123;<br>  converterFactories.add(Objects.requireNonNull(factory, <span class="hljs-string">&quot;factory == null&quot;</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="支持’Call’对象之外的返回类型"><a href="#支持’Call’对象之外的返回类型" class="headerlink" title="支持’Call’对象之外的返回类型"></a>支持’Call’对象之外的返回类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">addCallAdapterFactory</span><span class="hljs-params">(CallAdapter.Factory factory)</span> &#123;<br>  callAdapterFactories.add(Objects.requireNonNull(factory, <span class="hljs-string">&quot;factory == null&quot;</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用-callBack-时使用的Executor"><a href="#调用-callBack-时使用的Executor" class="headerlink" title="调用 callBack 时使用的Executor"></a>调用 callBack 时使用的Executor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">callbackExecutor</span><span class="hljs-params">(Executor executor)</span> &#123;<br>  <span class="hljs-built_in">this</span>.callbackExecutor = Objects.requireNonNull(executor, <span class="hljs-string">&quot;executor == null&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="是否提前验证接口中定义的方法"><a href="#是否提前验证接口中定义的方法" class="headerlink" title="是否提前验证接口中定义的方法"></a>是否提前验证接口中定义的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">validateEagerly</span><span class="hljs-params">(<span class="hljs-type">boolean</span> validateEagerly)</span> &#123;<br>  <span class="hljs-built_in">this</span>.validateEagerly = validateEagerly;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用-build-方法创建-Retrofit-对象"><a href="#调用-build-方法创建-Retrofit-对象" class="headerlink" title="调用 build()方法创建 Retrofit 对象"></a>调用 build()方法创建 Retrofit 对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Retrofit <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (baseUrl == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Base URL required.&quot;</span>);<br>  &#125;<br><br>  okhttp3.Call.<span class="hljs-type">Factory</span> <span class="hljs-variable">callFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.callFactory;<br>  <span class="hljs-keyword">if</span> (callFactory == <span class="hljs-literal">null</span>) &#123;<br>      callFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>();<br>  &#125;<br><br>  <span class="hljs-type">Executor</span> <span class="hljs-variable">callbackExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.callbackExecutor;<br>  <span class="hljs-keyword">if</span> (callbackExecutor == <span class="hljs-literal">null</span>) &#123;<br>      callbackExecutor = Platform.callbackExecutor;<br>  &#125;<br><br>  <span class="hljs-type">BuiltInFactories</span> <span class="hljs-variable">builtInFactories</span> <span class="hljs-operator">=</span> Platform.builtInFactories;<br><br>  <span class="hljs-comment">// Make a defensive copy of the adapters and add the default Call adapter.</span><br>  List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.callAdapterFactories);<br>  List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CallAdapter</span>.Factory&gt; defaultCallAdapterFactories =<br>  builtInFactories.createDefaultCallAdapterFactories(callbackExecutor);<br>  callAdapterFactories.addAll(defaultCallAdapterFactories);<br><br>  <span class="hljs-comment">// Make a defensive copy of the converters.</span><br>  List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Converter</span>.Factory&gt; defaultConverterFactories =<br>  builtInFactories.createDefaultConverterFactories();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">defaultConverterFactoriesSize</span> <span class="hljs-operator">=</span> defaultConverterFactories.size();<br>  List&lt;Converter.Factory&gt; converterFactories =<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">1</span> + <span class="hljs-built_in">this</span>.converterFactories.size() + defaultConverterFactoriesSize);<br><br>  <span class="hljs-comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span><br>  <span class="hljs-comment">// ensures correct behavior when using converters that consume all types.</span><br>  converterFactories.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BuiltInConverters</span>());<br>  converterFactories.addAll(<span class="hljs-built_in">this</span>.converterFactories);<br>  converterFactories.addAll(defaultConverterFactories);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>(<br>      callFactory,<br>      baseUrl,<br>      unmodifiableList(converterFactories),<br>      defaultConverterFactoriesSize,<br>      unmodifiableList(callAdapterFactories),<br>      defaultCallAdapterFactories.size(),<br>      callbackExecutor,<br>      validateEagerly);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>首先检查是否设置了 baseUrl，没设置直接抛异常</li><li>设置callFactory，默认为OkHttpClient</li><li>设置callbackExecutor默认为platform.defaultCallbackExecutor()，Android平台为MainThreadExecutor，其他平台为 null。这里的 AndroidMainExecutor 只是简单的使用 handler 转发到主线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidMainExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper());<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> &#123;<br>      handler.post(r);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>callAdapterFactories 默认添加 platform.defaultCallAdapterFactories,返回值为DefaultCallAdapterFactory，之后在 kotlin 中使用密闭类代替 callback 时就是抄的这个类中的方法</li><li>converterFactories<br>  ○ 先添加 new BuiltInConverters()<br>  ○ 再添加自定义的<br>  ○ 最后添加platform.defaultConverterFactories() 默认是空的<br>这样就配置好的 Retrofit 对象</li></ol><h2 id="如何发送请求"><a href="#如何发送请求" class="headerlink" title="如何发送请求"></a>如何发送请求</h2><p>我们在定义网络请求时是这么写的</p><h3 id="定义网络请求"><a href="#定义网络请求" class="headerlink" title="定义网络请求"></a>定义网络请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GitHub</span> &#123;<br>  <span class="hljs-meta">@GET(&quot;/repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span><br>  Call&lt;List&lt;Contributor&gt;&gt; <span class="hljs-title function_">contributors</span><span class="hljs-params">(<span class="hljs-meta">@Path(&quot;owner&quot;)</span> String owner, <span class="hljs-meta">@Path(&quot;repo&quot;)</span> String repo)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建GitHub对象-和发送请求"><a href="#创建GitHub对象-和发送请求" class="headerlink" title="创建GitHub对象 和发送请求"></a>创建<strong>GitHub对象</strong> 和发送请求</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Create an instance of our GitHub API interface.</span><br><span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> retrofit.create(GitHub.class);<br><span class="hljs-comment">// Create a call instance for looking up Retrofit contributors.</span><br>Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(<span class="hljs-string">&quot;square&quot;</span>, <span class="hljs-string">&quot;retrofit&quot;</span>);<br><span class="hljs-comment">// Fetch and print a list of the contributors to the library.</span><br>List&lt;Contributor&gt; contributors = call.execute().body();<br></code></pre></td></tr></table></figure><p>重点在我们调用<code>retrofit.create</code>方法时用到的动态代理商</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;T&gt; service)</span> &#123;<br>  validateServiceInterface(service);<br>  <span class="hljs-keyword">return</span> (T)<br>      Proxy.newProxyInstance(<br>          service.getClassLoader(),<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123;service&#125;,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] emptyArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>];<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>                <span class="hljs-keyword">throws</span> Throwable &#123;<br>              <span class="hljs-comment">// If the method is a method from Object then defer to normal invocation.</span><br>              <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;<br>                <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>, args);<br>              &#125;<br>              args = args != <span class="hljs-literal">null</span> ? args : emptyArgs;<br>              <span class="hljs-type">Reflection</span> <span class="hljs-variable">reflection</span> <span class="hljs-operator">=</span> Platform.reflection;<br>              <span class="hljs-keyword">return</span> reflection.isDefaultMethod(method)<br>                  ? reflection.invokeDefaultMethod(method, service, proxy, args)<br>                  : loadServiceMethod(service, method).invoke(proxy, args);<br>            &#125;<br>          &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="validateServiceInterface"><a href="#validateServiceInterface" class="headerlink" title="validateServiceInterface"></a>validateServiceInterface</h3><p>创建 Github 对象时使用了动态代理，不过在创建之前，先调用了<code>validateServiceInterface(service);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateServiceInterface</span><span class="hljs-params">(Class&lt;?&gt; service)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!service.isInterface()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;API declarations must be interfaces.&quot;</span>);<br>    &#125;<br><br>    Deque&lt;Class&lt;?&gt;&gt; check = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>    check.add(service);<br>    <span class="hljs-keyword">while</span> (!check.isEmpty()) &#123;<br>      Class&lt;?&gt; candidate = check.removeFirst();<br>      <span class="hljs-keyword">if</span> (candidate.getTypeParameters().length != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Type parameters are unsupported on &quot;</span>).append(candidate.getName());<br>        <span class="hljs-keyword">if</span> (candidate != service) &#123;<br>          message.append(<span class="hljs-string">&quot; which is an interface of &quot;</span>).append(service.getName());<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(message.toString());<br>      &#125;<br>      Collections.addAll(check, candidate.getInterfaces());<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (validateEagerly) &#123;<br>      <span class="hljs-type">Reflection</span> <span class="hljs-variable">reflection</span> <span class="hljs-operator">=</span> Platform.reflection;<br>      <span class="hljs-keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;<br>        <span class="hljs-keyword">if</span> (!reflection.isDefaultMethod(method)<br>            &amp;&amp; !Modifier.isStatic(method.getModifiers())<br>            &amp;&amp; !method.isSynthetic()) &#123;<br>          loadServiceMethod(service, method);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>先检查 Github 类是不是 Interface，接着定义一个双端队列，对当前接口及其父接口进行递归检查，这里是不支持泛型参数的。<br>在接下来判断一下在创建 Retrofit 时传入的validateEagerly参数，如果是 true，并且声明的方法不是默认、不是静态、不是合成方法，则调用loadServiceMethod方法解析接口中声明的方法。</p><h3 id="loadServiceMethod"><a href="#loadServiceMethod" class="headerlink" title="loadServiceMethod"></a>loadServiceMethod</h3><p>首先调用<code>ServiceMethod.parseAnnotations(this, service, method);</code>，先从缓存的map中获取有没有已经解析好的ServiceMethod。如果没有则调用ServiceMethod.parseAnnotations(this, method)方法进行解析。</p><h4 id="第一步创建requestFactory对象"><a href="#第一步创建requestFactory对象" class="headerlink" title="第一步创建requestFactory对象"></a>第一步创建requestFactory对象</h4><p>调用了 <code>RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, service, method); </code>，解析了例如请求方式（即 POST 还是 GET 等请求），请求头，contentType 等等参数并返回了一个<code>RequestFactory</code>对象</p><h4 id="第二步创建HttpServiceMethod子类CallAdapted"><a href="#第二步创建HttpServiceMethod子类CallAdapted" class="headerlink" title="第二步创建HttpServiceMethod子类CallAdapted"></a>第二步创建HttpServiceMethod子类CallAdapted</h4><p>接着通过<code>HttpServiceMethod</code>的静态方法<code>parseAnnotations</code>进一步解析，入参有<code>Retrofit</code>对象，<code>Method</code>对象和刚才创建的<code>RequestFactory </code>对象。<code>HttpServiceMethod</code>继承自<code>ServiceMethod</code>，但也是个抽象类，这个类提供的<code>parseAnnotations</code>方法的主要内容是进一步解析，并通过<code>createCallAdapter</code>创建适配器、通过<code>createResponseConverter</code>创建转换器，最后利用<code>RequestFactory</code>对象，<code>OkHttp</code>对象，<code>转换器</code>对象，<code>适配器</code>对象创建了一个<code>CallAdapted</code>类型的对象并返回。</p><h5 id="创建适配器"><a href="#创建适配器" class="headerlink" title="创建适配器"></a>创建适配器</h5><p>如果我们前面没有调用<code>addCallAdapterFactory(CallAdapter.Factory factory)</code>添加自定义的Factory的话，这里返回的是默认的<code>DefaultCallAdapterFactory</code>对象。<br>在该类的<code>adapt</code>方法中返回的<code>CallAdapter</code>对象中，先判断了<code>executor</code>是不是空，这里的<code>executor</code>就是在创建<code>Retrofit</code>时调用<code>public Builder callbackExecutor(Executor executor)</code>方法时传入的对象，前面也说过，在**Android(Dalvik)**平台上默认是<code>AndroidMainExecutor</code>,其他平台默认为空。</p><p>简单讲，<code>DefaultCallAdapterFactory</code>大致如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultCallAdapterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CallAdapter</span>.Factory &#123;<br>    <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span><br>        Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)<br>            ? <span class="hljs-literal">null</span><br>            : callbackExecutor;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallAdapter</span>&lt;Object, Call&lt;?&gt;&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> Type <span class="hljs-title function_">responseType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> responseType;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> Call&lt;Object&gt; <span class="hljs-title function_">adapt</span><span class="hljs-params">(Call&lt;Object&gt; call)</span> &#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> ? call : <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorCallbackCall</span>&lt;&gt;(executor, call);<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutorCallbackCall</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Call</span>&lt;T&gt; &#123;<br>   ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;<br>      <span class="hljs-built_in">this</span>.callbackExecutor = callbackExecutor;<br>      <span class="hljs-built_in">this</span>.delegate = delegate;<br>    &#125;<br>    <span class="hljs-comment">//。。。。一系列的方法，除了enqueue(final Callback&lt;T&gt; callback)方法外，都是调用delegate中对应的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="创建转换器"><a href="#创建转换器" class="headerlink" title="创建转换器"></a>创建转换器</h5><p>我们在使用的时候一般会传入一个ConverterFactory对象，比如MoshiConverterFactory、GsonConverterFactory等。最主要的就两个方法<br><code>responseBodyConverter</code> and <code>requestBodyConverter</code>.在调用<code>HttpServiceMethod.createResponseConverter</code>时，兜兜转转最终还是调用了 <code>Retrofit.nextCallAdapter</code>方法，从我们一开始构建的 Retrofit 对象中查找对应的转换器</p><h5 id="创建CallAdapted对象"><a href="#创建CallAdapted对象" class="headerlink" title="创建CallAdapted对象"></a>创建CallAdapted对象</h5><p>这里直接调用的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallAdapted</span>&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);<br></code></pre></td></tr></table></figure><p>注意这里传入的<code>callAdapter</code>对象就是前面提到的调用<code>createCallAdapter</code>返回的默认<code>DefaultCallAdapterFactory</code>示例。<br><code>CallAdapted</code>类是<code>HttpServiceMethod</code>的子类，实现了父类的抽象方法<code>adapt</code>。而<code>HttpServiceMethod</code>又实现了<code>ServiceMethod</code>的抽象方法<code>invoke</code>，在<code>invoke</code>方法里调用了<code>adapt</code>方法。</p><h4 id="loadServiceMethod过程总结"><a href="#loadServiceMethod过程总结" class="headerlink" title="loadServiceMethod过程总结"></a>loadServiceMethod过程总结</h4><p>所以前面说到的加载过程(loadServiceMethod)，最终就是返回了一个<code>CallAdapted</code>类型的对象，并存到缓存中。接下去就是调用了<code>CallAdapted</code>对象的<code>invoke</code>方法，显然最终调用了<code>CallAdapted</code>自身的<code>adapt</code>方法。<code>CallAdapted</code>提供的<code>adapt</code>方法里就一句，那就是调用适配器的<code>adapt</code>方法，并返回一个值。这个值就是我们定义的接口类型的代理对象.之后调用调用定义的接口方法获取到Call对象，调用enqueue异步执行；调用execute同步执行；</p><h3 id="invoke过程"><a href="#invoke过程" class="headerlink" title="invoke过程"></a>invoke过程</h3><p>前面知道了<code>loadServiceMethod</code>返回的是一个<code>CallAdapted</code>对象，然后紧接着调用了<code>invoke</code>方法。但<code>CallAdapted</code>并没有重写该方法，所以实际上还是调用的<code>HttpServiceMethod</code>类中的<code>invoke</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> ReturnT <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object instance, Object[] args)</span> &#123;<br>  Call&lt;ResponseT&gt; call =<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpCall</span>&lt;&gt;(requestFactory, instance, args, callFactory, responseConverter);<br>  <span class="hljs-keyword">return</span> adapt(call, args);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/Android/retrofit/NewOkHttpCall.png"><br><img src="/image/Android/retrofit/NewOkhttpCallArgs.png"></p><p>接着调用了<code>adapt(call, args)</code>方法，这个方法就需要子类实现了，这里的子类是<code>CallAdapted</code>,在<code>CallAdapted</code>中接着调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ReturnT <span class="hljs-title function_">adapt</span><span class="hljs-params">(Call&lt;ResponseT&gt; call, Object[] args)</span> &#123;<br>  <span class="hljs-keyword">return</span> callAdapter.adapt(call);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法中的<code>callAdapter</code>对象就是前面提到的<code>DefaultCallAdapterFactory.get</code>方法中返回的<code>CallAdapter</code>,调用了该对应的<code>adapt</code>方法。在上面的介绍的<strong>创建适配器</strong>小结中提到，在**Android(Dalvik)**平台上默认有<code>AndroidMainExecutor</code>,其他平台默认为空。所以在没有额外添加<code>callbackExecutor</code>的情况下，Android 平台上返回的是<code>ExecutorCallbackCall</code>,在其他平台上默认返回的就是参数中的<code>call</code>对象，也就是<code>retrofit2.OkHttpCall</code>。 这个对象也就是我们调用接口中的方法返回的对象。</p><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>上面提到在 Android 平台上会返回<code>ExecutorCallbackCall</code>对象，其他平台返回<code>retrofit2.OkHttpCall</code>对象。但在创建<code>ExecutorCallbackCall</code><br>对象的时候也会将<code>retrofit2.OkHttpCall</code>传进去，在调用各种方法的时候还是调用的<code>retrofit2.OkHttpCall</code>对象的方法，只不过在调用<code>void enqueue(Callback&lt;T&gt; callback);</code>方法的<code>callback</code>回调中使用<code>callbackExecutor</code>将回调切换回主线程而已。</p><p>在调用<code>retrofit2.OkHttpCall</code>的<code>enqueue</code>或者<code>execute</code>方法时，会调用<code>createRawCall</code>方法创建一个<code>okhttp3.Call</code>对象，实际上的网络请求还是 okhttp 发出的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> okhttp3.Call <span class="hljs-title function_">createRawCall</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  okhttp3.<span class="hljs-type">Call</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> callFactory.newCall(requestFactory.create(instance, args));<br>  <span class="hljs-keyword">if</span> (call == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Call.Factory returned null.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> call;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>requestFactory</code>是上面提到的<code>parseAnnotations</code>时创建的<code>RequestFactory</code>对象，包含了部分请求信息。这里又用它创建了<code>okhttp3.Request</code>对象。创建好之后接着就创建了<code>okhttp3.Call</code>对象，接下来就是调用<code>enqueue</code>或者<code>execute</code>方法发送请求。<br>当请求数据返回时，会调用<code>parseResponse(okhttp3.Response rawResponse)</code>方法，最终调用的是<code>responseConverter.convert(catchingBody)</code>方法，这里的<code>responseConverter</code>就是我们在创建<code>Retrofit</code>对象调用<code>addConverterFactory</code>时传入的解析方法.<br>至此，完成了一次网络请求。</p><hr><p>以上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的文章中介绍了《在kotlin协程中使用自定义CallAdapter处理错误》，既然选择了它，当然得先全面了解一下。&lt;br&gt;先下载一下源码，搭建一下环境，也没啥好说的，我下载的是2.11.0 版本的代码，使用的 IDEA2023.3.6。这都是小事情，只要能有代码跳转功能就好。首次配置需要下载相应依赖，时间会长一些，这不重要。等配置完成后，找到 simple module，有各种各样的示例代码。是可以直接运行的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Retrofit" scheme="https://blog.huangyuanlove.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>在kotlin协程中使用自定义CallAdapter处理错误</title>
    <link href="https://blog.huangyuanlove.com/2024/03/29/kotlin%E4%B8%ADRetrofit2-x%E8%87%AA%E5%AE%9A%E4%B9%89CallAdapter%E5%81%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://blog.huangyuanlove.com/2024/03/29/kotlin%E4%B8%ADRetrofit2-x%E8%87%AA%E5%AE%9A%E4%B9%89CallAdapter%E5%81%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</id>
    <published>2024-03-29T10:14:05.000Z</published>
    <updated>2024-06-07T07:58:27.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Retrofit在2019-06-05发布的2.6.0版本中就已经支持Kotlin 中的 suspend修饰符了，目前正准备在项目中使用 Kotlin，顺便替换一下网络库。这里先做一下调研和基础建设，方便后续的接入工作。<br>问就是15 年 16 年的老项目，之前并没有使用 Kotlin 的打算。</p><p>Retrofit已经在2024-03-28更新到2.11.0版本了，就用这个来做调研好了。</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;com.squareup.retrofit2:retrofit:2.11.0&#x27;</span><br>implementation <span class="hljs-string">&#x27;com.squareup.retrofit2:converter-gson:2.11.0&#x27;</span><br>implementation <span class="hljs-string">&#x27;com.squareup.okhttp3:okhttp:4.12.0&#x27;</span><br></code></pre></td></tr></table></figure><p>由于需要对 OKHttpClient 做一些操作和定制，这里添加了 okhttp 的依赖。实体类的转换使用了 gson，为啥用 gson，问就是项目里面就是用的 gson，后面再介绍一下其他的converter。</p><ul><li>Gson: com.squareup.retrofit2:converter-gson</li><li>Jackson: com.squareup.retrofit2:converter-jackson</li><li>Moshi: com.squareup.retrofit2:converter-moshi</li><li>Protobuf: com.squareup.retrofit2:converter-protobuf</li><li>Wire: com.squareup.retrofit2:converter-wire</li><li>Simple XML: com.squareup.retrofit2:converter-simplexml</li><li>JAXB: com.squareup.retrofit2:converter-jaxb</li><li>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</li></ul><h3 id="声明请求接口"><a href="#声明请求接口" class="headerlink" title="声明请求接口"></a>声明请求接口</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MainPageApi</span></span>&#123;<br>  <span class="hljs-meta">@GET(<span class="hljs-string">&quot;app_interface/home_pag/&quot;</span>)</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMainPageInfoWithRow</span><span class="hljs-params">()</span></span>:Call&lt;MainPageInfo&gt;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建-Retrofit-对象"><a href="#创建-Retrofit-对象" class="headerlink" title="创建 Retrofit 对象"></a>创建 Retrofit 对象</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()<br>    .baseUrl(BASE_URL)<br>    .addConverterFactory(GsonConverterFactory.create())<br>    .build()<br></code></pre></td></tr></table></figure><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> mainPageApi = retrofit.create(MainPageApi::<span class="hljs-keyword">class</span>.java)<br>mainPageApi.getMainPageInfoWithCall().enqueue(<span class="hljs-keyword">object</span>:retrofit2.Callback&lt;MainPageInfo&gt;&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">MainPageInfo</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">        response: <span class="hljs-type">retrofit2</span>.<span class="hljs-type">Response</span>&lt;<span class="hljs-type">MainPageInfo</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>,<span class="hljs-string">&quot;getMainPageInfoWithCall onResponse&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">MainPageInfo</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>,<span class="hljs-string">&quot;getMainPageInfoWithCall onFailure&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>到这里为止，我们还没有使用任何协程相关的特性，并且没有都得写回调，和 Java 写起来也没啥差别。</p><h3 id="支持协程"><a href="#支持协程" class="headerlink" title="支持协程"></a>支持协程</h3><p>我们对接口的声明加上<code>suspend</code>修饰</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@GET(<span class="hljs-string">&quot;app_interface/home_pag/&quot;</span>)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMainPageInfoWithRow</span><span class="hljs-params">()</span></span>:Call&lt;MainPageInfo&gt;<br></code></pre></td></tr></table></figure><p>这时候上面直接发送请求的代码会报错：<br><img src="/image/Android/kotlin/suspend_retrofit_error.png" alt="suspend_retrofit_error"><br>提示我们需要在协程中调用，这也简单，kotlin 对 activity 有个扩展的<code>lifecycleScope</code>成员变量，稍微修改一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lifecycleScope.launch(Dispatchers.IO) &#123;<br>  mainPageApi.getMainPageInfoWithCall().enqueue(.....)<br>&#125;<br></code></pre></td></tr></table></figure><p>不习惯这么写的话，可以将网络请求写在 ViewModel 中，通过 LiveData创建一个可观察对象实现数据绑定。</p><p>不出意外的出意外了，应用崩溃，错误信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">java.lang.IllegalArgumentException: Suspend functions should not return Call, as they already execute asynchronously.<br>Change its return type to class com.huangyuanlove.androidtest.kotlin.retrofit.MainPageInfo<br></code></pre></td></tr></table></figure><p>意思是在协程中发起请求已经是异步的了，不需要再返回 Call 对象了，直接返回对应的实体即可。<br>简单，修改一下接口声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@GET(<span class="hljs-string">&quot;app_interface/home_page/&quot;</span>)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMainPageInfoWithRow</span><span class="hljs-params">()</span></span>:MainPageInfo<br></code></pre></td></tr></table></figure><p>然后修改一下请求</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lifecycleScope.launch(Dispatchers.IO) &#123;<br>  <span class="hljs-keyword">val</span> mainPageInfo = mainPageApi.getMainPageInfo()<br>  withContext(Dispatchers.Main) &#123;<br>    refreshUI(mainPageInfo)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行一下，一切正常。我们修改一下接口，请求一个不存在的地址，会返回404，不出意外，应用还是崩溃</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">retrofit2.HttpException: HTTP 404 <br>at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)<br>at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)<br>at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:519)<br>at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)<br>at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)<br>at java.lang.Thread.run(Thread.java:929)<br>Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine&#123;Cancelling&#125;@ffa6ad2, Dispatchers.IO]<br></code></pre></td></tr></table></figure><p>哦~异常没有处理，粗暴点，直接 try-catch，kotlin 中还有<code>runCatching</code>这个语法糖</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> mainPageInfoRow = runCatching &#123; mainPageApi.getMainPageInfoWithRow() &#125;<br><span class="hljs-keyword">if</span> (mainPageInfoRow.isFailure) &#123;<br>    ToastUtils.showToast(<span class="hljs-string">&quot;请求失败&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mainPageInfoRow.isSuccess) &#123;<br>    ToastUtils.showToast(<span class="hljs-string">&quot;请求成功&quot;</span>)<br>    withContext(Dispatchers.Main) &#123;<br>        <span class="hljs-keyword">if</span> (mainPageInfoRow.getOrNull() == <span class="hljs-literal">null</span>) &#123;<br>            ToastUtils.showToast(<span class="hljs-string">&quot;请求结果为空&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            refreshViewWithLaunch(mainPageInfoRow.getOrNull()!!)<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是有时候我们会用<code>HTTP状态码</code>来表示一些业务上逻辑错误，并且不同的状态码返回的 JSON 结构还可能不一样。 别问为啥要这么搞，应该是HTTP 状态码就应该表示网络请求的状态，业务状态应该放在返回的数据中约定字段来处理。问就是15年的老代码，之前就是这么搞的，并且大范围应用，涉及到的部门、业务占半数以上。<br>这时候我们需要自定义<code>CallAdapter</code>了</p><h3 id="自定义-CallAdapter"><a href="#自定义-CallAdapter" class="headerlink" title="自定义 CallAdapter"></a>自定义 CallAdapter</h3><p>这时候就应该翻一下源码了，在<code>example</code>有个<code>ErrorHandlingAdapter.java</code>,路径在<a href="https://github.com/square/retrofit/blob/trunk/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java">samples&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;retrofit&#x2F;ErrorHandlingAdapter.java</a>。<br>我们来仿写一下，最关键的点在实现自己的 Call 类的时候，对callback 的处理。</p><h4 id="定义不同的返回状态"><a href="#定义不同的返回状态" class="headerlink" title="定义不同的返回状态"></a>定义不同的返回状态</h4><p>第一步，创建密闭类，来表示不同的状态，这里暂且定义了三种情况</p><ul><li>Success:HTTP状态码在<code>[200,300)</code>这个区间</li><li>NetError:HTTP状态码不在<code>[200,300)</code>这个区间</li><li>UnknownError:其他错误</li></ul><p>sealed class NetworkResponse&lt;out T : Any, out U : Any&gt; {<br>    data class Success<T : Any>(val body: T) : NetworkResponse&lt;T, Nothing&gt;()<br>    data class NetError(val httpCode:Int?,val errorMsg:String?,val exception: Throwable?) : NetworkResponse&lt;Nothing, Nothing&gt;()<br>    data class UnknownError(val error: Throwable?) : NetworkResponse&lt;Nothing, Nothing&gt;()<br>}</p><h4 id="创建自己的Call类"><a href="#创建自己的Call类" class="headerlink" title="创建自己的Call类"></a>创建自己的Call类</h4><p>这里为了简化方便，除了<code>enqueue</code>之外必须重写的方法，都是直接调用<code>delegate</code>对应的方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkResponseCall</span>&lt;<span class="hljs-type">S : Any, E : Any</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> delegate: Call&lt;S&gt;,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> errorConverter: Converter&lt;ResponseBody, E&gt;<br>) : Call&lt;NetworkResponse&lt;S, E&gt;&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>: Call&lt;NetworkResponse&lt;S, E&gt;&gt; &#123;<br>        <span class="hljs-keyword">return</span> NetworkResponseCall(delegate.clone(), errorConverter);<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>: Response&lt;NetworkResponse&lt;S, E&gt;&gt; &#123;<br>        <span class="hljs-keyword">throw</span> UnsupportedOperationException(<span class="hljs-string">&quot;NetworkResponseCall doesn&#x27;t support execute&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isExecuted</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> delegate.isExecuted;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> &#123;<br>        delegate.cancel()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isCanceled</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> delegate.isCanceled<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>: Request &#123;<br>        <span class="hljs-keyword">return</span> delegate.request()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>: Timeout &#123;<br>        <span class="hljs-keyword">return</span> delegate.timeout();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是关键的<code>enqueue</code>方法,在这里面，将所有的请求都用<code>Response.success</code>返回，不再走<code>Response.error</code>.并且根据不同的 HTTP 状态码，返回的数据等条件转成一开始定义的密闭类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(callback: <span class="hljs-type">Callback</span>&lt;<span class="hljs-type">NetworkResponse</span>&lt;<span class="hljs-type">S</span>, E&gt;&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> delegate.enqueue(<span class="hljs-keyword">object</span> : Callback&lt;S&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">S</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">S</span>&gt;)</span></span> &#123;<br>            <span class="hljs-keyword">val</span> body = response.body()<br>            <span class="hljs-keyword">val</span> code = response.code()<br>            <span class="hljs-keyword">val</span> error = response.errorBody()<br><br>            <span class="hljs-keyword">if</span> (response.isSuccessful) &#123;<br>                <span class="hljs-keyword">if</span> (body != <span class="hljs-literal">null</span>) &#123;<br>                    callback.onResponse(<br>                        <span class="hljs-keyword">this</span><span class="hljs-symbol">@NetworkResponseCall</span>,<br>                        Response.success(NetworkResponse.Success(body))<br>                    )<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <br>                    callback.onResponse(<br>                        <span class="hljs-keyword">this</span><span class="hljs-symbol">@NetworkResponseCall</span>,<br>                        Response.success(NetworkResponse.UnknownError(<span class="hljs-literal">null</span>))<br>                    )<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">val</span> errorBody = <span class="hljs-keyword">when</span> &#123;<br>                    error == <span class="hljs-literal">null</span> -&gt; <span class="hljs-literal">null</span><br>                    error.contentLength() == <span class="hljs-number">0L</span> -&gt; <span class="hljs-literal">null</span><br>                    <span class="hljs-keyword">else</span> -&gt; NetworkResponse.NetError(code, error.toString(), <span class="hljs-literal">null</span>)<br>                &#125;<br>                <span class="hljs-keyword">if</span> (errorBody != <span class="hljs-literal">null</span>) &#123;<br>                    callback.onResponse(<br>                        <span class="hljs-keyword">this</span><span class="hljs-symbol">@NetworkResponseCall</span>,<br>                        Response.success(errorBody)<br>                    )<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    callback.onResponse(<br>                        <span class="hljs-keyword">this</span><span class="hljs-symbol">@NetworkResponseCall</span>,<br>                        Response.success(NetworkResponse.UnknownError(<span class="hljs-literal">null</span>))<br>                    )<br>                &#125;<br>            &#125;<br><br><br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">S</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            <span class="hljs-keyword">val</span> networkResponse = <span class="hljs-keyword">when</span> (t) &#123;<br>                <span class="hljs-keyword">is</span> Exception -&gt; NetworkResponse.NetError(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,t)<br>                <span class="hljs-keyword">else</span> -&gt; NetworkResponse.UnknownError(t)<br>            &#125;<br>            callback.onResponse(<span class="hljs-keyword">this</span><span class="hljs-symbol">@NetworkResponseCall</span>, Response.success(networkResponse))<br>        &#125;<br><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建-CallAdapter"><a href="#创建-CallAdapter" class="headerlink" title="创建 CallAdapter"></a>创建 CallAdapter</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkResponseAdapter</span>&lt;<span class="hljs-type">S : Any, E : Any</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> successType: Type,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> errorBodyConverter: Converter&lt;ResponseBody, E&gt;<br>) : CallAdapter&lt;S, Call&lt;NetworkResponse&lt;S, E&gt;&gt;&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">responseType</span><span class="hljs-params">()</span></span>: Type = successType<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">adapt</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">S</span>&gt;)</span></span>: Call&lt;NetworkResponse&lt;S, E&gt;&gt; &#123;<br>        <span class="hljs-keyword">return</span> NetworkResponseCall(call, errorBodyConverter)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建CallAdapterFactory"><a href="#创建CallAdapterFactory" class="headerlink" title="创建CallAdapterFactory"></a>创建CallAdapterFactory</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">NetworkResponseAdapterFactory</span>:<span class="hljs-type">CallAdapter.Factory</span></span>()&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        returnType: <span class="hljs-type">Type</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        annotations: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Annotation</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">        retrofit: <span class="hljs-type">Retrofit</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: CallAdapter&lt;*, *&gt;? &#123;<br>        <span class="hljs-comment">// suspend functions wrap the response type in `Call`</span><br>        <span class="hljs-keyword">if</span>(Call::<span class="hljs-keyword">class</span>.java != getRawType(returnType))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>        &#125;<br>        check(returnType <span class="hljs-keyword">is</span> ParameterizedType)&#123;<br>            <span class="hljs-string">&quot;return type must be parameterized as Call&lt;NetworkResponse&lt;&lt;Foo&gt;&gt; or Call&lt;NetworkResponse&lt;out Foo&gt;&gt;&quot;</span><br>        &#125;<br>        <span class="hljs-comment">// get the response type inside the `Call` type</span><br>        <span class="hljs-keyword">val</span> responseType = getParameterUpperBound(<span class="hljs-number">0</span>,returnType)<br>        <span class="hljs-comment">// if the response type is not ApiResponse then we can&#x27;t handle this type, so we return null</span><br>        <span class="hljs-keyword">if</span>(getRawType(responseType) != NetworkResponse::<span class="hljs-keyword">class</span>.java)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>        &#125;<br><br><br>        <span class="hljs-comment">// the response type is ApiResponse and should be parameterized</span><br>        check(responseType <span class="hljs-keyword">is</span> ParameterizedType) &#123; <span class="hljs-string">&quot;Response must be parameterized as NetworkResponse&lt;Foo&gt; or NetworkResponse&lt;out Foo&gt;&quot;</span> &#125;<br><br>        <span class="hljs-keyword">val</span> successBodyType = getParameterUpperBound(<span class="hljs-number">0</span>, responseType)<br>        <span class="hljs-keyword">val</span> errorBodyType = getParameterUpperBound(<span class="hljs-number">1</span>, responseType)<br><br>        <span class="hljs-keyword">val</span> errorBodyConverter =<br>            retrofit.nextResponseBodyConverter&lt;Any&gt;(<span class="hljs-literal">null</span>, errorBodyType, annotations)<br><br>        <span class="hljs-keyword">return</span> NetworkResponseAdapter&lt;Any, Any&gt;(successBodyType, errorBodyConverter)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构建-Retrofit-实例时添加该-Factory"><a href="#构建-Retrofit-实例时添加该-Factory" class="headerlink" title="构建 Retrofit 实例时添加该 Factory"></a>构建 Retrofit 实例时添加该 Factory</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()<br>    .baseUrl(BASE_URL)<br>    .addCallAdapterFactory(NetworkResponseAdapterFactory())<br>    .addConverterFactory(GsonConverterFactory.create())<br>    .build()<br></code></pre></td></tr></table></figure><h4 id="使用typealias简化返回类型-可选"><a href="#使用typealias简化返回类型-可选" class="headerlink" title="使用typealias简化返回类型(可选)"></a>使用typealias简化返回类型(可选)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpError</span></span>(<span class="hljs-keyword">val</span> httpCode:<span class="hljs-built_in">Int</span>,<span class="hljs-keyword">val</span> errorMsg:String?,<span class="hljs-keyword">val</span> exception: Throwable?)<br><span class="hljs-comment">// before</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DemoApiService</span> </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mainPageInfo</span><span class="hljs-params">()</span></span>: NetworkResponse&lt;MainPageInfo, HttpError&gt;<br>&#125;<br><span class="hljs-comment">// after</span><br><span class="hljs-keyword">typealias</span> GenericResponse&lt;S&gt; = NetworkResponse&lt;S, HttpError&gt;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApiService</span> </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mainPageInfo</span><span class="hljs-params">()</span></span>: GenericResponse&lt;MainPageInfo&gt;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在 Activity 中直接使用lifecycleScope启动协程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">lifecycleScope.launch(Dispatchers.IO) &#123;<br>    Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>, <span class="hljs-string">&quot;lifecycleScope.launch --&gt;&gt;&quot;</span> + Thread.currentThread().name);<br>    <span class="hljs-keyword">val</span> mainPageInfo = mainPageApi.getMainPageInfo()<br><br>    withContext(Dispatchers.Main) &#123;<br>        Log.e(<br>            <span class="hljs-string">&quot;KotlinActivity&quot;</span>,<br>            <span class="hljs-string">&quot;withContext(Dispatchers.Main) --&gt;&gt;&quot;</span> + Thread.currentThread().name<br>        );<br>        <span class="hljs-keyword">when</span>(mainPageInfo)&#123;<br><br>            <span class="hljs-keyword">is</span> NetworkResponse.NetError -&gt; Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>,<br>                <span class="hljs-string">&quot;NetError-&gt;<span class="hljs-variable">$mainPageInfo</span>&quot;</span><br>            )<br>            <span class="hljs-keyword">is</span> NetworkResponse.Success -&gt;  refreshViewWithLaunch(mainPageInfo.body)<br>            <span class="hljs-keyword">is</span> NetworkResponse.UnknownError -&gt; Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>,<span class="hljs-string">&quot;UnknownError-&gt;&quot;</span> + mainPageInfo.error)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者在 ViewModel 中借助 LiveData 将返回值转化为可观察对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainPageInfoViewModel</span>:<span class="hljs-type">ViewModel</span></span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _mainPageInfo  = MutableLiveData&lt;MainPageInfo&gt;()<br>    <span class="hljs-keyword">val</span> mainPageInfo: LiveData&lt;MainPageInfo&gt; <span class="hljs-keyword">get</span>() = _mainPageInfo<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMainPageInfo</span><span class="hljs-params">()</span></span>&#123;<br>        viewModelScope.launch(Dispatchers.IO)&#123;<br>            <span class="hljs-keyword">val</span> result = mainPageApi.getMainPageInfo()<br>            withContext(Dispatchers.Main)&#123;<br>                <span class="hljs-keyword">when</span>(result)&#123;<br>                    <span class="hljs-keyword">is</span> NetworkResponse.NetError -&gt; Log.e(<span class="hljs-string">&quot;MainPageInfoViewModel&quot;</span>,<br>                        <span class="hljs-string">&quot;NetError-&gt;<span class="hljs-variable">$result</span>&quot;</span><br>                    )<br>                    <span class="hljs-keyword">is</span> NetworkResponse.Success -&gt;  _mainPageInfo.value =  result.body<br>                    <span class="hljs-keyword">is</span> NetworkResponse.UnknownError -&gt; Log.e(<span class="hljs-string">&quot;MainPageInfoViewModel&quot;</span>,<span class="hljs-string">&quot;UnknownError-&gt;&quot;</span> + result.error)<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Activity 中使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mainPageInfoModel = ViewModelProvider(<span class="hljs-keyword">this</span>).<span class="hljs-keyword">get</span>(MainPageInfoViewModel::<span class="hljs-keyword">class</span>.java)<br>mainPageInfoModel.mainPageInfo.observe(<span class="hljs-keyword">this</span>, Observer &#123;<br>    <span class="hljs-keyword">if</span> (it != <span class="hljs-literal">null</span>) &#123;<br>        Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>, <span class="hljs-string">&quot;viewmodel获取结果成功&quot;</span>)<br>        refreshViewWithViewModelResult(it);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>, <span class="hljs-string">&quot;viewmodel获取结果为空&quot;</span>)<br>    &#125;<br>&#125;)<br>mainPageInfoModel.getMainPageInfo()<br></code></pre></td></tr></table></figure><p>暂时先这样吧，基本上够用了</p><hr><p>以上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Retrofit在2019-06-05发布的2.6.0版本中就已经支持Kotlin 中的 suspend修饰符了，目前正准备在项目中使用 K</summary>
      
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
    <category term="Retrofit" scheme="https://blog.huangyuanlove.com/tags/Retrofit/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙ArkUI-X 跨平台通信：从入土到复活</title>
    <link href="https://blog.huangyuanlove.com/2024/03/27/%E9%B8%BF%E8%92%99ArkUI-X-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%80%9A%E4%BF%A1%EF%BC%9A%E4%BB%8E%E5%85%A5%E5%9C%9F%E5%88%B0%E5%A4%8D%E6%B4%BB/"/>
    <id>https://blog.huangyuanlove.com/2024/03/27/%E9%B8%BF%E8%92%99ArkUI-X-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%80%9A%E4%BF%A1%EF%BC%9A%E4%BB%8E%E5%85%A5%E5%9C%9F%E5%88%B0%E5%A4%8D%E6%B4%BB/</id>
    <published>2024-03-27T06:21:02.000Z</published>
    <updated>2024-03-27T06:24:39.185Z</updated>
    
    <content type="html"><![CDATA[<hr><p>2024.01.31 更新<br>在上一篇 <a href="https://juejin.cn/post/7327910163628294154">鸿蒙跨平台 ArkUI-X从入门到入土 </a>中提到创建 Bridge 对象时失败的问题，在本文中提到的问题又重新验证了几次，咨询了一下相关人员，结论是这样的</p><ol><li>在 Arkui-X 中，如果 Bridge 对象声明为成员变量并且立即创建，这时候 preview 会白屏，是加载界面时就挂了，因为这个bridge对象，是需要 native 侧的文件支持的，比如Android中的libbridge.so(集成产物到 Android 工程时复制过去的)。这时候集成到 Android 工程中是正常运行的。</li><li>DevEco 中的 preview 相当于纯鸿蒙系统(HarmonyOS next),在纯鸿蒙系统中是无法使用Bridge 的，因为纯鸿蒙上没有这个 so 库。所以在创建这个 Bridge 对象的时候需要判断一下是不是跨平台，一般从deviceInfo.osFullName判断：<br><code>let osName: string = deviceInfo.osFullName;</code>获取对应OS名字，该接口已支持跨平台，不同平台上其返回值如下:</li></ol><ul><li>OpenHarmony上，osName等于<code>OpenHarmony XXX</code></li><li>Android上，osName等于<code>Android XXX</code></li><li>iOS上，osName等于<code>iOS XXX</code><br>具体文档在这里 <a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/quick-start/platform-different-introduction.md#%E5%B9%B3%E5%8F%B0%E5%B7%AE%E5%BC%82%E5%8C%96">平台差异化</a></li></ul><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>话说前两天刚调研了 ArkUI-X 跨平台方案，最终卡死在了跨平台和 native 通信上，文章在这里<a href="https://juejin.cn/post/7327910163628294154">鸿蒙跨平台 ArkUI-X从入门到入土</a>，今天在社区的帮助下跑通了通信方案，该挖出来复活了。<br><strong>注意文章所说的官方是指社区，并不是指华为公司，更不是其他</strong></p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>这里只对 Android 侧进行了实现，iOS 侧因为没有实体机的原因，先放一放，原理都一样，代码也差不多。官方文档先放在这里了 <a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/tutorial/how-to-use-bridge-on-android.md#%E5%B9%B3%E5%8F%B0%E6%A1%A5%E6%8E%A5%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97">平台桥接开发指南</a></p><blockquote><p>平台桥接用于客户端（ArkUI）和平台（Android或iOS）之间传递消息，即用于ArkUI与平台双向数据传递、ArkUI侧调用平台的方法、平台调用ArkUI侧的方法。本文主要介绍Android平台与ArkUI交互，ArkUI侧具体用法请参考<a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/reference/apis/js-apis-bridge.md">Bridge API</a>，Android侧参考<a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/reference/arkui-for-android/BridgePlugin.md">BridgePlugin</a>。</p></blockquote><p>官方在 Android 侧提供了一个抽象类<code>BridgePlugin</code>，我们需要继承它实现一些方法来进行通信。在 ArkUI-X 侧同样提供了<code>&#39;@arkui-x.bridge</code>包来进行通信。</p><h4 id="ArkUI-X-侧-Bridge"><a href="#ArkUI-X-侧-Bridge" class="headerlink" title="ArkUI-X 侧 Bridge"></a>ArkUI-X 侧 Bridge</h4><p>先看下ArkUI-X 侧提供的方案，官方文档在这里 <a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/reference/apis/js-apis-bridge.md#arkui-xbridgedts-%E5%B9%B3%E5%8F%B0%E6%A1%A5%E6%8E%A5">@arkui-x.bridge.d.ts (平台桥接)</a>。<br>在官方提供的<a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/tutorial/how-to-use-bridge-on-android.md#%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B">场景示例中</a>中，是在页面(也就是被<code>@Entry</code>装饰的类)中创建的，但是在实践中发现不能正常运行，会创建 Bridge 对象时会报错</p><blockquote><p>Error message: Cannot read property createBridge of undefined</p></blockquote><p>指向了<code>private bridgeImpl = bridge.createBridge(&#39;Bridge&#39;);</code>这一行代码，向官方提交了 issue，在其帮助下，将创建 Bridge 对象的代码放在了另外的 ets 文件中可以正常运行。</p><h5 id="创建-Bridge"><a href="#创建-Bridge" class="headerlink" title="创建 Bridge"></a>创建 Bridge</h5><p>先导包 <code>import Bridge from &#39;@arkui-x.bridge&#39;;</code><br>再创建<code> bridgeObj: BridgeObject = Bridge.createBridge(&#39;Bridge&#39;);</code><br>需要注意的是，这里传入的参数值需要<strong>和 native 侧一致，否则无法调用</strong>。 </p><h4 id="Android-侧-BridgePlugin"><a href="#Android-侧-BridgePlugin" class="headerlink" title="Android 侧 BridgePlugin"></a>Android 侧 BridgePlugin</h4><p>看先 Android 侧提供的方案，官方文档在这里 <a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/reference/arkui-for-android/BridgePlugin.md#bridgeplugin-%E5%B9%B3%E5%8F%B0%E6%A1%A5%E6%8E%A5">BridgePlugin (平台桥接)</a> 。<br>暴露的 api 也不多，包括构造方法、callMethod、sendMessage，两个回调监听：setMessageListener和setMethodResultListener。</p><h5 id="创建-BridgePlugin"><a href="#创建-BridgePlugin" class="headerlink" title="创建 BridgePlugin"></a>创建 BridgePlugin</h5><p>一般来讲，我们会自己写个类继承<code>BridgePlugin</code>来进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArkUIBridge</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BridgePlugin</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ArkUIBridge&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArkUIBridge</span><span class="hljs-params">(Context context, String bridgeName, <span class="hljs-type">int</span> instanceId)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, bridgeName, instanceId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的<code>bridgeName</code>参数，传入的值<strong>必须</strong>与 ArkUI-X 侧一致，至于 instanceId 则是<code>StageActivity</code>这个用来展示 ArkUI-X 内容的容器提供的方法，其实也就是调用的<code>InstanceIdGenerator.getAndIncrement()</code>，具体实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> ohos.stage.ability.adapter;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceIdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ID_GENERATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InstanceIdGenerator</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ID_GENERATOR.getAndIncrement();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ID_GENERATOR.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在其他位置调用<code>InstanceIdGenerator.get()</code>来获取到 id。但需要注意，每次创建 ArkUI-X 产物的容器页面也就是StageActivity时，该 id 都会自增，如果 id 无法对应则无法互相通信</p><h4 id="ArkUI侧向Android侧传递数据"><a href="#ArkUI侧向Android侧传递数据" class="headerlink" title="ArkUI侧向Android侧传递数据"></a>ArkUI侧向Android侧传递数据</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// xxx.ets</span><br>bridgeImpl.<span class="hljs-title function_">sendMessage</span>(<span class="hljs-string">&#x27;text&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 监听Android侧的回执</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;response: &#x27;</span> + res);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error: &#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(err));<br>&#125;);<br></code></pre></td></tr></table></figure><p>在 Android 侧接收消息,在构造方法里面设置一下监听事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//ArkUIBridge extends BridgePlugin</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArkUIBridge</span><span class="hljs-params">(Context context, String bridgeName, <span class="hljs-type">int</span> instanceId)</span> &#123;<br>    <span class="hljs-built_in">super</span>(context, bridgeName, instanceId);<br>    setMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IMessageListener</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">onMessage</span><span class="hljs-params">(Object o)</span> &#123;<br>            Log.e(TAG,<span class="hljs-string">&quot;onMessage--&gt;&quot;</span> + o.toString());<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>            <span class="hljs-keyword">try</span> &#123;<br>                result.put(<span class="hljs-string">&quot;platform&quot;</span>,<span class="hljs-string">&quot;Android&quot;</span>);<br>                result.put(<span class="hljs-string">&quot;result_code&quot;</span>,<span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> result.toString();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessageResponse</span><span class="hljs-params">(Object o)</span> &#123;<br>            Log.e(TAG,<span class="hljs-string">&quot;onMessageResponse--&gt;&quot;</span> + o.toString());<br>        &#125;<br>    &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Android侧向ArkUI-X侧传递数据"><a href="#Android侧向ArkUI-X侧传递数据" class="headerlink" title="Android侧向ArkUI-X侧传递数据"></a>Android侧向ArkUI-X侧传递数据</h4><p>方式都一样，需要在 ArkUI-X 侧设置一下监听事件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">bridge</span> = <span class="hljs-title class_">Bridge</span>.<span class="hljs-title function_">createBridge</span>(<span class="hljs-string">&#x27;BridgeCommon&#x27;</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">bridge</span>!.<span class="hljs-title function_">setMessageListener</span>(<span class="hljs-function">(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (message) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`receive message：<span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">scanResult</span> = message<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ArkUI-X setMessageListener&quot;</span>;<br>&#125;)<br></code></pre></td></tr></table></figure><p>在 Android 侧，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">////ArkUIBridge extends BridgePlugin</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessageToArkUI</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        jsonObject.put(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;扫描结果&quot;</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-string">&quot;scan result from Android&quot;</span>);<br><br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    Log.e(TAG,<span class="hljs-string">&quot;toScan before sendMessage&quot;</span> );<br>    sendMessage(jsonObject.toString());<br><br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，在 Android 中调用 sendMessage 方法是没有返回值的，ArkUI-X 侧收到消息后的返回值是在<code>setMessageListener</code>的<code>onMessageResponse</code>回调中接收的。</p><h4 id="ArkUI-X-侧调用-Android-侧的方法"><a href="#ArkUI-X-侧调用-Android-侧的方法" class="headerlink" title="ArkUI-X 侧调用 Android 侧的方法"></a>ArkUI-X 侧调用 Android 侧的方法</h4><p>在 ArkUI-X 中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">async</span> <span class="hljs-title function_">getAppVersion</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initBridge</span>();<span class="hljs-comment">//创建 bridge 对象</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">params</span>:<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">Parameter</span>&gt; =&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;xuan&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bridge</span>!.<span class="hljs-title function_">callMethod</span>(<span class="hljs-string">&#x27;getAppVersion&#x27;</span>,params);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;getAppVersion返回值：&#x27;</span> + result)<br>  <span class="hljs-keyword">return</span> result!.<span class="hljs-title function_">toString</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 Android</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAppVersion</span><span class="hljs-params">(JSONObject params)</span>&#123;<br>    Log.e(TAG,<span class="hljs-string">&quot;getAppVersion from arkui-x，params--&gt; &quot;</span>  );<br>    <span class="hljs-keyword">if</span>(params == <span class="hljs-literal">null</span>)&#123;<br>        Log.e(TAG,<span class="hljs-string">&quot;is null&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        Log.e(TAG,params.toString());<br>    &#125;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        jsonObject.put(<span class="hljs-string">&quot;version&quot;</span>,BuildConfig.VERSION_NAME);<br>        jsonObject.put(<span class="hljs-string">&quot;buildVersion&quot;</span>,<span class="hljs-string">&quot;getAppVersion(Object params)&quot;</span>);<br><br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> jsonObject.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，两侧都不支持方法重载，在 Android 侧是通过 HashMap 保存的在 BridgePlugin 中的方法并且是以方法名为 key，java.lang.reflect.Method为值。在 Android 侧的方法会被自动注册，不需要我们调用代码注册。</p><h4 id="Android-侧调用-ArkUI-X-侧-的方法"><a href="#Android-侧调用-ArkUI-X-侧-的方法" class="headerlink" title="Android 侧调用 ArkUI-X 侧 的方法"></a>Android 侧调用 ArkUI-X 侧 的方法</h4><p>在 ArkUI-X 中，需要自己调用registerMethod方法来注册供 native 调用的方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//方法声明</span><br><span class="hljs-title function_">getString</span>(parameters?: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">Message</span>&gt;):<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">ResultValue</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`----调用 getString：parameters--&gt;<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(parameters)&#125;</span>`</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;call js getString success&#x27;</span>;<br>&#125;<br><span class="hljs-comment">//注册方法</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">bridge</span>!.<span class="hljs-title function_">registerMethod</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;getString&quot;</span>,<span class="hljs-attr">method</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">getString</span>&#125;)<br></code></pre></td></tr></table></figure><p>在 Android 侧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">JSONObject</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    params.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;xuan&quot;</span>);<br>    params.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">18</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br>Object[] paramObject = &#123;params&#125;;<br><span class="hljs-type">MethodData</span> <span class="hljs-variable">methodData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodData</span>(<span class="hljs-string">&quot;getString&quot;</span>, paramObject);<br>callMethod(methodData);<br></code></pre></td></tr></table></figure><p>同样的，Android 调用 ArkUI 的方法并没有返回值，需要在<code>setMethodResultListener</code>的<code>onSuccess</code>方法中获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//设置调用 ArkUI-X 方法的结果回调</span><br>setMethodResultListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IMethodResult</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(Object o)</span> &#123;<br>        Log.e(TAG,<span class="hljs-string">&quot;IMethodResult#onSuccess--&gt;&quot;</span> +o.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i, String s1)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodCancel</span><span class="hljs-params">(String s)</span> &#123;<br><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="BridgePlugin-中提供给-ArkUI-X-调用的方法不支持方法重载"><a href="#BridgePlugin-中提供给-ArkUI-X-调用的方法不支持方法重载" class="headerlink" title="BridgePlugin 中提供给 ArkUI-X 调用的方法不支持方法重载"></a>BridgePlugin 中提供给 ArkUI-X 调用的方法不支持方法重载</h4><p>原因上面也说了，是因为保存的时候是用方法名作为 key 保存在 HashMap 中的，重载也没用，虽然写了不报错，但结果不保证。也看一下为啥 Android 不用自己写代码注册供 ArkUI-X调用的方法。<br>在<code>ohos.ace.adapter.capability.bridge.BridgePlugin</code>这个类中，重点关注<code>HashMap&lt;String, Method&gt; methodsMap_</code>这个成员变量和这几个方法：  </p><ul><li>protected Object jsCallMethod(Object object, MethodData methodData) </li><li>private Method findMethod(String methodName)</li><li>private void registerMethod(String methodName, Method methods)</li></ul><p>当 ArkUI-X 调用 Android 方法时，首先调用的是<code>jsCallMethod</code>，在<code>jsCallMethod</code>中首先调用<code>findMethod</code>方法从<code>methodsMap_</code>中获取对应的方法，找了则直接调用。没找到则反射获取 BridgePlugin 实现类中的方法，然后使用方法名做匹配，找到对应的方法。到这里也就解释了为啥不支持方法重载。也解释了为啥方法参数对应不上会有异常。<br>cpp 的源码在 <a href="https://gitee.com/arkui-x/arkui_for_android/tree/master/capability/java/jni/bridge">https://gitee.com/arkui-x/arkui_for_android&#x2F;tree&#x2F;master&#x2F;capability&#x2F;java&#x2F;jni&#x2F;bridge</a><br>Java 源码在 <a href="https://gitee.com/arkui-x/arkui_for_android/tree/master/capability/java/src/ohos/ace/adapter/capability/bridge">https://gitee.com/arkui-x/arkui_for_android&#x2F;tree&#x2F;master&#x2F;capability&#x2F;java&#x2F;src&#x2F;ohos&#x2F;ace&#x2F;adapter&#x2F;capability&#x2F;bridge</a></p><p><img src="/image/HarmonyOS/arkui-x_debug.png" alt="image.png"></p><h4 id="参数类型对应关系"><a href="#参数类型对应关系" class="headerlink" title="参数类型对应关系"></a>参数类型对应关系</h4><p>Arkui-X 中callMethod是这么声明的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">callMethod</span>(<span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, parameters?: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Parameter</span>&gt;):<br><span class="hljs-title function_">callMethod</span>(<span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, ...<span class="hljs-attr">parameters</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ResultValue</span>&gt;;<br></code></pre></td></tr></table></figure><p>sendMessage是这么声明的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">sendMessage</span>(<span class="hljs-attr">message</span>: <span class="hljs-title class_">Message</span>, <span class="hljs-attr">callback</span>: <span class="hljs-title class_">AsyncCallback</span>&lt;<span class="hljs-title class_">Response</span>&gt;): <span class="hljs-built_in">void</span>;<br><span class="hljs-title function_">sendMessage</span>(<span class="hljs-attr">message</span>: <span class="hljs-title class_">Message</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt;;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">type</span> S = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span> | <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">type</span> T = S | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">boolean</span>&gt; | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Message</span> = T | <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, T&gt;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameter</span> = <span class="hljs-title class_">Message</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Response</span> = <span class="hljs-title class_">Message</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ResultValue</span> = T | <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, T&gt;;<br></code></pre></td></tr></table></figure><p>在 Android 中sendMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(Object data)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>callMethod</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callMethod</span><span class="hljs-params">(MethodData methodData)</span><br></code></pre></td></tr></table></figure><p>而 MethodData 只有两个成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodData</span> &#123;<br>    <span class="hljs-keyword">private</span> String methodName_;<br>    <span class="hljs-keyword">private</span> Object[] Parameters_;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MethodData</span><span class="hljs-params">(String methodName, Object[] parameter)</span> &#123;<br>        <span class="hljs-built_in">this</span>.methodName_ = methodName;<br>        <span class="hljs-built_in">this</span>.Parameters_ = parameter;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMethodName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.methodName_;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object[] getMethodParameter() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.Parameters_;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>那么在使用的时候可以这样:  </p><h5 id="ArkUI-X主动调用-Android"><a href="#ArkUI-X主动调用-Android" class="headerlink" title="ArkUI-X主动调用 Android"></a>ArkUI-X主动调用 Android</h5><p>在 ArkUI-X 中调用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">params</span>:<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">Parameter</span>&gt; =&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;xuan&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bridge</span>!.<span class="hljs-title function_">callMethod</span>(<span class="hljs-string">&#x27;getAppVersion&#x27;</span>,params);<br><br></code></pre></td></tr></table></figure><p>在 Android 端对应参数类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAppVersion</span><span class="hljs-params">(JSONObject params)</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Android-主动调用-ArkUI-X"><a href="#Android-主动调用-ArkUI-X" class="headerlink" title="Android 主动调用 ArkUI-X"></a>Android 主动调用 ArkUI-X</h5><p>在 Android 中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">JSONObject</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    params.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;xuan&quot;</span>);<br>    params.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">18</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br>Object[] paramObject = &#123;params&#125;;<br><span class="hljs-type">MethodData</span> <span class="hljs-variable">methodData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodData</span>(<span class="hljs-string">&quot;getString&quot;</span>, paramObject);<br>callMethod(methodData);<br></code></pre></td></tr></table></figure><p>在 ArkUI-X 中对应类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">getString</span>(parameters?: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">Message</span>&gt;):<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">ResultValue</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`----调用 getString：parameters--&gt;<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(parameters)&#125;</span>`</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;call js getString success&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BrigePlugin的bridgeType"><a href="#BrigePlugin的bridgeType" class="headerlink" title="BrigePlugin的bridgeType_"></a>BrigePlugin的bridgeType_</h4><p>BrigePlugin提供了一个可以指定<code>bridgeType_</code>的构造方法，<br><img src="/image/HarmonyOS/arkui-x_bridge_type.png" alt="image.png"><br>如果我们不指定类型的话，默认就是 <code>BridgeType.JSON_TYPE</code>，传一些非二进制的数据。但假如我们需要穿一些二进制数据，比如图片、音视频数据等，可以指定为<code>BridgeType.BINARY_TYPE</code>。</p><hr><p>以上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;2024.01.31 更新&lt;br&gt;在上一篇 &lt;a href=&quot;https://juejin.cn/post/7327910163628294154&quot;&gt;鸿蒙跨平台 ArkUI-X从入门到入土 &lt;/a&gt;中提到创建 Bridge 对象时失败的问题，在本文中提到的问题又重</summary>
      
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙跨平台 ArkUI-X从入门到入土</title>
    <link href="https://blog.huangyuanlove.com/2024/03/27/%E9%B8%BF%E8%92%99%E8%B7%A8%E5%B9%B3%E5%8F%B0-ArkUI-X%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>https://blog.huangyuanlove.com/2024/03/27/%E9%B8%BF%E8%92%99%E8%B7%A8%E5%B9%B3%E5%8F%B0-ArkUI-X%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2024-03-27T03:13:02.000Z</published>
    <updated>2024-03-27T06:20:14.729Z</updated>
    
    <content type="html"><![CDATA[<hr><p>2024.01.31 更新<br>码完了<br><a href="https://juejin.cn/post/7329310941106421811">鸿蒙ArkUI-X 跨平台通信：从入土到复活</a><br>在本文中提到的问题又重新验证了几次，咨询了一下相关人员，结论是这样的</p><ol><li>在 Arkui-X 中，如果 Bridge 对象声明为成员变量并且立即创建，这时候 preview 会白屏，是加载界面时就挂了，因为这个bridge对象，是需要 native 侧的文件支持的，比如Android中的libbridge.so(集成产物到 Android 工程时复制过去的)。这时候集成到 Android 工程中是正常运行的。</li><li>DevEco 中的 preview 相当于纯鸿蒙系统(HarmonyOS next),在纯鸿蒙系统中是无法使用Bridge 的，因为纯鸿蒙上没有这个 so 库。所以在创建这个 Bridge 对象的时候需要判断一下是不是跨平台，一般从deviceInfo.osFullName判断：<br><code>let osName: string = deviceInfo.osFullName;</code>获取对应OS名字，该接口已支持跨平台，不同平台上其返回值如下:</li></ol><ul><li>OpenHarmony上，osName等于<code>OpenHarmony XXX</code></li><li>Android上，osName等于<code>Android XXX</code></li><li>iOS上，osName等于<code>iOS XXX</code><br>具体文档在这里 <a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/quick-start/platform-different-introduction.md#%E5%B9%B3%E5%8F%B0%E5%B7%AE%E5%BC%82%E5%8C%96">平台差异化</a></li></ul><hr><p>2024.01.28 更新<br><del>上面</del>文章中提到跨平台通信(Bridge)的问题在社区的帮助下解决了，方案就不要在页面(也就是@Entry修饰)中进行初始化，可以写个工具类，在工具类中初始化，虽然 debug 也是提示 undefined，但运行的时候可以正常工作。<br>新的博客记录已经在码了。。。。</p><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>喊了好长时间要做鸿蒙应用，自己也写了一点，但要同时照顾三个移动平台有点恶心，大致看了一下鸿蒙社区的 arkui-x 跨平台方案 <a href="https://gitee.com/arkui-x">https://gitee.com/arkui-x</a> ,先调研一下试试水<br><strong>注意文章所说的官方是指社区，并不是指华为公司，更不是其他</strong></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>丑话说在前头，先说限制，按照官方文档说法，忘记在哪里看到了<br>Android系统版本8+ 且仅 arm 设备支持<br>iOS系统版本 10+ 且仅 arm 设备支持</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>官方文档看这里：<a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/README.md">https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/README.md</a></p><p>官方仓库在这里：<a href="https://gitee.com/arkui-x">https://gitee.com/arkui-x</a></p><p>使用官方的套件还是需要申请，方式和之前一样，就是找商务谈合作，签协议。然后给账号开通下载权限然后去下载。</p><h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>这里我们可以使用 OpenHarmony 社区提供的开发套件</p><p><img src="/image/HarmonyOS/deveco.png" alt="image.png"><br>下载链接：</p><p><a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/release-notes/OpenHarmony-v4.0-release.md#%E9%85%8D%E5%A5%97%E5%85%B3%E7%B3%BB">https://gitee.com/openharmony/docs/blob/master/zh-cn/release-notes/OpenHarmony-v4.0-release.md#%E9%85%8D%E5%A5%97%E5%85%B3%E7%B3%BB</a></p><p>安装步骤都一样，<strong>注意 node 和ohpm版本</strong>，选择ide建议的版本，可以重新下载，也可以使用本机上已经安装好的，我这里用的 node是 16.20.0，不要头铁搞个 18.x.x 20.x.x的版本，可能会有一些诡异的问题</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>启动 IDE，页面左侧有diagnose可以检测一些基础配置和网络连接情况。点击左侧Customize，在右侧底部点击”All settings”进入首选项配置</p><p><img src="/image/HarmonyOS/deveco_customize.png" alt="image.png"></p><p>选择 SDK，安装 OpenHarmony SDK api 10，安装完成之后再安装 ArkUI-X</p><p><img src="/image/HarmonyOS/deveco_sdk.png" alt="image.png"></p><p>安装完成后就可以了，没有其他需要安装的了</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>没有提供直接创建跨平台应用的地方，目前只能用 import 的形式</p><p><img src="/image/HarmonyOS/deveco_import_project.png" alt="image.png"></p><p>找到 import Sample,新页面左上角选择 OpenHarmony，下面会出现 ArkUI-X，这里用 HelloWorld 来做示例。</p><p><img src="/image/HarmonyOS/select_sample_to_improt.png" alt="image.png"></p><p>打开工程后开始自动同步，但这里会失败，因为各种插件版本不适配，点一下蓝色的文字，会帮你全部修改好，重新同步，到这里就已经全部准备好了。</p><p><img src="/image/HarmonyOS/sync_failed.png" alt="image.png"></p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>窗口顶部菜单 Build–&gt; Build Hap(s)&#x2F;APP(s)–&gt;Build APP(s)。会同时构建 Android 和 iOS 产物</p><p><img src="/image/HarmonyOS/build_result.png" alt="image.png"></p><p>不出意外的话出意外了，打包失败，但这时对应的资源都已经复制到相应的文件夹中了。对应的说明可以看这里</p><p><a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/quick-start/package-structure-guide.md">https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/quick-start/package-structure-guide.md</a></p><p>这时候我们进入到项目工程的 .arkui-x&#x2F;android目录下，执行 <strong>.&#x2F;gradlew assembleDebug</strong> 来编译 android 安装包。注意这里 gradlew 可能没有执行权限，<strong>chmod +x gradlew</strong> 给一下执行权限就好了。</p><p>对于 iOS 工程，可以用 Xcode 打开之后配置一下签名然后打包。</p><p>到这里，新建工程编译多平台就已经完成了。但我们有很多项目不是从头开始，部分新增内容需要使用 add-on方式，这里以 Android 为例</p><h3 id="添加到现有工程"><a href="#添加到现有工程" class="headerlink" title="添加到现有工程"></a>添加到现有工程</h3><p>接上面 <strong>窗口顶部菜单 Build–&gt; Build Hap(s)&#x2F;APP(s)–&gt;Build APP(s)。会同时构建 Android 和 iOS 产物</strong> 之后，对应资源文件已经复制到对相应文件夹了。</p><p>先准备一个 Android 项目，注意一个 ArkUI-x 跨平台的版本要求，Android 系统 8 以上，只支持 arm 设备。</p><p>看一下 .arkui-x&#x2F;android的代码，就一个<strong>继承自StageApplication的MyApplication</strong>和一个继承自 <strong>Activity 的EntryEntryAbilityActivity，</strong> 该类名通过通过module名和ability名拼接而得，一个ability对应一个Android工程侧的Activity类。</p><h4 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h4><ol><li>libs 下面的 jar 包和so 文件复制到 Android 工程中，注意arkui-x 的 Android 工程中指定了存放 so 文件的文件夹就是 libs，复制到 Android 工程中的时候别整错了</li><li>assets文件夹下的文件也原封不动的复制到 Android 工程的 assets 文件夹中</li><li>Android 工程中的 Application改造，这里提供了三种方式<br>  3.1 继承StageApplication</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> ohos.stage.ability.adapter.StageApplication;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HiStageApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StageApplication</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>   3.2 在 Application 中使用StageApplicationDelegate</p><p>这个方法和 StageApplication 源码一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StageApplicationDelegate</span> <span class="hljs-variable">appDelegate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StageApplication</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        Log.i(<span class="hljs-string">&quot;StageApplication&quot;</span>, <span class="hljs-string">&quot;StageApplication onCreate called&quot;</span>);<br>        <span class="hljs-built_in">super</span>.onCreate();<br>        <span class="hljs-built_in">this</span>.appDelegate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StageApplicationDelegate</span>();<br>        <span class="hljs-built_in">this</span>.appDelegate.initApplication(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onConfigurationChanged</span><span class="hljs-params">(Configuration newConfig)</span> &#123;<br>        Log.i(<span class="hljs-string">&quot;StageApplication&quot;</span>, <span class="hljs-string">&quot;StageApplication onConfigurationChanged called&quot;</span>);<br>        <span class="hljs-built_in">super</span>.onConfigurationChanged(newConfig);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.appDelegate == <span class="hljs-literal">null</span>) &#123;<br>            Log.e(<span class="hljs-string">&quot;StageApplication&quot;</span>, <span class="hljs-string">&quot;appDelegate is null&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.appDelegate.onConfigurationChanged(newConfig);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.3 在 Activity 中使用 StageApplicationDelegat</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.app.Activity;<br><span class="hljs-keyword">import</span> ohos.stage.ability.adapter.StageApplicationDelegate;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryEntryAbilityActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StageApplicationDelegate</span> <span class="hljs-variable">appDelegate_</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        appDelegate_ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StageApplicationDelegate</span>();<br>        appDelegate_.initApplication(<span class="hljs-built_in">this</span>.getApplication());<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>用于展示内容的 Activity</li></ol><p>直接复制也行，自己创建一个同名 Activity 把内容复制过来，清单文件中注册一下也行。</p><ol><li>原生拉起 arkui-x 跨平台页面并传参</li></ol><p>使用原生Activity拉起Ability时，需使用原生应用的startActivity方法，参数的传递需要通过Intent中的putExtra()进行设置，规则如下：</p><p>key值为params</p><p>value为json格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        intent.setClass(<span class="hljs-built_in">this</span>, EntryEntryAbilityTwoActivity.class);<br>        intent.putExtra(<span class="hljs-string">&quot;params&quot;</span>,<br>                <span class="hljs-string">&quot;&#123;&quot;</span>params<span class="hljs-string">&quot;:[&#123;&quot;</span>key<span class="hljs-string">&quot;:&quot;</span>bool<span class="hljs-string">&quot;,&quot;</span>type<span class="hljs-string">&quot;:1,&quot;</span>value<span class="hljs-string">&quot;:&quot;</span><span class="hljs-literal">true</span><span class="hljs-string">&quot;&#125;,&quot;</span> +<br>                <span class="hljs-string">&quot;&#123;&quot;</span>key<span class="hljs-string">&quot;:&quot;</span><span class="hljs-type">double</span><span class="hljs-string">&quot;,&quot;</span>type<span class="hljs-string">&quot;:9,&quot;</span>value<span class="hljs-string">&quot;:&quot;</span><span class="hljs-number">2.3</span><span class="hljs-string">&quot;&#125;,&quot;</span> +<br>                <span class="hljs-string">&quot;&#123;&quot;</span>key<span class="hljs-string">&quot;:&quot;</span><span class="hljs-type">int</span><span class="hljs-string">&quot;,&quot;</span>type<span class="hljs-string">&quot;:5,&quot;</span>value<span class="hljs-string">&quot;:&quot;</span><span class="hljs-number">2</span><span class="hljs-string">&quot;&#125;,&quot;</span> +<br>                <span class="hljs-string">&quot;&#123;&quot;</span>key<span class="hljs-string">&quot;:&quot;</span>string<span class="hljs-string">&quot;,&quot;</span>type<span class="hljs-string">&quot;:10,&quot;</span>value<span class="hljs-string">&quot;:&quot;</span>test<span class="hljs-string">&quot;&#125;]&#125;&quot;</span>);<br>        startActivity(intent);<br></code></pre></td></tr></table></figure><p>至此，集成完成。<br>在 Android 项目中调用一下就可以看到页面了</p><h3 id="arkui-x-和-native-通信"><a href="#arkui-x-和-native-通信" class="headerlink" title="arkui-x 和 native 通信"></a>arkui-x 和 native 通信</h3><p>原生和跨平台通信是非常重要的一个功能，也是不可或缺的一部分，官方给出了桥接平台 Bridge，在 Android、iOS 和 arkui-x 侧都有配套说明：</p><blockquote><p>平台桥接用于客户端（ArkUI）和平台（Android或iOS）之间传递消息，即用于ArkUI与平台双向数据传递、ArkUI侧调用平台的方法、平台调用ArkUI侧的方法。本文主要介绍Android平台与ArkUI交互，ArkUI侧具体用法请参考Bridge API，Android侧参考BridgePlugin。  </p></blockquote><p>这里也给出了一个<br><a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/tutorial/how-to-use-bridge-on-android.md#%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B">场景示例</a>，但奇怪的是不能正常运行，复现步骤和现象放在这个 <a href="https://gitee.com/arkui-x/docs/issues/I8YWM2?from=project-issue">issue</a> 中了。目前是待确认状态。</p><p>到这里也没有需要继续下去的东西，就先入土吧，上面这个问题有答案了再挖出来继续。</p><hr><p>以上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;2024.01.31 更新&lt;br&gt;码完了&lt;br&gt;&lt;a href=&quot;https://juejin.cn/post/7329310941106421811&quot;&gt;鸿蒙ArkUI-X 跨平台通信：从入土到复活&lt;/a&gt;&lt;br&gt;在本文中提到的问题又重新验证了几次，咨询了一下相关</summary>
      
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙--canvas 画时钟</title>
    <link href="https://blog.huangyuanlove.com/2024/03/27/%E9%B8%BF%E8%92%99-canvas-%E7%94%BB%E6%97%B6%E9%92%9F/"/>
    <id>https://blog.huangyuanlove.com/2024/03/27/%E9%B8%BF%E8%92%99-canvas-%E7%94%BB%E6%97%B6%E9%92%9F/</id>
    <published>2024-03-27T03:01:33.000Z</published>
    <updated>2024-03-27T03:10:26.782Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>你在 Android 上能画出来的东西，在鸿蒙上画不出来？<br>画个时钟嘛，有啥难的？<br>你行你上！<br>给钱就上！<br>给钱？早说嘛，来来来，现在就画</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>画时钟需要画哪些元素？<br>圆圈、直线，没了，就这些，临时看一下canvas 相关的 api，这不都有么？直接画。<br>看看需要用的方法  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">arc</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">startAngle</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">endAngle</span>: <span class="hljs-built_in">number</span>, counterclockwise?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure><p>看下参数含义</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">必填</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">x</td><td align="left">number</td><td align="left">是</td><td align="left">0</td><td align="left">弧线圆心的x坐标值。</td></tr><tr><td align="left">y</td><td align="left">number</td><td align="left">是</td><td align="left">0</td><td align="left">弧线圆心的y坐标值。</td></tr><tr><td align="left">radius</td><td align="left">number</td><td align="left">是</td><td align="left">0</td><td align="left">弧线的圆半径。</td></tr><tr><td align="left">startAngle</td><td align="left">number</td><td align="left">是</td><td align="left">0</td><td align="left">弧线的起始弧度。</td></tr><tr><td align="left">endAngle</td><td align="left">number</td><td align="left">是</td><td align="left">0</td><td align="left">弧线的终止弧度。</td></tr><tr><td align="left">counterclockwise</td><td align="left">boolean</td><td align="left">否</td><td align="left">false</td><td align="left">是否逆时针绘制圆弧。</td></tr></tbody></table><p>弧度制，一圈是 2π，这个需要注意一下，还有endAngle，是终止弧度，而不是需要画多少弧度，浅浅的尝试。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><br>struct <span class="hljs-title class_">ClockViewTest</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>)<br>      .<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>        <span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">width</span><br>        <span class="hljs-keyword">let</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">height</span><br><br>        <span class="hljs-keyword">let</span> centerX = width / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">let</span> centerY = height / <span class="hljs-number">2</span><br>        <span class="hljs-comment">//取长宽中小的一个做直径</span><br>        <span class="hljs-keyword">let</span> maxRadius = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(width, height) / <span class="hljs-number">2</span><br><br>        <span class="hljs-comment">//设置线的粗细</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">4</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(centerX, centerY, maxRadius-<span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)<br>        <span class="hljs-comment">//设置线的颜色</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#ff0000&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">beginPath</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(centerX, centerY, maxRadius - <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)<br>        <span class="hljs-comment">//设置线的颜色</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#00ff00&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br><br>      &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果是这样的：  </p><p><img src="/image/HarmonyOS/canvas_circle.png" alt="image.png"><br>画直线就不用多说了，开干~~  </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><p>指针是需要根据时间变化来转动的，表盘画好一次就不需要重绘了，偷个懒，搞两个 canvas 摞起来，底层画表盘，上层画指针，时间变了只重画上层指针就行了。  </p><h4 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h4><p>简单的三角函数，但要注意是弧度制，数值别搞错了。<br>另外需要注意的是画布左上角坐标是(0,0)，右下角坐标为(width,height)。  </p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>先画一大一小两个圆圈组成一个圆环。  </li><li>再划线把圆环均分 60 份，每 5 条线加粗一下。  </li><li>再把圆周分成 12 份，对应位置画上1~12 数字。  </li><li>获取当前时间，计算出指针位置，划线。  </li><li>定时更新指针位置。  </li><li>结束。</li></ol><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="第一步-画圆环"><a href="#第一步-画圆环" class="headerlink" title="第一步 画圆环"></a>第一步 画圆环</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>)<br>  .<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>    <span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">width</span><br>    <span class="hljs-keyword">let</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">height</span><br><br>    <span class="hljs-keyword">let</span> centerX = width / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">let</span> centerY = height / <span class="hljs-number">2</span><br>    <span class="hljs-comment">//取长宽中小的一个做直径</span><br>    <span class="hljs-keyword">let</span> maxRadius = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(centerX, centerY)<br><br>    <span class="hljs-comment">//留一些外边距</span><br>    <span class="hljs-keyword">let</span> outerCircleRadius = maxRadius - <span class="hljs-number">20</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#1b91e0&quot;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>    <span class="hljs-comment">//最中间的小圈圈</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(centerX, centerY, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br><br>    <span class="hljs-comment">//画内圈</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">beginPath</span>()<br>    <span class="hljs-keyword">let</span> innerCircleRadius = outerCircleRadius -<span class="hljs-number">20</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(centerX, centerY, innerCircleRadius, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br><br>    <span class="hljs-comment">//画外圈</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">beginPath</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(centerX, centerY, outerCircleRadius, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br>    <br>  &#125;)<br></code></pre></td></tr></table></figure><p>效果图  </p><p><img src="/image/HarmonyOS/canvas_ring.png" alt="image.png"></p><p>看着还行，颜色和粗细大家自己调。</p><h4 id="第二步-画格子"><a href="#第二步-画格子" class="headerlink" title="第二步 画格子"></a>第二步 画格子</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//画 60 个格子，5 的倍数则线条粗一些</span><br><span class="hljs-keyword">let</span> perMinuteDegree = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">60</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">60</span>; i++) &#123;<br>  <span class="hljs-comment">//结束坐标，也就是在外圆上的点</span><br>  <span class="hljs-keyword">let</span> endX = centerX + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(i * perMinuteDegree) * outerCircleRadius<br>  <span class="hljs-keyword">let</span> endY = centerY + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(i * perMinuteDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * outerCircleRadius<br>  <span class="hljs-comment">//起始坐标，也就是在内圆上的点</span><br>  <span class="hljs-keyword">let</span> startX = centerX + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(i * perMinuteDegree) * innerCircleRadius<br>  <span class="hljs-keyword">let</span> startY = centerY + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(i * perMinuteDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * innerCircleRadius<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#000000&quot;</span><br>  <span class="hljs-keyword">let</span> path2D = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>  path2D.<span class="hljs-title function_">moveTo</span>(startX, startY)<br>  path2D.<span class="hljs-title function_">lineTo</span>(endX, endY)<br>  <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">6</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>(path2D)<br>&#125;<br></code></pre></td></tr></table></figure><p>效果图  </p><p><img src="/image/HarmonyOS/canvas_ring_clock.png" alt="image.png"><br>马马虎虎，不太好看。<br>这里需要注意一下，画布是以垂直向下为 Y 轴的正方向，计算时加了 <code>Math.PI</code> 弧度纠正一下  </p><h4 id="第三步-画数字"><a href="#第三步-画数字" class="headerlink" title="第三步 画数字"></a>第三步 画数字</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//画 1~12 数字圆形分布</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">font</span> = <span class="hljs-string">&quot;40px&quot;</span><br><span class="hljs-keyword">let</span> perNumberDegree = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">12</span><br><span class="hljs-keyword">let</span> numberRadius = outerCircleRadius - <span class="hljs-number">40</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>  <span class="hljs-keyword">let</span> x = centerX + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(i * perNumberDegree) * numberRadius<br>  <span class="hljs-keyword">let</span> y = centerY + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(i * perNumberDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * numberRadius<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span> = i + <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#000000&quot;</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">textMetrics</span>: <span class="hljs-title class_">TextMetrics</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">measureText</span>(text)<br>  <span class="hljs-comment">//填充文字时，传入的坐标是文字的左下角坐标</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fillText</span>(text, x-textMetrics.<span class="hljs-property">width</span>/<span class="hljs-number">2</span> , y+textMetrics.<span class="hljs-property">height</span>/<span class="hljs-number">2</span>)<br>  <span class="hljs-comment">//把下面这两行注释掉就没有小方块了</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#aaff6134&quot;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fillRect</span>(x,y,textMetrics.<span class="hljs-property">width</span>,textMetrics.<span class="hljs-property">height</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="/image/HarmonyOS/canvas_ring_clock_number.png" alt="image.png"><br>图上的方块是为了对比画文字和画方块的坐标区别展示出来的：填充文字时传入的坐标是<code>文字左下角的坐标</code>，而画方块时是传入的<code>方块左上角坐标</code>,这里注意一下就好了，代码中测量了一下文字宽高，粗暴的做了一下纠偏。  </p><h4 id="第四、五步-画指针-amp-定时更新"><a href="#第四、五步-画指针-amp-定时更新" class="headerlink" title="第四、五步 画指针&amp;定时更新"></a>第四、五步 画指针&amp;定时更新</h4><p>上面也说要把指针画在另外一个 <code>canvas</code> 上，减少一下绘制时的内容，没做对比，也不知道有没有作用。<br>准备另外个画布，把两个画布用 <code>Stack</code> 包一下。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">date</span>: <span class="hljs-title class_">Date</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">minute</span> = date.<span class="hljs-title function_">getMinutes</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hour</span> = date.<span class="hljs-title function_">getHours</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span> = date.<span class="hljs-title function_">getSeconds</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">draw</span>()<br>  &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">500</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里需要把第一块代码中的 <code>innerCircleRadius</code> 变量提到外部，作为类成员两个画布共用一下，主要是计算指针终点坐标用的。<code>centerX</code> 和 <code>centerY</code> 无所谓，只要两个画布对齐了，用哪个都行，这里还是提到了外部，用的第一块画布的。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) &#123;<br>  清空一下画布<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span> * <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span> * <span class="hljs-number">2</span>)<br><br>  <span class="hljs-comment">//画秒针</span><br>  <span class="hljs-comment">//计算秒针的角度</span><br>  <span class="hljs-keyword">let</span> secondDegree = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">60</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span><br>  <span class="hljs-keyword">let</span> secondStartX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span><br>  <span class="hljs-keyword">let</span> secondStartY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span><br>  <span class="hljs-keyword">let</span> secondEndX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(secondDegree) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span><br>  <span class="hljs-keyword">let</span> secondEndY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(secondDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span><br>  <span class="hljs-keyword">let</span> secondPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>  secondPath.<span class="hljs-title function_">moveTo</span>(secondStartX, secondStartY)<br>  secondPath.<span class="hljs-title function_">lineTo</span>(secondEndX, secondEndY)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-title function_">stroke</span>(secondPath)<br><br><br>  <span class="hljs-comment">//画分针 颜色弄点透明度，要不然重合的时候看不清楚</span><br>  <span class="hljs-comment">//秒针走一圈，分针走一格，其实可以忽略不计</span><br>  <span class="hljs-keyword">let</span> minuteDegree = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">60</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">minute</span><br>  <span class="hljs-keyword">let</span> minuteStartX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span><br>  <span class="hljs-keyword">let</span> minuteStartY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span><br>  <span class="hljs-keyword">let</span> minuteEndX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(minuteDegree) * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span> / <span class="hljs-number">5</span> * <span class="hljs-number">4</span>)<br>  <span class="hljs-keyword">let</span> minuteEndY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(minuteDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span> / <span class="hljs-number">5</span> * <span class="hljs-number">4</span>)<br>  <span class="hljs-keyword">let</span> minutePath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>  minutePath.<span class="hljs-title function_">moveTo</span>(minuteStartX, minuteStartY)<br>  minutePath.<span class="hljs-title function_">lineTo</span>(minuteEndX, minuteEndY)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#aa1b91e0&quot;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">4</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-title function_">stroke</span>(minutePath)<br><br>  <span class="hljs-comment">//画时针</span><br>  <span class="hljs-comment">//分针走一圈，时针走 5 小格</span><br>  <span class="hljs-keyword">let</span> hourDegree = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">12</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">hour</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">minute</span> / <span class="hljs-number">60</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">12</span><br>  <span class="hljs-keyword">let</span> hourStartX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span><br>  <span class="hljs-keyword">let</span> hourStartY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span><br>  <span class="hljs-keyword">let</span> hourEndX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(hourDegree) * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span> / <span class="hljs-number">4</span> * <span class="hljs-number">3</span>)<br>  <span class="hljs-keyword">let</span> hourEndY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(hourDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span> / <span class="hljs-number">4</span> * <span class="hljs-number">3</span>)<br>  <span class="hljs-keyword">let</span> hourPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>  hourPath.<span class="hljs-title function_">moveTo</span>(hourStartX, hourStartY)<br>  hourPath.<span class="hljs-title function_">lineTo</span>(hourEndX, hourEndY)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">6</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#aa39d167&quot;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-title function_">stroke</span>(hourPath)<br>&#125;<br></code></pre></td></tr></table></figure><p>计算指针角度的时候也偷懒了，时针只考虑了当前分钟数，没有考虑秒数，实际差不多，先这样吧。  </p><h4 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h4><p>效果图</p><p><img src="/image/HarmonyOS/canvas_clock_finish.png" alt="image.png"><br>就先这样吧，勉勉强强，可以自己调调颜色，调调样式，或者搞一些图片来代替这些元素也行。  </p><p>源码在这里 <a href="https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/AlarmClockPage.ets">github</a> ,<br><a href="https://gitee.com/huangyuan/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/AlarmClockPage.ets">gitee</a></p><p>仓库地址：<a href="https://github.com/huangyuanlove/HelloArkUI">https://github.com/huangyuanlove/HelloArkUI</a>  </p><p><a href="https://gitee.com/huangyuan/HelloArkUI">https://gitee.com/huangyuan/HelloArkUI</a></p><hr><p>以上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;你在 Android 上能画出来的东西，在鸿蒙上画不出来？&lt;br&gt;画个时钟嘛，有啥难的？&lt;br&gt;你行你上！&lt;br&gt;给钱就上！&lt;br&gt;给钱？早</summary>
      
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙--canvas 实现波浪效果</title>
    <link href="https://blog.huangyuanlove.com/2024/03/27/%E9%B8%BF%E8%92%99-canvas-%E5%AE%9E%E7%8E%B0%E6%B3%A2%E6%B5%AA%E6%95%88%E6%9E%9C/"/>
    <id>https://blog.huangyuanlove.com/2024/03/27/%E9%B8%BF%E8%92%99-canvas-%E5%AE%9E%E7%8E%B0%E6%B3%A2%E6%B5%AA%E6%95%88%E6%9E%9C/</id>
    <published>2024-03-27T02:44:55.000Z</published>
    <updated>2024-03-27T02:53:17.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android 中 canvas 能画出来的东西鸿蒙的 canvas 还画不了，不大可能吧？有个朋友问鸿蒙应用中想实现波浪效果，应该咋画？这个问题，你能在 Android 上用 canvas 画出来，在鸿蒙里面用 canvas 画不出来？还是 api 不熟悉吧？</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>波浪效果嘛，首先想到的是正弦、余弦函数、贝塞尔曲线，还有一个傅里叶变换，不过这个有点搞不定。这里选择使用贝塞尔曲线，因为之前在 Android 中画过，应该可以很丝滑的迁移过来<br>先复习一下在 Android 中怎么实现：<a href="https://blog.huangyuanlove.com/2019/01/20/%E8%87%AA%E5%AE%9A%E4%B9%89View-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E3%80%81Shader/">https://blog.huangyuanlove.com/2019/01/20/%E8%87%AA%E5%AE%9A%E4%B9%89View-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E3%80%81Shader/</a></p><p>确认起始点，确认终点，计算控制点，然后调用 api 划线，最后填充一下就好了。<br>怎么动起来？Android 这边用的动画，其实用 handler 或者其他东西搞个定时更新也行。<br>先看效果图<br><img src="/image/HarmonyOS/wave.gif" alt="wave.gif">  </p><p>看下鸿蒙对应的 api，目前开放的最新的HarmonyOS文档是 3.1&#x2F;4.0的，对应地址是这个 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-canvasrenderingcontext2d-0000001478181441-V3#ZH-CN_TOPIC_0000001573928937__quadraticcurveto">https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-canvasrenderingcontext2d-0000001478181441-V3#ZH-CN_TOPIC_0000001573928937__quadraticcurveto</a><br>目前开放的最新的 OpenHarmony 文档是4.0 的，对应地址在这里 <a href="https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/ui/arkts-drawing-customization-on-canvas.md/#%E7%94%BB%E5%B8%83%E7%BB%84%E4%BB%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/ui/arkts-drawing-customization-on-canvas.md/#%E7%94%BB%E5%B8%83%E7%BB%84%E4%BB%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95</a><br>步骤都差不多，只不过鸿蒙中没有画笔的概念，需要对<code>CanvasRenderingContext2D</code>对象进行操作设置，包括设置线条颜色、线条宽度、图型填充颜色等。<br>想要画线、画出各种形状，可以直接操作<code>CanvasRenderingContext2D</code>对象，也可以创建<code>Path2D</code>对象进行操作。其余 api 可以查看对应的文档。  </p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>这还有啥好设计的，直接<del>抄</del>移植 Android 上面的实现就好了<br>由于需要动起来，为了避免移动后左右有空白，这里需要<strong>多画一个波浪</strong></p><p><img src="/image/HarmonyOS/wave.png" alt="WX20240108-233545@2x.png">  </p><p>这里需要注意的是，我们需要上面这条蓝色的线，而不是下面这条绿色的。</p><p>在 Android 中画二阶贝塞尔曲线有两个 api,一个是<br><code>public void rQuadTo(float dx1, float dy1, float dx2, float dy2)</code><br>这个表示的是控制点和终点相对于上一个控制点和终点的偏移量<br>另外一个是<br><code>public void quadTo(float x1, float y1, float x2, float y2)</code><br>这个表示是控制点和终点的绝对坐标值<br>但在鸿蒙中没有找到对应的 api，我们可以自己计算一下：这里的控制点的横坐标是起点和终点的中间值，控制点的纵坐标取的是波浪高度<br>所以上面两条线的画法是这样的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;30%&quot;</span>)<br>        .<span class="hljs-title function_">onAreaChange</span>(<span class="hljs-function">(<span class="hljs-params">oldValue,newValue</span>)=&gt;</span>&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#39d167&quot;</span><br><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#39d167&quot;</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">10</span><br>          <span class="hljs-keyword">let</span> canvasWidth = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">width</span>.<span class="hljs-title function_">toString</span>())<br>          <span class="hljs-keyword">let</span> canvasHeight = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">height</span>.<span class="hljs-title function_">toString</span>())<br><br>          <span class="hljs-keyword">let</span> waveWidth = canvasWidth/<span class="hljs-number">2</span><br>          <span class="hljs-keyword">let</span> waveHeight = <span class="hljs-number">100</span><br>          <span class="hljs-keyword">let</span> baseHeight =canvasHeight<br><br>          <span class="hljs-keyword">let</span> <span class="hljs-attr">path</span>:<span class="hljs-title class_">Path2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>          <br>          path.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">0</span>,baseHeight)<br>          <span class="hljs-comment">//波浪宽度是画布的一半，这里偷懒直接写了</span><br>          path.<span class="hljs-title function_">quadraticCurveTo</span>( waveWidth/<span class="hljs-number">2</span>,baseHeight-waveHeight ,waveWidth,baseHeight)<br>          path.<span class="hljs-title function_">quadraticCurveTo</span>(waveWidth+waveWidth/<span class="hljs-number">2</span>,  baseHeight-waveHeight ,canvasWidth,baseHeight)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>(path)<br><br><br>          path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>          baseHeight /=<span class="hljs-number">3</span><br>          path.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">0</span>,baseHeight)<br>          <span class="hljs-comment">//波浪宽度是画布的一半，这里偷懒直接写了</span><br>          path.<span class="hljs-title function_">quadraticCurveTo</span>( waveWidth/<span class="hljs-number">2</span>,baseHeight-waveHeight ,waveWidth,baseHeight)<br>          path.<span class="hljs-title function_">quadraticCurveTo</span>(waveWidth+waveWidth/<span class="hljs-number">2</span>,  baseHeight+waveHeight ,canvasWidth,baseHeight)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#1b91e0&quot;</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>(path)<br>          <br>        &#125;)<br></code></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现也一样，直接<del>抄</del> 移植过来就好了，对应的 api 怎么用也搞定了，代码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">WaveView</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasHeight</span>: <span class="hljs-built_in">number</span> = -<span class="hljs-number">1</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasWidth</span>: <span class="hljs-built_in">number</span> = -<span class="hljs-number">1</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-attr">dx</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span> <span class="hljs-comment">//最大值等于 waveWidth，每次移动的距离</span><br>  <span class="hljs-keyword">private</span> waveHeight = <span class="hljs-number">50</span> <span class="hljs-comment">//拍脑袋订的数值</span><br>  <span class="hljs-keyword">private</span> baseHeight = <span class="hljs-number">300</span> <span class="hljs-comment">//拍脑袋订的数值</span><br>  <span class="hljs-keyword">private</span> waveWidth = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">intervalTimer</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-title function_">drawWave</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span> += <span class="hljs-number">4</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span> = <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>)<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> / <span class="hljs-number">2</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">path</span>: <span class="hljs-title class_">Path2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>    <span class="hljs-comment">//需要在屏幕外多画一个波浪，这里先将画笔移动到画布|屏幕外，记得加上动画的偏移量 dx</span><br>    path.<span class="hljs-title function_">moveTo</span>(-<span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span>)<br>    <span class="hljs-keyword">let</span> startX = -<span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span><span class="hljs-comment">//记录开始点的横坐标</span><br>    <span class="hljs-comment">//需要多画一个波浪，直接循环开始画就好了</span><br>    <span class="hljs-keyword">while</span> (startX &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span>) &#123;<br><br>      <span class="hljs-keyword">let</span> endY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span><br>      <span class="hljs-comment">//画向下和向上的波浪，全靠控制点的纵坐标控制波浪的上线</span><br>      path.<span class="hljs-title function_">quadraticCurveTo</span>(startX + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> / <span class="hljs-number">4</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveHeight</span>, startX + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span>/<span class="hljs-number">2</span>, endY)<br>      path.<span class="hljs-title function_">quadraticCurveTo</span>(startX + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> / <span class="hljs-number">4</span>*<span class="hljs-number">3</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveHeight</span>, startX + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span>, endY)<br>      <span class="hljs-comment">//画完一上一下这一组波浪后更新起始点坐标</span><br>      startX += <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span><br>    &#125;<br>    <span class="hljs-comment">//需要将波浪线下方的区域填满颜色，这里取巧圈起来一个框，使用 fill 方法填充</span><br>    path.<span class="hljs-title function_">lineTo</span>(startX ,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>) <span class="hljs-comment">//波浪线最右侧画一条到画布底部的垂线</span><br>    path.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">0</span> ,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>)<span class="hljs-comment">//画布底部的横线</span><br>    path.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">0</span> ,<span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveHeight</span>) <span class="hljs-comment">//波浪线最左侧到画布底部的垂线</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#39d167&quot;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#39d167&quot;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">10</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>(path)<br><br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>)<br>        .<span class="hljs-title function_">onAreaChange</span>(<span class="hljs-function">(<span class="hljs-params">oldValue, newValue</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">width</span>.<span class="hljs-title function_">toString</span>())<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">height</span>.<span class="hljs-title function_">toString</span>())<br><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> - <span class="hljs-number">300</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> / <span class="hljs-number">2</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawWave</span>()<br><br>        &#125;)<br>      <span class="hljs-title class_">Row</span>() &#123;<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;开始&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">intervalTimer</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">intervalTimer</span>)<br>          &#125;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">intervalTimer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawWave</span>()<br>          &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">10</span>)<br>        &#125;)<br>        <span class="hljs-title class_">Blank</span>().<span class="hljs-title function_">width</span>(<span class="hljs-number">15</span>)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;停止&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">intervalTimer</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">intervalTimer</span>)<br>          &#125;<br>        &#125;)<br>      &#125;.<span class="hljs-title function_">margin</span>(&#123; <span class="hljs-attr">bottom</span>: <span class="hljs-number">10</span> &#125;)<br><br>    &#125;<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面就是完整的代码了，github 仓库在这里：<a href="https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/WaveView.ets">https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/WaveView.ets</a><br><a href="https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/WaveLinePage.ets">https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/WaveLinePage.ets</a></p><h3 id="进化"><a href="#进化" class="headerlink" title="进化"></a>进化</h3><p>稍微修改一下就可以做成其他效果<br>比如将<code>baseHeight</code>也用<code>@State</code>修饰一下，同时在定时器中更新一下，就可以实现注水效果<br>再将画布裁成圆形，就是一个简单的充电、内存加速球效果。再做点随机的粒子效果或者多画几条浅色的波浪线，效果就更好了</p><hr><p>以上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Android 中 canvas 能画出来的东西鸿蒙的 canvas 还画不了，不大可能吧？有个朋友问鸿蒙应用中想实现波浪效果，应该咋画？这</summary>
      
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>riverpod2中的修饰符及注解</title>
    <link href="https://blog.huangyuanlove.com/2024/03/27/riverpod2%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E6%B3%A8%E8%A7%A3/"/>
    <id>https://blog.huangyuanlove.com/2024/03/27/riverpod2%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E6%B3%A8%E8%A7%A3/</id>
    <published>2024-03-27T02:43:24.000Z</published>
    <updated>2024-03-27T02:44:14.329Z</updated>
    
    <content type="html"><![CDATA[<p>原文来自：<a href="https://codewithandrea.com/articles/flutter-state-management-riverpod/">https://codewithandrea.com/articles/flutter-state-management-riverpod/</a></p><h3 id="监听、观察、选择、记录、重建"><a href="#监听、观察、选择、记录、重建" class="headerlink" title="监听、观察、选择、记录、重建"></a>监听、观察、选择、记录、重建</h3><h4 id="ref-read-or-ref-watch"><a href="#ref-read-or-ref-watch" class="headerlink" title="ref.read or ref.watch"></a>ref.read or ref.watch</h4><p>在上一篇中，我们使用了 ref.read和 ref.watch，那么这两者在什么情况下使用？<br>一般来讲，如果需要在Provider 值发生改变时更新依赖它的 widget，就使用 watch。比如 我们在 build 函数中使用watch,这确保了如果提供者的值发生更改，我们会重建依赖它的widget.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterStateProvider = StateProvider&lt;<span class="hljs-built_in">int</span>&gt;((_) =&gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>    <span class="hljs-meta">@override</span><br>    Widget build(BuildContext context, WidgetRef ref) &#123;<br>      <span class="hljs-comment">// 1. watch the provider and rebuild when the value changes</span><br>      <span class="hljs-keyword">final</span> counter = ref.watch(counterStateProvider);<br>      <span class="hljs-keyword">return</span> ElevatedButton(<br>        <span class="hljs-comment">// 2. use the value</span><br>        child: Text(<span class="hljs-string">&#x27;Value: <span class="hljs-subst">$counter</span>&#x27;</span>),<br>        <span class="hljs-comment">// 3. change the state inside a button callback</span><br>        onPressed: () =&gt; ref.read(counterStateProvider.notifier).state++,<br>      );<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>如果我们只是读取到 Provider 的值做操作，一般使用 read，比如上面点击 ElevatedButton 时我们获取到 notifier 之后对count 做了++操作<br>需要注意的是：notifier语法仅适用于StateProvider和StateNotifierProvider，其工作方式如下：</p><ul><li>在StateProvider上调用ref.read(provider.notifier)，以返回底层的StateController，我们可以使用它来修改状态。</li><li>在StateNotifierProvider上调用ref.read(provider.notifier)，以返回底层的StateNotifier，以便我们可以调用其方法。</li></ul><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>我们有时候也会遇到这种需求：一个对象有多个属性，希望只有特定属性发生变化时才更新页面，这时候我们就可以使用 select 来完成</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  Student(<span class="hljs-keyword">this</span>.firstName, <span class="hljs-keyword">this</span>.lastName, <span class="hljs-keyword">this</span>.age);<br><br>  <span class="hljs-built_in">String</span> firstName;<br>  <span class="hljs-built_in">String</span> lastName;<br>  <span class="hljs-built_in">int</span> age;<br>  Student copy() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student(firstName, lastName, age);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要在年龄发生改变时更新页面</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> age = ref.watch( provider.select((value) =&gt; value.age) );<br>    <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&quot;<span class="hljs-subst">$age</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><p>除此之外，我们还有 listen， 比如我们希望在 Provider 内容发生变化时弹出一个 SnakeBar提示用户，我们可以这样做:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterStateProvider = StateProvider&lt;<span class="hljs-built_in">int</span>&gt;((_) =&gt; <span class="hljs-number">0</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-comment">// if we use a StateProvider&lt;T&gt;, the type of the previous and current </span><br>    <span class="hljs-comment">// values is StateController&lt;T&gt;</span><br>    ref.listen&lt;StateController&lt;<span class="hljs-built_in">int</span>&gt;&gt;(counterStateProvider.state, (previous, current) &#123;<br>      <span class="hljs-comment">// note: this callback executes when the provider value changes,</span><br>      <span class="hljs-comment">// not when the build method is called</span><br>      ScaffoldMessenger.of(context).showSnackBar(<br>        SnackBar(content: Text(<span class="hljs-string">&#x27;Value is <span class="hljs-subst">$&#123;current.state&#125;</span>&#x27;</span>)),<br>      );<br>    &#125;);<br>    <span class="hljs-comment">// watch the provider and rebuild when the value changes</span><br>    <span class="hljs-keyword">final</span> counter = ref.watch(counterStateProvider);<br>    <span class="hljs-keyword">return</span> ElevatedButton(<br>      <span class="hljs-comment">// use the value</span><br>      child: Text(<span class="hljs-string">&#x27;Value: <span class="hljs-subst">$counter</span>&#x27;</span>),<br>      <span class="hljs-comment">// change the state inside a button callback</span><br>      onPressed: () =&gt; ref.read(counterStateProvider.notifier).state++,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>我们需要在 Provider 内容发生改变时打印日志，以方便我们进行调试，但又不想在每个 Provider 中都加上打印代码，应该怎么办？<br>在 Rivepod 中有一个ProviderObserver类，我们可以继承它实现自己的逻辑</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProviderObserver</span> </span>&#123;<br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-keyword">void</span> didUpdateProvider(<br>      ProviderBase provider,<br>      <span class="hljs-built_in">Object?</span> previousValue,<br>      <span class="hljs-built_in">Object?</span> newValue,<br>      ProviderContainer container,<br>    ) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[<span class="hljs-subst">$&#123;provider.name ?? provider.runtimeType&#125;</span>] value: <span class="hljs-subst">$newValue</span>&#x27;</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>同样的，需要将它添加到 ProviderScope内的观察者列表中</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>    runApp(<br>      ProviderScope(observers: [ProviderLogger()], child: MyApp()),<br>    );<br>  &#125;<br></code></pre></td></tr></table></figure><p>为了方便我们区分是哪一个 Provider 的日志，我们在声明 Provider 时可以提供一个名字</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterStateProvider = StateProvider&lt;<span class="hljs-built_in">int</span>&gt;((ref) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;, name: <span class="hljs-string">&#x27;main_page_counter&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="autoDispose"><a href="#autoDispose" class="headerlink" title="autoDispose"></a>autoDispose</h4><p>上一篇中提到Riverpod 作者强烈建议将 Provider 声明为全局的而不是类内部，这样有一个问题，页面销毁时也就是provider没有任何监听者时并不会被重置。再次进入页面后还是页面销毁之前的值，比如 StateProvider 实现的计数功能。当我们在页面中点击加号，将数字变为 5 后，返回上一个页面后再次打开该页面，会发现页面还是 5。这有时不符合我们的需求，这里我们可以使用autoDispose来实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> autoDisposeProvider = StateProvider.autoDispose&lt;<span class="hljs-built_in">int</span>&gt;(((ref) &#123;<br>  ref.onDispose(() &#123;<br>    debugPrint(<span class="hljs-string">&quot;countProvider onDispose&quot;</span>);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;));<br><br><span class="hljs-keyword">final</span> countProvider = StateProvider&lt;<span class="hljs-built_in">int</span>&gt;((ref) =&gt; <span class="hljs-number">1</span>);<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RiverpodAutoDisposeWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> autoDisposeValue = ref.watch(autoDisposeProvider);<br>    <span class="hljs-keyword">final</span> normalValue = ref.watch(countProvider);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;AutoDispose&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Column(children: [<br>        Text(<span class="hljs-string">&quot;autoDispose:当privder不被使用时，可以被自动释放&quot;</span>),<br>        Text(<span class="hljs-string">&quot;autoDisposeValue-&gt; <span class="hljs-subst">$&#123;autoDisposeValue&#125;</span>&quot;</span>),<br>        Text(<span class="hljs-string">&quot;normalValue-&gt; <span class="hljs-subst">$&#123;normalValue&#125;</span>&quot;</span>),<br>        Row(<br>          children: [<br>            ElevatedButton(<br>                onPressed: (() &#123;<br>                  ref.read(autoDisposeProvider.notifier).state++;<br>                  ref.read(countProvider.notifier).state++;<br>                &#125;),<br>                child: Text(<span class="hljs-string">&quot;增加计数&quot;</span>))<br>          ],<br>        )<br>      ]),<br>    );<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>可以看到当页面被销毁时，被autoDispose修饰的 provider 会被释放并重置。这里的 ref.onDispose会在没有监听者之后调用。</p><h4 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h4><p>我们可以使用 ref.keepAlive实现超时缓存。<br>简单粗暴点就是这样：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> tmpProvider = StateProvider.autoDispose&lt;<span class="hljs-built_in">int</span>&gt;((ref)&#123;<br><br>    <span class="hljs-comment">// get the [KeepAliveLink]</span><br>    <span class="hljs-keyword">final</span> link = ref.keepAlive();<br>    <span class="hljs-comment">// start a 30 second timer</span><br>    <span class="hljs-keyword">final</span> timer = Timer(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">30</span>), () &#123;<br>      <span class="hljs-comment">// dispose on timeout</span><br>      link.close();<br>    &#125;);<br>    <span class="hljs-comment">// make sure to cancel the timer when the provider state is disposed</span><br>    <span class="hljs-comment">// (prevents undesired test failures)</span><br>    ref.onDispose(() =&gt; timer.cancel());<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>我们可以使用<code>extension</code>封装一下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">extension</span> AutoDisposeRefCache <span class="hljs-keyword">on</span> AutoDisposeRef &#123;<br>  <span class="hljs-keyword">void</span> cacheFor(<span class="hljs-built_in">Duration</span> duration) &#123;<br>    <span class="hljs-keyword">final</span> link = keepAlive();<br>    <span class="hljs-keyword">final</span> timer = Timer(duration, () &#123;<br>      link.close();<br>    &#125;);<br>    onDispose(() &#123;<br>      timer.cancel();<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//使用</span><br><span class="hljs-keyword">final</span> timerCachedProvider = Provider.autoDispose&lt;<span class="hljs-built_in">int</span>&gt;((ref) &#123;<br>  ref.cacheFor(<span class="hljs-built_in">Duration</span>(minutes: <span class="hljs-number">5</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="family"><a href="#family" class="headerlink" title="family"></a>family</h4><p>我们可以用它向 Provider 提供参数，比如我们的计数器示例，比如想从指定的数字开始</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> countProviderBase = StateProvider.autoDispose.family&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt; ((ref,start)&#123;<br>  <span class="hljs-keyword">return</span> start;<br>&#125;);<br><span class="hljs-comment">//使用</span><br><span class="hljs-keyword">final</span> startValue =  ref.watch(countProviderBase(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><h4 id="依赖覆盖"><a href="#依赖覆盖" class="headerlink" title="依赖覆盖"></a>依赖覆盖</h4><p>有时候我们希望使用 Provider 存储无法立即获取的对象或者值，比如做本地存储时用的<code>shared_preferences</code>。但是它的初始化是异步的，如果我们直接在 Provider 中使用则会提示</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> spProvider = Provider&lt;SharedPreferences&gt;((ref) &#123;<br>  <span class="hljs-keyword">return</span> SharedPreferences.getInstance();<span class="hljs-comment">//不可以这样使用</span><br>  <span class="hljs-comment">//The return type &#x27;Future&lt;SharedPreferences&gt;&#x27; isn&#x27;t a &#x27;SharedPreferences&#x27;, as required by the closure&#x27;s context.</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>这时候我们可以先抛出一个为实现的异常</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> sharedPreferencesProvider = Provider&lt;SharedPreferences&gt;((ref) &#123;<br>    <span class="hljs-keyword">throw</span> UnimplementedError();<br>  &#125;);<br></code></pre></td></tr></table></figure><p>然后我们可以在 ProviderScope 组件中进行依赖覆盖</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-keyword">void</span>&gt; main() <span class="hljs-keyword">async</span> &#123;<br>  WidgetsFlutterBinding.ensureInitialized();<br>  <span class="hljs-keyword">final</span> sharedPreferences = <span class="hljs-keyword">await</span> SharedPreferences.getInstance();<br>  runApp(ProviderScope(<br>    overrides: [<br>      <span class="hljs-comment">// override the previous value with the new object</span><br>      sharedPreferencesProvider.overrideWithValue(sharedPreferences),<br>    ],<br>    child: MyApp(),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以在任何地方观察sharedPreferencesProvider对象，而无需使用基于Future的API</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>我们在使用 Provider 时都需要手动编写，我们是否可以使用 build_runner生成？Riverpod 中已经提供了这种方式，但当前只支持以下几种</p><ul><li>Provider</li><li>FutureProvider</li><li>StreamProvider</li><li>NotifierProvider</li><li>AsyncNotifierProvider</li></ul><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-comment"># or flutter_riverpod/hooks_riverpod as per https://riverpod.dev/docs/getting_started</span><br>  <span class="hljs-attr">riverpod:</span> <span class="hljs-string">^2.4.10</span><br>  <span class="hljs-comment"># the annotation package containing @riverpod</span><br>  <span class="hljs-attr">riverpod_annotation:</span> <span class="hljs-string">^2.3.4</span><br><span class="hljs-attr">dev_dependencies:</span><br>  <span class="hljs-comment"># a tool for running code generators</span><br>  <span class="hljs-attr">build_runner:</span><br>  <span class="hljs-comment"># the code generator</span><br>  <span class="hljs-attr">riverpod_generator:</span> <span class="hljs-string">^2.3.9</span><br>  <span class="hljs-comment"># riverpod_lint makes it easier to work with Riverpod</span><br>  <span class="hljs-attr">riverpod_lint:</span> <span class="hljs-string">^2.3.7</span><br>  <span class="hljs-comment"># import custom_lint too as riverpod_lint depends on it</span><br>  <span class="hljs-attr">custom_lint:</span><br></code></pre></td></tr></table></figure><p>其中<code>riverpod_lint</code>和<code>custom_lint</code>这两个包是可选的。<br>之后我们需要在<code>watch</code>模式下启动代码生成器<br><code>flutter pub run build_runner watch -d</code>,较新的flutter版本会提示使用<code>dart run build_runner watch -d</code>。</p><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>我们来看个简单的示例，从 Provider 开始<br>没有使用注解生成器之前：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// dio_provider.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/dio.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><span class="hljs-comment">// a provider for the Dio client to be used by the rest of the app</span><br><span class="hljs-keyword">final</span> dioProvider = Provider&lt;Dio&gt;((ref) &#123;<br>  <span class="hljs-keyword">return</span> Dio();<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用注解生成器之后</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/dio.dart&#x27;</span>;<br><span class="hljs-comment">// 1. import the riverpod_annotation package</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:riverpod_annotation/riverpod_annotation.dart&#x27;</span>;<br><span class="hljs-comment">// 2. add a part file</span><br><span class="hljs-keyword">part</span> <span class="hljs-string">&#x27;dio_provider.g.dart&#x27;</span>;<br><br><br><span class="hljs-comment">//需要执行 flutter pub run build_runner watch -d 来生成对应代码</span><br><span class="hljs-meta">@riverpod</span><br>Dio dio(DioRef ref)&#123;<br>  <span class="hljs-keyword">return</span> Dio();<br>&#125;<br></code></pre></td></tr></table></figure><p>会生成<code>dio_provider.g.dart</code>文件，内容如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// GENERATED CODE - DO NOT MODIFY BY HAND</span><br><br><span class="hljs-keyword">part</span> of <span class="hljs-string">&#x27;dio_provider.dart&#x27;</span>;<br><br><span class="hljs-comment">// **************************************************************************</span><br><span class="hljs-comment">// RiverpodGenerator</span><br><span class="hljs-comment">// **************************************************************************</span><br><br><span class="hljs-built_in">String</span> _$dioHash() =&gt; <span class="hljs-string">r&#x27;58eeefbd0832498ca2574c1fe69ed783c58d1d8f&#x27;</span>;<br><br><span class="hljs-comment">/// <span class="language-markdown">See also [dio].</span></span><br><span class="hljs-meta">@ProviderFor</span>(dio)<br><span class="hljs-keyword">final</span> dioProvider = AutoDisposeProvider&lt;Dio&gt;.internal(<br>  dio,<br>  name: <span class="hljs-string">r&#x27;dioProvider&#x27;</span>,<br>  debugGetCreateSourceHash:<br>      <span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">&#x27;dart.vm.product&#x27;</span>) ? <span class="hljs-keyword">null</span> : _$dioHash,<br>  dependencies: <span class="hljs-keyword">null</span>,<br>  allTransitiveDependencies: <span class="hljs-keyword">null</span>,<br>);<br><br><span class="hljs-keyword">typedef</span> DioRef = AutoDisposeProviderRef&lt;Dio&gt;;<br><span class="hljs-comment">// ignore_for_file: type=lint</span><br><span class="hljs-comment">// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member</span><br><br></code></pre></td></tr></table></figure><h4 id="autoDispose和-keepAlive"><a href="#autoDispose和-keepAlive" class="headerlink" title="autoDispose和 keepAlive"></a>autoDispose和 keepAlive</h4><p>在使用注解生成代码时，autoDispose 现在默认启用，并已重命名为 keepAlive。如果不想销毁 provider，可以将keepAlive设置为 true</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Riverpod</span>(keepAlive: <span class="hljs-keyword">true</span>)<br><span class="hljs-built_in">int</span> counter(CounterRef ref)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的代码是这样的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> _$counterHash() =&gt; <span class="hljs-string">r&#x27;6b26baf29ab7c65258c6367ad62133458d88a2b3&#x27;</span>;<br><br><span class="hljs-comment">/// <span class="language-markdown">See also [counter].</span></span><br><span class="hljs-meta">@ProviderFor</span>(counter)<br><span class="hljs-keyword">final</span> counterProvider = Provider&lt;<span class="hljs-built_in">int</span>&gt;.internal(<br>  counter,<br>  name: <span class="hljs-string">r&#x27;counterProvider&#x27;</span>,<br>  debugGetCreateSourceHash:<br>      <span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">&#x27;dart.vm.product&#x27;</span>) ? <span class="hljs-keyword">null</span> : _$counterHash,<br>  dependencies: <span class="hljs-keyword">null</span>,<br>  allTransitiveDependencies: <span class="hljs-keyword">null</span>,<br>);<br><br><span class="hljs-keyword">typedef</span> CounterRef = ProviderRef&lt;<span class="hljs-built_in">int</span>&gt;;<br><span class="hljs-comment">// ignore_for_file: type=lint</span><br><span class="hljs-comment">// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member</span><br><br></code></pre></td></tr></table></figure><p>可以看到，当 keepAlive 是默认值(true)时，使用的是<code>AutoDisposeProvider</code>,为 false 时，使用的是<code>Provider</code></p><h4 id="FutureProvider-和-StreamProvider"><a href="#FutureProvider-和-StreamProvider" class="headerlink" title="FutureProvider 和 StreamProvider"></a>FutureProvider 和 StreamProvider</h4><p>几乎是一样的写法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@riverpod</span><br>Future&lt;<span class="hljs-built_in">String</span>&gt; generateName(GenerateNameRef ref) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span>  <span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@riverpod</span><br>Stream&lt;<span class="hljs-built_in">int</span>&gt; timeCount(TimeCountRef ref)&#123;<br>  <span class="hljs-keyword">return</span> Stream.periodic(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>),(number)&#123;<br>    <span class="hljs-keyword">return</span> number +<span class="hljs-number">1</span>;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="NotifierProvider"><a href="#NotifierProvider" class="headerlink" title="NotifierProvider"></a>NotifierProvider</h4><p>我们把上一篇中<code>NotifierProvider</code>例子简化一下，还是那个万能的计数器</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//声明一个Notifier对象</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Notifier</span>&lt;<span class="hljs-title">int</span>&gt;</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">int</span> build() &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br> <span class="hljs-comment">//对 state 进行操作，也可以在外部直接操作</span><br>  <span class="hljs-keyword">void</span> increment()&#123;<br>    state ++;<br>  &#125;<br><br>&#125;<br><span class="hljs-comment">//两种 provider 的声明方式</span><br><span class="hljs-keyword">final</span> counterProvider = NotifierProvider&lt;Counter, <span class="hljs-built_in">int</span>&gt;(() &#123;<br>  <span class="hljs-keyword">return</span> Counter();<br>&#125;);<br><span class="hljs-comment">// final counterProvider = NotifierProvider&lt;Counter, int&gt;(Counter.new);</span><br></code></pre></td></tr></table></figure><p>在 widget 中使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RiverpodGeneratorWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> count = ref.watch(counterProvider);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(title: Text(<span class="hljs-string">&quot;RiverpodGeneratorWidget&quot;</span>),centerTitle: <span class="hljs-keyword">true</span>,),<br>      body: Column(children: [<br>        Text(<span class="hljs-string">&quot;count <span class="hljs-subst">$count</span>&quot;</span>)<br>      ],),<br>      floatingActionButton: FloatingActionButton(onPressed: ()&#123;<br>        <span class="hljs-comment">//调用 notifier 中定义的方法</span><br>        ref.read(counterProvider.notifier).increment();<br>        <span class="hljs-comment">//直接获取到 state 进行操作</span><br>        ref.read(counterProvider.notifier).state++;<br>      &#125;,child: Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们如是用注解代码生成？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//counter.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:riverpod_annotation/riverpod_annotation.dart&#x27;</span>;<br><span class="hljs-keyword">part</span> <span class="hljs-string">&#x27;counter.g.dart&#x27;</span>;<br><span class="hljs-meta">@riverpod</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">_</span>$<span class="hljs-title">Counter</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">int</span> build() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">void</span> increment()&#123;<br>    state ++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，这里我们需要继承<code>_$Counter</code>而不是<code>Notifier</code>。<br>因为 <code>Counter</code>中的 <code>build</code> 方法返回值是<code>int</code>类型，生成的代码中也就使用了 <code>int</code>类型。简单来讲就是<code>build</code>方法的返回值类型决定了 <code>state</code> 的类型.</p><p>还是需要运行 <code>flutter pub run build_runner watch</code> 或者 <code>dart run build_runner watch</code>,这时会生成<code>counter.g.dart</code>文件，内容如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// GENERATED CODE - DO NOT MODIFY BY HAND</span><br><br><span class="hljs-keyword">part</span> of <span class="hljs-string">&#x27;counter.dart&#x27;</span>;<br><br><span class="hljs-comment">// **************************************************************************</span><br><span class="hljs-comment">// RiverpodGenerator</span><br><span class="hljs-comment">// **************************************************************************</span><br><br><span class="hljs-built_in">String</span> _$counterHash() =&gt; <span class="hljs-string">r&#x27;7015b4a05f8ed24a914f6b3aad12be335d0c73d7&#x27;</span>;<br><br><span class="hljs-comment">/// <span class="language-markdown">See also [Counter].</span></span><br><span class="hljs-meta">@ProviderFor</span>(Counter)<br><span class="hljs-keyword">final</span> counterProvider = AutoDisposeNotifierProvider&lt;Counter, <span class="hljs-built_in">int</span>&gt;.internal(<br>  Counter.<span class="hljs-keyword">new</span>,<br>  name: <span class="hljs-string">r&#x27;counterProvider&#x27;</span>,<br>  debugGetCreateSourceHash:<br>      <span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">&#x27;dart.vm.product&#x27;</span>) ? <span class="hljs-keyword">null</span> : _$counterHash,<br>  dependencies: <span class="hljs-keyword">null</span>,<br>  allTransitiveDependencies: <span class="hljs-keyword">null</span>,<br>);<br><br><span class="hljs-keyword">typedef</span> _$Counter = AutoDisposeNotifier&lt;<span class="hljs-built_in">int</span>&gt;;<br><span class="hljs-comment">// ignore_for_file: type=lint</span><br><span class="hljs-comment">// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member</span><br><br></code></pre></td></tr></table></figure><h4 id="AsyncNotifierProvider"><a href="#AsyncNotifierProvider" class="headerlink" title="AsyncNotifierProvider"></a>AsyncNotifierProvider</h4><p>也是同样的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@riverpod</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCounters</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">_</span>$<span class="hljs-title">AsyncCounters</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  FutureOr&lt;<span class="hljs-built_in">int</span>&gt; build()&#123;<br>    <span class="hljs-keyword">return</span> Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>),()&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的代码如下</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// GENERATED CODE - DO NOT MODIFY BY HAND</span><br><br><span class="hljs-keyword">part</span> of <span class="hljs-string">&#x27;async_counter.dart&#x27;</span>;<br><br><span class="hljs-comment">// **************************************************************************</span><br><span class="hljs-comment">// RiverpodGenerator</span><br><span class="hljs-comment">// **************************************************************************</span><br><br><span class="hljs-built_in">String</span> _$asyncCountersHash() =&gt; <span class="hljs-string">r&#x27;787b7c6513c7794fa310550d32594b97238e7e3c&#x27;</span>;<br><br><span class="hljs-comment">/// <span class="language-markdown">See also [AsyncCounters].</span></span><br><span class="hljs-meta">@ProviderFor</span>(AsyncCounters)<br><span class="hljs-keyword">final</span> asyncCountersProvider =<br>    AutoDisposeAsyncNotifierProvider&lt;AsyncCounters, <span class="hljs-built_in">int</span>&gt;.internal(<br>  AsyncCounters.<span class="hljs-keyword">new</span>,<br>  name: <span class="hljs-string">r&#x27;asyncCountersProvider&#x27;</span>,<br>  debugGetCreateSourceHash: <span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">&#x27;dart.vm.product&#x27;</span>)<br>      ? <span class="hljs-keyword">null</span><br>      : _$asyncCountersHash,<br>  dependencies: <span class="hljs-keyword">null</span>,<br>  allTransitiveDependencies: <span class="hljs-keyword">null</span>,<br>);<br><br><span class="hljs-keyword">typedef</span> _$AsyncCounters = AutoDisposeAsyncNotifier&lt;<span class="hljs-built_in">int</span>&gt;;<br><span class="hljs-comment">// ignore_for_file: type=lint</span><br><span class="hljs-comment">// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member</span><br><br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Notifier-和-AsyncNotifier：是否值得使用？"><a href="#Notifier-和-AsyncNotifier：是否值得使用？" class="headerlink" title="Notifier 和 AsyncNotifier：是否值得使用？"></a>Notifier 和 AsyncNotifier：是否值得使用？</h4><p>长时间以来，StateNotifier 一直在为我们提供服务，提供了一个存储复杂状态和修改状态逻辑的地方，使其不再依赖于小部件树。</p><p>Notifier 和 AsyncNotifier 旨在取代 StateNotifier 并带来一些新的好处：</p><p>更容易执行复杂的异步初始化<br>更符合人体工程学的 API：不再需要传递 ref<br>不再需要手动声明提供者（如果使用 Riverpod Generator）<br>对于新项目来说，这些好处是值得的，因为新的类可以帮助您用更少的代码实现更多的功能。</p><p>但如果您有很多现有代码使用 StateNotifier，则由您决定是否（或何时）迁移到新的语法。</p><p>无论如何，StateNotifier 还会存在一段时间，如果您愿意，可以逐个迁移您的提供者。</p><h4 id="使用-generator-还是手动编写-provider"><a href="#使用-generator-还是手动编写-provider" class="headerlink" title="使用 generator 还是手动编写 provider"></a>使用 generator 还是手动编写 provider</h4><p>使用 generator 需要我们执行额外的代码来生成对应的代码文件，并且在编写生成代码时体验不是那么的友好。但另外一方面，能省去我们编写模板的代码的时间。如何使用，看个人喜好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文来自：&lt;a href=&quot;https://codewithandrea.com/articles/flutter-state-management-riverpod/&quot;&gt;https://codewithandrea.com/articles/flutter-state-m</summary>
      
    
    
    
    
    <category term="Flutter" scheme="https://blog.huangyuanlove.com/tags/Flutter/"/>
    
    <category term="riverpod" scheme="https://blog.huangyuanlove.com/tags/riverpod/"/>
    
  </entry>
  
  <entry>
    <title>riverpod2.x中的 Provider 简介</title>
    <link href="https://blog.huangyuanlove.com/2024/03/27/riverpod2-x%E4%B8%AD%E7%9A%84-Provider-%E7%AE%80%E4%BB%8B/"/>
    <id>https://blog.huangyuanlove.com/2024/03/27/riverpod2-x%E4%B8%AD%E7%9A%84-Provider-%E7%AE%80%E4%BB%8B/</id>
    <published>2024-03-27T02:13:58.000Z</published>
    <updated>2024-04-01T02:18:11.659Z</updated>
    
    <content type="html"><![CDATA[<p>原文来自：<a href="https://codewithandrea.com/articles/flutter-state-management-riverpod/">https://codewithandrea.com/articles/flutter-state-management-riverpod/</a></p><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Riverpod是一个响应式缓存和数据绑定框架，由Provider软件包演化而来。根据官方文档的说法，riverpod 是把 provider 重写了，实现了原来无法实现的功能。</p><h3 id="为什么使用-riverpod"><a href="#为什么使用-riverpod" class="headerlink" title="为什么使用 riverpod"></a>为什么使用 riverpod</h3><p>从设计上来说，Provider是对<code>InheritedWidget</code>的改进，因此它依赖于小部件树。<br>这是一个不幸的设计决策，可能会导致常见的<code>ProviderNotFoundException</code>：<br><img src="/image/riverpod/provider_demo.png" alt="provider_demo"><br>另一方面，Riverpod是编译时安全的，因为所有的 provider 都被声明为全局的，可以在任何地方访问，这也意味着这些 provider 可以不依赖于widget tree 来存储应用状态和业务逻辑。由于 Riverpod 是一个反应式框架，因此只需在需要时重建providers和widgets即可。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>3.0 已经有 preview 版本了，但还没有出正式版，这里使用稍微旧一点的版本</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter_riverpod:</span> <span class="hljs-string">^2.4.10</span><br></code></pre></td></tr></table></figure><p>为了简单起见，这里没有使用<code>hooks_riverpod</code>,至于使用注解来生成 provier，会在后续介绍。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先我们需要改造一下程序入口，提供一个<code>ProviderScope</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(<br>    ProviderScope(<br>      child: MyApp(),<br>    ),<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>接着声明一个全局的<code>Provider</code>，和这个 main 方法平级就可以</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> authorNameProvider = Provider&lt;<span class="hljs-built_in">String</span>&gt;(<br>  (ref) =&gt; <span class="hljs-string">&quot;xuan&quot;</span>,<br>);<br></code></pre></td></tr></table></figure><p>然后改造一下<code>MyApp</code>,让它可以读取到数据。改造前是继承<code>StatelessWidget</code>,这里需要改成继承自<code>ConsumerWidget</code>.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> value = ref.watch(helloWorldProvider);<br><br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: Scaffold(<br>        appBar: AppBar(title:  Text(<span class="hljs-string">&#x27;ProviderWidget&#x27;</span>)),<br>        body: Center(<br>          child: Text(value),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，继承<code>ConsumerWidget</code>之后，<code>build</code>方法的签名变了，多了一个<code>WidgetRef</code>对象，我们就是使用这个对象来读取、观察、监听各种 provider。</p><p>除了继承<code>ConsumerWidget</code>之外，还有其他方案可供使用</p><h4 id="使用-Consumer"><a href="#使用-Consumer" class="headerlink" title="使用 Consumer"></a>使用 Consumer</h4><p>在旧代码中新增使用 riverpod，但又不打算大面积重构时，可以考虑这种方案:使用<code>Consumer</code>包裹需要更新的控件。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_widget/third_part/riverpod/riverpod_widget.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:widget_with_codeview/widget_with_codeview.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderWithConsumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;ProviderWithConsumer&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: WidgetWithCodeView(<br>        child: Column(children: [<br>          Text(<br>            <span class="hljs-string">&quot;有一个包含复杂布局的大型小部件类，您可以使用 Consumer 来仅重新构建依赖于提供者的小部件\n创建小而可重用的小部件有利于组合，使代码更加简洁、性能更高，更易于理解。\n如果您遵循这一原则并创建小而可重用的小部件，那么大部分时间您将自然而然地使用 ConsumerWidget。&quot;</span>,<br>            style: TextStyle(color: Colors.blue, fontSize: <span class="hljs-number">16</span>),<br>          ),<br>          Consumer(builder: (_, ref, __) &#123;<br>            <span class="hljs-keyword">return</span> Text(ref.read(helloWorldProvider));<br>          &#125;)<br>        ]),<br>        filePath: <span class="hljs-string">&quot;lib/third_part/riverpod/provider_with_consumer.dart&quot;</span>,<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中的<code>WidgetWithCodeView</code>是三方库<code>widget_with_codeview</code>用来展示代码的控件。去除后没有影响。</p><h4 id="使用ConsumerStatefulWidget"><a href="#使用ConsumerStatefulWidget" class="headerlink" title="使用ConsumerStatefulWidget"></a>使用ConsumerStatefulWidget</h4><p>相对于<code>ConsumerWidget</code>来代替<code>StatelessWidget</code>,<code>使用ConsumerStatefulWidget</code>是用来代替<code>StatefulWidget</code>.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_widget/third_part/riverpod/riverpod_widget.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:widget_with_codeview/widget_with_codeview.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderWithConsumerStatefulWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerStatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  ConsumerState&lt;ProviderWithConsumerStatefulWidget&gt; createState() &#123;<br>    <span class="hljs-keyword">return</span> ProviderWithConsumerStatefulWidgetState();<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderWithConsumerStatefulWidgetState</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerState</span>&lt;<span class="hljs-title">ProviderWithConsumerStatefulWidget</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// 3. if needed, we can read the provider inside initState</span><br>    <span class="hljs-keyword">final</span> helloWorld = ref.read(helloWorldProvider);<br>    <span class="hljs-built_in">print</span>(helloWorld); <span class="hljs-comment">// &quot;Hello world&quot;</span><br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 4. use ref.watch() to get the value of the provider</span><br>    <span class="hljs-keyword">final</span> helloWorld = ref.watch(helloWorldProvider);<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;ProviderWithConsumerStatefulWidget&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: WidgetWithCodeView(<br>        child: Column(<br>          children: [<br>            Text(<br>              <span class="hljs-string">&quot;ConsumerStatefulWidget可以用来代替StatefulWidget\n当我们从ConsumerState进行子类化时，我们可以在所有小部件生命周期方法中访问ref对象。这是因为ConsumerState声明WidgetRef作为属性，类似于Flutter的State类声明BuildContext作为可以在所有小部件生命周期方法中直接访问的属性。&quot;</span>,<br>              style: TextStyle(color: Colors.blue, fontSize: <span class="hljs-number">16</span>),<br>            ),<br>            Text(helloWorld),<br>          ],<br>        ),<br>        filePath:<br>            <span class="hljs-string">&quot;lib/third_part/riverpod/provider_with_consumerStatefulWidget.dart&quot;</span>,<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>同样的需要使用<code>ConsumerState</code>代替原来的<code>State</code>.需要注意的是,在这里面我们并没有看到<code>WidgetRef</code>,但我们依旧可以在整个页面声明周期内访问<code>WidgetRef</code>对象的实例<code>ref</code>,这是因为<code>ConsumerState</code>将<code>WidgetRef</code>声明为属性。</p><h3 id="WidgetRef是什么"><a href="#WidgetRef是什么" class="headerlink" title="WidgetRef是什么"></a>WidgetRef是什么</h3><p>官方文档定义<code>WidgetRef</code>为允许Widgets和Provider交互的对象。可以用来观察(watch)Provider 值的改变，也可以作为<code>Consumer</code>和<code>ConsumerWidget</code>的参数，同样也可以作为<code>ConsumerState</code>的属性。<br>将<code>WidgetRef</code>和<code>BuildContext</code>做一下比较：我们可以通过<code>BuildContext</code>在 Widget tree 中访问祖先节点，比如<code>Theme.of(context)</code> 和 <code>MediaQuery.of(context)</code><br>而<code>WidgetRef</code>可以让我们在 app 中访问任意provider，前提是provider被声明为全局的。这也是设计的初衷。<br>当然，将 provider 声明在类内部，只允许该类访问在编译、运行时也不会报错，但这会影响关注点分离的原则。</p><h3 id="八中不同的-Provider"><a href="#八中不同的-Provider" class="headerlink" title="八中不同的 Provider"></a>八中不同的 Provider</h3><ul><li>Provider</li><li><del>StateProvider</del> (被NotifierProvider代替)</li><li><del>StateNotifierProvider</del> (被NotifierProvider代替)</li><li>FutureProvider</li><li>StreamProvider</li><li><del>ChangeNotifierProvider</del> (被NotifierProvider代替)</li><li>NotifierProvider (Riverpod 2.0新增)</li><li>AsyncNotifierProvider (Riverpod 2.0新增)</li></ul><p>以后会提到使用<code>riverpod_generator</code>包中的<code>@riverpod</code>注解来代替我们的手动声明provider</p><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p>上面示例中的代码就是用的这一个，更适合提供一些不会变的常量值，比如 Dio 实例、版本号、格式化对象、数据库对象等</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> dateFormatterProvider = Provider&lt;DateFormat&gt;((ref) &#123;<br>  <span class="hljs-keyword">return</span> DateFormat.MMMEd();<br>&#125;);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-comment">// retrieve the formatter</span><br>    <span class="hljs-keyword">final</span> formatter = ref.watch(dateFormatterProvider);<br>    <span class="hljs-comment">// use it</span><br>    <span class="hljs-keyword">return</span> Text(formatter.format(<span class="hljs-built_in">DateTime</span>.now()));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="StateProvider"><a href="#StateProvider" class="headerlink" title="StateProvider"></a>StateProvider</h4><p>可以用来存储一些简单的变量，比如计数器</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><br><span class="hljs-keyword">final</span> globalStateProvider = StateProvider((ref) =&gt; <span class="hljs-number">1</span>);<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateProviderDemoWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-comment">//不推荐</span><br>  <span class="hljs-keyword">final</span> localStateProvider = StateProvider((ref) =&gt; <span class="hljs-number">1</span>);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;StateProviderDemoWidget&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Center(<br>          child: Flex(<br>        direction: Axis.vertical,<br>        children: [<br>          Text(<span class="hljs-string">&quot;globalStateProvider count <span class="hljs-subst">$&#123;ref.watch(globalStateProvider)&#125;</span>&quot;</span>),<br>          Text(<span class="hljs-string">&quot;localStateProvider count <span class="hljs-subst">$&#123;ref.watch(localStateProvider)&#125;</span>&quot;</span>),<br>          Text(<br>            <span class="hljs-string">&quot;StateProvider.state标记为过时，并将在3.0移除&quot;</span>,<br>            style: TextStyle(color: Colors.red, fontSize: <span class="hljs-number">14</span>),<br>          ),<br>          Text(<span class="hljs-string">&quot;声明为全局，则状态一直被保存，直到应用重启。&quot;</span>,<br>              style: TextStyle(color: Colors.blue, fontSize: <span class="hljs-number">14</span>)),<br>          Text(<span class="hljs-string">&quot;声明为类成员，则页面重启则重新初始化。&quot;</span>,<br>              style: TextStyle(color: Colors.blue, fontSize: <span class="hljs-number">14</span>)),<br>          Text(<span class="hljs-string">&quot;StateProvider适用于存储简单的状态变量，如枚举、字符串、布尔值和数字&quot;</span>,<br>              style: TextStyle(color: Colors.blue, fontSize: <span class="hljs-number">14</span>)),<br>          IconButton(<br>            icon: Icon(Icons.plus_one_sharp),<br>            onPressed: () &#123;<br>              ref.read(globalStateProvider.notifier).state++;<br>              ref.read(localStateProvider.notifier).state++;<br>            &#125;,<br>          ),<br>        ],<br>      )),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里有一些有意思的事情。我们声明了两个 Provider，一个是全局的，一个是类内部的。<br>当我们打开页面点击几次按钮之后，页面内容更新，这时候我们返回上一页再次打开这个页面，会发现<code>globalStateProvider</code>提供的值还是上一次返回时候的值，而<code>localStateProvider</code>提供的值是初始值。因为<code>localStateProvider</code>在页面关闭时就被销毁了，这种情况似乎更符合我们没有使用 riverpod 的习惯。这里可以使用 autoDispose 让<code>globalStateProvider</code>在所有 watcher 被销毁也可以重置。</p><h4 id="StateNotifierProvider"><a href="#StateNotifierProvider" class="headerlink" title="StateNotifierProvider"></a>StateNotifierProvider</h4><p>可以用它来监听和导出一个 <code>StateNotifier</code> ,<code>StateNotifierProvider</code> 和 <code>StateNotifier</code> 非常适合管理因事件或用户交互而改变的状态。这里有一个 <code>todolist</code>示例。<br>我们先定义一个 todo 的对象,实现一个 copyWith 方法来复制当前对象。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@immutable</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> Todo(<br>      &#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.description, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.completed&#125;);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> id;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> description;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> completed;<br>  Todo copyWith(&#123;<span class="hljs-built_in">String?</span> id, <span class="hljs-built_in">String?</span> description, <span class="hljs-built_in">bool?</span> completed&#125;) &#123;<br>    <span class="hljs-keyword">return</span> Todo(<br>      id: id ?? <span class="hljs-keyword">this</span>.id,<br>      description: description ?? <span class="hljs-keyword">this</span>.description,<br>      completed: completed ?? <span class="hljs-keyword">this</span>.completed,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们继承<code>StateNotifier</code>实现自己的<code>TodosNotifier</code>类，并完善所需逻辑</p><ol><li>统计已完成的待办</li><li>添加待办</li><li>删除待办</li><li>完成、取消完成待办</li><li>全选，反全选</li><li>是否选中全部</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodosNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StateNotifier</span>&lt;<span class="hljs-title">List</span>&lt;<span class="hljs-title">Todo</span>&gt;&gt; </span>&#123;<br>  TodosNotifier() : <span class="hljs-keyword">super</span>([]);<br><br>  <span class="hljs-keyword">void</span> addTodo(Todo todo) &#123;<br>    state = [...state, todo];<br>  &#125;<br><br>  <span class="hljs-built_in">int</span> completedCount() &#123;<br>    <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state) &#123;<br>      <span class="hljs-keyword">if</span> (todo.completed) &#123;<br>        count++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> removeTodo(<span class="hljs-built_in">String</span> todoId) &#123;<br>    state = [<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state)<br>        <span class="hljs-keyword">if</span> (todo.id != todoId) todo,<br>    ];<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> toggle(<span class="hljs-built_in">String</span> todoID) &#123;<br>    state = [<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state)<br>        <span class="hljs-keyword">if</span> (todo.id == todoID)<br>          todo.copyWith(completed: !todo.completed)<br>        <span class="hljs-keyword">else</span><br>          todo<br>    ];<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> selectAll() &#123;<br>    state = [<span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state) todo.copyWith(completed: <span class="hljs-keyword">true</span>)];<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> unSelectAll() &#123;<br>    state = [<span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state) todo.copyWith(completed: <span class="hljs-keyword">false</span>)];<br>  &#125;<br><br>  <span class="hljs-built_in">bool</span> isSelectAll() &#123;<br>    <span class="hljs-built_in">bool</span> result = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state) &#123;<br>      <span class="hljs-keyword">if</span> (!todo.completed) &#123;<br>        result = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着声明一个全局的<code>StateNotifierProvider</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> todoProvider =<br>    StateNotifierProvider&lt;TodosNotifier, <span class="hljs-built_in">List</span>&lt;Todo&gt;&gt;((ref) =&gt; TodosNotifier());<br></code></pre></td></tr></table></figure><p>最后我们就可以在页面中使用了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateNotifierProviderWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-built_in">List</span>&lt;Todo&gt; todos = ref.watch(todoProvider);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;State Notifier Provider Widget&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Column(<br>        children: [<br>          Text(<span class="hljs-string">&quot;StateNotifierProvider和StateNotifier非常适合管理可能会因事件或用户交互而发生变化的状态。&quot;</span>),<br>          Text(<span class="hljs-string">&quot;注意StateNotifier中通知更新时是比较的对象内存地址&quot;</span>),<br>          Divider(),<br>          Container(<br>            child: Text(<br>                <span class="hljs-string">&quot;共<span class="hljs-subst">$&#123;todos.length.toString()&#125;</span>,完成-》<span class="hljs-subst">$&#123;ref.read(todoProvider.notifier).completedCount()&#125;</span>&quot;</span>),<br>          ),<br>          CheckboxListTile(<br>            value: ref.read(todoProvider.notifier).isSelectAll(),<br>            onChanged: (value) &#123;<br>              <span class="hljs-keyword">if</span> (value ?? <span class="hljs-keyword">false</span>) &#123;<br>                ref.read(todoProvider.notifier).selectAll();<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                ref.read(todoProvider.notifier).unSelectAll();<br>              &#125;<br>            &#125;,<br>            title: Text(<span class="hljs-string">&quot;全选&quot;</span>),<br>          ),<br>          Expanded(<br>              child: ListView(<br>            shrinkWrap: <span class="hljs-keyword">true</span>,<br>            children: [<br>              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> todos)<br>                Dismissible(<br>                  key: Key(todo.id),<br>                  child: CheckboxListTile(<br>                    value: todo.completed,<br>                    onChanged: (value) =&gt;<br>                        ref.read(todoProvider.notifier).toggle(todo.id),<br>                    title: Text(todo.description),<br>                  ),<br>                  onDismissed: (direction) =&gt;<br>                      &#123;ref.read(todoProvider.notifier).removeTodo(todo.id)&#125;,<br>                ),<br>            ],<br>          )),<br>        ],<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add),<br>        onPressed: () &#123;<br>          <span class="hljs-keyword">final</span> notifier = ref.read(todoProvider.notifier);<br>          notifier.addTodo(Todo(<br>              id: <span class="hljs-built_in">DateTime</span>.now().microsecond.toString(),<br>              description: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;DateTime.now().microsecondsSinceEpoch&#125;</span>&quot;</span>,<br>              completed: <span class="hljs-keyword">false</span>));<br>        &#125;,<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这样我们就完成了一个简易版的待办页面</p><p><img src="/image/riverpod/state_notifier_demo.png" alt="state_notifier_demo"></p><h4 id="FutureProvider"><a href="#FutureProvider" class="headerlink" title="FutureProvider"></a>FutureProvider</h4><p>我们经常会遇到一些耗时操作，比如请求服务器接口获取到数据后展示在页面上；比如读取配置文件等。这种情况我们就需要 <code>FutureProvider</code>了。<br>这里以读取 assets 中的配置文件为例:<br>首先声明一个<code>FutureProvider</code>泛型中填入返回值，使用<code>rootBundle.loadString</code>来读取资源文件的内容。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> getConfigFutureProvider =<br>    FutureProvider&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&gt;((ref) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-built_in">String</span> configContant =<br>      <span class="hljs-keyword">await</span> rootBundle.loadString(<span class="hljs-string">&quot;assets/fake_configurations.json&quot;</span>);<br>  <span class="hljs-keyword">final</span> configMap = jsonDecode(configContant) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;;<br>  <span class="hljs-keyword">return</span> configMap;<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后再声明一个用来模拟请求服务端的<code>FutureProvider</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> wordPairProvider = FutureProvider&lt;<span class="hljs-built_in">String</span>&gt;((ref)  <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>  <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span> - <span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>注意这里的<code>generateWordPairs</code>是三方包<code>english_words: ^4.0.0</code>提供的。在<code>wordPairProvider</code>中我们延迟 2 秒返回了结果，用以模拟网络耗时。<br>在页面中我们可以这么使用:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureProviderWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> AsyncValue&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&gt; getConfigResult =<br>        ref.watch(getConfigFutureProvider);<br>    <span class="hljs-keyword">final</span> AsyncValue&lt;<span class="hljs-built_in">String</span>&gt; wordPairResult = ref.watch(wordPairProvider);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;FutureProvider&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: RefreshIndicator(<br>        onRefresh: () =&gt; ref.refresh(wordPairProvider.future),<br>        child: ListView(<br>          children: [<br>            getConfigResult.when(<br>                data: (data) &#123;<br>                  <span class="hljs-keyword">return</span> Text(data.toString());<br>                &#125;,<br>                error: (error, stack) &#123;<br>                  <span class="hljs-keyword">return</span> Text(error.toString());<br>                &#125;,<br>                loading: () =&gt; <span class="hljs-keyword">const</span> CircularProgressIndicator()),<br>            wordPairResult.when(data: (data) &#123;<br>              <span class="hljs-keyword">return</span> Text(data);<br>            &#125;, error: (error, stack) &#123;<br>              <span class="hljs-keyword">return</span> ElevatedButton(<br>                  onPressed: () &#123;<br>                    ref.refresh(wordPairProvider.future);<br>                  &#125;,<br>                  child: Text(<span class="hljs-string">&quot;点击刷新&quot;</span>));<br>            &#125;, loading: () &#123;<br>              <span class="hljs-keyword">return</span> CircularProgressIndicator();<br>            &#125;),<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意，<code>ref.watch(FutureProvider)</code>的返回值是AsyncValue类型，我们可以使用模式匹配的方式来更新UI。这里会有三个状态:data,loading,error。<br>我们在页面上添加了一个下拉刷新的控价来刷新模拟网络请求的 provider:<code>ref.refresh(wordPairProvider.future)</code>。</p><ul><li>FutureProvider功能非常强大，可以用它来</li><li>执行和缓存异步操作（如网络请求）</li><li>处理异步操作的错误和加载状态</li><li>将多个异步值合并为另一个值</li><li>重新获取和刷新数据（适用于拉到刷新操作）<br>如果退出页面需要重新进行刷新，我们可以配合autoDispose使用:<code>FutureProvider.autoDispose&lt;String&gt;((ref) async &#123;&#125;</code></li></ul><h4 id="StreamProvider"><a href="#StreamProvider" class="headerlink" title="StreamProvider"></a>StreamProvider</h4><p>这里例子不大好写，它和 FutureProvider 类似，被 watch 时返回的也是 AsyncValue 类型，这里是一个计时器的示例。<br>同样的，先声明一个<code>StreamProvider</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> streamProvider = StreamProvider.autoDispose&lt;<span class="hljs-built_in">int</span>&gt;((ref) &#123;<br>    ref.onDispose(() &#123;<br>      debugPrint(<span class="hljs-string">&quot;streamProvider autoDispose&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> Stream.periodic(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>), (number) &#123;<br>      <span class="hljs-keyword">return</span> number + <span class="hljs-number">1</span>;<br>    &#125;);<br>  &#125;);<br><br></code></pre></td></tr></table></figure><p>然后在页面中使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamProviderWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> AsyncValue&lt;<span class="hljs-built_in">int</span>&gt; streamResult = ref.watch(streamProvider);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;StreamProviderWidget&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Column(<br>        children: [<br>          Text(streamResult.toString()),<br>          streamResult.when(<br>                  data: (data) &#123;<br>                    <span class="hljs-keyword">return</span> Text(data.toString());<br>                  &#125;,<br>                  error: (error, stack) &#123;<br>                    <span class="hljs-keyword">return</span> Text(error.toString());<br>                  &#125;,<br>                  loading: () =&gt; CircularProgressIndicator())<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="ChangeNotifierProvider"><a href="#ChangeNotifierProvider" class="headerlink" title="ChangeNotifierProvider"></a>ChangeNotifierProvider</h4><p>建议使用 NotifierProvider 代替。<br>这里是一个计数器示例。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> _count = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> count =&gt; _count;<br>  <span class="hljs-keyword">void</span> increment() &#123;<br>    _count++;<br>    notifyListeners(); <span class="hljs-comment">// 当计数器值改变时通知所有监听者</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义ChangeNotifierProvider</span><br><span class="hljs-keyword">final</span> counterProvider = ChangeNotifierProvider&lt;CounterNotifier&gt;((ref) &#123;<br>  <span class="hljs-keyword">return</span> CounterNotifier();<br>&#125;);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeNotifierProviderWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">return</span>  Scaffold(<br>        appBar: AppBar(title: Text(<span class="hljs-string">&#x27;ChangeNotifierProviderWidget&#x27;</span>)),<br>        body: Center(<br>          child: Consumer(builder: (context, ref, _) &#123; <span class="hljs-comment">// 使用Consumer读取并显示状态</span><br>            <span class="hljs-keyword">final</span> counter = ref.watch(counterProvider);<br>            <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&#x27;Count: <span class="hljs-subst">$&#123;counter.count&#125;</span>&#x27;</span>);<br>          &#125;),<br>        ),<br>        floatingActionButton: FloatingActionButton(<br>          onPressed: () &#123;<br>            <span class="hljs-comment">// 在点击按钮时，通过ref调用notifier的方法更新状态</span><br>            ref.read(counterProvider.notifier).increment();<br>          &#125;,<br>          child: Icon(Icons.add),<br>        ),<br>      );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="NotifierProvider"><a href="#NotifierProvider" class="headerlink" title="NotifierProvider"></a>NotifierProvider</h4><p>用来代替 StateProvider 和 ChangeNotifierProvider。<br>同样的，我们先定义一个数据类 Student</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  Student(&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.name, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id&#125;);<br>  <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-built_in">String</span> id;<br><br>  Student copyWith(&#123;<span class="hljs-built_in">String?</span> copyID, <span class="hljs-built_in">String?</span> copyName&#125;) &#123;<br>    <span class="hljs-keyword">return</span> Student(name: copyName ?? <span class="hljs-keyword">this</span>.name, id: copyID ?? <span class="hljs-keyword">this</span>.id);<br>  &#125;<br>  <span class="hljs-built_in">String</span> toString()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$id</span> : <span class="hljs-subst">$name</span>&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个继承自 Notifier 的类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Notifier</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Student build() &#123;<br>    <span class="hljs-keyword">return</span> generateStudent();<br>  &#125;<br><br>  Student generateStudent() &#123;<br>    <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>    <span class="hljs-keyword">final</span> id = Random().nextInt(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">return</span> Student(<br>        name: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span> - <span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>, id: id.toString());<br>  &#125;<br><br>  <span class="hljs-built_in">String</span> toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;state.id&#125;</span> : <span class="hljs-subst">$&#123;state.name&#125;</span>&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> change() &#123;<br>    state = generateStudent();<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> changeNameWithCopy(<span class="hljs-built_in">String</span> name) &#123;<br>    state = state.copyWith(copyName: name);<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> justChangeName(<span class="hljs-built_in">String</span> name) &#123;<br>    state.name = name;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> changeIdWithCopy(<span class="hljs-built_in">String</span> id) &#123;<br>    state = state.copyWith(copyID: id);<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> justChangeId(<span class="hljs-built_in">String</span> id) &#123;<br>    state.id = id;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这里的 build 方法是必须的。同时为了解释刷新页面的条件，这里定义了几个改变属性的方法。xxxWithCopy是重新生成了对象，justxxx 则是在原对象上直接修改属性值。<br>然后声明<code>NotifierProvider</code>,这里提供了两种方式，哪一种都可以。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterProvider = NotifierProvider&lt;StudentNotifier, Student&gt;(() &#123;<br>  <span class="hljs-keyword">return</span> StudentNotifier();<br>&#125;);<br><span class="hljs-keyword">final</span> counterProviderOther =<br>    NotifierProvider&lt;StudentNotifier, Student&gt;(StudentNotifier.<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure><p>在页面中我们这样使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterNotifierWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> student = ref.watch(counterProvider);<br>    ref.listen(counterProvider, (oldValue, newValue) &#123;<br>      logger.d(<br>          <span class="hljs-string">&quot;oldValue--&gt; <span class="hljs-subst">$&#123;oldValue?.id.toString()&#125;</span> \n newValue--&gt; <span class="hljs-subst">$&#123;newValue.id&#125;</span>&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;CounterNotifierWidget&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Column(<br>        children: [<br>          Text(<span class="hljs-string">&quot;student <span class="hljs-subst">$&#123;student.id.toString()&#125;</span> : <span class="hljs-subst">$&#123;student.name&#125;</span>  --&gt; <span class="hljs-subst">$&#123;student.toString()&#125;</span>&quot;</span>),<br><br>          ElevatedButton(<br>              onPressed: () &#123;<br>                ref<br>                    .read(counterProvider.notifier)<br>                    .changeIdWithCopy(Random().nextInt(<span class="hljs-number">100</span>).toString());<br>              &#125;,<br>              child: Text(<span class="hljs-string">&quot;changeIdWithCopy&quot;</span>)),<br>          ElevatedButton(<br>              onPressed: () &#123;<br>                <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>                ref.read(counterProvider.notifier).changeNameWithCopy(<br>                    <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span> - -<span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>);<br>              &#125;,<br>              child: Text(<span class="hljs-string">&quot;changeNameWithCopy&quot;</span>)),<br><br>          ElevatedButton(<br>              onPressed: () &#123;<br>                ref<br>                    .read(counterProvider.notifier)<br>                    .justChangeId(Random().nextInt(<span class="hljs-number">100</span>).toString());<br>              &#125;,<br>              child: Text(<span class="hljs-string">&quot;justChangeId&quot;</span>)),<br>          ElevatedButton(<br>              onPressed: () &#123;<br>                <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>                ref<br>                    .read(counterProvider.notifier)<br>                    .justChangeName(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span> - -<span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>);<br>              &#125;,<br>              child: Text(<span class="hljs-string">&quot;justChangeName&quot;</span>)),<br>        ],<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () &#123;<br>          ref.read(counterProvider.notifier).change();<br>        &#125;,<br>        child: Icon(Icons.change_circle),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行之后可以看到，只有当我们调用<code>xxxwithCopy</code>时才会刷新页面。戳到<code>NotifierProviderElement</code>源码中查看<code>updateShouldNotify</code>方法，发现是调用的identical(previous, next)方法来做判断的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@protected</span><br><span class="hljs-built_in">bool</span> updateShouldNotify(State previous, State next) &#123;<br>  <span class="hljs-keyword">return</span> !identical(previous, next);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AsyncNotifierProvider"><a href="#AsyncNotifierProvider" class="headerlink" title="AsyncNotifierProvider"></a>AsyncNotifierProvider</h4><p>相比<code>NotifierProvider</code>,它是异步而已.<br>还是先声明一个数据类Student</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  Student(&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.name,<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id&#125;);<br>  <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-built_in">String</span> id;<br><br>  <span class="hljs-built_in">String</span> toString()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$id</span> - <span class="hljs-subst">$name</span>&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>声明一个继承自AsyncNotifier的类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentAsyncNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AsyncNotifier</span>&lt;<span class="hljs-title">Student</span>&gt;</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  FutureOr&lt;Student&gt; build() <span class="hljs-keyword">async</span> &#123;<br><br>      <span class="hljs-keyword">return</span> getInfo();<br>  &#125;<br><br> Future&lt;Student&gt; getInfo()<span class="hljs-keyword">async</span>&#123;<br>    <br>    <span class="hljs-keyword">await</span>  Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>    <span class="hljs-keyword">return</span> Student(name: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span> - <span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>, id: Random().nextInt(<span class="hljs-number">100</span>).toString());<br>    <br>  &#125; <br><br>  Future&lt;<span class="hljs-keyword">void</span>&gt; refresh() <span class="hljs-keyword">async</span>&#123;<br>      state = AsyncValue.loading();<br>      state = <span class="hljs-keyword">await</span> AsyncValue.guard(()<span class="hljs-keyword">async</span> &#123;<br>        <span class="hljs-keyword">return</span> getInfo();<br>      &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>声明一个 Provider</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> studentAsyncNotifier = AsyncNotifierProvider&lt;StudentAsyncNotifier, Student&gt;(() &#123;<br>  <span class="hljs-keyword">return</span> StudentAsyncNotifier();<br>&#125;);<br></code></pre></td></tr></table></figure><p>在页面中使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncNotifierProviderWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br><br>    <span class="hljs-keyword">final</span> asyncValue = ref.watch(studentAsyncNotifier);<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(title: Text(<span class="hljs-string">&quot;AsyncNotifierProviderWidget&quot;</span>),centerTitle: <span class="hljs-keyword">false</span>,),<br>      body: asyncValue.when(data: (data)&#123;<br>       <span class="hljs-keyword">return</span> Center(child: Text(data .toString()),);<br>      &#125;, error: (error,stack)&#123;<br>       <span class="hljs-keyword">return</span> Center(child: Text(error.toString()),);<br>      &#125;, loading: ()&#123;<br>        <span class="hljs-keyword">return</span> Center(child: CircularProgressIndicator());<br>      &#125;),<br>      floatingActionButton: FloatingActionButton(onPressed: ()&#123;<br>        ref.read(studentAsyncNotifier.notifier).refresh();<br>      &#125;,child: Icon(Icons.refresh),),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是：使用AsyncNotifier与autoDispose的正确方式是继承 AutoDisposeAsyncNotifier类而不是使用 autoDispose 修饰符。</p><p>以上就是 riverpod 中常见的 Provider 的用法示例，后面会介绍一些修饰符、注解相关的信息。</p><hr><p>以上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文来自：&lt;a href=&quot;https://codewithandrea.com/articles/flutter-state-management-riverpod/&quot;&gt;https://codewithandrea.com/articles/flutter-state-m</summary>
      
    
    
    
    
    <category term="Flutter" scheme="https://blog.huangyuanlove.com/tags/Flutter/"/>
    
    <category term="riverpod" scheme="https://blog.huangyuanlove.com/tags/riverpod/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙应用开发使用canvas实现球面运动动画</title>
    <link href="https://blog.huangyuanlove.com/2023/12/24/%E9%B8%BF%E8%92%99%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8canvas%E5%AE%9E%E7%8E%B0%E7%90%83%E9%9D%A2%E8%BF%90%E5%8A%A8%E5%8A%A8%E7%94%BB/"/>
    <id>https://blog.huangyuanlove.com/2023/12/24/%E9%B8%BF%E8%92%99%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8canvas%E5%AE%9E%E7%8E%B0%E7%90%83%E9%9D%A2%E8%BF%90%E5%8A%A8%E5%8A%A8%E7%94%BB/</id>
    <published>2023-12-24T03:38:04.000Z</published>
    <updated>2024-03-27T02:20:27.914Z</updated>
    
    <content type="html"><![CDATA[<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>习惯了 Android 的 Canvas,用鸿蒙的 canvas 多少有点别扭<br>效果图<br><img src="/image/HarmonyOS/canvas_ball_animation.gif" alt="canvas_ball_animation.gif"><br>上面的图是用 transform 属性做的动画<br>下面的图是用 canvas 画的，参考自<a href="https://mp.weixin.qq.com/s/p_gy8s1SqPUTAa3wCIk7FQ">https://mp.weixin.qq.com/s/p_gy8s1SqPUTAa3wCIk7FQ</a></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>众所周知，我们在手机或者平板上看到的 3D 动画只是在二维的投影，我们只需要计算好运动物体的大小和位置的对应关系，就可以实现类似 3D 的效果。想要了解具体的算法以及映射关系，可以阅读原文。<br>根据参考文章中的计算方式，我们只需要移植一下就行。这里是根据<code>总结</code>中的代码实现的<br>原文中的关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">double</span> <span class="hljs-variable">xr</span> <span class="hljs-operator">=</span> Math.toRadians(<span class="hljs-number">5</span>);  <span class="hljs-comment">//绕x轴旋转则把这个值设置为大于 0</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">yr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//绕y轴旋转则把这个值设置为大于 0;  </span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">zr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//绕z轴旋转则把这个值设置为大于 0;  </span><br><br><span class="hljs-comment">//保存小球的位置、颜色及缩放</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> color;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> x;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> y;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> z;   <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> <span class="hljs-variable">scale</span> <span class="hljs-operator">=</span> <span class="hljs-number">1f</span>;  <br>    &#125;<br><span class="hljs-comment">//pointList 保存的是随机生成的小球相关信息</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pointList.size(); i++) &#123;  <br>  <br>            <span class="hljs-type">Point</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> pointList.get(i);  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> point.x;  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> point.y;  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> point.z;  <br>  <br>            <span class="hljs-comment">//绕X轴旋转，乘以X轴的旋转矩阵  </span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">rx1</span> <span class="hljs-operator">=</span> x;  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">ry1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (y * Math.cos(xr) + z * -Math.sin(xr));  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">rz1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (y * Math.sin(xr) + z * Math.cos(xr));  <br>  <br>            <span class="hljs-comment">// 绕Y轴旋转,乘以Y轴的旋转矩阵  </span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">rx2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (rx1 * Math.cos(yr) + rz1 * Math.sin(yr));  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">ry2</span> <span class="hljs-operator">=</span> ry1;  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">rz2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (rx1 * -Math.sin(yr) + rz1 * Math.cos(yr));  <br>  <br>            <span class="hljs-comment">// 绕Z轴旋转,乘以Z轴的旋转矩阵  </span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">rx3</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (rx2 * Math.cos(zr) + ry2 * -Math.sin(zr));  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">ry3</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (rx2 * Math.sin(zr) + ry2 * Math.cos(zr));  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">rz3</span> <span class="hljs-operator">=</span> rz2;  <br>  <br>  <br>            point.x = rx3;  <br>            point.y = ry3;  <br>            point.z = rz3;  <br>  <br>            <span class="hljs-comment">// 透视除法，z轴向内的方向  </span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">scale</span> <span class="hljs-operator">=</span> (<span class="hljs-number">2</span> * radius) / ((<span class="hljs-number">2</span> * radius) + rz3);  <br>            point.scale = scale;  <br>        <span class="hljs-comment">//到这里就完成了小球位置的计算，接下来就是需要定时更新上面xr、yr、zr的值就可以实现小球沿球面运动了</span><br>  <br>        &#125;<br><br></code></pre></td></tr></table></figure><h3 id="鸿蒙-transform-实现"><a href="#鸿蒙-transform-实现" class="headerlink" title="鸿蒙 transform 实现"></a>鸿蒙 transform 实现</h3><p>清楚了原理及计算方式，实现起来就简单了<br>先 stack 堆叠两个圆球，小球需要不断运动，x、y、z需要一直变化，使用<code>@State</code>修饰一下。值的变化过程就用上面原文中的计算方法。定时更新就用<code>setInterval</code>,组件的位移变化给我们提供了<code>transform</code>方法，需要一个<code>matrix4</code>对象，移动变化也不需要我们去填充矩阵，有对应的<code>translate</code>方法，组合起来代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> matrix4 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos.matrix4&#x27;</span><br><br><span class="hljs-meta">@Preview</span><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">AnimationOfSphericalPaths</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">angleX</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">translateX</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">translateY</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">translateZ</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">ballRadius</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">30</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">timerInterval</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> radius = <span class="hljs-number">200</span><br>  <span class="hljs-keyword">private</span> a = <span class="hljs-number">90</span><br>  <span class="hljs-keyword">private</span> b = <span class="hljs-number">0</span><br><br><br>  <span class="hljs-title function_">toRadians</span>(degrees): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> degrees * (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">changeAngle</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> += <span class="hljs-number">3</span><br>    <span class="hljs-comment">// this.a += 3</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> &gt; <span class="hljs-number">360</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> - <span class="hljs-number">360</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> &gt; <span class="hljs-number">360</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> - <span class="hljs-number">360</span><br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateX</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>)) * <span class="hljs-number">2</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateY</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>)) * <span class="hljs-number">2</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateZ</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>)) * <span class="hljs-number">2</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ballRadius</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateZ</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">10</span> + <span class="hljs-number">50</span><br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`translateX-&gt; <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.translateX&#125;</span> ,translateY-&gt; <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.translateY&#125;</span> ,translateZ-&gt; <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.translateZ&#125;</span>`</span>)<br><br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Stack</span>() &#123;<br>        <span class="hljs-title class_">Circle</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span>, <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span> &#125;).<span class="hljs-title function_">fill</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Yellow</span>)<br>        <span class="hljs-title class_">Circle</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">ballRadius</span>, <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">ballRadius</span> &#125;).<span class="hljs-title function_">fill</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Pink</span>)<br>          .<span class="hljs-title function_">transform</span>(matrix4.<span class="hljs-title function_">identity</span>().<span class="hljs-title function_">translate</span>(&#123; <span class="hljs-attr">x</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateX</span>, <span class="hljs-attr">y</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateY</span>, <span class="hljs-attr">z</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateZ</span> &#125;))<br>      &#125;.<span class="hljs-title function_">alignContent</span>(<span class="hljs-title class_">Alignment</span>.<span class="hljs-property">Center</span>).<span class="hljs-title function_">width</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span>).<span class="hljs-title function_">height</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span>)<br><br>      <span class="hljs-title class_">Row</span>() &#123;<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;start&quot;</span>)<br>          .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerInterval</span> &gt; <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">return</span><br>            &#125;<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerInterval</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">changeAngle</span>()<br><br>            &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">20</span>)<br>          &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;stop&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerInterval</span>)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerInterval</span> = <span class="hljs-number">0</span><br>        &#125;).<span class="hljs-title function_">margin</span>(&#123; <span class="hljs-attr">left</span>: <span class="hljs-number">48</span> &#125;)<br>      &#125;.<span class="hljs-title function_">margin</span>(&#123; <span class="hljs-attr">top</span>: <span class="hljs-number">48</span> &#125;)<br><br>    &#125;.<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">White</span>)<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="鸿蒙canvas实现"><a href="#鸿蒙canvas实现" class="headerlink" title="鸿蒙canvas实现"></a>鸿蒙canvas实现</h3><p>需要注意的是，鸿蒙里面的 math 包下没有<code>toRadians</code>方法，需要我们自己实现一下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">toRadians</span>(degrees): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> degrees * (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>定时更新这里用了<code>setInterval</code><br>鸿蒙的 canvas 中也没有画笔的概念，需要设置<code>RenderingContextSettings</code>实例的填充方式及填充颜色<br>鸿蒙的 canvas 中也没有 drawcircle 方法，这里使用的是<code>Path2D</code>对象中画圆弧方法(arc)然后填充颜色的方式，需要注意是<code>Path2D.arc()</code>中的角度单位  </p><p>整体流程如下</p><ol><li>先生成随机的小球，分布在一个圆上generateBall()</li><li>计算小球的缩放比例及位置calculateRotateValue()</li><li>对小球排序，z 轴越大，越靠近我们，小球越大，越要遮盖住其他小球，越要最后画</li><li>所以先画背面的，再画正面的。这里的正面和背面是相对于中间的大球来说的，为了透视效果，背面的小球加上透明度，正面的小球不透明</li><li>定时更新就可以了</li></ol><p>下面是全部代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Preview</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">CanvasBallAnimation</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br>  <span class="hljs-keyword">private</span> canvasWidth = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> canvasHeight = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">canvasBallRoundRadius</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasBallAnimationTimer</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">startDegree</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">xr</span>: <span class="hljs-built_in">number</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">startDegree</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">yr</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">zr</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">pointList</span>: <span class="hljs-title class_">Point</span>[] = []<br><br>  <span class="hljs-title function_">toRadians</span>(degrees): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> degrees * (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">canvasBallAnimation</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startDegree</span> += <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">startDegree</span> &gt; <span class="hljs-number">360</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">startDegree</span> -= <span class="hljs-number">360</span><br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateRotateValue</span>()<br>    <span class="hljs-comment">//排序，先画背面的，再画正面的</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">comparator</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawFrontBall</span>()<br><br>    <span class="hljs-comment">//在中间画一个大圆</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawCenterBall</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawBackBall</span>()<br><br><br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br><br><br>      <span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>)<br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>)<br>        .<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;40%&quot;</span>)<br>        .<span class="hljs-title function_">onAreaChange</span>(<span class="hljs-function">(<span class="hljs-params">oldValue: Area, newValue: Area</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">width</span>.<span class="hljs-title function_">toString</span>())<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">height</span>.<span class="hljs-title function_">toString</span>())<br><br>          <span class="hljs-comment">//小球运动的半径</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>) / <span class="hljs-number">3</span><br>          <span class="hljs-comment">// this.canvasRendering.translate(this.canvasWidth / 2, this.canvasHeight / 2)</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateBall</span>()<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateRotateValue</span>()<br>          <span class="hljs-comment">//排序，先画背面的，再画正面的</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">comparator</span>)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawFrontBall</span>()<br><br>          <span class="hljs-comment">//在中间画一个大圆</span><br>         <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawCenterBall</span>()<br><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawBackBall</span>()<br><br><br>        &#125;)<br>      <span class="hljs-title class_">Row</span>() &#123;<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;canvas ball start&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallAnimationTimer</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span><br>          &#125;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallAnimationTimer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">canvasBallAnimation</span>()<br>          &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">20</span>)<br>        &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;canvas ball end&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallAnimationTimer</span>)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallAnimationTimer</span> = <span class="hljs-number">0</span><br>        &#125;)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">comparator</span>(<span class="hljs-attr">left</span>: <span class="hljs-title class_">Point</span>, <span class="hljs-attr">right</span>: <span class="hljs-title class_">Point</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">if</span> (left.<span class="hljs-property">z</span> - right.<span class="hljs-property">z</span> &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left.<span class="hljs-property">z</span> == right.<span class="hljs-property">z</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>  &#125;<br><br>  <span class="hljs-title function_">randomColor</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">r</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">256</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">g</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">256</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">256</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">`<span class="hljs-subst">$&#123;r&#125;</span><span class="hljs-subst">$&#123;g&#125;</span><span class="hljs-subst">$&#123;b&#125;</span>`</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`随机颜色--&gt; <span class="hljs-subst">$&#123;result&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br><br>  <span class="hljs-title function_">generateBall</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">let</span> maxBallCount = <span class="hljs-number">10</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span> = []<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maxBallCount; i++) &#123;<br><br>        <span class="hljs-keyword">let</span> v = -<span class="hljs-number">1.0</span> + (<span class="hljs-number">2.0</span> * i - <span class="hljs-number">1.0</span>) / maxBallCount;<br>        <span class="hljs-keyword">if</span> (v &lt; -<span class="hljs-number">1.0</span>) &#123;<br>          v = <span class="hljs-number">1.0</span><br>        &#125;<br><br>        <span class="hljs-keyword">let</span> delta = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">acos</span>(v)<br>        <span class="hljs-keyword">let</span> alpha = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(maxBallCount * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * delta<br>        <span class="hljs-keyword">let</span> point = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>()<br>        point.<span class="hljs-property">x</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(alpha) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(delta)<br>        point.<span class="hljs-property">y</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(alpha) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(delta)<br>        point.<span class="hljs-property">z</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(delta)<br>        point.<span class="hljs-property">color</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">randomColor</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-title function_">push</span>(point)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">calculateRotateValue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-property">length</span>; i++) &#123;<br><br>      <span class="hljs-keyword">let</span> point = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>[i];<br>      <span class="hljs-keyword">let</span> x = point.<span class="hljs-property">x</span>;<br>      <span class="hljs-keyword">let</span> y = point.<span class="hljs-property">y</span>;<br>      <span class="hljs-keyword">let</span> z = point.<span class="hljs-property">z</span>;<br><br>      <span class="hljs-comment">//绕X轴旋转，乘以X轴的旋转矩阵</span><br>      <span class="hljs-keyword">let</span> rx1 = x;<br>      <span class="hljs-keyword">let</span> ry1 = (y * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xr</span>) + z * -<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xr</span>));<br>      <span class="hljs-keyword">let</span> rz1 = (y * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xr</span>) + z * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xr</span>));<br><br>      <span class="hljs-comment">// 绕Y轴旋转,乘以Y轴的旋转矩阵</span><br>      <span class="hljs-keyword">let</span> rx2 = (rx1 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yr</span>) + rz1 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yr</span>));<br>      <span class="hljs-keyword">let</span> ry2 = ry1;<br>      <span class="hljs-keyword">let</span> rz2 = (rx1 * -<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yr</span>) + rz1 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yr</span>));<br><br>      <span class="hljs-comment">// 绕Z轴旋转,乘以Z轴的旋转矩阵</span><br>      <span class="hljs-keyword">let</span> rx3 = (rx2 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zr</span>) + ry2 * -<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zr</span>));<br>      <span class="hljs-keyword">let</span> ry3 = (rx2 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zr</span>) + ry2 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zr</span>));<br>      <span class="hljs-keyword">let</span> rz3 = rz2;<br><br><br>      point.<span class="hljs-property">x</span> = rx3;<br>      point.<span class="hljs-property">y</span> = ry3;<br>      point.<span class="hljs-property">z</span> = rz3;<br><br>      <span class="hljs-comment">// 透视除法，z轴向内的方向</span><br>      <span class="hljs-keyword">let</span> scale = (<span class="hljs-number">2</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span>) / ((<span class="hljs-number">2</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span>) + rz3);<br>      point.<span class="hljs-property">scale</span> = scale;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">drawFrontBall</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> point = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>[i];<br>      <span class="hljs-keyword">if</span> (point.<span class="hljs-property">z</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawBall</span>(point)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">drawBall</span>(<span class="hljs-params">point: Point</span>) &#123;<br>    <span class="hljs-keyword">if</span> (point.<span class="hljs-property">scale</span> &gt; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">`#FF<span class="hljs-subst">$&#123;point.color&#125;</span>`</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">let</span> fillColor = <span class="hljs-string">`#<span class="hljs-subst">$&#123; <span class="hljs-built_in">Math</span>.round(point.scale * <span class="hljs-number">255</span>).toString(<span class="hljs-number">16</span>)&#125;</span><span class="hljs-subst">$&#123;point.color&#125;</span>`</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = fillColor<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;填充颜色--&gt;&quot;</span> +fillColor)<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> ballPath2D = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>    ballPath2D.<span class="hljs-title function_">arc</span>(point.<span class="hljs-property">x</span> * point.<span class="hljs-property">scale</span> +<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> / <span class="hljs-number">2</span> , point.<span class="hljs-property">y</span> * point.<span class="hljs-property">scale</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> / <span class="hljs-number">2</span>, <span class="hljs-number">5</span> + <span class="hljs-number">25</span> * point.<span class="hljs-property">scale</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">beginPath</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>(ballPath2D)<br>  &#125;<br><br>  <span class="hljs-title function_">drawBackBall</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">let</span> point = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>[i];<br>      <span class="hljs-keyword">if</span> (point.<span class="hljs-property">z</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawBall</span>(point)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">drawCenterBall</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> circlePath2D = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>    circlePath2D.<span class="hljs-title function_">arc</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>/<span class="hljs-number">2</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>/<span class="hljs-number">2</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span>,<span class="hljs-number">0</span>,<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">beginPath</span>()<br><br>    <span class="hljs-keyword">let</span> radialGradient = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">createRadialGradient</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>/<span class="hljs-number">2</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>/<span class="hljs-number">2</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>/<span class="hljs-number">2</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span>)<br>    radialGradient.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">0.0</span>,<span class="hljs-string">&quot;#ff0000&quot;</span>)<br>    radialGradient.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">0.3</span>,<span class="hljs-string">&quot;#aaec5533&quot;</span>)<br>    radialGradient.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">0.9</span>,<span class="hljs-string">&quot;#11000000&quot;</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span>=radialGradient<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>(circlePath2D)<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">z</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">scale</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h3&gt;&lt;p&gt;习惯了 Android 的 Canvas,用鸿蒙的 canvas 多少有点别扭&lt;br&gt;效果图&lt;br&gt;&lt;img src=&quot;/image/Har</summary>
      
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙应用开发踩坑记录</title>
    <link href="https://blog.huangyuanlove.com/2023/11/29/%E9%B8%BF%E8%92%99%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://blog.huangyuanlove.com/2023/11/29/%E9%B8%BF%E8%92%99%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2023-11-29T06:50:40.000Z</published>
    <updated>2023-12-22T06:53:20.156Z</updated>
    
    <content type="html"><![CDATA[<p>使用HarmonyOS4+ArkUI+Stage模型进行开发的翻译软件，目前只是半成品，代码写的很挫。记录一下开发过程中踩过的坑。<br>项目地址：<br>码云<br><a href="https://gitee.com/huangyuan/HarmonyTranslator">https://gitee.com/huangyuan/HarmonyTranslator</a><br>github<br><a href="https://github.com/huangyuanlove/HarmonyTranslator">https://github.com/huangyuanlove/HarmonyTranslator</a><br>码云项目是从github导入的，偶尔会忘记同步</p><h4 id="冻屏、黑屏、假死"><a href="#冻屏、黑屏、假死" class="headerlink" title="冻屏、黑屏、假死"></a>冻屏、黑屏、假死</h4><p>运行环境是MetaPadPro 2019 鸿蒙4.0.0，使用api9+stage模型开发，运行在模拟器上正常，但是运行在该设备上出现冻屏现象，页面轮播图无法轮播，滑动组件无法发滑动，就像卡在了这一帧上一样。点击输入框键盘能弹出，但页面是黑的。可以通过锁屏、解锁或者音量键刷新页面。</p><p>感觉上就是屏幕不会主动刷新，需要按物理键让屏幕刷新一次似的。  </p><p>询问过朋友后发现，这个现象只会出现在麒麟系列芯片的手机或平板上，看到论坛也有人咨询相同的问题。向官方提工单后官方回复是已知问题，将会在HarmonyOS next系统中修复  </p><p>如果只是自己写着玩，可以安装 <a href="https://github.com/Genymobile/scrcpy">scrcpy</a> 将屏幕内容同步到电脑上，在电脑上操作是没有问题的。  </p><p>如果是公司用，建议咨询鸿蒙运营，成为合作伙伴，直接上HarmonyOS Next进行开发。或者降低api版本。</p><h4 id="PersistentStorage和-StorageLink"><a href="#PersistentStorage和-StorageLink" class="headerlink" title="PersistentStorage和@StorageLink"></a>PersistentStorage和@StorageLink</h4><p>项目中有些设置需要持久化存储，于是选择了PersistentStorage和@StorageLink方式进行存储，大致如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  &#125;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-title class_">PersistentStorage</span>.<span class="hljs-property">PersistProp</span>&lt;<span class="hljs-title class_">User</span>&gt;(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;xuan&#x27;</span>,<span class="hljs-number">18</span>))<br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">Tmp</span> &#123;<br>  <span class="hljs-meta">@StorageLink</span>(<span class="hljs-string">&#x27;user&#x27;</span>) <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;xuan&#x27;</span>, <span class="hljs-number">18</span>)<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.user.name&#125;</span> : <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.user.age&#125;</span>`</span>)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当我第一运行的时候，页面显示正常，Text显示的内容是<code>xuan : 18</code><br/><br>但是当我重新打开应用(不是重新编译，就是简单的在设备上关掉应用然后点击桌面图标打开应用)的时候，Text显示内容是 <code>undefined : undefined</code><br/><br>打上断点发现重新打开应用的时候 <code>user</code> 是一个字符串类型，值为 {‘name’:’xuan’,’age’:18}，但字符串对象没有name和age属性，所以显示了 undefined.<br/><br>看到文档中有写 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/arkts-state-management-0000001504151156-V3#ZH-CN_TOPIC_0000001523808562__persistprop">https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/arkts-state-management-0000001504151156-V3#ZH-CN_TOPIC_0000001523808562__persistprop</a></p><blockquote><p>AppStorage的属性向PersistentStorage中持久化的允许的类型是：<br/><br>number，string，boolean，enum基础类型。<br/><br>Object中可序列化的属性。<br/><br>不允许undefined和null。</p></blockquote><p>但同样的，在指南中同样有PersistentStorage描述 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-persiststorage-0000001474017166-V3#section610120319595">https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-persiststorage-0000001474017166-V3#section610120319595</a></p><blockquote><p>PersistentStorage允许的类型和值有：<br/><br>number, string, boolean, enum 等简单类型。<br/><br>可以被JSON.stringify()和JSON.parse()重构的对象。例如Date, Map, Set等内置类型则不支持，以及对象的属性方法不支持持久化。<br/></p></blockquote><p>看到论坛有同样的求助，有开发者回复说他是将对象转成字符串保存的，使用的时候再parse一下。</p><h4 id="剪贴板-pasteboard-getSystemPasteboard"><a href="#剪贴板-pasteboard-getSystemPasteboard" class="headerlink" title="剪贴板 pasteboard.getSystemPasteboard()"></a>剪贴板 pasteboard.getSystemPasteboard()</h4><p>在使用剪贴板时需要先创建剪贴板数据，<br>创建方法如下 </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">createData</span>(<span class="hljs-attr">mimeType</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">ValueType</span>): <span class="hljs-title class_">PasteData</span>  <br><span class="hljs-title function_">createRecord</span>(<span class="hljs-attr">mimeType</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">ValueType</span>):<span class="hljs-title class_">PasteDataRecord</span><br></code></pre></td></tr></table></figure><p>第一个参数含义为：自定义数据的MIME类型。 文档中 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-pasteboard-0000001544384177-V3#ZH-CN_TOPIC_0000001523648478__pasteboardcreatedata9">鸿蒙开发api参考</a><br>中写的示例</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> pasteboard <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos.pasteboard&#x27;</span>;<br><span class="hljs-keyword">let</span> dataXml = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br><span class="hljs-keyword">let</span> pasteDataRecord = pasteboard.<span class="hljs-title function_">createRecord</span>(<span class="hljs-string">&#x27;app/xml&#x27;</span>, dataXml);<br></code></pre></td></tr></table></figure><p>实际中发现时不能使用这自定义的<code>app/xml</code>值，会崩溃，只能使用pasteboard中预定义的MIME类型</p><h4 id="对象属性从有值变为空，应用会崩溃"><a href="#对象属性从有值变为空，应用会崩溃" class="headerlink" title="对象属性从有值变为空，应用会崩溃"></a>对象属性从有值变为空，应用会崩溃</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">PlayGround</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">people</span>:<span class="hljs-title class_">People</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">log</span>(<span class="hljs-attr">log</span>:<span class="hljs-built_in">string</span>):<span class="hljs-built_in">boolean</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`---------<span class="hljs-subst">$&#123;log&#125;</span>---------`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">people</span>)&#123;<br>        <span class="hljs-title class_">Text</span>(<span class="hljs-string">`姓名： <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.people.name&#125;</span>  年龄：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.people.age&#125;</span>`</span>)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">people</span>.<span class="hljs-property">address</span>)&#123;<br>          <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;address 有值&#x27;</span>))&#123;<br>            <span class="hljs-title class_">Text</span>( <span class="hljs-string">`地址： <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.people.address.name&#125;</span>  邮编：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.people.address.zipCode&#125;</span>`</span>)<br>          &#125;<br>          <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;address 为空 内部&#x27;</span>)<br>          &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;address 为空 最外层&#x27;</span>))&#123;<br>            <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;address 为空 最外层&#x27;</span>)<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;网络请求返回一个有地址的对象&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> tmpPeople = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>        <span class="hljs-keyword">let</span> tmpAddress = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>()<br>        tmpAddress.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;测试地址&#x27;</span><br>        tmpAddress.<span class="hljs-property">zipCode</span> = -<span class="hljs-number">1000</span><br>        tmpPeople.<span class="hljs-property">address</span> = tmpAddress<br><br>        tmpPeople.<span class="hljs-property">age</span> = <span class="hljs-number">10</span><br>        tmpPeople.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;有地址&#x27;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">people</span> = tmpPeople<br>      &#125;)<br><br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;网络请求返回一个没有地址的对象&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> tmpPeople = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>        tmpPeople.<span class="hljs-property">age</span> = <span class="hljs-number">10</span><br>        tmpPeople.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;没有地址&#x27;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">people</span> = tmpPeople<br>      &#125;)<br>    &#125;.<span class="hljs-title function_">margin</span>(&#123;<span class="hljs-attr">top</span>:<span class="hljs-number">48</span>&#125;)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Address</span>&#123;<br>  <span class="hljs-attr">zipCode</span>:<span class="hljs-built_in">number</span><br>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">People</span>&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span><br>  <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span><br>  address :<span class="hljs-title class_">Address</span><br>&#125;<br></code></pre></td></tr></table></figure><p>很简单的页面，展示对象属性，<br>刚开始运行，一切正常。点击返回有地址的对象，页面正常刷新并且展示。然后点击返回没有地址的对象，这时候会崩溃。<br>日志指向了 Text( <code>地址： $&#123;this.people.address.name&#125;  邮编：$&#123;this.people.address.zipCode&#125;</code>)<br>说是<code>不能从undefined对象中读取name属性</code> 具体可以看这里：<a href="https://developer.huawei.com/consumer/cn/forum/topic/0204136377582311317?fid=0102683795438680754">开发这论坛</a><br>规避方案：我有一个朋友，尝试出了使用 <code>?.</code>来规避的方法。 取对象属性除了要用if判断来控制渲染之外，需要用 <code>?.</code>来取值，防崩溃，将上面的代码修改为<br>Text( <code>地址： $&#123;this.people.address?.name&#125;  邮编：$&#123;this.people.address?.zipCode&#125;</code>)<br>应用不会崩溃，这个对象也不会渲染在页面上<br/><br>但根据文档描述，既然if条件不成立，下面的Text组件就不应该被渲染，也不应该读取address的name属性。同样提工单，回复说是双框架问题，将在HarmonyOS Next版本解决</p><p>需要注意的是，文档上写的被状态管理装饰器修饰的变量，基本上都不支持any、undefined、null值，但实际写代码的过程中是没有校验的，目前来看即使是这些类型或者值，也是没什么大问题的，但还是建议大家按文档写，有问题咨询相关技术人员或者论坛、提工单。</p><hr><p>以上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用HarmonyOS4+ArkUI+Stage模型进行开发的翻译软件，目前只是半成品，代码写的很挫。记录一下开发过程中踩过的坑。&lt;br&gt;项目地址：&lt;br&gt;码云&lt;br&gt;&lt;a href=&quot;https://gitee.com/huangyuan/HarmonyTranslato</summary>
      
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>Java使用Protocol Buffer与服务端交互</title>
    <link href="https://blog.huangyuanlove.com/2023/05/09/Java%E4%BD%BF%E7%94%A8Protocol-Buffer%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92/"/>
    <id>https://blog.huangyuanlove.com/2023/05/09/Java%E4%BD%BF%E7%94%A8Protocol-Buffer%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92/</id>
    <published>2023-05-09T06:14:26.000Z</published>
    <updated>2023-05-19T12:51:02.220Z</updated>
    
    <content type="html"><![CDATA[<p>最近和三方对接时，对方给出的接口文档是使用protol buffer进行交互的，并非是我们常见的json、xml这种格式，了解了一下这种格式或者说交协议的特点。<br>首先，Protocol Buffer序列化之后是二进制流，不进行反序列化基本不可读。<br>其次，序列化之后的体积很小，适合网络传输或者设备之间传输<br>最后，可以跨平台、跨语言使用<br>不过这些特点既是优点也是缺点：序列化之后的数据不可读，还原序列化之后的数据需要事先定义好的数据格式</p><span id="more"></span><h4 id="安装Protocol-Buffer的编译器"><a href="#安装Protocol-Buffer的编译器" class="headerlink" title="安装Protocol Buffer的编译器"></a>安装Protocol Buffer的编译器</h4><p>我们需要使用相应的编译器将<code>.proto</code>文件转化为对应的编程语言的代码。<br>编译器可以在这里下载<a href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a><br>这里我下载的版本是22.3。下载完成后解压、添加环境变量，命令行执行 <code>protoc --version</code>能够输出版本号就可以了</p><h4 id="编写-proto文件"><a href="#编写-proto文件" class="headerlink" title="编写 .proto文件"></a>编写 .proto文件</h4><p>文件内容及格式可以参考这里<a href="https://protobuf.dev/">https://protobuf.dev/</a><br>下面是一个示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs protocol">syntax = &quot;proto2&quot;;<br><br>package tutorial;<br><br>option java_multiple_files = true;<br>option java_package = &quot;com.example.tutorial.protos&quot;;<br>option java_outer_classname = &quot;AddressBookProtos&quot;;<br><br>message Person &#123;<br>  optional string name = 1;<br>  optional int32 id = 2;<br>  optional string email = 3;<br><br>  enum PhoneType &#123;<br>    MOBILE = 0;<br>    HOME = 1;<br>    WORK = 2;<br>  &#125;<br><br>  message PhoneNumber &#123;<br>    optional string number = 1;<br>    optional PhoneType type = 2 [default = HOME];<br>  &#125;<br><br>  repeated PhoneNumber phones = 4;<br>&#125;<br><br>message AddressBook &#123;<br>  repeated Person people = 1;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后我们需要使用上面安装好的编译工具将文件编译转化为对应编程语言的文件，这里使用的是java</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>protocol --java_out=src/main/java src/main/protobuf/AddressBookProtos.proto<br><br></code></pre></td></tr></table></figure><p><code>src/main/java</code>是输出文件的位置，<code>src/main/protobuf/tgssp.proto</code>是数据格式文件的位置</p><p>没有报错的话，我们就可以在输出文件的位置看到生成的java文件了</p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>想要使用该文件，我们需要在工程中引入相应的依赖库，这里还是用java举例</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;com.google.protobuf&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;protobuf-java&#x27;</span>, <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.22.3&#x27;</span><br></code></pre></td></tr></table></figure><p>因为上面的<code>.proto</code>文件中定义的<code>java_multiple_files</code>为true，所以这里是分开生成的文件。<br>然后我们就可以使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> Person.newBuilder()<br>        .setEmail(<span class="hljs-string">&quot;123@123.com&quot;</span>)<br>        .setId(<span class="hljs-number">1</span>)<br>        .setName(<span class="hljs-string">&quot;null&quot;</span>)<br>        .build();<br><span class="hljs-type">AddressBook</span> <span class="hljs-variable">addressBook</span> <span class="hljs-operator">=</span> AddressBook.newBuilder()<br>        .addPeople(person)<br>        .build();<br>System.out.println(addressBook);<br></code></pre></td></tr></table></figure><p>当然我们也可以将<code>addressBook</code>对象调用<code>toByteArray()</code>方法序列化为二进制数据流;也可以调用<code>AddressBook.parseFrom(byte[] bytes)</code>从二进制数据中反序列化</p><h4 id="与服务器交互"><a href="#与服务器交互" class="headerlink" title="与服务器交互"></a>与服务器交互</h4><p>这里为了方便，直接使用的apache的网络请求库，使用其他库原理是一样的<br>依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;org.apache.httpcomponents&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;httpcore&#x27;</span>, <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;4.4.14&#x27;</span><br>implementation <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;org.apache.httpcomponents&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;httpclient&#x27;</span>, <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;4.5.13&#x27;</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpPost</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(<span class="hljs-string">&quot;https://a.b.com&quot;</span>);<br>request.setEntity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayEntity</span>(tgrequest.toByteArray()));<br><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.execute(request);<br><span class="hljs-comment">// 处理 HTTP 响应</span><br><span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> response.getEntity();<br><span class="hljs-keyword">if</span> (entity != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 将响应实体转换为字节数组</span><br>    <span class="hljs-type">byte</span>[] data = toByteArray(entity.getContent());<br>    <span class="hljs-type">AddressBook</span> <span class="hljs-variable">addressBook</span> <span class="hljs-operator">=</span> AddressBook.parseFrom(data);<br>    System.out.println(addressBook);<br>&#125;<br><br><span class="hljs-comment">//读取响应</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] toByteArray(InputStream in) <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4096</span>];<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>        out.write(buffer, <span class="hljs-number">0</span>, len);<br>    &#125;<br>    <span class="hljs-keyword">return</span> out.toByteArray();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>到这里就算是完成了一次使用protocol buffer的交互</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>我们可以使用<code>protostuff</code>这个库，从而不借助<code>.proto</code>文件就可以直接对POJO进行序列化和反序列化。<br>详情可以查看这个仓库 <a href="https://github.com/protostuff/protostuff">https://github.com/protostuff/protostuff</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近和三方对接时，对方给出的接口文档是使用protol buffer进行交互的，并非是我们常见的json、xml这种格式，了解了一下这种格式或者说交协议的特点。&lt;br&gt;首先，Protocol Buffer序列化之后是二进制流，不进行反序列化基本不可读。&lt;br&gt;其次，序列化之后的体积很小，适合网络传输或者设备之间传输&lt;br&gt;最后，可以跨平台、跨语言使用&lt;br&gt;不过这些特点既是优点也是缺点：序列化之后的数据不可读，还原序列化之后的数据需要事先定义好的数据格式&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://blog.huangyuanlove.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>flutter_Key</title>
    <link href="https://blog.huangyuanlove.com/2023/01/23/flutter-Key/"/>
    <id>https://blog.huangyuanlove.com/2023/01/23/flutter-Key/</id>
    <published>2023-01-23T06:31:47.000Z</published>
    <updated>2023-05-19T12:51:02.230Z</updated>
    
    <content type="html"><![CDATA[<p>官方视频在这里，有条件的可以看下<br><a href="https://www.youtube.com/watch?v=kn0EOS-ZiIc">https://www.youtube.com/watch?v=kn0EOS-ZiIc</a><br>也可以看下这个对diff算法的详解<br><a href="https://juejin.cn/post/6935422635194974244">https://juejin.cn/post/6935422635194974244</a><br>主要代码如下</p><span id="more"></span><p>一个用于获取颜色的RandomColor</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomColor</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Random _random = Random();<br><br>  <span class="hljs-keyword">static</span> Color getColor() &#123;<br>    <span class="hljs-keyword">return</span> Color.fromRGBO(<br>      _random.nextInt(<span class="hljs-number">256</span>),<br>      _random.nextInt(<span class="hljs-number">256</span>),<br>      _random.nextInt(<span class="hljs-number">256</span>),<br>      <span class="hljs-number">1</span>,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个继承自StatefulWidget的widget，使用State保存了颜色信息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomColorBoxStateful</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  RandomColorBoxStateful(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;RandomColorBoxStateful&gt; createState() =&gt; RandomColorBoxState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomColorBoxState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">RandomColorBoxStateful</span>&gt; </span>&#123;<br><br>  <span class="hljs-keyword">late</span> Color myColor;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    myColor = RandomColor.getColor();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&quot;<span class="hljs-subst">$myColor</span>&quot;</span>,style: TextStyle(color: myColor),);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个继承自StatelessWidget的widget，内容差不多</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomColorBoxStateless</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>   RandomColorBoxStateless(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br>  Color myColor = RandomColor.getColor();<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>      <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&quot;<span class="hljs-subst">$myColor</span>&quot;</span>,style: TextStyle(color: myColor),););<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个用来显示界面的SwapColorBox</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwapColorBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; SwapColorBoxState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwapColorBoxState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">SwapColorBox</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">List</span>&lt;Widget&gt; tiles = [ RandomColorBoxStateful(), RandomColorBoxStateful() ];<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      body: SafeArea(child: Column(children: tiles)),<br>      floatingActionButton: FloatingActionButton(<br>        child: Icon(Icons.sentiment_very_satisfied),<br>        onPressed: swapTiles,<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> swapTiles() &#123;<br>    setState(() &#123;<br>      <span class="hljs-built_in">List</span>&lt;Widget&gt; tmp = [tiles[<span class="hljs-number">1</span>],tiles[<span class="hljs-number">0</span>]];<br>      tiles = tmp;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时点击floatingActionButton会发现页面没有变化。</p><h3 id="如何修改"><a href="#如何修改" class="headerlink" title="如何修改"></a>如何修改</h3><p>好几种办法</p><ul><li>将SwapColorBoxState中的tiles改为 List<Widget> tiles &#x3D; [ RandomColorBoxStateless(), RandomColorBoxStateless() ]</li><li>将SwapColorBoxState中的tiles中RandomColorBoxStateful加上UniqueKey: List<Widget> tiles &#x3D; [ RandomColorBoxStateful(key: UniqueKey(),), RandomColorBoxStateful(key: UniqueKey(),) ];</li><li>将RandomColorBoxStateful中的myColor放在RandomColorBoxStateful中而不是RandomColorBoxState中</li></ul><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>元素树没有交换，虽然我们交换了Widget，但是其Element并没有交换，而颜色状态又是由State维护，所以在执行build的时候颜色并没有变化。<br>先看下更新的代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Element</span>&gt; updateChildren(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Element</span>&gt; oldChildren, <span class="hljs-built_in">List</span>&lt;Widget&gt; newWidgets, &#123; <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Element</span>&gt;? forgottenChildren, <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object?</span>&gt;? slots &#125;) &#123;<br><br><br>  <span class="hljs-built_in">Element?</span> replaceWithNullIfForgotten(<span class="hljs-built_in">Element</span> child) &#123;<br>    <span class="hljs-keyword">return</span> forgottenChildren != <span class="hljs-keyword">null</span> &amp;&amp; forgottenChildren.contains(child) ? <span class="hljs-keyword">null</span> : child;<br>  &#125;<br><br>  <span class="hljs-built_in">Object?</span> slotFor(<span class="hljs-built_in">int</span> newChildIndex, <span class="hljs-built_in">Element?</span> previousChild) &#123;<br>    <span class="hljs-keyword">return</span> slots != <span class="hljs-keyword">null</span><br>      ? slots[newChildIndex]<br>      : IndexedSlot&lt;<span class="hljs-built_in">Element?</span>&gt;(newChildIndex, previousChild);<br>  &#125;<br><br><br>  <span class="hljs-built_in">int</span> newChildrenTop = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> oldChildrenTop = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> newChildrenBottom = newWidgets.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">int</span> oldChildrenBottom = oldChildren.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Element</span>&gt; newChildren = oldChildren.length == newWidgets.length ?<br>      oldChildren : <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Element</span>&gt;.filled(newWidgets.length, _NullElement.instance);<br><br>  <span class="hljs-built_in">Element?</span> previousChild;<br><br>  <span class="hljs-comment">// Update the top of the list.</span><br>  <span class="hljs-keyword">while</span> ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element?</span> oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]);<br>    <span class="hljs-keyword">final</span> Widget newWidget = newWidgets[newChildrenTop];<br>   <br>    <span class="hljs-keyword">if</span> (oldChild == <span class="hljs-keyword">null</span> || !Widget.canUpdate(oldChild.widget, newWidget))<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!;<br>    <br>    newChildren[newChildrenTop] = newChild;<br>    previousChild = newChild;<br>    newChildrenTop += <span class="hljs-number">1</span>;<br>    oldChildrenTop += <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Scan the bottom of the list.</span><br>  <span class="hljs-keyword">while</span> ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element?</span> oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenBottom]);<br>    <span class="hljs-keyword">final</span> Widget newWidget = newWidgets[newChildrenBottom];<br>    <br>    <span class="hljs-keyword">if</span> (oldChild == <span class="hljs-keyword">null</span> || !Widget.canUpdate(oldChild.widget, newWidget))<br>      <span class="hljs-keyword">break</span>;<br>    oldChildrenBottom -= <span class="hljs-number">1</span>;<br>    newChildrenBottom -= <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Scan the old children in the middle of the list.</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> haveOldChildren = oldChildrenTop &lt;= oldChildrenBottom;<br>  <span class="hljs-built_in">Map</span>&lt;Key, <span class="hljs-built_in">Element</span>&gt;? oldKeyedChildren;<br>  <span class="hljs-keyword">if</span> (haveOldChildren) &#123;<br>    oldKeyedChildren = &lt;Key, <span class="hljs-built_in">Element</span>&gt;&#123;&#125;;<br>    <span class="hljs-keyword">while</span> (oldChildrenTop &lt;= oldChildrenBottom) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element?</span> oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]);<br>     <br>      <span class="hljs-keyword">if</span> (oldChild != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldChild.widget.key != <span class="hljs-keyword">null</span>)<br>          oldKeyedChildren[oldChild.widget.key!] = oldChild;<br>        <span class="hljs-keyword">else</span><br>          deactivateChild(oldChild);<br>      &#125;<br>      oldChildrenTop += <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Update the middle of the list.</span><br>  <span class="hljs-keyword">while</span> (newChildrenTop &lt;= newChildrenBottom) &#123;<br>    <span class="hljs-built_in">Element?</span> oldChild;<br>    <span class="hljs-keyword">final</span> Widget newWidget = newWidgets[newChildrenTop];<br>    <span class="hljs-keyword">if</span> (haveOldChildren) &#123;<br>      <span class="hljs-keyword">final</span> Key? key = newWidget.key;<br>      <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span>) &#123;<br>        oldChild = oldKeyedChildren![key];<br>        <span class="hljs-keyword">if</span> (oldChild != <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (Widget.canUpdate(oldChild.widget, newWidget)) &#123;<br>            <span class="hljs-comment">// we found a match!</span><br>            <span class="hljs-comment">// remove it from oldKeyedChildren so we don&#x27;t unsync it later</span><br>            oldKeyedChildren.remove(key);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Not a match, let&#x27;s pretend we didn&#x27;t see it for now.</span><br>            oldChild = <span class="hljs-keyword">null</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!;<br>   <br>    newChildren[newChildrenTop] = newChild;<br>    previousChild = newChild;<br>    newChildrenTop += <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// We&#x27;ve scanned the whole list.</span><br>  <br>  newChildrenBottom = newWidgets.length - <span class="hljs-number">1</span>;<br>  oldChildrenBottom = oldChildren.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// Update the bottom of the list.</span><br>  <span class="hljs-keyword">while</span> ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> oldChild = oldChildren[oldChildrenTop];<br>   <br>    <span class="hljs-keyword">final</span> Widget newWidget = newWidgets[newChildrenTop];<br>   <br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!;<br>   <br>    newChildren[newChildrenTop] = newChild;<br>    previousChild = newChild;<br>    newChildrenTop += <span class="hljs-number">1</span>;<br>    oldChildrenTop += <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Clean up any of the remaining middle nodes from the old list.</span><br>  <span class="hljs-keyword">if</span> (haveOldChildren &amp;&amp; oldKeyedChildren!.isNotEmpty) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> oldChild <span class="hljs-keyword">in</span> oldKeyedChildren.values) &#123;<br>      <span class="hljs-keyword">if</span> (forgottenChildren == <span class="hljs-keyword">null</span> || !forgottenChildren.contains(oldChild))<br>        deactivateChild(oldChild);<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-keyword">return</span> newChildren;<br>&#125;<br></code></pre></td></tr></table></figure><p>前置条件：</p><h4 id="Widget-canUpdate"><a href="#Widget-canUpdate" class="headerlink" title="Widget.canUpdate()"></a>Widget.canUpdate()</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;<br>  <span class="hljs-keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType<br>      &amp;&amp; oldWidget.key == newWidget.key;<br>&#125;<br></code></pre></td></tr></table></figure><p>比较两个Widget的runtimeType和key是否相同</p><h4 id="Element-update"><a href="#Element-update" class="headerlink" title="Element.update()"></a>Element.update()</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> update(<span class="hljs-keyword">covariant</span> Widget newWidget) &#123;<br>   _widget = newWidget;<br>&#125;<br></code></pre></td></tr></table></figure><p>只是简单的替换所持有Widget，并没有更新自己的其他属性</p><h3 id="更新算法"><a href="#更新算法" class="headerlink" title="更新算法"></a>更新算法</h3><p>framwork中将节点列表分成了三部分：顶部、中间部分、底部，当发生更新时，尽最大可能的复用Element，无法复用的才会去创建新的Element</p><ol><li>首先自顶向下的进行diff并更新子节点，也就是第一个while循环，是否能复用就是调用的canUpdate</li><li>然后自底向上的进行diff(这里没有更新子节点)，也就是第二个while循环，依然是用canUpdate看判断是否可以复用</li><li>然后在这两个中间的部分寻找可以复用的Element，并进行存储</li><li>这时候就已经扫描完整棵树了，接下来更新中间部分</li><li>最后更新底部</li></ol><p>为什么在自底向上的进行diff时候没有更新：因为这时候拿不到Slot信息<br>回到我们上面提到的例子中点击按钮时会触发<code>Column</code>的更新，也就是<code>MultiChildRenderObjectElement</code>的更新，就会触发上面的<code>updateChildren()</code>方法<br>所以在自顶向下的更新中，<code>canUpdate()</code>返回的是<code>true</code>(当我们设置了Key之后，这里会返回false，不进行复用)，也就是可以复用<code>element</code>，接着执行了<code>updateChild(Element? child, Widget? newWidget, Object? newSlot)</code><br>这里的<code>child</code>是<em>旧element</em>，<code>newWidget</code>也就是要显示的<em>widget</em>，两者并不相等，所以就执行了<code>child.update(newWidget);</code>只是简单的对所持有的<code>widget</code>进行了赋值。我们知道<code>StatefullWidget</code>中<code>State</code>和<code>StatefulElement</code>互相持有，并且两者都持有<code>StatefulWidget</code>。所以<code>State</code>并没有被更新，所持有的颜色值还是交换之前的颜色值，所以点击交换按钮后，<code>Widget</code>虽然交换了位置，但是<code>Element</code>并没有更新。<br>有点像是A机器生产A物品，B机器生产B物品；原来操作机器A的去操作机器B，原来操作机器B的去操作机器A，虽然换了操作员，但生产A的机器还是生产A，生产B的机器还是生产B。</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>这里的key就两个分支<code>LocalKey</code> 和<code>GlobalKey</code> 。我们知道<em>key</em>的作用就是为<code>Widget</code>确认唯一的身份，可以在多子组件更新中被识别，这就是<code>LocalKey</code>的作用。所以<code>LocalKey</code>保证的是 <strong>相同父级</strong>组件的身份唯一性。而 <code>GlobalKey</code> 是整个应用中，组件的身份唯一。</p><p><code>LocalKey</code>下面有<code>UniqueKey</code>、<code>ValueKey&lt;T&gt;</code>、<code>ObjectKey</code>,区别也很简单，戳进去看下源码就好了</p><h4 id="Globalkey"><a href="#Globalkey" class="headerlink" title="Globalkey"></a>Globalkey</h4><p>对于<code>GlobalKey</code>来讲，只要获取到了<code>Element</code>，就能获取到<code>Widget</code>对象。只要<code>Element</code>是<code>StatefulElement</code>，就能获取到<code>State</code>.<br>那么如何获取到Element呢？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Element?</span> <span class="hljs-keyword">get</span> _currentElement =&gt; WidgetsBinding.instance.buildOwner!._globalKeyRegistry[<span class="hljs-keyword">this</span>];<br><br><span class="hljs-comment">///<span class="language-markdown">BuildOwner</span></span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;GlobalKey, <span class="hljs-built_in">Element</span>&gt; _globalKeyRegistry = &lt;GlobalKey, <span class="hljs-built_in">Element</span>&gt;&#123;&#125;;<br><span class="hljs-keyword">void</span> _registerGlobalKey(GlobalKey key, <span class="hljs-built_in">Element</span> element) &#123;<br>  _globalKeyRegistry[key] = element;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么是在什么时候调用_registerGlobalKey注册的呢？前面提到的mount方法中</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (key <span class="hljs-keyword">is</span> GlobalKey) &#123;<br>  owner!._registerGlobalKey(key, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 就是在这里注册的。<br>并且会在unmount中进行反注册</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> Key? key = _widget?.key;<br><span class="hljs-keyword">if</span> (key <span class="hljs-keyword">is</span> GlobalKey) &#123;<br>  owner!._unregisterGlobalKey(key, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>源码中也对<code>GlobalKey</code>的使用场景做出了介绍，当你真的需要获取某个<code>BuildContext</code>或<code>State</code>时，用<code>GlobalKey</code>是完全没有问题的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;官方视频在这里，有条件的可以看下&lt;br&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=kn0EOS-ZiIc&quot;&gt;https://www.youtube.com/watch?v=kn0EOS-ZiIc&lt;/a&gt;&lt;br&gt;也可以看下这个对diff算法的详解&lt;br&gt;&lt;a href=&quot;https://juejin.cn/post/6935422635194974244&quot;&gt;https://juejin.cn/post/6935422635194974244&lt;/a&gt;&lt;br&gt;主要代码如下&lt;/p&gt;</summary>
    
    
    
    
    <category term="Flutter" scheme="https://blog.huangyuanlove.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter_StatefulWidget</title>
    <link href="https://blog.huangyuanlove.com/2023/01/18/flutter-StatefulWidget/"/>
    <id>https://blog.huangyuanlove.com/2023/01/18/flutter-StatefulWidget/</id>
    <published>2023-01-18T08:00:47.000Z</published>
    <updated>2023-05-19T12:51:02.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="createState-是何时被调用的？"><a href="#createState-是何时被调用的？" class="headerlink" title="createState()是何时被调用的？"></a>createState()是何时被调用的？</h3><p>断点查看调用栈，发现是在<code>StatefulElement</code>的构造方法中创建的,而<code>element</code>的创建则是在父元素调用<code>inflateWidget</code>时触发子元素的<code>createElement</code>方法创建的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">StatefulElement(StatefulWidget widget)<br>    : _state = widget.createState(),<br>      <span class="hljs-keyword">super</span>(widget) &#123;<br>  state._element = <span class="hljs-keyword">this</span>;<br>  state._widget = widget;<br>&#125;<br></code></pre></td></tr></table></figure><p>去掉断言代码可以看到，在构造方法中调用了<code>createState()</code>来创建<code>State</code>对象，接着对<code>_state</code>对象的<code>_element</code>和<code>_widget</code>成员进行赋值。<br>到这里我们可以清楚的知道:<code>State</code>和<code>StatefulElement</code>互相持有，并且两者都持有<code>StatefulWidget</code>。</p><h3 id="State类中的方法"><a href="#State类中的方法" class="headerlink" title="State类中的方法"></a>State类中的方法</h3><p>这里面定义了生命周期方法</p><ul><li>initState()</li><li>didUpdateWidget(covariant T oldWidget)</li><li>void reassemble()</li><li>void deactivate()</li><li>void activate()</li><li>void dispose()</li><li>Widget build(BuildContext context)</li><li>void didChangeDependencies()</li></ul><p>其实看一下这些方法上面的注释基本上就能理解的差不多，断点走一遍流程，也就都了解了</p><h3 id="回调时机"><a href="#回调时机" class="headerlink" title="回调时机"></a>回调时机</h3><p><code>StatefulElement</code>继承自<code>ComponentElement</code>类，该类在<code>mount()</code>时调用的了<code>_firstBuild()</code>方法，这个方法被<code>StatefulElement</code>覆写，可以看到在这里里面调用了<code>state.initState()</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> _firstBuild() &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    _debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object?</span> debugCheckForReturnedFuture = state.initState() <span class="hljs-keyword">as</span> <span class="hljs-built_in">dynamic</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    _debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="hljs-keyword">false</span>);<br>  &#125;<br>  state.didChangeDependencies();<br>  <span class="hljs-keyword">super</span>._firstBuild();<br>&#125;<br></code></pre></td></tr></table></figure><p>紧着这就调用了<code>state.didChangeDependencies()</code>方法,最后调用了<code>super._firstBuild()</code>;<br>还是在<code>ComponentElement</code>类中的<code>_firstBuild()</code>方法中调用了<code>rebuild()--&gt;performRebuild</code>,这里<code>performRebuild()</code>在<code>StatefulElement</code>有被重写</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> performRebuild() &#123;<br>  <span class="hljs-keyword">if</span> (_didChangeDependencies) &#123;<br>    state.didChangeDependencies();<br>    _didChangeDependencies = <span class="hljs-keyword">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">super</span>.performRebuild();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>_didChangeDependencies</code>默认为<code>false</code>，所以第一次进来并不会触发<code>state.didChangeDependencies()</code>方法;接下来执行了<code>super.performRebuild()</code>;<br>同样的在<code>ComponentElement</code>类中的<code>performRebuild()</code>方法中调用了<code>build()</code>方法,当然这里的<code>build</code>方法已经被子类<code>StatefulElement</code>重写，调用了<code>state.build(this)</code>方法，然后调用了<code>updateChild()</code>方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> performRebuild() &#123;<br>  <span class="hljs-keyword">assert</span>(_debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="hljs-keyword">true</span>));<br>  Widget? built;<br>  <span class="hljs-keyword">try</span> &#123;<br>    built = build();<br>    debugWidgetBuilderValue(widget, built);<br>  &#125; <span class="hljs-keyword">catch</span> (e, stack) &#123;<br>    _debugDoingBuild = <span class="hljs-keyword">false</span>;<br>    built = ErrorWidget.builder(...);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>     _dirty = <span class="hljs-keyword">false</span>;<br>    <br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    _child = updateChild(_child, built, slot);<br>    <br>  &#125; <span class="hljs-keyword">catch</span> (e, stack) &#123;<br>    built = ErrorWidget.builder();<br>    _child = updateChild(<span class="hljs-keyword">null</span>, built, slot);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就接上了控件是如何进行挂载的</p><h3 id="如何更新"><a href="#如何更新" class="headerlink" title="如何更新"></a>如何更新</h3><p>我们知道在<code>StatefulWidget</code>中可以使用<code>setState()</code>来更新页面内容，那么表示状态的属性是在什么时机赋值，这里有两种方式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">_color = Colors.red;<br>setState(()&#123;<br>&#125;);<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">setStaate(()&#123;<br>  _color = Colors.red;<br>&#125;);<br></code></pre></td></tr></table></figure><p>戳进去看源码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> setState(VoidCallback fn) &#123;<br>  <span class="hljs-keyword">assert</span>(fn != <span class="hljs-keyword">null</span>);<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object?</span> result = fn() <span class="hljs-keyword">as</span> <span class="hljs-built_in">dynamic</span>;<br>  <span class="hljs-keyword">assert</span>(() &#123;<br>    <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">is</span> Future) &#123;<br>      <span class="hljs-keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[<br>        ErrorSummary(<span class="hljs-string">&#x27;setState() callback argument returned a Future.&#x27;</span>),<br>        ErrorDescription(<br>          <span class="hljs-string">&#x27;The setState() method on <span class="hljs-subst">$this</span> was called with a closure or method that &#x27;</span><br>          <span class="hljs-string">&#x27;returned a Future. Maybe it is marked as &quot;async&quot;.&#x27;</span>,<br>        ),<br>        ErrorHint(<br>          <span class="hljs-string">&#x27;Instead of performing asynchronous work inside a call to setState(), first &#x27;</span><br>          <span class="hljs-string">&#x27;execute the work (without updating the widget state), and then synchronously &#x27;</span><br>          <span class="hljs-string">&#x27;update the state inside a call to setState().&#x27;</span>,<br>        ),<br>      ]);<br>    &#125;<br>    <span class="hljs-comment">// We ignore other types of return values so that you can do things like:</span><br>    <span class="hljs-comment">//   setState(() =&gt; x = 3);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;());<br>  _element!.markNeedsBuild();<br>&#125;<br></code></pre></td></tr></table></figure><p>一坨断言，判断<code>callback</code>是不是空，<code>callback</code>的返回值是不是<code>Future</code>类型;然后调用<code>_element!.markNeedsBuild()</code>。所以就这段代码来看，上面两种写法都可以，但还是建议向源码看齐：状态属性的改变写在<code>callback</code>中，确保在<code>markNeedsBuild()</code>之前，状态值是自己期望的结果；</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> markNeedsBuild() &#123;<br>  <span class="hljs-keyword">if</span> (_lifecycleState != _ElementLifecycle.active)<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (dirty)<br>    <span class="hljs-keyword">return</span>;<br>  _dirty = <span class="hljs-keyword">true</span>;<br>  owner!.scheduleBuildFor(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果当前状态不是active则不标记，如果已经标记过也不在标记；</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="language-markdown">Adds an element to the dirty elements list so that it will be rebuilt</span></span><br><span class="hljs-comment">/// <span class="language-markdown">when [WidgetsBinding.drawFrame] calls [buildScope].</span></span><br><span class="hljs-keyword">void</span> scheduleBuildFor(<span class="hljs-built_in">Element</span> element) &#123;<br><br>  <span class="hljs-keyword">if</span> (element._inDirtyList) &#123;<br>    _dirtyElementsNeedsResorting = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != <span class="hljs-keyword">null</span>) &#123;<br>    _scheduledFlushDirtyElements = <span class="hljs-keyword">true</span>;<br>    onBuildScheduled!();<br>  &#125;<br>  _dirtyElements.add(element);<br>  element._inDirtyList = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里也是进行了二次判断，保证不会被多次重绘。注意<code>onBuildScheduled()</code>的调用，它的定义是<code>VoidCallback? onBuildScheduled</code>;并且是在<code>BuildOwner</code>类中的构造方法中初始化的，那么这个<code>onBuildScheduled</code>到底是什么方法?断点看一下是<code>WidgetsBinding#_handleBuildScheduled</code>这个方法。它是在什么时候被赋值的？<code>owner</code>是<code>element</code>对象中的一个成员变量<code>_owner</code>,搜一下看一看到是在<code>mount()</code>方法中赋值的，值为<code>parent.owner</code>。还记的之前初始化根节点的的时候调用的<code>WidgetsBinding#attachRootWidget(Widget rootWidget)</code>这个方法中创建<code>RenderObjectToWidgetAdapter</code>对象后调用的<code>attachToRenderTree()</code>方法中有传入<code>BuildOwner</code>对象，接着向上查找，发现是在<code>initInstances()</code>方法中创建的.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> initInstances() &#123;<br>  <span class="hljs-keyword">super</span>.initInstances();<br>  _instance = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-comment">// Initialization of [_buildOwner] has to be done after</span><br>  <span class="hljs-comment">// [super.initInstances] is called, as it requires [ServicesBinding] to</span><br>  <span class="hljs-comment">// properly setup the [defaultBinaryMessenger] instance.</span><br>  _buildOwner = BuildOwner();<br>  buildOwner!.onBuildScheduled = _handleBuildScheduled;<br>  platformDispatcher.onLocaleChanged = handleLocaleChanged;<br>  platformDispatcher.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;<br>  SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);<br><br>  platformMenuDelegate = DefaultPlatformMenuDelegate();<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>_handleBuildScheduled</code> 中就只是调用了<code>ensureVisualUpdate()</code>方法，然后调用了<code>scheduleFrame()</code>;</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> scheduleFrame() &#123;<br>  <span class="hljs-keyword">if</span> (_hasScheduledFrame || !framesEnabled)<br>    <span class="hljs-keyword">return</span>;<br>  ensureFrameCallbacksRegistered();<br>  platformDispatcher.scheduleFrame();<br>  _hasScheduledFrame = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里先确保两个回调确实被注册了，然后通过<code>platformDispatcher.scheduleFrame()</code>这个<em>native</em>方法向系统发送一个帧调度的请求。<br>然后会回调<code>_handleDrawFrame()</code>方法，也就是<code>ensureFrameCallbacksRegistered()</code>方法中确保两个回调方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> handleDrawFrame() &#123;<br>  <span class="hljs-keyword">assert</span>(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);<br>  _frameTimelineTask?.finish(); <span class="hljs-comment">// end the &quot;Animate&quot; phase</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// PERSISTENT FRAME CALLBACKS</span><br>    _schedulerPhase = SchedulerPhase.persistentCallbacks;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> FrameCallback callback <span class="hljs-keyword">in</span> _persistentCallbacks)<br>      _invokeFrameCallback(callback, _currentFrameTimeStamp!);<br><br>    <span class="hljs-comment">// POST-FRAME CALLBACKS</span><br>    _schedulerPhase = SchedulerPhase.postFrameCallbacks;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;FrameCallback&gt; localPostFrameCallbacks =<br>        <span class="hljs-built_in">List</span>&lt;FrameCallback&gt;.of(_postFrameCallbacks);<br>    _postFrameCallbacks.clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> FrameCallback callback <span class="hljs-keyword">in</span> localPostFrameCallbacks)<br>      _invokeFrameCallback(callback, _currentFrameTimeStamp!);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    _schedulerPhase = SchedulerPhase.idle;<br>    _frameTimelineTask?.finish(); <span class="hljs-comment">// end the Frame</span><br>    <span class="hljs-keyword">assert</span>(() &#123;<br>      <span class="hljs-keyword">if</span> (debugPrintEndFrameBanner)<br>        debugPrint(<span class="hljs-string">&#x27;▀&#x27;</span> * _debugBanner!.length);<br>      _debugBanner = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;());<br>    _currentFrameTimeStamp = <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是调用 <code>_invokeFrameCallback</code>，这里的<code>_persistentCallbacks</code>是个<code>list</code>，通过</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> addPersistentFrameCallback(FrameCallback callback) &#123;<br>  _persistentCallbacks.add(callback);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法添加回调；这里的回调是在<code>RendererBinding</code>类中的<code>initInstances()</code>方法中注册的，实际上调用的方法是</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart">_handlePersistentFrameCallback<br>  <span class="hljs-keyword">void</span> _handlePersistentFrameCallback(<span class="hljs-built_in">Duration</span> timeStamp) &#123;<br>    drawFrame();<br>    _scheduleMouseTrackerUpdate();<br>  &#125;<br></code></pre></td></tr></table></figure><p>然后调用了<code>drawFrame();</code>方法,需要注意的是:<code>RendererBinding</code>是一个<em>mixin</em>的类，被<code>WidgetsBinding</code>混入，并且<code>WidgetsBinding</code>类中重写了<code>drawFrame()</code>方法，所以最后走的是<code>WidgetsBinding</code>类中的<code>drawFrame()</code>方法；在这里面调用了<code>buildOwner!.buildScope(renderViewElement!);</code><br>在这个方法中先对脏列表进行排序</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _sort(<span class="hljs-built_in">Element</span> a, <span class="hljs-built_in">Element</span> b) &#123;<br>  <span class="hljs-keyword">if</span> (a.depth &lt; b.depth)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (b.depth &lt; a.depth)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (b.dirty &amp;&amp; !a.dirty)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (a.dirty &amp;&amp; !b.dirty)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后循环调用<code>element.rebuild();</code>触发<code>performRebuild()</code>接着就是<code>widget</code>的<code>build()</code>方法被触发.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;createState-是何时被调用的？&quot;&gt;&lt;a href=&quot;#createState-是何时被调用的？&quot; class=&quot;headerlink&quot; title=&quot;createState()是何时被调用的？&quot;&gt;&lt;/a&gt;createState()是何时被调用的？&lt;/h3</summary>
      
    
    
    
    
    <category term="Flutter" scheme="https://blog.huangyuanlove.com/tags/Flutter/"/>
    
  </entry>
  
</feed>
