<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>放码过来</title>
  <icon>https://www.gravatar.com/avatar/771a5b96a1b55228dbb1eeb23619ef45</icon>
  <subtitle>技术宅 huangyuan@huangyuanlove.com</subtitle>
  <link href="https://blog.huangyuanlove.com/atom.xml" rel="self"/>
  
  <link href="https://blog.huangyuanlove.com/"/>
  <updated>2025-01-17T15:08:16.319Z</updated>
  <id>https://blog.huangyuanlove.com/</id>
  
  <author>
    <name>HuangYuan_xuan</name>
    <email>huangyuan@huangyuanlove.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>鸿蒙-hvigor定制构建</title>
    <link href="https://blog.huangyuanlove.com/2025/01/17/%E9%B8%BF%E8%92%99-hvigor%E5%AE%9A%E5%88%B6%E6%9E%84%E5%BB%BA/"/>
    <id>https://blog.huangyuanlove.com/2025/01/17/%E9%B8%BF%E8%92%99-hvigor%E5%AE%9A%E5%88%B6%E6%9E%84%E5%BB%BA/</id>
    <published>2025-01-17T15:30:13.000Z</published>
    <updated>2025-01-17T15:08:16.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前需要发版时都是在开发机上修改一下相关配置，比如签名文件、三方SDK参数等，然后打包上传到应用商店。略显繁琐，也担心某次打包会有漏改错改的配置。现在使用jenkins搭建了构建流水线，希望可以根据传入的参数不同，替换配置文件中的字段。翻看文档后发现可以在<code>hvigorfile.ts</code>中接收部分编译配置。</p><h2 id="BuildProfile"><a href="#BuildProfile" class="headerlink" title="BuildProfile"></a>BuildProfile</h2><p>该类和 Android 项目中的 BuildConfig类很像，也是在编译构建时生成的。我们可以通过该类在运行时获取编译构建参数，也可以在<code>build-profile.json5</code>中通过buildProfileFields增加自定义字段，从而在运行时获取自定义的参数。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>项目代码已经迭代了将近10年，有些功能的添加没有办法做到完美向下兼容，只能在请求参数中添加当前应用版本号，服务端根据版本号来判断需要下发哪些数据。但鸿蒙版本是刚开发开发，在一个版本内无法完成全部功能，需要分版本按紧急程度开发，因此版本号也不能直接和 Android、iOS 对齐，也是从 1.0.0 版本开始发版。所以无法在请求参数中直接传递应用版本号。因此我们将当前适配的版本号写入到<code>BuildProfile.ets</code>文件中，方便各个业务调用。</p><p>我们在项目根目录下的<code>build-profile.json5</code>文件中添加如下内容就可以将自定义的字段写入到该文件中.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">&#123;<br><span class="hljs-attr">app</span>: &#123;<br><span class="hljs-attr">products</span>: [&#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;default&quot;</span>,<br><span class="hljs-attr">signingConfig</span>: <span class="hljs-string">&quot;default&quot;</span>,<br><span class="hljs-attr">compatibleSdkVersion</span>: <span class="hljs-string">&quot;5.0.0(12)&quot;</span>,<br><span class="hljs-attr">runtimeOS</span>: <span class="hljs-string">&quot;HarmonyOS&quot;</span>,<br><span class="hljs-attr">buildOption</span>: &#123;<br><span class="hljs-attr">arkOptions</span>: &#123;<br><span class="hljs-attr">buildProfileFields</span>: &#123;<br><span class="hljs-attr">online</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-attr">version_to_servier</span>: <span class="hljs-string">&quot;5.11.10&quot;</span>,<br>&#125;,<br>&#125;<br>&#125;,<br>&#125;,<br>]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义参数可以在<code>buildOption</code>、<code>buildOptionSet</code>、<code>targets</code>节点下的<code>arkOptions</code>子节点中通过增加<code>buildProfileFields</code>字段实现，自定义参数通过<code>key-value</code>键值对的方式配置，其中<code>value</code>取值仅支持<code>number</code>、<code>string</code>、<code>boolean</code>类型。<br>当然，该配置也可以在模块下的<code>build-profile.json5</code>中配置。优先级如下：</p><blockquote><p>模块级target &gt; 模块级buildOptionSet &gt; 模块级buildOption &gt; 工程级product &gt; 工程级buildModeSet</p></blockquote><p>这里我们添加了<code>version_to_servier</code>字段来表示当前应用适配到了哪个版本。<br>正常情况下，我们运行代码就可以在<code>$&#123;moduleName&#125; / build / $&#123;productName&#125; / generated / profile / $&#123;targetName&#125; </code>目录下生成<code>BuildProfile.ets</code>文件。<br>也可以在命令行执行<code>hvigorw GenerateBuildProfile</code>。<br>也可以选中需要编译的模块，在菜单栏选择<code>Build &gt; Generate Build Profile $&#123;moduleName&#125;</code>。<br>也可以在菜单栏选择<code>Build &gt; Build Hap(s)/APP(s) &gt; Build Hap(s)”或“Build &gt; Build Hap(s)/APP(s) &gt; Build APP(s)</code>。</p><p>使用时可以这么用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">BuildProfile</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./BuildProfile&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">VERSION_TO_SERVER</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">BuildProfile</span>.<span class="hljs-property">version_to_servier</span>;<br></code></pre></td></tr></table></figure><h2 id="替换模块module-json5字段的值"><a href="#替换模块module-json5字段的值" class="headerlink" title="替换模块module.json5字段的值"></a>替换模块module.json5字段的值</h2><p>我们使用了某三方SDK，需要在<strong>模块</strong>下<code>module.json5</code>文件中添加对应的id </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">&#123;<br>  <span class="hljs-string">&quot;module&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;metadata&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xxx_APPID&quot;</span>,<br>        <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;1234567&quot;</span><br>      &#125;<br>    ],<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了区分测试环境和生产环境，<code>xxx_APPID</code>配置了不一样的值，我们期望是打包时通过命令行参数来修改这个值，避免认为配置出现错误。</p><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>使用命令行<code>hvigorw</code>打包时除了<code>buildMode</code>、<code>debuggable</code>等参数外，还支持<code>--config properties.key=value</code>进行自定义参数。并且在模块下、工程下的<code>hvigorfile.ts</code>中都可以接收到该参数。</p><p>这里我们定义了布尔类型的<code>online</code>参数来表示是否为发版包，当模块下的<code>hvigorfile.ts</code>文件中根据该字段的值来区分配置的参数。<br>具体代码如下，在模块下的<code>hvigorfile.ts</code>文件中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; hapTasks, <span class="hljs-title class_">OhosHapContext</span>, <span class="hljs-title class_">OhosPluginId</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/hvigor-ohos-plugin&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; getNode &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/hvigor&#x27;</span><br><br><span class="hljs-keyword">const</span> entryNode = <span class="hljs-title function_">getNode</span>(__filename);<br><span class="hljs-comment">// 为此节点添加一个afterNodeEvaluate hook 在hook中修改module.json5的内容并使能</span><br>entryNode.<span class="hljs-title function_">afterNodeEvaluate</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">//获取命令行参数</span><br>  <span class="hljs-keyword">let</span> online = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">let</span> propertyOnline = hvigor.<span class="hljs-title function_">getParameter</span>().<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&#x27;online&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (propertyOnline != <span class="hljs-literal">undefined</span>) &#123;<br>    online = propertyOnline<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;entry online-&gt; &quot;</span> + propertyOnline);<br><br>  <span class="hljs-comment">// 获取此节点使用插件的上下文对象 此时为hap插件 获取hap插件上下文对象</span><br>  <span class="hljs-keyword">const</span> hapContext = node.<span class="hljs-title function_">getContext</span>(<span class="hljs-title class_">OhosPluginId</span>.<span class="hljs-property">OHOS_HAP_PLUGIN</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">OhosHapContext</span>;<br>  <span class="hljs-comment">// 通过上下文对象获取从module.json5文件中读出来的obj对象</span><br>  <span class="hljs-keyword">const</span> moduleJsonOpt = hapContext.<span class="hljs-title function_">getModuleJsonOpt</span>();<br>  <span class="hljs-comment">// 修改obj对象为想要的，此处举例修改module中的deviceTypes</span><br>  <span class="hljs-keyword">let</span> metaDateList = moduleJsonOpt[<span class="hljs-string">&#x27;module&#x27;</span>][<span class="hljs-string">&#x27;metadata&#x27;</span>]<br>  metaDateList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (element[<span class="hljs-string">&#x27;name&#x27;</span>] === <span class="hljs-string">&#x27;xxx_APPID&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (online) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;线上环境，修改xxx_APPID配置为   abcdefg&#x27;</span>)<br>        element[<span class="hljs-string">&#x27;value&#x27;</span>] = <span class="hljs-string">&#x27;abcdefg&#x27;</span><br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;测试环境，修改xxx_APPID配置为   1234567&#x27;</span>)<br>        element[<span class="hljs-string">&#x27;value&#x27;</span>] = <span class="hljs-string">&#x27;1234567&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;);<br><br>    <span class="hljs-comment">// 将obj对象设置回上下文对象以使能到构建的过程与结果中</span><br>    hapContext.<span class="hljs-title function_">setModuleJsonOpt</span>(moduleJsonOpt);<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">system</span>: hapTasks,  <span class="hljs-comment">/* Built-in plugin of Hvigor. It cannot be modified. */</span><br>    <span class="hljs-attr">plugins</span>:[]         <span class="hljs-comment">/* Custom plugin to extend the functionality of Hvigor. */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在打包构建时只需要执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hvigorw clean  assembleApp -p buildMode=release --config properties.online=true<br></code></pre></td></tr></table></figure><p>就可以直接替换为生产环境的配置了。因为平时开发都是直接点 IDE 中的 run 进行调试，不会传入该参数，也就不会影响文件中原本配置的值。</p><h2 id="打包签名"><a href="#打包签名" class="headerlink" title="打包签名"></a>打包签名</h2><p>上面也提到自定义的参数也可以在工程下的<code>hvigorfile.ts</code>接收到该参数，上面<code>BuildProfile</code>中也提到在工程下的<code>build-profile.json5</code>添加了自定义字段<code>online</code>。我们同样可以根据命令行参数替换掉。同时也将配置的测试签名文件删除，只构建产物，随后再使用命令行进行签名。</p><p>代码如下，在工程根目录下的<code>hvigorfile.ts</code>文件中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; appTasks, <span class="hljs-title class_">OhosAppContext</span>, <span class="hljs-title class_">OhosPluginId</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/hvigor-ohos-plugin&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; hvigor,getNode &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/hvigor&#x27;</span><br><span class="hljs-comment">// 获取根节点</span><br><span class="hljs-keyword">const</span> rootNode = <span class="hljs-title function_">getNode</span>(__filename);<br><span class="hljs-comment">// 为根节点添加一个afterNodeEvaluate hook 在hook中修改根目录下的build-profile.json5的内容并使能</span><br>rootNode.<span class="hljs-title function_">afterNodeEvaluate</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br><br>    <span class="hljs-comment">//获取命令行参数</span><br>    <span class="hljs-keyword">let</span> online = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">let</span> propertyOnline = hvigor.<span class="hljs-title function_">getParameter</span>().<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&#x27;online&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (propertyOnline != <span class="hljs-literal">undefined</span>) &#123;<br>        online = propertyOnline<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;online-&gt; &quot;</span> + propertyOnline);<br><br>    <span class="hljs-comment">// 获取app插件的上下文对象</span><br>    <span class="hljs-keyword">const</span> appContext = node.<span class="hljs-title function_">getContext</span>(<span class="hljs-title class_">OhosPluginId</span>.<span class="hljs-property">OHOS_APP_PLUGIN</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">OhosAppContext</span>;<br>    <span class="hljs-comment">// 通过上下文对象获取从根目录build-profile.json5文件中读出来的obj对象</span><br>    <span class="hljs-keyword">const</span> buildProfileOpt = appContext.<span class="hljs-title function_">getBuildProfileOpt</span>();<br>    <span class="hljs-comment">//将 BuildProfile 文件中的online值改为传入的值</span><br>    buildProfileOpt[<span class="hljs-string">&#x27;app&#x27;</span>][<span class="hljs-string">&#x27;products&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;buildOption&#x27;</span>][<span class="hljs-string">&#x27;arkOptions&#x27;</span>][<span class="hljs-string">&#x27;buildProfileFields&#x27;</span>][<span class="hljs-string">&#x27;online&#x27;</span>] = online<br>    <span class="hljs-keyword">if</span> (online) &#123;<br>      <span class="hljs-comment">//清除签名文件信息</span><br>        buildProfileOpt[<span class="hljs-string">&#x27;app&#x27;</span>][<span class="hljs-string">&#x27;signingConfigs&#x27;</span>] = []<br>    &#125;<br>    <br>    <span class="hljs-comment">// 将obj对象设置回上下文对象以使能到构建的过程与结果中</span><br>    appContext.<span class="hljs-title function_">setBuildProfileOpt</span>(buildProfileOpt);<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">system</span>: appTasks,  <span class="hljs-comment">/* Built-in plugin of Hvigor. It cannot be modified. */</span><br>    <span class="hljs-attr">plugins</span>:[]         <span class="hljs-comment">/* Custom plugin to extend the functionality of Hvigor. */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>打包的时候，由于上架需要 app 文件，所以我们需要打 release 模式的 app 文件。测试时需要打release 模式的hap 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">//先安装一下依赖<br>ohpm install --all<br>//发版包<br>hvigorw clean  assembleApp -p buildMode=release --config properties.online=true <br>//测试包<br>hvigorw clean  assembleHap -p buildMode=release --config properties.online=false<br></code></pre></td></tr></table></figure><p>这样我们就将<code>BuildProfile</code>文件中的<code>online</code>值改为传入的值，同时也清除了签名文件配置。</p><p>这里需要注意的是，如果执行的是<code>assembleApp</code>,则产物是在项目根目录<code>build/outputs/$&#123;productName&#125;/xxx-default-unsigned.app</code>。如果执行的是<code>assembleHap</code>，则会在<code>$&#123;moduleName&#125;/build/$&#123;productName&#125;/outputs/$&#123;productName&#125;/entry-default-unsigned.hap</code>.</p><p>下面我们对产物进行签名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">/Applications/DevEco-Studio.app/Contents/jbr/Contents/Home/bin/java -jar /Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains/lib/hap-sign-tool.jar sign-app -keyAlias &quot;keyAlias&quot; -signAlg &quot;SHA256withECDSA&quot; -mode &quot;localSign&quot; -appCertFile &quot;release.cer&quot; -profileFile &quot;release.p7b&quot; -inFile &quot;build/outputs/default/xxx-default-unsigned.app&quot; -keystoreFile &quot;default.p12&quot; -outFile &quot;xxx-default-signed.app&quot; -keyPwd &quot;keyPwd&quot; -keystorePwd &quot;keystorePwd&quot; -signCode &quot;1&quot;<br><br>/Applications/DevEco-Studio.app/Contents/jbr/Contents/Home/bin/java -jar /Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains/lib/hap-sign-tool.jar sign-app -keyAlias &quot;keyAlias&quot; -signAlg &quot;SHA256withECDSA&quot; -mode &quot;localSign&quot; -appCertFile &quot;debug.cer&quot; -profileFile &quot;debug.p7b&quot; -inFile &quot;entry/build/default/outputs/default/entry-default-unsigned.hap&quot; -keystoreFile &quot;default.p12&quot; -outFile &quot;entry-default-signed.hap&quot; -keyPwd &quot;keyPwd&quot; -keystorePwd &quot;keystorePwd&quot; -signCode &quot;1&quot;<br><br></code></pre></td></tr></table></figure><p>我们可以把打包签名的流程写在文件(build.sh)中，每次去执行这个文件就好了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化build_type为release</span><br>online=true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解析命令行参数</span><br>while [[ $# -gt 0 ]]; do<br>    case $1 in<br>        --debug)<br>            online=false<br>            echo &quot;需要构建测试包&quot;<br>            shift<br>            ;;<br>        --release)<br>            # 实际上这个选项是多余的，因为默认就是release<br>            # 但如果你希望明确指定release以覆盖其他可能设置默认值的逻辑，可以保留<br>            online=true<br>            echo &quot;需要构建线上包&quot;<br>            shift<br>            ;;<br>        *)<br>            # 未知选项，打印帮助信息或错误消息<br>            echo &quot;Usage: $0 [--debug|--release]&quot;<br>            exit 1<br>            ;;<br>    esac<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装依赖</span><br>ohpm install --all<br><br><br>if [ &quot;$online&quot; == true ]; then<br>    # 打线上 app 包<br>    echo &quot;Executing online release build commands...&quot;<br>    hvigorw clean  assembleApp -p buildMode=release --config properties.online=true <br>elif [ &quot;$online&quot; == false ]; then<br>    # 打测试 hap 包<br>    echo &quot;Executing not online release build commands...&quot;<br>    hvigorw clean  assembleHap -p buildMode=release --config properties.online=false<br>else<br>    # 理论上不应该走到这里，除非build_type被设置为非预期的值<br>    echo &quot;Unknown build type: $build_type&quot;<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">签名</span><br><br>if [ &quot;$online&quot; == true ]; then<br>    # 打线上 app 包<br>    echo &quot;签名 app 文件&quot;<br>    /Applications/DevEco-Studio.app/Contents/jbr/Contents/Home/bin/java -jar /Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains/lib/hap-sign-tool.jar sign-app -keyAlias &quot;keyAlias&quot; -signAlg &quot;SHA256withECDSA&quot; -mode &quot;localSign&quot; -appCertFile &quot;release.cer&quot; -profileFile &quot;release.p7b&quot; -inFile &quot;build/outputs/default/xxx-default-unsigned.app&quot; -keystoreFile &quot;default.p12&quot; -outFile &quot;xxx-default-signed.app&quot; -keyPwd &quot;keyPwd&quot; -keystorePwd &quot;keystorePwd&quot; -signCode &quot;1&quot;<br><br>elif [ &quot;$online&quot; == false ]; then<br>    # 打测试 hap 包<br>    echo &quot;签名 hap 文件&quot;<br>    /Applications/DevEco-Studio.app/Contents/jbr/Contents/Home/bin/java -jar /Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains/lib/hap-sign-tool.jar sign-app -keyAlias &quot;keyAlias&quot; -signAlg &quot;SHA256withECDSA&quot; -mode &quot;localSign&quot; -appCertFile &quot;debug.cer&quot; -profileFile &quot;debug.p7b&quot; -inFile &quot;entry/build/default/outputs/default/entry-default-unsigned.hap&quot; -keystoreFile &quot;default.p12&quot; -outFile &quot;entry-default-signed.hap&quot; -keyPwd &quot;keyPwd&quot; -keystorePwd &quot;keystorePwd&quot; -signCode &quot;1&quot;<br><br>else<br>    # 理论上不应该走到这里，除非build_type被设置为非预期的值<br>    echo &quot;Unknown build type: $build_type&quot;<br>    exit 1<br>fi<br></code></pre></td></tr></table></figure><p>打包时，如果需要打测试包，则执行 <code>build.sh --debug</code>，如果要打发版包，则执行<code>build.sh --release</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前需要发版时都是在开发机上修改一下相关配置，比如签名文件、三方SDK参数等，然后打包上传到应用商店。略显繁琐，也担心某次打包会有漏改错改的</summary>
      
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙-自定义相机拍照</title>
    <link href="https://blog.huangyuanlove.com/2024/12/19/%E9%B8%BF%E8%92%99-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7/"/>
    <id>https://blog.huangyuanlove.com/2024/12/19/%E9%B8%BF%E8%92%99-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7/</id>
    <published>2024-12-19T06:29:17.000Z</published>
    <updated>2025-01-08T07:51:05.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个就没啥好说的，有需求就要搞定需求，搞不定需求就搞定提出需求的人嘛</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>相机开发需要使用真机，模拟器目前还是不支持的。这就劝退了一部分开发者。<br>所需要的调用的接口大部分集中在<code>@kit.CameraKit</code>、<code>@kit.AbilityKit</code>中。保存图片时需要用到<code>@kit.ImageKit</code>、<code>@kit.CoreFileKit</code>、<code>@kit.MediaLibraryKit</code>等<br>接下来看下需要做哪些工作：</p><ol><li>获取相机权限</li><li>获取可用相机列表<ol><li>可以在这里监听相机状态(USB相机连接、断开连接、关闭、被占用等)</li><li>选择当前使用的相机</li></ol></li><li>创建相机输入流并打开相机<ol><li>可以创建相机输入流</li><li>可以监听预览输出流状态，包括预览流启动、预览流结束、预览流输出错误</li><li>可以获取相机支持的模式列表(NORMAL_PHOTO,NORMAL_VIDEO,SECURE_PHOTO)</li><li>可以获取当前相机设备支持的所有输出流，如预览流、拍照流、录像流等</li></ol></li><li>会话(Session)管理<ol><li>配置相机的输入流和输出流(分辨路等配置)</li><li>添加闪光灯、调整焦距等配置</li><li>会话切换控制:切换拍照或者录像</li><li>交和开启会话，可以开始调用相机相关功能</li></ol></li><li>预览<ol><li>创建Surface用于预览</li><li>将预览输出流通过SurfaceID与Surface关联</li><li>调用Session.start方法开始预览</li></ol></li><li>拍照<ol><li>创建拍照输出流</li><li>设置拍照photoAvailable的回调，并将拍照的buffer保存为图片。</li><li>参数配置(闪光灯、变焦、焦距等)</li><li>触发拍照</li></ol></li></ol><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="权限处理"><a href="#权限处理" class="headerlink" title="权限处理"></a>权限处理</h3><p>在进入拍照页面之前先申请权限，具体的流程看这里<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/request-app-permissions-V5">申请应用权限</a>，本文不再赘述。</p><h3 id="获取可用相机列表"><a href="#获取可用相机列表" class="headerlink" title="获取可用相机列表"></a>获取可用相机列表</h3><p>首先要获取相机管理实例，这里为了代码看起来清晰，将各个步骤写到了单独的方法中。<br>另外多出使用<code>camera.CameraManager</code>实例，因此定义为了全局变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">TakePhotoPage</span> &#123;<br><br><br>  <span class="hljs-comment">//相机管理</span><br>  <span class="hljs-title function_">getCameraManager</span>(<span class="hljs-attr">context</span>: common.<span class="hljs-property">BaseContext</span>): camera.<span class="hljs-property">CameraManager</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">cameraManager</span>: camera.<span class="hljs-property">CameraManager</span> = camera.<span class="hljs-title function_">getCameraManager</span>(context);<br>    <span class="hljs-keyword">return</span> cameraManager;<br>  &#125;<br><br>  <span class="hljs-comment">//获取可用相机列表</span><br>  <span class="hljs-title function_">getCameraDevices</span>(<span class="hljs-attr">cameraManager</span>: camera.<span class="hljs-property">CameraManager</span>): <span class="hljs-title class_">Array</span>&lt;camera.<span class="hljs-property">CameraDevice</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">cameraArray</span>: <span class="hljs-title class_">Array</span>&lt;camera.<span class="hljs-property">CameraDevice</span>&gt; = cameraManager.<span class="hljs-title function_">getSupportedCameras</span>();<br>    <br>    <span class="hljs-keyword">if</span> (cameraArray != <span class="hljs-literal">undefined</span> &amp;&amp; cameraArray.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">//在这里可以输出一些相机参数，比如相机位置(前置、后置)、相机类型(广角相机、长焦相机)等信息</span><br>      <span class="hljs-keyword">return</span> cameraArray;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">&quot;cameraManager.getSupportedCameras error&quot;</span>);<br>      <span class="hljs-keyword">return</span> [];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 监听相机状态</span><br>  <span class="hljs-title function_">onCameraStatusChange</span>(<span class="hljs-attr">cameraManager</span>: camera.<span class="hljs-property">CameraManager</span>): <span class="hljs-built_in">void</span> &#123;<br>    cameraManager.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;cameraStatus&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err: BusinessError, cameraStatusInfo: camera.CameraStatusInfo</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err !== <span class="hljs-literal">undefined</span> &amp;&amp; err.<span class="hljs-property">code</span> !== <span class="hljs-number">0</span>) &#123;<br>        hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`Callback Error, errorCode: <span class="hljs-subst">$&#123;err.code&#125;</span>`</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">// 如果当通过USB连接相机设备时，回调函数会返回新的相机出现状态</span><br>      <span class="hljs-keyword">if</span> (cameraStatusInfo.<span class="hljs-property">status</span> == camera.<span class="hljs-property">CameraStatus</span>.<span class="hljs-property">CAMERA_STATUS_APPEAR</span>) &#123;<br>        hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`New Camera device appear.`</span>);<br>      &#125;<br>      <span class="hljs-comment">// 如果当断开相机设备USB连接时，回调函数会返回相机被移除状态</span><br>      <span class="hljs-keyword">if</span> (cameraStatusInfo.<span class="hljs-property">status</span> == camera.<span class="hljs-property">CameraStatus</span>.<span class="hljs-property">CAMERA_STATUS_DISAPPEAR</span>) &#123;<br>        hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`Camera device has been removed.`</span>);<br>      &#125;<br>      <span class="hljs-comment">// 相机被关闭时，回调函数会返回相机可用状态</span><br>      <span class="hljs-keyword">if</span> (cameraStatusInfo.<span class="hljs-property">status</span> == camera.<span class="hljs-property">CameraStatus</span>.<span class="hljs-property">CAMERA_STATUS_AVAILABLE</span>) &#123;<br>        hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`Current Camera is available.`</span>);<br>      &#125;<br>      <span class="hljs-comment">// 相机被打开/占用时，回调函数会返回相机不可用状态</span><br>      <span class="hljs-keyword">if</span> (cameraStatusInfo.<span class="hljs-property">status</span> == camera.<span class="hljs-property">CameraStatus</span>.<span class="hljs-property">CAMERA_STATUS_UNAVAILABLE</span>) &#123;<br>        hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`Current Camera has been occupied.`</span>);<br>      &#125;<br>      hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`camera: <span class="hljs-subst">$&#123;cameraStatusInfo.camera.cameraId&#125;</span>`</span>);<br>      hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`status: <span class="hljs-subst">$&#123;cameraStatusInfo.status&#125;</span>`</span>);<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们可以获取到所有可用的相机列表，并且可以根据相机类型、连接类型等过滤掉不适用的相机。<br>在获取到相机列表后，我们默认使用返回列表的第一个相机。  </p><h3 id="创建相机输入流并打开相机"><a href="#创建相机输入流并打开相机" class="headerlink" title="创建相机输入流并打开相机"></a>创建相机输入流并打开相机</h3><p>在这一步我们主要是创建相机的输入流，为后面在<code>XComponent</code>中预览做准备。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">createInput</span>(): camera.<span class="hljs-property">CameraInput</span> | <span class="hljs-literal">undefined</span> &#123;<br><span class="hljs-comment">// 创建相机输入流</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">cameraInput</span>: camera.<span class="hljs-property">CameraInput</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    cameraInput = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameraManager</span>.<span class="hljs-title function_">createCameraInput</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentCamera</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to createCameraInput errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (cameraInput === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>&#125;<br><span class="hljs-comment">// 监听cameraInput错误信息</span><br>cameraInput.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentCamera</span>, <span class="hljs-function">(<span class="hljs-params">error: BusinessError</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Camera input error code: <span class="hljs-subst">$&#123;error.code&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-keyword">return</span> cameraInput;<br>&#125;<br></code></pre></td></tr></table></figure><p>最重要的就一行代码：调用<code>cameraManager.createCameraInput(camera: CameraDevice)</code>创建一个输入流并返回，之后调用返回的输入流的<code>open()</code>方法打开相机，注意该方法是异步的。<br>同样的，我们可以调用<code>cameraManager.getSupportedSceneModes(camera: CameraDevice)</code>来获取相机支持的模式，一般情况下都会支持拍照和录像。<br>之后我们获取设备支持的输出流能力</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">getSupportedOutputCapability</span>(): camera.<span class="hljs-property">CameraOutputCapability</span> | <span class="hljs-literal">undefined</span> &#123;<br><span class="hljs-comment">// 获取相机设备支持的输出流能力</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">cameraOutputCapability</span>: camera.<span class="hljs-property">CameraOutputCapability</span> =<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameraManager</span>.<span class="hljs-title function_">getSupportedOutputCapability</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentCamera</span>, camera.<span class="hljs-property">SceneMode</span>.<span class="hljs-property">NORMAL_PHOTO</span>)<br><br><span class="hljs-keyword">if</span> (!cameraOutputCapability) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;cameraManager.getSupportedOutputCapability error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cameraOutputCapability;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们拿到<code>cameraOutputCapability</code>之后，可以从该对象的<code>previewProfiles</code>、<code>photoProfiles</code>属性中获取到设备支持的分辨率大小。这里我们直接使用<code>1920*1080</code>的分辨率。<br>需要注意的是 <code>previewProfiles</code>和<code>photoProfiles</code>所支持的分辨率不一定是一致的。预览的话只要宽高比一致，分辨率别差的太离谱就可以。  </p><p>之后我们使用选择好的<code>Profile</code>对象来创建拍照输出流和预览输出流</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameraManager</span>.<span class="hljs-title function_">createPhotoOutput</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPhotoProfile</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">previewOutput</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameraManager</span>.<span class="hljs-title function_">createPreviewOutput</span>(previewProfile, <span class="hljs-variable language_">this</span>.<span class="hljs-property">surfaceId</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to createPhotoOutput errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span> === <span class="hljs-literal">undefined</span>) &#123;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，创建预览输出流的时候需要传入 surfaceID，该值来源于组件<code>XComponent</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">private</span> <span class="hljs-attr">mXComponentController</span>: <span class="hljs-title class_">XComponentController</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XComponentController</span>;<br><span class="hljs-title class_">XComponent</span>(&#123;<br><span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;componentId&#x27;</span>,<br><span class="hljs-attr">type</span>: <span class="hljs-title class_">XComponentType</span>.<span class="hljs-property">SURFACE</span>,<br><span class="hljs-attr">controller</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">mXComponentController</span>,<br>&#125;)<br>.<span class="hljs-title function_">onLoad</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">surfaceId</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">mXComponentController</span>.<span class="hljs-title function_">getXComponentSurfaceId</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><p>所以这里我们需要注意一下创建预览输出流的时机</p><h3 id="创建并配置会话"><a href="#创建并配置会话" class="headerlink" title="创建并配置会话"></a>创建并配置会话</h3><p>创建会话也只是一行的就可以搞定，但可能会有异常出现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">createSession</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//创建会话</span><br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameraManager</span>.<span class="hljs-title function_">createSession</span>(camera.<span class="hljs-property">SceneMode</span>.<span class="hljs-property">NORMAL_PHOTO</span>) <span class="hljs-keyword">as</span> camera.<span class="hljs-property">PhotoSession</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to create the session instance. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span> === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 监听session错误信息</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error: BusinessError</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Capture session error code: <span class="hljs-subst">$&#123;error.code&#125;</span>`</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>配置会话主要是添加相机输入流、预览输出流和拍照输出流，最后提交配置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">configSession</span>(<span class="hljs-params">cameraInput: camera.CameraInput, previewOutput: camera.PreviewOutput</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// 开始配置会话</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">beginConfig</span>();<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to beginConfig. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 向会话中添加相机输入流</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">addInput</span>(cameraInput);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to addInput. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 向会话中添加预览输出流</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">addOutput</span>(previewOutput);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to addOutput(previewOutput). errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 向会话中添加拍照输出流</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">addOutput</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to addOutput(photoOutput). errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 提交会话配置</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">commitConfig</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拍照回调和启动会话"><a href="#拍照回调和启动会话" class="headerlink" title="拍照回调和启动会话"></a>拍照回调和启动会话</h3><p>我们先启动会话</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">start</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;Promise returned to indicate the session start success.&#x27;</span>);<br>      &#125;);<br></code></pre></td></tr></table></figure><p>会话启动之后我们就可以进行拍照了。拍照的话需要调用拍照输出流的<code>capture</code>方法  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">takePhoto</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">photoCaptureSetting</span>: camera.<span class="hljs-property">PhotoCaptureSetting</span> = &#123;<br>    <span class="hljs-attr">quality</span>: camera.<span class="hljs-property">QualityLevel</span>.<span class="hljs-property">QUALITY_LEVEL_HIGH</span>, <span class="hljs-comment">// 设置图片质量高</span><br>    <span class="hljs-attr">rotation</span>: camera.<span class="hljs-property">ImageRotation</span>.<span class="hljs-property">ROTATION_0</span> <span class="hljs-comment">// 设置图片旋转角度0</span><br>&#125;<br><span class="hljs-comment">// 使用当前拍照设置进行拍照</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span>.<span class="hljs-title function_">capture</span>(photoCaptureSetting, <span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Failed to capture the photo <span class="hljs-subst">$&#123;err.message&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;Callback invoked to indicate the photo capture request success.&#x27;</span>);<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>但照片内容确不是在该方法中返回，而是需要我们在拍照输出流中添加<code>photoAvailable</code>事件监听，该监听可以在创建拍照输出流之后就添加</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">setPhotoOutputCb</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">//设置回调之后，调用photoOutput的capture方法，就会将拍照的buffer回传到回调中</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;photoAvailable&#x27;</span>, (<span class="hljs-attr">errCode</span>: <span class="hljs-title class_">BusinessError</span>, <span class="hljs-attr">photo</span>: camera.<span class="hljs-property">Photo</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;getPhoto start&#x27;</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`err: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(errCode)&#125;</span>`</span>);<br>      <span class="hljs-keyword">if</span> (errCode || photo === <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;getPhoto failed&#x27;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">let</span> imageObj = photo.<span class="hljs-property">main</span>;<br>      imageObj.<span class="hljs-title function_">getComponent</span>(image.<span class="hljs-property">ComponentType</span>.<span class="hljs-property">JPEG</span>, (<span class="hljs-attr">errCode</span>: <span class="hljs-title class_">BusinessError</span>, <span class="hljs-attr">component</span>: image.<span class="hljs-property">Component</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;getComponent start&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (errCode || component === <span class="hljs-literal">undefined</span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;getComponent failed&#x27;</span>);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>;<br>        <span class="hljs-keyword">if</span> (component.<span class="hljs-property">byteBuffer</span>) &#123;<br>          buffer = component.<span class="hljs-property">byteBuffer</span>;<br>          <span class="hljs-keyword">let</span> filePath = <span class="hljs-title function_">getContext</span>().<span class="hljs-property">cacheDir</span> + <span class="hljs-string">&#x27;/&#x27;</span> + systemDateTime.<span class="hljs-title function_">getTime</span>() + <span class="hljs-string">&#x27;.jpg&#x27;</span><br>          <span class="hljs-keyword">let</span> file = fileIo.<span class="hljs-title function_">openSync</span>(filePath, fileIo.<span class="hljs-property">OpenMode</span>.<span class="hljs-property">READ_WRITE</span> | fileIo.<span class="hljs-property">OpenMode</span>.<span class="hljs-property">CREATE</span>)<br>          fileIo.<span class="hljs-title function_">writeSync</span>(file.<span class="hljs-property">fd</span>, buffer)<br>          fileIo.<span class="hljs-title function_">closeSync</span>(file)<br><br>          <span class="hljs-keyword">let</span> fileUrl = fileUri.<span class="hljs-title function_">getUriFromPath</span>(filePath)<br>          promptAction.<span class="hljs-title function_">showToast</span>(&#123;<span class="hljs-attr">message</span>:fileUrl&#125;)<br><br><br>          <span class="hljs-keyword">let</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>          promptAction.<span class="hljs-title function_">openCustomDialog</span>(&#123;<br>            <span class="hljs-attr">builder</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">saveImageToAlbumDialog</span>(fileUrl, <span class="hljs-function">() =&gt;</span> &#123;<br>                promptAction.<span class="hljs-title function_">closeCustomDialog</span>(id)<br>              &#125;)<br>            &#125;<br>          &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">dialogID</span>) =&gt;</span> &#123;<br>            id = dialogID<br>          &#125;)<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;byteBuffer is null&#x27;</span>);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        imageObj.<span class="hljs-title function_">release</span>();<br>      &#125;);<br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里就简单写了一下处理：拿到 ArrayBuffer 之后写入沙箱文件，然后在弹窗中展示</p><h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>我们创建会话(camera.PhotoSession)之后，可以通过该对象配置闪光灯模式、对焦模式、缩放等</p><h4 id="闪光灯"><a href="#闪光灯" class="headerlink" title="闪光灯"></a>闪光灯</h4><p>首先判断设备是否支持闪光灯，然后再判断支持的闪光灯模式。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">getSupportFlashMode</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">supportFlashMode</span> = []<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>) &#123;<br>     <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-comment">// 判断设备是否支持闪光灯</span><br>   <span class="hljs-keyword">let</span> <span class="hljs-attr">flashStatus</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>   <span class="hljs-keyword">try</span> &#123;<br>     flashStatus = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">hasFlash</span>();<br>   &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>     <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to hasFlash. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>   &#125;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;Returned with the flash light support status:&#x27;</span> + flashStatus);<br><br>   <span class="hljs-keyword">if</span> (flashStatus) &#123;<br>     <span class="hljs-comment">// 判断支持的闪光灯模式</span><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">isFlashModeSupported</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_CLOSE</span>);<br>       <span class="hljs-keyword">if</span> (status) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">supportFlashMode</span>.<span class="hljs-title function_">push</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_CLOSE</span>)<br>       &#125;<br>     &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>       <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to check whether the flash mode is supported. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">isFlashModeSupported</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_OPEN</span>);<br>       <span class="hljs-keyword">if</span> (status) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">supportFlashMode</span>.<span class="hljs-title function_">push</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_OPEN</span>)<br>       &#125;<br>     &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>       <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to check whether the flash mode is supported. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">isFlashModeSupported</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_AUTO</span>);<br>       <span class="hljs-keyword">if</span> (status) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">supportFlashMode</span>.<span class="hljs-title function_">push</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_AUTO</span>)<br>       &#125;<br>     &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>       <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to check whether the flash mode is supported. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">isFlashModeSupported</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_ALWAYS_OPEN</span>);<br>       <span class="hljs-keyword">if</span> (status) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">supportFlashMode</span>.<span class="hljs-title function_">push</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_ALWAYS_OPEN</span>)<br>       &#125;<br>     &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>       <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to check whether the flash mode is supported. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>     &#125;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="连续自动对焦"><a href="#连续自动对焦" class="headerlink" title="连续自动对焦"></a>连续自动对焦</h4><p>也是需要先判断是否支持自动连续对焦，不支持的话只能手动对焦</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">setAutoContinuousFocus</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 判断是否支持连续自动变焦模式</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">focusModeStatus</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">isFocusModeSupported</span>(camera.<span class="hljs-property">FocusMode</span>.<span class="hljs-property">FOCUS_MODE_CONTINUOUS_AUTO</span>);<br>    focusModeStatus = status;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to check whether the focus mode is supported. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (focusModeStatus) &#123;<br>    <span class="hljs-comment">// 设置连续自动变焦模式</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">setFocusMode</span>(camera.<span class="hljs-property">FocusMode</span>.<span class="hljs-property">FOCUS_MODE_CONTINUOUS_AUTO</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to set the focus mode. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>手动对焦则是获取到用户点击的位置，然后调用<code>this.photoSession.setFocusPoint(point: camera.Point)</code>方法进行对焦</p><h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>同样的，需要先获取到支持的缩放范围</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">getZoomRatioRange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 获取相机支持的可变焦距比范围</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">zoomRatioRange</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [];<br>  <span class="hljs-keyword">try</span> &#123;<br>    zoomRatioRange = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">getZoomRatioRange</span>();<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to get the zoom ratio range. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (zoomRatioRange.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">zoomRatioRangeStart</span> = zoomRatioRange[<span class="hljs-number">0</span>]<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">zoomRatioRangeEnd</span> = zoomRatioRange[<span class="hljs-number">1</span>]<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用<code>this.photoSession.setZoomRatio(zoom);</code>设置缩放比</p><h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><p>在拍照结束后需要释放相应的资源</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">await</span> photoSession.<span class="hljs-title function_">stop</span>();<br><br><span class="hljs-comment">// 释放相机输入流</span><br><span class="hljs-keyword">await</span> cameraInput.<span class="hljs-title function_">close</span>();<br><br><span class="hljs-comment">// 释放预览输出流</span><br><span class="hljs-keyword">await</span> previewOutput.<span class="hljs-title function_">release</span>();<br><br><span class="hljs-comment">// 释放拍照输出流</span><br><span class="hljs-keyword">await</span> photoOutput.<span class="hljs-title function_">release</span>();<br><br><span class="hljs-comment">// 释放会话</span><br><span class="hljs-keyword">await</span> photoSession.<span class="hljs-title function_">release</span>();<br><br><span class="hljs-comment">// 会话置空</span><br>photoSession = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="设备旋转"><a href="#设备旋转" class="headerlink" title="设备旋转"></a>设备旋转</h4><p>上面的代码中我们并没有考虑设备旋转问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; display &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.ArkUI&#x27;</span>;   <br><br><span class="hljs-keyword">let</span> initDisplayRotation = display.<span class="hljs-title function_">getDefaultDisplaySync</span>().<span class="hljs-property">rotation</span>;<br><span class="hljs-keyword">let</span> initPreviewRotation = previewOutput.<span class="hljs-title function_">getPreviewRotation</span>(initDisplayRotation * camera.<span class="hljs-property">ImageRotation</span>.<span class="hljs-property">ROTATION_90</span>);<br>previewOutput.<span class="hljs-title function_">setPreviewRotation</span>(initPreviewRotation, <span class="hljs-literal">false</span>);<br>display.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;change&#x27;</span>);<br>display.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  initDisplayRotation = display.<span class="hljs-title function_">getDefaultDisplaySync</span>().<span class="hljs-property">rotation</span>;<br>  <span class="hljs-keyword">let</span> imageRotation = initDisplayRotation * camera.<span class="hljs-property">ImageRotation</span>.<span class="hljs-property">ROTATION_90</span>;<br>  <span class="hljs-keyword">let</span> previewRotation = previewOutput.<span class="hljs-title function_">getPreviewRotation</span>(imageRotation);<br>  previewOutput.<span class="hljs-title function_">setPreviewRotation</span>(previewRotation, <span class="hljs-literal">false</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="在-Worker-线程中使用相机"><a href="#在-Worker-线程中使用相机" class="headerlink" title="在 Worker 线程中使用相机"></a>在 Worker 线程中使用相机</h4><p>一般情况下，设备的性能足以支持我们直接使用相机，但如果要追求极致性能，可以将拍照的一系列流程都放在 Worker 线程中完成，通过宿主线程的即时消息通信完成线程间交互</p><hr><p>具体的代码在<a href="https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/take_photo/TakePhotoPage.ets">https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/take_photo&#x2F;TakePhotoPage.ets</a><br>就不再贴一遍了。<br>上面代码中并没有实现切换摄像头、切换闪光灯、切换分辨率功能，只是做了展示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这个就没啥好说的，有需求就要搞定需求，搞不定需求就搞定提出需求的人嘛&lt;/p&gt;
&lt;h2 id=&quot;大致流程&quot;&gt;&lt;a href=&quot;#大致流程&quot; c</summary>
      
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙--Canvas 图片滑动验证</title>
    <link href="https://blog.huangyuanlove.com/2024/11/28/%E9%B8%BF%E8%92%99-Canvas-%E5%9B%BE%E7%89%87%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/"/>
    <id>https://blog.huangyuanlove.com/2024/11/28/%E9%B8%BF%E8%92%99-Canvas-%E5%9B%BE%E7%89%87%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/</id>
    <published>2024-11-28T14:55:23.000Z</published>
    <updated>2024-12-09T09:39:50.286Z</updated>
    
    <content type="html"><![CDATA[<p>群里有朋友问图片滑块验证码怎么做，就是一张图上扣出来一块，然后拖动这一小块完成拼图。<br>第一个想法就是偷懒一下：直接让设计在图片上抠出来一小块，把这两个图片和抠图的坐标一块下发，用Image或者canvas自己绘制一下，监听一下手指移动，当手指抬起的时候，如果移动的坐标和抠图的坐标误差在指定范围内，就算成功。<br>后来说Android那边是自己处理的，下发整张图片，然后客户端自己抠图，自己处理。<br>Android能做的，鸿蒙应该也能做，这时候就应该掏出来Canvas怼一波了</p><span id="more"></span><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>两个Canvas，一个使用<code>drawImage</code>画整张图片，画出来后，随机两个坐标值使用<code>getImageData</code>获取指定位置的图片内容。然后在这个区域绘制上边框或者填充颜色，告诉用户获取的是这个区域的内容。想上难度的话，不提示这个截取位置也行。<br>在另外一个Canvas上使用<code>putImageData</code>将图片绘制出来，绑定一下移动手势监听，然后不断更新绘制图片的坐标。当抬起手指的时候，对比一下移动的坐标和抠图的坐标，在允许的范围内，判定为成功。<br>结束。打完收工。完结撒花。</p><p><img src="/image/HarmonyOS/slide_code.gif" alt="image.png">  </p><h2 id="绘制形状方式详细解释"><a href="#绘制形状方式详细解释" class="headerlink" title="绘制形状方式详细解释"></a>绘制形状方式详细解释</h2><p>先看下面不需要处理抠图的，这个简单点，我们循序渐进。</p><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>两个Canvas，需要两个<code>CanvasRenderingContext2D</code>分别绘制两个Canvas上的内容。<br>一个能接受的误差值。<br>随机出来的抠图的横纵坐标。<br>抠图的大小。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering2</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><span class="hljs-comment">//允许的误差</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">diffInterval</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span> <br><span class="hljs-comment">//随机抠图的横坐标</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">clip_start_x</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span><br><span class="hljs-comment">//随机抠图的纵坐标</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">clip_start_y</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span><br><span class="hljs-comment">//抠图的宽度</span><br><span class="hljs-keyword">private</span> clip_image_width = <span class="hljs-number">120</span><br><span class="hljs-comment">//抠图的高度</span><br><span class="hljs-keyword">private</span> clip_image_height = <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>这个没啥好说的，Stack里面摞两个Canvas，底部的Canvas画整个图，上面的Canvas画形状。</p><h3 id="整图Canvas"><a href="#整图Canvas" class="headerlink" title="整图Canvas"></a>整图Canvas</h3><p>这里使用的本地图片，理论上讲，使用网络图片应该也能处理。<br>随机坐标时，注意减去抠图的宽度，否则万一随机出来的坐标在绘制完形状之后超出的图片范围就好玩了。<br>这里随机之后绘制了一个三角形。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>   <span class="hljs-comment">//这里用的本地图片</span><br>   <span class="hljs-keyword">let</span> <span class="hljs-attr">imageBitMap</span>: <span class="hljs-title class_">ImageBitmap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageBitmap</span>(<span class="hljs-string">&quot;pages/playground/cat.webp&quot;</span>)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">drawImage</span>(imageBitMap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>   hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;imageBitMap width --&gt; &#x27;</span> + imageBitMap.<span class="hljs-property">width</span>)<br>   hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;imageBitMap height --&gt; &#x27;</span> + imageBitMap.<span class="hljs-property">height</span>)<br><br>   <span class="hljs-comment">//随机两个坐标，注意不要超出图片范围</span><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (imageBitMap.<span class="hljs-property">width</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>))<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (imageBitMap.<span class="hljs-property">height</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>))<br><br>   hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;clip_start_x --&gt; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>)<br>   hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;clip_start_y --&gt; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&#x27;#FFFFFF&#x27;</span><br>   <span class="hljs-comment">//在对应的区域绘制标识，这里画了个三角形，想画其他的自己调整就好</span><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">moveTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span> / <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span> / <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br> &#125;)<br></code></pre></td></tr></table></figure><h3 id="需要滑动的形状"><a href="#需要滑动的形状" class="headerlink" title="需要滑动的形状"></a>需要滑动的形状</h3><p>我们拿到了随机的坐标后，在新的Canvas上绘制相同的形状。<br>这里需要监听手指的滑动，我们使用了<code>priorityGesture</code>来绑定<code>PanGesture</code>。注意这里<strong>滑动最小距离为5vp时识别成功</strong>。<br>这里我们限制了只能横向滑动。想加点难度的话，可以在横纵方向上都能滑动。<br>最后在<code>onActionEnd</code>的时候判断一下移动的坐标是否满足条件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>&#125;)<br>  <span class="hljs-comment">//绑定优先识别手势</span><br>  .<span class="hljs-title function_">priorityGesture</span>(<br>    <span class="hljs-comment">//平移手势，滑动最小距离为5vp时识别成功。</span><br>    <span class="hljs-title class_">PanGesture</span>()<br>      .<span class="hljs-title function_">onActionStart</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>      &#125;)<br>      .<span class="hljs-title function_">onActionUpdate</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//重置一下画布</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">reset</span>()<br><br>        <span class="hljs-comment">//绘制形状，和整图canvas中的形状、大小一致</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">moveTo</span>(event.<span class="hljs-property">offsetX</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>/<span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">lineTo</span>(event.<span class="hljs-property">offsetX</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">lineTo</span>(event.<span class="hljs-property">offsetX</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">lineTo</span>(event.<span class="hljs-property">offsetX</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>/<span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Pink</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">stroke</span>()<br><br>      &#125;)<br>      .<span class="hljs-title function_">onActionEnd</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>        hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView&#x27;</span>, <span class="hljs-string">`onActionEnd <span class="hljs-subst">$&#123;event.offsetX.toString()&#125;</span>`</span>)<br>        <span class="hljs-comment">//判定是否成功</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(event.<span class="hljs-property">offsetX</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>) &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">diffInterval</span>) &#123;<br>          promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;验证成功&#x27;</span> &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;验证失败&#x27;</span> &#125;)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">reset</span>()<br>        &#125;<br>      &#125;)<br>  )<br></code></pre></td></tr></table></figure><p>这种是最简单的，不需要处理图片，只需要绘制形状就好了</p><h2 id="需要处理图片的方式"><a href="#需要处理图片的方式" class="headerlink" title="需要处理图片的方式"></a>需要处理图片的方式</h2><p>比起上面这种，我们只需要多定义一个ImageData就好了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering2</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">diffInterval</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">clip_start_x</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">clip_start_y</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span><br><span class="hljs-keyword">private</span> clip_image_width = <span class="hljs-number">120</span><br><span class="hljs-keyword">private</span> clip_image_height = <span class="hljs-number">120</span><br><span class="hljs-keyword">private</span> imageData?: <span class="hljs-title class_">ImageData</span><br></code></pre></td></tr></table></figure><h3 id="处理抠图"><a href="#处理抠图" class="headerlink" title="处理抠图"></a>处理抠图</h3><p>在绘制整图的Canvas上调用<code>getImageData</code>获取一下抠出来的图片内容就好了。<br>由于ImageData是个正方形，我们这里需要处理成三角形，我没有找到很好的方法，只能对ImageData.data属性进行处理，它是一维数组，保存了相应的颜色数据，数据值范围为0到255。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">imageBitMap</span>: <span class="hljs-title class_">ImageBitmap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageBitmap</span>(<span class="hljs-string">&quot;pages/playground/cat.webp&quot;</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">drawImage</span>(imageBitMap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;imageBitMap width --&gt; &#x27;</span> + imageBitMap.<span class="hljs-property">width</span>)<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;imageBitMap height --&gt; &#x27;</span> + imageBitMap.<span class="hljs-property">height</span>)<br><br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (imageBitMap.<span class="hljs-property">width</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>))<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (imageBitMap.<span class="hljs-property">height</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>))<br><br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;clip_start_x --&gt; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>)<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;clip_start_y --&gt; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">getImageData</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br><br>  <span class="hljs-comment">//在对应的区域绘制标识</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&#x27;#66FFFFFF&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">moveTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span> / <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span> / <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>()<br><br>  <span class="hljs-comment">//将ImageData处理成三角形</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>)&#123;<br>    <span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>.<span class="hljs-property">width</span> * <span class="hljs-number">4</span><br>    <span class="hljs-keyword">let</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>.<span class="hljs-property">height</span><br>    <span class="hljs-keyword">let</span> rate = width / height<br>    <span class="hljs-keyword">let</span> widthCenter = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(width / <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>      <span class="hljs-comment">//第几行</span><br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; width; j++) &#123;<br>        <span class="hljs-comment">//第几列</span><br>        <span class="hljs-keyword">if</span> (j &lt; widthCenter - rate * i / <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>.<span class="hljs-property">data</span>[i * width +j] = <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; widthCenter + rate * i / <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>.<span class="hljs-property">data</span>[i * width +j] = <span class="hljs-number">0</span><br>        &#125;<br><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="绘制抠出来的图"><a href="#绘制抠出来的图" class="headerlink" title="绘制抠出来的图"></a>绘制抠出来的图</h3><p>这个就更简单了，相同的绑定手势方法，相同的判定方法。<br>唯一的变化就是在<code>onActionUpdate</code>回调中使用<code>putImageData</code>绘制图片</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  &#125;)<br>    .<span class="hljs-title function_">priorityGesture</span>(<br>      <span class="hljs-title class_">PanGesture</span>()<br>        .<span class="hljs-title function_">onActionStart</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>        &#125;)<br>        .<span class="hljs-title function_">onActionUpdate</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>          hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView&#x27;</span>, event.<span class="hljs-property">offsetX</span>.<span class="hljs-title function_">toString</span>())<br>          <br>          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">reset</span>()<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">putImageData</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>, event.<span class="hljs-property">offsetX</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>          &#125;<br>        &#125;)<br>        .<span class="hljs-title function_">onActionEnd</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>          hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView&#x27;</span>, <span class="hljs-string">`onActionEnd <span class="hljs-subst">$&#123;event.offsetX.toString()&#125;</span>`</span>)<br><br>          <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(event.<span class="hljs-property">offsetX</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>) &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">diffInterval</span>) &#123;<br>            promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;验证成功&#x27;</span> &#125;)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;验证失败&#x27;</span> &#125;)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">reset</span>()<br>          &#125;<br>        &#125;)<br>    )<br></code></pre></td></tr></table></figure><p>到此，我们就完成了简单的滑动图片验证的功能</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体的流程上面也说过了，这里就不再赘述。<br>我们还可以加大点难度，比如在抠图后不在原图上提示范围，让使用者自己找。<br>比如我们还可以将抠出来的图镜像一下，让使用者自己找。<br>比如我们还可以将抠出来的图隔像素点抽样一下。<br>比如我们还可以将抠出来的图中的像素调整一下颜色。<br>。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;群里有朋友问图片滑块验证码怎么做，就是一张图上扣出来一块，然后拖动这一小块完成拼图。&lt;br&gt;第一个想法就是偷懒一下：直接让设计在图片上抠出来一小块，把这两个图片和抠图的坐标一块下发，用Image或者canvas自己绘制一下，监听一下手指移动，当手指抬起的时候，如果移动的坐标和抠图的坐标误差在指定范围内，就算成功。&lt;br&gt;后来说Android那边是自己处理的，下发整张图片，然后客户端自己抠图，自己处理。&lt;br&gt;Android能做的，鸿蒙应该也能做，这时候就应该掏出来Canvas怼一波了&lt;/p&gt;</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙-那些年我们踩过的坑-下</title>
    <link href="https://blog.huangyuanlove.com/2024/11/11/%E9%B8%BF%E8%92%99-%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E4%B8%8B/"/>
    <id>https://blog.huangyuanlove.com/2024/11/11/%E9%B8%BF%E8%92%99-%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E4%B8%8B/</id>
    <published>2024-11-11T07:33:33.000Z</published>
    <updated>2024-11-14T02:51:56.267Z</updated>
    
    <content type="html"><![CDATA[<p>书接上回，在上一篇文章中介绍了 ForEach循环渲染和自绘制输入框遇到的坑，这里聊一下 字面量对象和类对象 以及 自定义 Dialog 的坑。</p><span id="more"></span><p>先从简单的Dialog 开始，这里没有很深入的讲解，只是一些注意点以及官方推荐用法</p><h2 id="CustomDialogController"><a href="#CustomDialogController" class="headerlink" title="CustomDialogController"></a>CustomDialogController</h2><p>先说结论：在使用<code>CustomDialog</code>和<code>CustomDialogController</code>做自定义弹窗时，只能作为被<code>@Component</code>修饰的自定义组件的成员变量，甚至可以写在组件的点击事件中，但不能写到单纯的方法中。因为它需要 UIContext 上下文</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>正常情况：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">DialogControllerPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br>  <span class="hljs-attr">dialogID</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">dialogController</span>: <span class="hljs-title class_">CustomDialogController</span> | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDialogController</span>(&#123;<br>    <span class="hljs-attr">builder</span>: <span class="hljs-title class_">CustomDialogExample</span>(&#123;<br>      <span class="hljs-attr">cancel</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>      <span class="hljs-attr">confirm</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>    &#125;),<br>  &#125;)<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;在 Click 事件中定义&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)<br>        .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)<br>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> <span class="hljs-attr">dialogController</span>: <span class="hljs-title class_">CustomDialogController</span> | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDialogController</span>(&#123;<br>            <span class="hljs-attr">builder</span>: <span class="hljs-title class_">CustomDialogExample</span>(&#123;<br>              <span class="hljs-attr">cancel</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>              &#125;,<br>              <span class="hljs-attr">confirm</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>              &#125;,<br>            &#125;),<br>          &#125;)<br>          dialogController.<span class="hljs-title function_">open</span>()<br>        &#125;)<br>      <br>      <span class="hljs-comment">//在自定义组件中定义</span><br>      <span class="hljs-title class_">CustomDialogView</span>()<br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;在页面中定义&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)<br>        .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)<br>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogController</span>?.<span class="hljs-title function_">open</span>()<br>        &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CustomDialogView</span>&#123;<br>  <span class="hljs-attr">dialogController</span>: <span class="hljs-title class_">CustomDialogController</span> | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDialogController</span>(&#123;<br>    <span class="hljs-attr">builder</span>: <span class="hljs-title class_">CustomDialogExample</span>(&#123;<br>      <span class="hljs-attr">cancel</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>      <span class="hljs-attr">confirm</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>    &#125;),<br>  &#125;)<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;在自定义组件中定义&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>      .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)<br>      .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)<br>      .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogController</span>?.<span class="hljs-title function_">open</span>()<br>      &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这三种情况都是可以正常弹出弹窗的，但当我们把<code>CustomDialogController</code>写在普通方法中时</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">showDialog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">dialogController</span>: <span class="hljs-title class_">CustomDialogController</span> | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDialogController</span>(&#123;<br>    <span class="hljs-attr">builder</span>: <span class="hljs-title class_">CustomDialogExample</span>(&#123;<br>      <span class="hljs-attr">cancel</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>      <span class="hljs-attr">confirm</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>    &#125;),<br>  &#125;)<br>  dialogController.<span class="hljs-title function_">open</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里会报一个错误，应用会崩溃，报错信息挺长的，这里截取了一部分</p><blockquote><p>Pid:25224<br>Uid:20020185<br>Process name:com.huangyuanlove.arkui_demo<br>Process life time:47s<br>Reason:Signal:SIGSEGV(SEGV_MAPERR)@0x00000000000008b0  probably caused by NULL pointer dereference<br>Fault thread info:<br>Tid:25224, Name:love.arkui_demo<br>#00 pc 00000000029cfd70 &#x2F;system&#x2F;lib64&#x2F;platformsdk&#x2F;libace_compatible.z.so(OHOS::Ace::Framework::JSCustomDialogController::JsOpenDialog(OHOS::Ace::Framework::JsiCallbackInfo const&amp;)+8)(1a64ce74d582cc151101042697df670d)<br>#01 pc 00000000009a8cb0 &#x2F;system&#x2F;lib64&#x2F;platformsdk&#x2F;libace_compatible.z.so(panda::Local<a href="panda::JSValueRef">panda::JSValueRef</a> OHOS::Ace::Framework::JsiClass<a href="OHOS::Ace::Framework::JSCustomDialogController">OHOS::Ace::Framework::JSCustomDialogController</a>::InternalJSMemberFunctionCallback<a href="OHOS::Ace::Framework::JSCustomDialogController">OHOS::Ace::Framework::JSCustomDialogController</a>(panda::JsiRuntimeCallInfo*)+2148)(1a64ce74d582cc151101042697df670d)<br>#02 pc 00000000004dc50c &#x2F;system&#x2F;lib64&#x2F;platformsdk&#x2F;libark_jsruntime.so(panda::Callback::RegisterCallback(panda::ecmascript::EcmaRuntimeCallInfo*)+456)(3499a0e0c3b8b8dc50b1a4589295965e)</p></blockquote><p>我想这可能就是为啥需要在<code>@CustomDialog</code>修饰的 struct 中声明一个<code>CustomDialogController</code>变量的原因。</p><h3 id="官方推荐方案"><a href="#官方推荐方案" class="headerlink" title="官方推荐方案"></a>官方推荐方案</h3><p>在官方文档中有一个 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-uicontext-custom-dialog-V5">不依赖UI组件的全局自定义弹窗 (推荐)</a>。虽然说是<strong>不依赖UI组件</strong>，但实际上还是使用的<code>UIContext</code>这个上下文获取到<code>promptAction</code>，调用<code>promptAction.openCustomDialog</code>方法来实现的弹窗。<br>吐槽归吐槽，先看下用法，看完了再评价也不迟。<br>这里有两种方案，一种是传入<code>ComponentContent</code>对象，这个方案在 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-uicontext-custom-dialog-V5">不依赖UI组件的全局自定义弹窗 (推荐)</a>这里有详细介绍<br>另外一种方案是传入<code> promptAction.CustomDialogOptions</code>,这种方案是在<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-promptaction-V5">@ohos.promptAction (弹窗)</a> API 参考中介绍的。</p><h4 id="传入ComponentContent对象"><a href="#传入ComponentContent对象" class="headerlink" title="传入ComponentContent对象"></a>传入<code>ComponentContent</code>对象</h4><p>创建<code>ComponentContent</code>对象需要一个<code>UIContext</code>对象，一个<code>wrapBuilder</code>以及<code>wrapBuilder</code>中需要的参数对象。</p><ul><li>UIContext对象可以在页面中通过<code>this.getUIContext()</code>获取。  </li><li><code>wrapBuilder</code>需要一个全局被@Build修饰的方法。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">glaobleConfirmOrCancelDialogBuilder1</span>(<span class="hljs-params">dialogData: DialogData</span>) &#123;<br>  <span class="hljs-title class_">Column</span>() &#123;<br>    <span class="hljs-comment">//这里写弹窗中的布局</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们可以在某个组件的点击事件中展示弹窗</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">.<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">dialogData</span>: <span class="hljs-title class_">DialogData</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogData</span>()<br>  dialogData.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;推荐方案 一&#x27;</span><br>  dialogData.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;使用  promptAction.openCustomDialog&#x27;</span><br><br><br>  <span class="hljs-keyword">let</span> uiContext = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>();<br>  <span class="hljs-keyword">let</span> promptAction = uiContext.<span class="hljs-title function_">getPromptAction</span>();<br><br>  <span class="hljs-keyword">let</span> contentNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentContent</span>(uiContext, <span class="hljs-title function_">wrapBuilder</span>(glaobleConfirmOrCancelDialogBuilder1), dialogData);<br>  dialogData.<span class="hljs-property">onCancel</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    promptAction.<span class="hljs-title function_">closeCustomDialog</span>(contentNode)<br><br>  &#125;<br>  dialogData.<span class="hljs-property">onConfirm</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    promptAction.<span class="hljs-title function_">closeCustomDialog</span>(contentNode)<br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    promptAction.<span class="hljs-title function_">openCustomDialog</span>(contentNode);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> message = (error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>).<span class="hljs-property">message</span>;<br>    <span class="hljs-keyword">let</span> code = (error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>).<span class="hljs-property">code</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`OpenCustomDialog args error code is <span class="hljs-subst">$&#123;code&#125;</span>, message is <span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>  &#125;;<br>&#125;)<br></code></pre></td></tr></table></figure><p>当然，在调用<code>openCustomDialog</code>还有第二个可选参数<code>promptAction.BaseDialogOptions</code>,相应的介绍在<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-promptaction-V5#basedialogoptions11">这里</a></p><h4 id="传入CustomDialogOptions"><a href="#传入CustomDialogOptions" class="headerlink" title="传入CustomDialogOptions"></a>传入<code>CustomDialogOptions</code></h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">.<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">dialogData</span>: <span class="hljs-title class_">DialogData1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogData1</span>()<br>  dialogData.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;推荐方案二&#x27;</span><br>  dialogData.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;使用  promptAction.openCustomDialog&#x27;</span><br>  dialogData.<span class="hljs-property">onCancel</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    promptAction.<span class="hljs-title function_">closeCustomDialog</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogID</span>)<br>  &#125;<br>  dialogData.<span class="hljs-property">onConfirm</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    promptAction.<span class="hljs-title function_">closeCustomDialog</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogID</span>)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getPromptAction</span>().<span class="hljs-title function_">openCustomDialog</span>(&#123;<br>    <span class="hljs-attr">builder</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">confirmOrCancelDialogBuilder1</span>(dialogData)<br>    &#125;,<br><br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">dialogID: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogID</span> = dialogID<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里展示弹窗的时候会返回一个dialogID，我们在关闭弹窗的时候需要传入这个id。</p><h2 id="字面量对象与类对象"><a href="#字面量对象与类对象" class="headerlink" title="字面量对象与类对象"></a>字面量对象与类对象</h2><p>对应的英文是plain (literal) objects,class (constructor) objects，但是在不知道该怎么优雅的翻译，就先这么叫吧。<br>在 ArkTS 中，创建的每个字面量对象都必须有对应的类型，比如</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> tmpUser = &#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;123&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>直接这么写会报错，提示：<strong>Object literal must correspond to some explicitly declared class or interface (arkts-no-untyped-obj-literals) <ArkTSCheck></strong><br>也就是说我们必须要先定义一个<code>class</code> 或者 <code>interface</code>,但是这里需要注意一下，我们直接使用字面量语法创建对应的<code>class</code>对象时，要求该<code>class</code>对象中不能声明方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserInterface</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserWithOutMethod</span>&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span> =<span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserWithMethod</span>&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span> =<span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-title function_">getInfo</span>(<span class="hljs-params"></span>)&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&#x27;UserWithMethod&#x27;</span>,<span class="hljs-string">&#x27;getInfo&#x27;</span>)<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">userInterface</span>: <span class="hljs-title class_">UserInterface</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;123&quot;</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">userWithOutMethod</span>: <span class="hljs-title class_">UserWithOutMethod</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;123&quot;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">userWithMethod</span>: <span class="hljs-title class_">UserWithMethod</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;123&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p><code>userInterface</code> 和 <code>userWithOutMethod</code>都是正常的，但<code>userWithMethod</code>会报错，提示<code>Property &#39;getInfo&#39; is missing in type &#39;&#123; name: string; &#125;&#39; but required in type &#39;UserWithMethod&#39;</code><br><img src="/image/HarmonyOS/%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E8%B1%A11.png" alt="字面量语法创建含有方法的对象错误信息"><br>即使我们把这个方法补上，也是会提示错误：<code>Object literal must correspond to some explicitly declared class or interface</code><br><img src="/image/HarmonyOS/%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E8%B1%A12.png" alt="字面量语法创建含有方法的对象错误信息">  </p><p>不过话又说回来，为啥要用字面量的语法创建类对象嘞？用<code>new</code>关键字它不香么？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> userWithMethod = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserWithMethod</span>()<br></code></pre></td></tr></table></figure><h4 id="小坑"><a href="#小坑" class="headerlink" title="小坑"></a>小坑</h4><p>不过对于上面包含方法的类，也有其他方案，比如通过<code>as</code>关键字强转</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> userStr =  <span class="hljs-string">`&#123;&quot;name&quot;:&quot;123&quot;&#125;`</span><br><span class="hljs-keyword">let</span> userWithMethodJSON = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(userStr) <span class="hljs-keyword">as</span>  <span class="hljs-title class_">UserWithMethod</span><br>hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&#x27;UseASPage&#x27;</span>,userWithMethodJSON.<span class="hljs-property">name</span>)<br></code></pre></td></tr></table></figure><p>这样的话，我们是可以获取到对象的<code>name</code>属性，也能正常使用，<br>但是，不能调用这个对象的<code>getInfo()</code>方法，会崩溃，报错提示<code>Error message:is not callable</code>.<br>这个也挺好理解：</p><blockquote><p>使用<code>JSON.parse(userStr) as  UserWithMethod</code>这种方式得到的对象实际上是字面量对象，这个对象中并没有<code>getInfo()</code>方法，它的原型链上也没有这个方法，所以就会报错。 </p></blockquote><p>为啥 IDE 不给提示嘞？那就不知道了<br>当然，我们也有方法将字面量对象转为类对象，使得我们可以调用其方法：使用<code>&quot;class-transformer&quot;: &quot;^0.5.1&quot;</code> 这个三方库，github 地址(<a href="https://github.com/typestack/class-transformer)[https://github.com/typestack/class-transformer],%E4%BD%86%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%BA%93%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84ohpm%E5%BA%93%EF%BC%8C%E8%99%BD%E7%84%B6%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%9C%A8">https://github.com/typestack/class-transformer)[https://github.com/typestack/class-transformer],但要注意的是，这个库不是一个标准的ohpm库，虽然它可以在</a> ArkTS 里面使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; plainToClass &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;class-transformer&#x27;</span>;<br><span class="hljs-keyword">let</span> userStr = <span class="hljs-string">`&#123;&quot;name&quot;:&quot;123&quot;&#125;`</span><br><span class="hljs-keyword">let</span> userWithMethodJSON = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(userStr) <span class="hljs-keyword">as</span> <span class="hljs-title class_">UserWithMethod</span><br><span class="hljs-keyword">let</span> tmp = <span class="hljs-title function_">plainToClass</span>(<span class="hljs-title class_">UserWithMethod</span>, userWithMethodJSON)<br>tmp.<span class="hljs-title function_">getInfo</span>()<br></code></pre></td></tr></table></figure><p>这样就正常了。</p><h3 id="另外一个坑"><a href="#另外一个坑" class="headerlink" title="另外一个坑"></a>另外一个坑</h3><p>还记得上一篇中提到的状态管理装饰器 <code>@Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化</code>么？<br>这里还有一个小坑，使用<code>as强转</code>或者使用<code>plainToClass</code>方法创建的对象的属性发生变化时，是无法被<code>@ObjectLink装饰器</code>观察到的。<br>举个例子，我们有一个嵌套类，使用<code>@Observed</code>装饰</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstLevel</span> &#123;<br>  <span class="hljs-attr">time</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">secondLevel</span>: <span class="hljs-title class_">SecondLevel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondLevel</span>()<br>&#125;<br><br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondLevel</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>再定义几个赋值的方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@State</span> firstLevel?:<span class="hljs-title class_">FirstLevel</span> = <span class="hljs-literal">undefined</span><br> <span class="hljs-title function_">initWithNew</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstLevel</span>()<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">time</span> = systemDateTime.<span class="hljs-title function_">getTime</span>()<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">secondLevel</span>:<span class="hljs-title class_">SecondLevel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondLevel</span>()<br>  secondLevel.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;new SecondLevel&#x27;</span><br>  secondLevel.<span class="hljs-property">age</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span> = secondLevel<br>&#125;<br><br><span class="hljs-title function_">initWithAs</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">secondLevel</span>:<span class="hljs-title class_">SecondLevel</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;as SecondLevel&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span> = &#123;<br>    <span class="hljs-attr">time</span>:systemDateTime.<span class="hljs-title function_">getTime</span>(),<br>    <span class="hljs-attr">secondLevel</span>:secondLevel<br>  &#125;<br>&#125;<br><span class="hljs-title function_">initWithPlainToText</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">`&#123;&quot;time&quot;:<span class="hljs-subst">$&#123;systemDateTime.getTime()&#125;</span>,&quot;secondLevel&quot;:&#123;&quot;name&quot;:&quot;PlainToText<span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>)&#125;</span>&quot;,&quot;age&quot;:<span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>)&#125;</span>&#125;&#125;`</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">tmp</span>:<span class="hljs-title class_">FirstLevel</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str) <span class="hljs-keyword">as</span> <span class="hljs-title class_">FirstLevel</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span> = <span class="hljs-title function_">plainToClass</span>(<span class="hljs-title class_">FirstLevel</span>,tmp)<br>&#125;<br></code></pre></td></tr></table></figure><p>两个用于展示数据的自定义组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-meta">@Component</span><br>struct  <span class="hljs-title class_">ShowFistLevel</span>&#123;<br>  <span class="hljs-meta">@Watch</span>(<span class="hljs-string">&#x27;onFirstLevelChange&#x27;</span>) <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">firstLevel</span>:<span class="hljs-title class_">FirstLevel</span><br>  <span class="hljs-title function_">onFirstLevelChange</span>(<span class="hljs-params"></span>)&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;UseASPage&#x27;</span>, <span class="hljs-string">&#x27;onFirstLevelChange&#x27;</span>)<br>  &#125;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>()&#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">time</span>.<span class="hljs-title function_">toString</span>())<br>      <span class="hljs-title class_">ShowSecondLevel</span>(&#123;<span class="hljs-attr">secondLevel</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>&#125;)<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">15</span>)<br>    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&quot;#e7e7e7e7&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br>struct  <span class="hljs-title class_">ShowSecondLevel</span>&#123;<br>  <span class="hljs-meta">@Watch</span>(<span class="hljs-string">&#x27;onSecondLevelChange&#x27;</span>) <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">secondLevel</span>:<span class="hljs-title class_">SecondLevel</span><br>  <span class="hljs-title function_">onSecondLevelChange</span>(<span class="hljs-params"></span>)&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;UseASPage&#x27;</span>, <span class="hljs-string">&#x27;onSecondLevelChange&#x27;</span>)<br>  &#125;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>()&#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">name</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">age</span>.<span class="hljs-title function_">toString</span>())<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">15</span>)<br>    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&quot;#e7e7e7e7&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，渲染嵌套类的组件需要和类对象的层级相同，不然也不会刷新。<br>比如这里<code>FirstLevel</code>类中有<code>SecondLevel</code>类型属性，就需要写成上面这样：拆成两个组件，在<code>ShowFistLevel</code>组件中引用<code>ShowSecondLevel</code>,而不能这样写</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct  <span class="hljs-title class_">ShowFistLevel</span>&#123;<br>  <span class="hljs-meta">@Watch</span>(<span class="hljs-string">&#x27;onFirstLevelChange&#x27;</span>) <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">firstLevel</span>:<span class="hljs-title class_">FirstLevel</span><br>  <span class="hljs-title function_">onFirstLevelChange</span>(<span class="hljs-params"></span>)&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;UseASPage&#x27;</span>, <span class="hljs-string">&#x27;onFirstLevelChange&#x27;</span>)<br>  &#125;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>()&#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">time</span>.<span class="hljs-title function_">toString</span>())<br>      <span class="hljs-comment">//这里</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">name</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">age</span>.<span class="hljs-title function_">toString</span>())<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">15</span>)<br>    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&quot;#e7e7e7e7&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样合并成一个组件后，其中的<code>name</code>和<code>age</code>属性发生变化时，<strong>并不能刷新页面</strong></p><p>然后我们写个页面测试一下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><br><br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Column</span>() &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;使用New&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initWithNew</span>()<br>      &#125;)<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;使用PlainToClass&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initWithPlainToText</span>()<br>      &#125;)<br><br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;使用As&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initWithAs</span>()<br>      &#125;)<br>    &#125;<br><br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改time属性&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>)&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">time</span> = systemDateTime.<span class="hljs-title function_">getTime</span>()<br>        &#125;<br>      &#125;)<br><br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改 name、age 属性&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;新名字 &#x27;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">age</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)<br>        &#125;<br>      &#125;)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>)&#123;<br>      <span class="hljs-title class_">ShowFistLevel</span>(&#123;<span class="hljs-attr">firstLevel</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>&#125;)<br>    &#125;<br><br>  &#125;<br>  .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>  .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>点击<code>使用New</code>后，再点击修改属性，可以看到页面刷新了<br>这时候点击<code>使用PlainToClass</code>后，页面也刷新了，但这时候点击<code>修改time属性</code>,页面会刷新，但点击<code>修改 name、age 属性</code>，页面是没有刷新的。但我们多次点击<code>使用PlainToClass</code>时，页面是可以刷新的。<br>点击使用<code>使用As</code>后，页面也刷新了，，但这时候点击<code>修改time属性</code>,页面会刷新，但点击<code>修改 name、age 属性</code>，页面是没有刷新的。但我们多次点击<code>使用As</code>时，页面是可以刷新的。</p><p>也就是说我们使用<code>PlainToClass</code>和<code>as</code> 这两种方式创建出来的对象，会使得<code>@Observed装饰器和@ObjectLink装饰器</code>失效。这是开发过程中需要注意的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>使用<code>CustomDialogController</code>做弹窗展示时，需要在组件中创建<code>CustomDialogController</code>对象，至少在 api12 上是这样的。</li><li>不想使用<code>CustomDialogController</code>的话，可以使用<code>promptAction.openCustomDialog</code>做弹窗展示，当时，它是依赖<code>UIContext</code>这个上下文。注意不要和<code>Context</code>弄混了</li><li>注意字面量对象和类对象。使用<code>as</code>将字面量对象转为类对象时，无法使用类本身的方法，可以使用<strong>class-transformer中的plainToClass</strong>创建类对象，这样可以调用对象的方法</li><li>使用<code>PlainToClass</code>和<code>as</code> 这两种方式创建出来的对象，会使得<code>@Observed装饰器和@ObjectLink装饰器</code>失效。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;书接上回，在上一篇文章中介绍了 ForEach循环渲染和自绘制输入框遇到的坑，这里聊一下 字面量对象和类对象 以及 自定义 Dialog 的坑。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙--那些年我们踩过的坑(上)</title>
    <link href="https://blog.huangyuanlove.com/2024/11/09/%E9%B8%BF%E8%92%99-%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E4%B8%8A/"/>
    <id>https://blog.huangyuanlove.com/2024/11/09/%E9%B8%BF%E8%92%99-%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E4%B8%8A/</id>
    <published>2024-11-09T06:16:16.000Z</published>
    <updated>2024-11-11T07:32:04.270Z</updated>
    
    <content type="html"><![CDATA[<p>写了这么长时间的ArkTs,一个应用上架了,另外一个应用也快要提交审核了。记录一下自己踩过的坑以及对应的解决方案,大家可以借鉴一下,少走一些弯路。但也不一定,万一我的方法是另外一条弯路嘞~<br>不过话又说回来,再过几个版本说不定官方就把这些坑填上了。。  </p><span id="more"></span><h2 id="自绘制编辑框"><a href="#自绘制编辑框" class="headerlink" title="自绘制编辑框"></a>自绘制编辑框</h2><p>输入验证码的输入框,由于有些样式需要定制,使用<code>TextInput</code>满足不了需求(有没有一种可能是因为我菜？),于是就按照<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/use-inputmethod-in-custom-edit-box-V5">在自绘编辑框中使用输入法</a>中的介绍,通过<code>InputMethodController.on(&#39;insertText&#39;)</code>监听键盘输入, 使用多个<code>Text</code>来展示输入的验证码,具体文章可以看<a href="https://juejin.cn/post/7414024083443236927">这里</a>。<br>写起来也挺简单,带着业务跑了一下也挺好,直到后来这个组件被用到了验证码登录的情景:用户输入手机号,点击获取验证码按钮,请求服务器发送验证码,服务器返回成功,跳转到输入验证码页面,弹起键盘,用户输入验证码。  </p><p>中规中矩的流程,四四方方的需求。但是,键盘弹起来之后输入的内容不会展示。呵呵哒,在其他业务上表现正常,为啥在这里就不正常？<del>首先排除控件有bug</del> 首先怀疑控件问题,整个playground工程,精简业务流程后就留下一个输入框,一个按钮,点击按钮后跳转输入验证码页面,这个页面也只留下封装的控件。<br>简单走一下流程,果然键盘弹出来了,但输入内容后没有展示出来。</p><p>一开始以为是监听失败了,debug,加日志后发现是<code>InputMethodController.attach</code>失败了,报了<code>&#123;&quot;code&quot;:12800009&#125;</code>错误码,查问但发现该错误码是<code>input method client is detached.</code>当时就麻了:我要进行<strong>attach</strong>操作,你告诉我已经<strong>detached</strong>。 emmm  </p><p>后来发现是其他业务上是点击按钮或者其他操作之后直接发送验证码,然后跳转到输入验证码页面。而登录需要先输入手机号码,再跳转到输入验证码页面。当网络不好的时候,上个页面跳转之前键盘完全收起来,在输入验证码页面再调起键盘就正常。 </p><p>这里有两个解决方案:<br>方案一:在控件中延迟一定时间后再进行<strong>attach</strong>操作<br>方案二:展示的时候使用TextInput,可以看<a href="https://juejin.cn/post/7413607758577106978">这里</a></p><h2 id="Foreach循环渲染刷新"><a href="#Foreach循环渲染刷新" class="headerlink" title="Foreach循环渲染刷新"></a>Foreach循环渲染刷新</h2><p>列表渲染大部分甚至绝大部分都是使用的ForEach循环渲染,本着磨刀不误砍柴工的原则,先看文档,了解注意事项 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-rendering-control-foreach-V5#%E6%B8%B2%E6%9F%93%E7%BB%93%E6%9E%9C%E9%9D%9E%E9%A2%84%E6%9C%9F">ForEach:循环渲染</a>。<br>文档中提到:<strong>在ForEach组件进行非首次渲染时,它会检查新生成的键值是否在上次渲染中已经存在。如果键值不存在,则会创建一个新的组件；如果键值存在,则不会创建新的组件,而是直接渲染该键值所对应的组件</strong>。也就是说,我们如果想要刷新某一项,需要改变对应的生成的key,当然也提供了默认的生成规则:</p><blockquote><p>默认的键值生成函数,即(item: Object, index: number) &#x3D;&gt; { return index + ‘__’ + JSON.stringify(item); }。</p></blockquote><p>一般情况下, 默认的生成函数就够用了。</p><p>但我还是遇到了坑,这里先放结论:<strong>key一旦生成了,再去修改item的属性(假如item是个字面量对象),这个key也不会更新</strong>。</p><p>这就会遇到一些比较恶心的问题:当我们想要单独刷新某一项时,需要自已定义键值函数,单独改变这一项参与生成键值函数变量的值,比如自定义的键值生成函数<code>(item: Object, index: number) =&gt; &#123; return index + &#39;__&#39; + item.id +&#39;__&#39; +item.updateTime  ; &#125;</code>,并且这里的item必须是被<code>@Observed</code>修饰的class,并且每一个子组件都必须是自定义组件,并且组件内部的数据(也就是这个 item 类型的变量)需要使用<code>@ObjectLink</code>修饰。<br>这是因为@State只能观察到简单的数据类型数组数据源变化,对于自定义类,嵌套类,是观察不到的,需要使用<code>@Observed</code>和<code>@ObjectLink</code>来实现这种深度观察。</p><p>关于这两个装饰器可以看这里 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-observed-and-objectlink-V5">@Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化</a></p><p>举个例子<br>先定义一个普通的数据类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ForeachModel</span>&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>=<span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">defaultSelect</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>页面也很简单,顶部三个按钮操作数据,下面就是一个ForEach循环渲染的列表;自定义的键值生成函数就是index和属性name、属性defaultSelect字符串连接。<br>列表内容也很简单,一个展示<code>name</code>属性的<code>Text</code>组件,一个展示<code>defaultSelect</code>属性的<code>Checkbox</code>组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">ForeachPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">foreachModelList</span>: <span class="hljs-title class_">ForeachModel</span>[] = []<br><br>  <span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initData</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">initData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span> = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">ForeachModel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForeachModel</span>()<br>      model.<span class="hljs-property">name</span> = <span class="hljs-string">`第 <span class="hljs-subst">$&#123;i&#125;</span> 项`</span><br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">false</span><br>      &#125;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>.<span class="hljs-title function_">push</span>(model)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>     <span class="hljs-comment">//顶部的三个操作函数</span><br>      <span class="hljs-title class_">Row</span>() &#123;<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;重新赋值&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initData</span>()<br>        &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;改变最后一项的值&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>].<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;改变后的值&#x27;</span><br>        &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;添加一项&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">ForeachModel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForeachModel</span>()<br>          model.<span class="hljs-property">name</span> = <span class="hljs-string">`第 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.foreachModelList.length&#125;</span> 项`</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>.<span class="hljs-title function_">push</span>(model)<br>        &#125;)<br><br>      &#125;<br><br>      <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>, <span class="hljs-function">(<span class="hljs-params">model: ForeachModel</span>) =&gt;</span> &#123;<br>        <br>        <span class="hljs-title class_">Row</span>() &#123;<br>          <span class="hljs-title class_">Text</span>(model.<span class="hljs-property">name</span>)<br>          <span class="hljs-title class_">Checkbox</span>().<span class="hljs-title function_">select</span>(model.<span class="hljs-property">defaultSelect</span>).<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">checked: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> &#123;<br>            model.<span class="hljs-property">defaultSelect</span> = checked<br>            hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, <span class="hljs-string">`checked <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(model.name)&#125;</span>`</span>)<br><br>          &#125;)<br>        &#125;<br>      &#125;, <span class="hljs-function">(<span class="hljs-params">item: ForeachModel, index: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> key = index + <span class="hljs-string">&#x27;__&#x27;</span> + item.<span class="hljs-property">name</span> +<span class="hljs-string">&#x27;__&#x27;</span>+item.<span class="hljs-property">defaultSelect</span>;<br>        <span class="hljs-keyword">return</span> key<br>      &#125;)<br><br>    &#125;<br>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/image/HarmonyOS/foreach_render_a.gif" alt="ForEach循环渲染_a"><br>gif图中有几个现象:</p><ol><li>当点击<code>添加一项</code>的时候,页面可以刷新,因为<code>@State</code>能观察到数组长度的变化从而刷新页面。</li><li>当<code>添加一项</code>后,点击<code>重新赋值</code>,页面可以刷新,因为数组长度发生了变化,而<code>@State</code>能观察到数组长度的变化从而刷新页面。</li><li>当点击<code>改变最后一项的值</code>时,页面并没有刷新,因为<code>@State</code>观察不到对象内部属性变化</li><li>先点击<code>改变最后一项的值</code>,再点击<code>添加一项</code>时,会发现最后一项内容发生了变化,并且新增了一项。因为数组长度发生变化,页面刷新。刷新时发现ForEach子组件的key发生了变化,重新渲染。</li><li>当点击某项的选择框,改变选中状态后,不管是点击修<code>改变最后一项的值</code>,还是<code>添加一项</code>、<code>重新赋值</code>都不会刷新其选中状态。</li></ol><p>对于第三项,我们只需要使用<code>@Observed</code>和<code>@ObjectLink</code>就可以解决:<br>修改后:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">SimpleView</span>&#123;<br>  <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">model</span>:<span class="hljs-title class_">ForeachModel</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">name</span>)<br>      <span class="hljs-title class_">Checkbox</span>().<span class="hljs-title function_">select</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">defaultSelect</span>).<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">checked: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">defaultSelect</span> = checked<br>        hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, <span class="hljs-string">`checked <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-variable language_">this</span>.model.name)&#125;</span>`</span>)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ForeachModel</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">defaultSelect</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">//循环渲染</span><br><span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>, <span class="hljs-function">(<span class="hljs-params">model: ForeachModel</span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">SimpleView</span>(&#123;<span class="hljs-attr">model</span>:model&#125;)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">item: ForeachModel, index: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> key = index + <span class="hljs-string">&#x27;__&#x27;</span> + item.<span class="hljs-property">name</span> +<span class="hljs-string">&#x27;__&#x27;</span>+item.<span class="hljs-property">defaultSelect</span>;<br>    <span class="hljs-keyword">return</span> key<br>&#125;)<br></code></pre></td></tr></table></figure><p>修改成这种形式之后,点击<code>改变最后一项的值</code>后,发现内容页面刷新了,但需要注意的是,这是因为<code>@ObjectLink</code>观察到了类属性的变化,从而刷新了页面,但ForEach子组件的key并没有发生变化,我们可以通过在键值对生成函数中添加日志来验证。<br>在上面修改后的代码中,点击<code>改变最后一项的值</code>后,再次点击<code>重新赋值</code>,页面并没有刷新为初始状态。原因上面也解释了,因为点击<code>改变最后一项的值</code>后,key并没有发生变化,再次点击<code>重新赋值</code>后,通过函数生成的key和之前一致,所以页面也不会刷新。</p><p>在上面修改后的代码中,上述第五条依然成立：因为点击选择框之后,虽然UI发生了变化,但这种变化是因为点击行为导致的,并不是因为key的改变,也不是因为属性的改变。因此,不管是点击修<code>改变最后一项的值</code>,还是<code>添加一项</code>、<code>重新赋值</code>都不会刷新其选中状态。</p><h3 id="奇怪现象"><a href="#奇怪现象" class="headerlink" title="奇怪现象"></a>奇怪现象</h3><p>这里还有一个奇怪的现象，也可能是 SDK 的 bug 也不一定：<br>我们在页面<code>aboutToAppear</code>这个生命周期函数中调用了一次<code>this.initData()</code>,页面展示出来之后，点击<code>改变最后一项的值</code>表现是正常的。<br>但是如果页面在页面展示出来之后，再点击一次<code>重新赋值</code>，这时候 子组件是重新渲染了一遍，因为看到键值生成函数中有日志打印。但这时候点击<code>改变最后一项的值</code>，页面是没有刷新的。怀疑是因为key 没有改变(重新赋值是加载了同样的数据)，但实际的对象地址是变化了的，但不知道为啥<code>@ObjectLink</code>没有观察到。<br>当我们点击其他按钮，比如增加一项其他操作之后，再点击<code>改变最后一项的值</code>是有刷新的，这时候再点击<code>重新赋值</code>，再点击<code>改变最后一项的值</code>页面是有刷新的。 </p><p>也就是说，当我们两次或者多次对数组赋值，并且多次赋值使得键值对生成函数生成的 key 是一致的话，<code>@ObjectLink</code>和<code>@Observed</code>这两个装饰器会失效。<br>真让人摸不着头脑</p><hr><p>PS：如何知道<code>@ObjectLink</code>有没有生效。可以加个<code>@Watch</code>哇，比如这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Watch</span>(<span class="hljs-string">&#x27;onForeachModelChange&#x27;</span>)  <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">ForeachModel</span><br><span class="hljs-title function_">onForeachModelChange</span>(<span class="hljs-params"></span>)&#123;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, <span class="hljs-string">`onForeachModelChange`</span>)<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>有了解这个奇怪现象细节的朋友可以在评论区留言，或者私信我，感谢您指点迷津</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写了这么长时间的ArkTs,一个应用上架了,另外一个应用也快要提交审核了。记录一下自己踩过的坑以及对应的解决方案,大家可以借鉴一下,少走一些弯路。但也不一定,万一我的方法是另外一条弯路嘞~&lt;br&gt;不过话又说回来,再过几个版本说不定官方就把这些坑填上了。。  &lt;/p&gt;</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙--如何发布一个三方库</title>
    <link href="https://blog.huangyuanlove.com/2024/11/06/%E9%B8%BF%E8%92%99-%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>https://blog.huangyuanlove.com/2024/11/06/%E9%B8%BF%E8%92%99-%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E4%B8%89%E6%96%B9%E5%BA%93/</id>
    <published>2024-11-06T13:08:16.000Z</published>
    <updated>2024-11-08T06:45:52.787Z</updated>
    
    <content type="html"><![CDATA[<p>最近不是觉得官方的展示富文本的控件<code>RichText</code>和<code>RichEditor</code>不好用嘛,然后自己撸了一个能展示简单富文本的组件,具体文章内容看<a href="https://juejin.cn/post/7427455855941156876">鸿蒙-做一个简单的、大家都能学会的富文本解析渲染控件</a>。然后把这个控件发布到了<code>OpenHarmony三方库中心仓</code>,地址<a href="https://ohpm.openharmony.cn/#/cn/detail/simplehtmlrender">simplehtmlrender</a>,没有依赖任何三方控件,使用官方的xml解析器进行解析,使用<code>Text</code>、<code>ContainerSpan</code>、<code>Span</code>和<code>ImageSpan</code>进行展示。<br>这里记录一下发布过程以及需要注意的点</p><span id="more"></span><h2 id="需要的工具"><a href="#需要的工具" class="headerlink" title="需要的工具"></a>需要的工具</h2><p>DevEcoStudio和ohpm命令行工具。<br>安装完DevEcoStudio后,windows上ohpm在安装目录的<code>DevEco Studio\tools\ohpm\bin</code>文件夹下,mac上是在<code>/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin</code>文件夹下。</p><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>这没啥好说的,按提示注册就好了</p><h2 id="认证管理"><a href="#认证管理" class="headerlink" title="认证管理"></a>认证管理</h2><h3 id="生成公私密钥文件"><a href="#生成公私密钥文件" class="headerlink" title="生成公私密钥文件"></a>生成公私密钥文件</h3><p>利用工具 ssh-keygen 生成公、私钥文件,这个和github的流程差不多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -m PEM -t RSA -b 4096 -f ~/.ssh_ohpm/mykey <br></code></pre></td></tr></table></figure><p>windows下可以把路径换成<code>C:\Users\username\.ssh_ohpm</code>。<br>需要注意几点：</p><ul><li>先创建对应的文件夹,否则会报错。</li><li>生成公私密钥文件时一定要输入密码,不要直接回车跳过,要不然在发布流程会有对应提示,还得再重新生成</li></ul><h3 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h3><p>在【个人中心】-【认证管理】下：点击页面左上角的“新增”按钮,并将公钥文件（mykey.pub）的内容粘贴到公钥输入框中。<br>在<code>.ohpmrc</code>文件的<code>key_path</code>字段上。该文件一般在<code>C:\Users\username\.ohpm</code> 或者mac的<code>~/.ohpm</code>文件夹下。<br>找不到这个文件也可以执行下面的命令进行配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ohpm config set key_path ~/.ssh_ohpm/mykey <br></code></pre></td></tr></table></figure><p>同样的,windows下把路径换成<code>C:\Users\username\.ssh_ohpm</code>。</p><h3 id="发布之前的配置"><a href="#发布之前的配置" class="headerlink" title="发布之前的配置"></a>发布之前的配置</h3><p>登录OpenHarmony三方库中心仓,从 【个人中心】页面中【复制发布码】,并配置到<code>.ohpmrc</code>文件中<code>publish_id</code>字段上,可执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ohpm config set publish_id your_publish_id<br></code></pre></td></tr></table></figure><p>配置发布地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ohpm config set publish_registry https://ohpm.openharmony.cn/ohpm<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>可以创建自己的组织,这个不是必须的。<br>注意一下三方库的名称,<a href="https://ohpm.openharmony.cn/#/cn/help/guidename">三方库名称指南</a></p><h2 id="编写及发布"><a href="#编写及发布" class="headerlink" title="编写及发布"></a>编写及发布</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>创建一个新的项目,然后在项目中创建一个Module,这里需要选择<code>static library</code>。然后在这个Module中编写相关代码。</p><h3 id="必须的文件"><a href="#必须的文件" class="headerlink" title="必须的文件"></a>必须的文件</h3><h4 id="README-md"><a href="#README-md" class="headerlink" title="README.md"></a>README.md</h4><p>在Module的根目录创建一个 README.md 文件,描述您三方库的代码以及如何使用它,文件不能为空。<br>并且该文件中<strong>必须</strong>包含如何安装,也就是<code> ohpm install 库名字</code>,否则审核不通过。<br>可以看下其他仓库怎么写的。基本上包含如何安装、如何使用以及一些示例。<br>该文件的内容会展示在仓库的描述标签下。</p><h4 id="CHANGELOG-md"><a href="#CHANGELOG-md" class="headerlink" title="CHANGELOG.md"></a>CHANGELOG.md</h4><p>在Module的根目录中,创建一个 CHANGELOG.md 文件,描述您三方库的代码不同版本的变更内容,文件不能为空。<br>该文件的内容会展示在仓库的更新日志标签下</p><h4 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h4><p>在Module的根目录中,创建一个 LICENSE 文件,指定该软件包可以在什么样的许可下被使用、修改和共享,文件不能为空。</p><h4 id="oh-package-json5"><a href="#oh-package-json5" class="headerlink" title="oh-package.json5"></a>oh-package.json5</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;simplehtmlrender&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.2&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;简易的富文本渲染控件，支持span、font、br、a标签，支持color、font-color、size、font-size、background、href属性&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Index.ets&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;富文本&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;html展示&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;富文本展示&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> &#x27;huangyuan&#x27;<span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;huangyuan@huangyuanlove.com&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Apache-2.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;homepage&quot;</span><span class="hljs-punctuation">:</span> &#x27;https<span class="hljs-punctuation">:</span><span class="hljs-comment">//juejin.cn/post/7427455855941156876&#x27;,</span><br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span>&#x27;https<span class="hljs-punctuation">:</span><span class="hljs-comment">//gitee.com/huangyuan/SimpleHtmlRender&#x27;,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>其中,<code>name</code>、<code>version</code>、<code>description</code>、<code>keywords</code>、<code>author</code>、<code>license</code>字段是必须的</p><h4 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h4><p>三方库中央仓里面还有个points评分，最高是50分，这个是根据文件、文档的健全程度来打分的，不包含任何个人主观看法。</p><p><img src="/image/HarmonyOS/third_part_points.png" alt="三方库评分"><br>这个评分很好弄，按照标准来就行</p><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><strong>发布之前删除敏感信息</strong><br><strong>发布之前删除敏感信息</strong><br><strong>发布之前删除敏感信息</strong><br>发布的时候需要上传har文件，这就需要使用DevEcoStudio来构建，如何构建看(这里)[<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-hvigor-build-har-V5]%E3%80%82">https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-hvigor-build-har-V5]。</a><br>我们在前面已经配置好了<code>publish_id</code>和<code>publish_registry</code>信息，接着执行<code>ohpm publish &lt;HAR路径&gt;</code>就可以了。过程中会让你输入生成公钥时使用的密码，上传成功后可以在<code>个人中心--&gt;消息</code>中查看审核是否通过的消息。<br>如果上传失败，会提示对应的错误信息，根据提示修改就好了</p><p>这样就完成了发布。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近不是觉得官方的展示富文本的控件&lt;code&gt;RichText&lt;/code&gt;和&lt;code&gt;RichEditor&lt;/code&gt;不好用嘛,然后自己撸了一个能展示简单富文本的组件,具体文章内容看&lt;a href=&quot;https://juejin.cn/post/7427455855941156876&quot;&gt;鸿蒙-做一个简单的、大家都能学会的富文本解析渲染控件&lt;/a&gt;。然后把这个控件发布到了&lt;code&gt;OpenHarmony三方库中心仓&lt;/code&gt;,地址&lt;a href=&quot;https://ohpm.openharmony.cn/#/cn/detail/simplehtmlrender&quot;&gt;simplehtmlrender&lt;/a&gt;,没有依赖任何三方控件,使用官方的xml解析器进行解析,使用&lt;code&gt;Text&lt;/code&gt;、&lt;code&gt;ContainerSpan&lt;/code&gt;、&lt;code&gt;Span&lt;/code&gt;和&lt;code&gt;ImageSpan&lt;/code&gt;进行展示。&lt;br&gt;这里记录一下发布过程以及需要注意的点&lt;/p&gt;</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙-做一个简版的富文本解析控件</title>
    <link href="https://blog.huangyuanlove.com/2024/10/17/%E9%B8%BF%E8%92%99-%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E7%89%88%E7%9A%84%E5%AF%8C%E6%96%87%E6%9C%AC%E8%A7%A3%E6%9E%90%E6%8E%A7%E4%BB%B6/"/>
    <id>https://blog.huangyuanlove.com/2024/10/17/%E9%B8%BF%E8%92%99-%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E7%89%88%E7%9A%84%E5%AF%8C%E6%96%87%E6%9C%AC%E8%A7%A3%E6%9E%90%E6%8E%A7%E4%BB%B6/</id>
    <published>2024-10-17T13:30:03.000Z</published>
    <updated>2024-10-19T14:22:27.803Z</updated>
    
    <content type="html"><![CDATA[<p>本来只是需要展示一下简单的富文本，支持简单的背景色，字体大小，字体颜色就够了。调研了一圈都没有完全符合需求的。那就自己撸一个呗。<br>支持 span、font、br、a标签就好，属性的话就支持color、font-color、size、font-size、background、href这些属性就好了。</p><span id="more"></span><p>老规矩，先上效果图</p><p><img src="/image/HarmonyOS/html_parse_render.png" alt="富文本解析.png">  </p><p>最上方是在浏览器中的表现，手机截图分割线中间是自己撸的控件，最下方是鸿蒙自带的<code>RichText</code></p><p>看起来还行，主要是自己写的，调整起来也方便</p><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ol><li>目前只支持了上面说的那些标签级属性：span、font、br、a标签 和 color、font-color、size、font-size、background、href这些属性</li><li>富文本的解析使用的是<code>xml.XmlPullParser</code>,因此对富文本内容中的标签要求比较严格，一定要严格闭合才行，否则解析会失败。</li><li>也要求所有元素都必须包含在标签内容，否则也会失败，应对这个问题，可以通过在富文本最外层添加没有属性的span标签解决</li><li>对于颜色值，只支持了有限了英文名字，建议使用十六进制表示</li></ol><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>解析结果的展示是<code>Text</code>中嵌套<code>Span</code>和<code>ContainerSpan</code>实现的：</p><ol><li><code>Span</code>不支持背景色，要么只能依赖父级控件<code>Text</code>或者父级控件<code>ContainerSpan</code>来设置背景色</li><li><code>ContainerSpan</code>只能包含<code>Span</code>、<code>ImageSpan</code>子组件。</li><li><code>Span</code>、<code>ImageSpan</code> 没有子控件</li></ol><p>也就是说解析结果只有一个<code>Text</code>控件，内容样式都由<code>Span</code>和<code>ContainerSpan</code>完成</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>展示结果使用<code>Text</code>嵌套<code>Span</code>和<code>ContainerSpan</code>实现,将样式抽成一个类，要展示的文字作为属性就好了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VNode</span>&#123;<br>  <span class="hljs-attr">text</span>:<span class="hljs-built_in">string</span>=<span class="hljs-string">&#x27;&#x27;</span><br>  child?:<span class="hljs-title class_">VNode</span>[]=[]<br>  <span class="hljs-attr">style</span>:<span class="hljs-title class_">Style</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 属性默认值都可以做成配置，由调用者传入</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Style</span>&#123;<br>  <span class="hljs-comment">//如果有backGround属性需要使用 ContainerSpan</span><br>  <span class="hljs-attr">backgroundColor</span>:<span class="hljs-built_in">string</span>|<span class="hljs-title class_">Resource</span>|<span class="hljs-title class_">Color</span>=<span class="hljs-title class_">Color</span>.<span class="hljs-property">Transparent</span><br>  <span class="hljs-attr">fontSize</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">16</span><br>  <span class="hljs-attr">fontColor</span>:<span class="hljs-built_in">string</span>|<span class="hljs-title class_">Resource</span>|<span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Black</span><br>  <span class="hljs-attr">hrefFontColor</span>:<span class="hljs-built_in">string</span>|<span class="hljs-title class_">Resource</span>|<span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span><br>  <span class="hljs-attr">href</span>:<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了方便的话，这里的<code>Style</code>属性默认值可以做成配置的，由调用者传入，方便定制。<br>如果父级标签设置了背景颜色、文字颜色等属性，子控件没有设置的话，需要继承父标签的属性。如果子标签也设置了属性，则需要覆盖父控件对应的属性。简单来讲就是需要合并子标签和父标签的属性来作为子标签的属性，当然，子标签属性值优先级高于父标签，也就是子标签属性值覆盖父标签的属性值。</p><p>就拿截图中的例子来讲：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue;background:yellow&quot;</span>&gt;</span><br>  这位姑娘有一双 <br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue;background:red&quot;</span>&gt;</span>蓝<br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red;background:blue&quot;</span>&gt;</span>色<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  的眼睛<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码按照<code>xml</code>样式格式化了一下，看着方便<br><code>蓝</code>这个字的父级标签设置了背景色为<code>yellow</code>,字体颜色为<code>blue</code>,所以<code>这位姑娘有一双</code>这几个字的背景色就是<code>yellow</code>，字体颜色为<code>blue</code>。但<code>蓝</code>这个字的标签同样设置了背景色为<code>red</code>,优先级要高于父标签，所以<code>蓝</code>这个字的背景色为<code>red</code>。<br><code>的眼睛</code>是和<code>这位姑娘有一双</code>同级的文字，因此背景色和字体颜色也是一致的。</p><p>基于上面的规则，很自然的想到使用<code>Stack</code>来保存每一层级的属性，遇到开始标签则复制一份父控件的样式属性(栈顶元素)然后入栈。遇到结束标签则出栈。注意下<code>br</code>标签，只是换行，不会有样式，直接添加一个<code>Span(&#39;\n&#39;)</code>就行。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基于我们的需求，需要展示的富文本不会很复杂，最多也就是上面说的这些属性，鸿蒙正好也由自带的<code>xml</code>解析，用来解析富文本也行。<br>具体文档可以看这里 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/xml-parsing-V5">XML解析</a>  </p><h3 id="xml-XmlPullParser"><a href="#xml-XmlPullParser" class="headerlink" title="xml.XmlPullParser"></a>xml.XmlPullParser</h3><p>这里简单介绍一下流程，<br>需要导入 <code>import &#123; util, xml &#125; from &quot;@kit.ArkTS&quot;;</code> 这两个包，其中需要用<code>util</code>对富文本进行编码，防止中文和特殊符号乱码。</p><p>首先准备好富文本，并且编码一下,创建<code>xml.XmlPullParser</code>对象</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 对数据编码，防止包含中文字符乱码</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">textEncoder</span>: util.<span class="hljs-property">TextEncoder</span> = <span class="hljs-keyword">new</span> util.<span class="hljs-title class_">TextEncoder</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arrBuffer</span>: <span class="hljs-title class_">Uint8Array</span> = textEncoder.<span class="hljs-title function_">encodeInto</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">htmlContent</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">xmlPullParser</span>: xml.<span class="hljs-property">XmlPullParser</span> = <span class="hljs-keyword">new</span> xml.<span class="hljs-title class_">XmlPullParser</span>(arrBuffer.<span class="hljs-property">buffer</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">ArrayBuffer</span>, <span class="hljs-string">&#x27;UTF-8&#x27;</span>);<br></code></pre></td></tr></table></figure><p>调用开始解析的方法需要传入一个<code>xml.ParseOptions</code>对象，这个是重点。<br>这个对象由三个回调方法：<code>tagValueCallbackFunction</code>、<code>attributeValueCallbackFunction</code>和<code>tokenValueCallbackFunction</code>。我们在解析的过程中需要知道标签名(根据标签名解析属性值)，标签的开始和结束以及标签包裹的文本。因此我们这里只需要<code>attributeValueCallbackFunction</code> 和 <code>tokenValueCallbackFunction</code>这两个回调就好了。<br>先来打印一下解析出来的数据，再决定后面怎么获取属性值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">attributeValueCallback</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">let</span> str = name + <span class="hljs-string">&#x27; &#x27;</span> + value + <span class="hljs-string">&#x27; &#x27;</span>;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;HtmlParsePage&#x27;</span>, <span class="hljs-string">`attribute  <span class="hljs-subst">$&#123;str&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// true:继续解析 false:停止解析</span><br>&#125;<br><span class="hljs-title function_">tokenValueCallback</span>(<span class="hljs-attr">name</span>: xml.<span class="hljs-property">EventType</span>, <span class="hljs-attr">value</span>: xml.<span class="hljs-property">ParseInfo</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-comment">//只需要关心 START_TAG  END_TAG TEXT 这三个类型就好</span><br>  <span class="hljs-keyword">let</span> nameStr = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">if</span>(name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">START_TAG</span> || name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">END_TAG</span> || name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">TEXT</span>)&#123;<br>    nameStr = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getTagEventName</span>(name)<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br><br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;HtmlParsePage&#x27;</span>, <span class="hljs-string">`token    <span class="hljs-subst">$&#123;nameStr&#125;</span>  getName:<span class="hljs-subst">$&#123;value.getName()&#125;</span>    getText:<span class="hljs-subst">$&#123;value.getText()&#125;</span> `</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-title function_">getTagEventName</span>(<span class="hljs-attr">name</span>: xml.<span class="hljs-property">EventType</span>):<span class="hljs-built_in">string</span>&#123;<br>  <span class="hljs-keyword">let</span> nameStr = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> (name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">START_TAG</span>) &#123;<br>    nameStr = <span class="hljs-string">&#x27;START_TAG&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">END_TAG</span>) &#123;<br>    nameStr = <span class="hljs-string">&#x27;END_TAG&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">TEXT</span>) &#123;<br>    nameStr = <span class="hljs-string">&#x27;TEXT&#x27;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> nameStr<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们开始解析，看看打印出来的数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-keyword">let</span> <span class="hljs-attr">options</span>: xml.<span class="hljs-property">ParseOptions</span> = &#123;<br>  <span class="hljs-attr">supportDoctype</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">ignoreNameSpace</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">attributeValueCallbackFunction</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">attributeValueCallback</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>),<br>  <span class="hljs-attr">tokenValueCallbackFunction</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">tokenValueCallback</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>&#125;;<br>xmlPullParser.<span class="hljs-title function_">parse</span>(options);<br></code></pre></td></tr></table></figure><h3 id="得到属性值"><a href="#得到属性值" class="headerlink" title="得到属性值"></a>得到属性值</h3><p>然后我们就可以看到结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">token    START_TAG  getName:span    getText: <br>attribute  style color:blue;background:yellow <br>token    TEXT  getName:    getText:这位姑娘有一双  <br>token    START_TAG  getName:span    getText: <br>attribute  style color:blue;background:red <br>token    TEXT  getName:    getText:蓝 <br>token    START_TAG  getName:span    getText: <br>attribute  style color:red;background:blue <br>token    TEXT  getName:    getText:色 <br>token    END_TAG  getName:span    getText: <br>token    END_TAG  getName:span    getText: <br>token    TEXT  getName:    getText:的眼睛 <br>token    END_TAG  getName:span    getText: <br></code></pre></td></tr></table></figure><p>这就好办多了，就像上面思路中说的一样：遇到<code>START_TAG</code>复制一个父标签属性对象，在属性回调中解析属性并设置属性，然后入栈。遇到<code>TEXT</code>则根据有无背景色属性添加一个<code>ContainerSpan</code>或者<code>Span</code>,遇到<code>END_TAG</code>则属性出栈。<br>对于属性解析，<code>style</code>属性根据<code>;</code>分割一下，将结果再按<code>:</code>分割，就得到了我们想要的属性名字(color、backgroud等)和属性值。然后我们就可以映射成抽象出来的<code>Style</code>类。<br>哦，对了，还有一点，如果颜色的属性值是<code>red</code>、<code>green</code>这种英文名字，需要解析成对应的十六进制或者在鸿蒙中对应的Color对象。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>按照上面的介绍，我们在<code>tokenValueCallback</code>创建样式或者<code>Span</code>、<code>ContainerSpan</code>。在<code>attributeValueCallback</code>中解析具体属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">attributeValueCallback</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">let</span> str = name + <span class="hljs-string">&#x27; &#x27;</span> + value + <span class="hljs-string">&#x27; &#x27;</span>;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;HtmlParsePage&#x27;</span>, <span class="hljs-string">`attribute  <span class="hljs-subst">$&#123;str&#125;</span>`</span>)<br>  <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;href&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">href</span> = value<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;size&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;px&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">let</span> tmp = value.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;px&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">fontSize</span> = <span class="hljs-title function_">px2fp</span>(<span class="hljs-built_in">parseInt</span>(tmp))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">fontSize</span> = <span class="hljs-title function_">px2fp</span>(<span class="hljs-built_in">parseInt</span>(value))<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;style&#x27;</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">attributes</span>: <span class="hljs-built_in">string</span>[] = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;;&#x27;</span>)<br>    attributes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">attribute: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">tmp</span>: <span class="hljs-built_in">string</span> [] = attribute.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br>      <span class="hljs-keyword">if</span> (tmp[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;color&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">fontColor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getColorWithStr</span>(tmp[<span class="hljs-number">1</span>])<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;background&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">backgroundColor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getColorWithStr</span>(tmp[<span class="hljs-number">1</span>])<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;font-size&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">fontSize</span> = <span class="hljs-title function_">px2fp</span>(<span class="hljs-built_in">parseInt</span>(tmp[<span class="hljs-number">1</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;px&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)))<br>      &#125;<br>    &#125;)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;color&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">fontColor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getColorWithStr</span>(value)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// true:继续解析 false:停止解析</span><br>&#125;<br><br><span class="hljs-title function_">tokenValueCallback</span>(<span class="hljs-attr">name</span>: xml.<span class="hljs-property">EventType</span>, <span class="hljs-attr">value</span>: xml.<span class="hljs-property">ParseInfo</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-comment">//只需要关心 START_TAG  END_TAG TEXT 这三个类型就好</span><br>  <span class="hljs-keyword">let</span> nameStr = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">if</span>(name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">START_TAG</span> || name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">END_TAG</span> || name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">TEXT</span>)&#123;<br>    nameStr = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getTagEventName</span>(name)<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br><br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;HtmlParsePage&#x27;</span>, <span class="hljs-string">`token    <span class="hljs-subst">$&#123;nameStr&#125;</span>  getName:<span class="hljs-subst">$&#123;value.getName()&#125;</span>    getText:<span class="hljs-subst">$&#123;value.getText()&#125;</span> `</span>)<br>  <span class="hljs-keyword">if</span> (name === xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">TEXT</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">vNode</span>: <span class="hljs-title class_">VNode</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>()<br>    vNode.<span class="hljs-property">text</span> = value.<span class="hljs-title function_">getText</span>()<br>    vNode.<span class="hljs-property">style</span> = <span class="hljs-title function_">copyStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>())<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rootNode</span>.<span class="hljs-property">child</span>?.<span class="hljs-title function_">push</span>(vNode)<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (name === xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">START_TAG</span>) &#123;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;br&#x27;</span>) &#123;<br>      <span class="hljs-keyword">let</span> lineBreakSpan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>()<br>      lineBreakSpan.<span class="hljs-property">text</span> = <span class="hljs-string">&#x27;\n&#x27;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">rootNode</span>.<span class="hljs-property">child</span>?.<span class="hljs-title function_">push</span>(lineBreakSpan)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;font&#x27;</span> || value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;span&#x27;</span> || value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>())<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> style = <span class="hljs-title function_">copyStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>())<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">push</span>(style)<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (name === xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">END_TAG</span> &amp;&amp; (value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;font&#x27;</span> || value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;span&#x27;</span>|| value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;a&#x27;</span>)) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">pop</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//true:继续解析 false:停止解析</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>所有的准备工作都做完了，渲染就成了最简单的一步。<br>根节点使用Text控件，判断子节点Sytle背景色属性，如果设置了其他值，就使用<code>ContainerSpan()&#123;Span()&#125;</code>,如果没有，直接使用<code>Span()</code>.<br>这里将属性写成了<code>Extend(Span)</code>形式  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Extend</span>(<span class="hljs-title class_">Span</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">configSpanStyle</span>(<span class="hljs-params">vNode: VNode</span>) &#123;<br>  .<span class="hljs-title function_">backgroundColor</span>(vNode.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span>)<br>  .<span class="hljs-title function_">fontColor</span>(vNode.<span class="hljs-property">style</span>.<span class="hljs-property">href</span> ? vNode.<span class="hljs-property">style</span>.<span class="hljs-property">hrefFontColor</span> : vNode.<span class="hljs-property">style</span>.<span class="hljs-property">fontColor</span>)<br>  .<span class="hljs-title function_">fontSize</span>(vNode.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span>)<br>  .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">event: ClickEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (vNode.<span class="hljs-property">style</span>.<span class="hljs-property">href</span>) &#123;<br>      promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: vNode.<span class="hljs-property">style</span>.<span class="hljs-property">href</span> &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">hasParse</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">buildWithVNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">rootNode</span>)<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title class_">LoadingProgress</span>()<br>        .<span class="hljs-title function_">color</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span>).<span class="hljs-title function_">width</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">10</span>)<br><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Builder</span><br>  <span class="hljs-title function_">buildWithVNode</span>(<span class="hljs-params">vNode: VNode</span>) &#123;<br>    <span class="hljs-title class_">Text</span>() &#123;<br>      <span class="hljs-title class_">ForEach</span>(vNode.<span class="hljs-property">child</span>, <span class="hljs-function">(<span class="hljs-params">child: VNode</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (child.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> != <span class="hljs-title class_">Color</span>.<span class="hljs-property">Transparent</span>) &#123;<br>          <span class="hljs-title class_">ContainerSpan</span>() &#123;<br>            <span class="hljs-title class_">Span</span>(child.<span class="hljs-property">text</span>).<span class="hljs-title function_">configSpanStyle</span>(child)<br>          &#125;.<span class="hljs-title function_">textBackgroundStyle</span>(&#123; <span class="hljs-attr">color</span>: child.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title class_">Span</span>(child.<span class="hljs-property">text</span>).<span class="hljs-title function_">configSpanStyle</span>(child)<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>到这里就结束了，源码在github<a href="https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/html_parse/HtmlParsePage.ets">github</a>、<a href="https://gitee.com/huangyuan/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/html_parse/HtmlParsePage.ets">gitee</a></p><p>当然代码都是硬怼上去的，有很多可以改进的地方：</p><ol><li>上面提到的默认属性，可以由调用者传入</li><li>结果标签和属性目前也是直接写死的支持哪些，其实可以做成责任链，解析可以让使用者自定义，更加方便扩展</li><li>因为是使用xml的解析器，遇到不复合标准的富文本会崩溃，要么在解析上加个try catch。或者在使用无属性的<code>span</code>标签再包裹一下。建议可以两个都用上，毕竟墨菲定律</li></ol><hr><p>下个版本再说吧</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来只是需要展示一下简单的富文本，支持简单的背景色，字体大小，字体颜色就够了。调研了一圈都没有完全符合需求的。那就自己撸一个呗。&lt;br&gt;支持 span、font、br、a标签就好，属性的话就支持color、font-color、size、font-size、background、href这些属性就好了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙-自定义布局-实现一个可限制行数的 Flex</title>
    <link href="https://blog.huangyuanlove.com/2024/09/18/%E9%B8%BF%E8%92%99-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%99%90%E5%88%B6%E8%A1%8C%E6%95%B0%E7%9A%84-Flex/"/>
    <id>https://blog.huangyuanlove.com/2024/09/18/%E9%B8%BF%E8%92%99-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%99%90%E5%88%B6%E8%A1%8C%E6%95%B0%E7%9A%84-Flex/</id>
    <published>2024-09-18T07:59:02.000Z</published>
    <updated>2024-09-19T09:29:43.045Z</updated>
    
    <content type="html"><![CDATA[<p>千呼万唤始出来的自定义布局功能终于可以用了，这就给了我们更多自由发挥创造的空间，不再局限于使用已有组件做组合。当然，用 NAPI 和 C|C++页可以实现自己绘制所有内容，更别提还有类似<code>XComponent</code>这种东西了。但假如我们只是需要简单的自己控制子组件所在的位置，不需要接管绘制等逻辑，比如实现一个扇形菜单、实现一个可以控制行数的标签列表等，怎么搞嘞？现在鸿蒙提供了<code>onPlaceChildren</code>和<code>onMeasureSize</code>这两个回调方法，使得我们可以按照自己的意愿来摆放组件。</p><span id="more"></span><p>老样子，先放效果图</p><img src='/image/HarmonyOS/line_limit_flex.gif' width='30%' heigh='30%'/><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>我们先来了解一下这两个回调方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">onMeasureSize</span>(<span class="hljs-params">selfLayoutInfo: GeometryInfo, children: <span class="hljs-built_in">Array</span>&lt;Measurable&gt;, constraint: ConstraintSizeOptions</span>) &#123;&#125;<br><span class="hljs-title function_">onPlaceChildren</span>(<span class="hljs-params">selfLayoutInfo: GeometryInfo, children: <span class="hljs-built_in">Array</span>&lt;Layoutable&gt;, constraint: ConstraintSizeOptions</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="onMeasureSize"><a href="#onMeasureSize" class="headerlink" title="onMeasureSize"></a>onMeasureSize</h3><blockquote><p>ArkUI框架会在自定义组件确定尺寸时，将该自定义组件的节点信息和尺寸范围通过onMeasureSize传递给该开发者。不允许在onMeasureSize函数中改变状态变量。</p></blockquote><p>在<code>build</code>方法调用之后，就会调用<code>onMeasureSize</code>方法。在该方法中，我们可以获取到组件本身和子组件的大小，通过计算确认组件本身大小后返回一个<code>SizeResult</code>对象，告知系统该组件最终大小。</p><h4 id="selfLayoutInfo"><a href="#selfLayoutInfo" class="headerlink" title="selfLayoutInfo"></a>selfLayoutInfo</h4><p>在该方法的的参数中，有一个<code>GeometryInfo</code>对象实例<code>selfLayoutInfo</code>.通过这个对象，我们可以拿到父组件的宽高、padding、margin、borderWidth等信息。<br>文档中对<code>selfLayoutInfo</code>的解释为<strong>父组件布局信息</strong>，这里的<code>父组件</code>是指的自定义组件本身，而不是包含该自定义组件的组件。举个简单的例子：<br>自定义组件名字为<code>CustomLayout</code>,有如下布局</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">LineLimitFlexPage</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">CustomLayout</span>().<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>).<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>.<span class="hljs-property">Yellow</span>, <span class="hljs-attr">radius</span>: <span class="hljs-number">2</span> &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">2</span>)<br>    &#125;.<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>).<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>, <span class="hljs-attr">radius</span>: <span class="hljs-number">6</span> &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">6</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在<code>CustomLayout</code>组建内重写<code>onMeasureSize</code>方法，将相关信息打印出来</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">onMeasureSize</span>(<span class="hljs-attr">selfLayoutInfo</span>: <span class="hljs-title class_">GeometryInfo</span>, <span class="hljs-attr">children</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Measurable</span>&gt;, <span class="hljs-attr">constraint</span>: <span class="hljs-title class_">ConstraintSizeOptions</span>):<span class="hljs-title class_">SizeResult</span> &#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&quot;LineLimitFlexPage&quot;</span>, <span class="hljs-string">`onMeasureSize selfLayoutInfo: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(selfLayoutInfo)&#125;</span>`</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>日志信息是这样的</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">onMeasureSize selfLayoutInfo: &#123;&quot;borderWidth&quot;:&#123;&quot;top&quot;:2,&quot;right&quot;:2,&quot;bottom&quot;:2,&quot;left&quot;:2&#125;,&quot;margin&quot;:&#123;&quot;top&quot;:2,&quot;right&quot;:2,&quot;bottom&quot;:2,&quot;left&quot;:2&#125;,&quot;padding&quot;:&#123;&quot;top&quot;:2,&quot;right&quot;:2,&quot;bottom&quot;:2,&quot;left&quot;:2&#125;,&quot;width&quot;:292.9846003605769,&quot;height&quot;:731.3846153846154&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，打印出来的信息是自定义组件本身的属性。</p><h4 id="constraint"><a href="#constraint" class="headerlink" title="constraint"></a>constraint</h4><p>另外，还有一个<code>constraint</code>的<code>ConstraintSizeOptions</code>对象，文档中对其解释是<strong>设置约束尺寸，组件布局时，进行尺寸范围限制。</strong>,同样也打印一下，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">onMeasureSize constraint: &#123;&quot;minWidth&quot;:0,&quot;minHeight&quot;:0,&quot;maxWidth&quot;:285.59998497596155,&quot;maxHeight&quot;:724&#125;<br></code></pre></td></tr></table></figure><p>可以看到有四个属性：最小宽度，最小高度，最大宽度，最大高度。这也是我们组件大小的下限和上限。</p><h4 id="children"><a href="#children" class="headerlink" title="children"></a>children</h4><p>一个关键的参数：<code>children: Array&lt;Measurable&gt;</code>,子组件的布局信息。这里并没有直接把子组件传递下来，而是抽象成了<code>Measurable</code>对象。该对象有四个方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">measure</span>(<span class="hljs-attr">constraint</span>: <span class="hljs-title class_">ConstraintSizeOptions</span>): <span class="hljs-title class_">MeasureResult</span>;<br><span class="hljs-title function_">getMargin</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br><span class="hljs-title function_">getPadding</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br><span class="hljs-title function_">getBorderWidth</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br></code></pre></td></tr></table></figure><p>见名知义，没有什么好说的，我们通过<code>measure</code>方法可以获取到子组件的大小，之后通过计算，综合子组件大小、selfLayoutInfo、constraint三者的信息来计算该组件需要的大小。并且返回<code>SizeResult</code>对象，来告知系统该组件的最终大小。</p><h3 id="onPlaceChildren"><a href="#onPlaceChildren" class="headerlink" title="onPlaceChildren"></a>onPlaceChildren</h3><p>在来看<code>onPlaceChildren</code>方法，在该方法中的<code>selfLayoutInfo</code>和<code>constraint</code>这两个参数，和<code>onMeasureSize</code>方法中的参数含义是相同的，这里不再赘述。<br>来看一下<code>children: Array&lt;Layoutable&gt;</code>参数。这里也是把子组件抽象成了<code>Layoutable</code>对象，它有一个<code>measureResult: MeasureResult;</code>属性和四个方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">layout</span>(<span class="hljs-attr">position</span>: <span class="hljs-title class_">Position</span>): <span class="hljs-built_in">void</span>;<br><span class="hljs-title function_">getMargin</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br><span class="hljs-title function_">getPadding</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br><span class="hljs-title function_">getBorderWidth</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br></code></pre></td></tr></table></figure><p>同样的见名知义，没有什么好说的。我们不需要了解子组件的具体信息，只需要关心子组件大小和摆放的位置就好。这里我们通过<code>layout</code>方法来确认子组件摆放位置。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>前置的条件我们都已经了解了，那么如何实现一个简易版可指定展示行数的 Flex 也就有思路了。这里为了简单，我们只考虑横向从左向右排列的情况，没有考虑 <code>padding</code> 和 <code>margin</code>属性。其他的属性大家有兴趣可以自己实现</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在<code>onMeasureSize</code>方法中测量并获取每个子组件的大小，长度累加大于等于约束的最大宽度则换行，高度累加。直到超过指定行数或者遍历完子组件结束。返回组件大小。<br>在<code>onPlaceChildren</code>方法中遍历子组件，通过子组件的宽高确认摆放位置，长度累加大于等于约束的最大宽度则换行，高度累加，直到超过指定行数或者遍历完子组件结束。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>这里我们只考虑水平间隔和垂直间隔以及指定行数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CustomLayout</span> &#123;<br>  <span class="hljs-attr">hSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">vSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里还有一些需要特别注意的细节点：</p><ul><li>自定义布局暂不支持LazyForEach写法。</li><li>使用builder形式的自定义布局创建，自定义组件的build()方法内只允许存在this.builder()，即示例的推荐用法。</li><li>父容器（自定义组件）上设置的尺寸信息，除aspectRatio之外，优先级小于onMeasureSize设置的尺寸信息。</li><li>子组件设置的位置信息，offset、position、markAnchor优先级大于onPlaceChildren设置的位置信息，其他位置设置属性不生效。</li><li>使用自定义布局方法时，需要同时调用onMeasureSize和onPlaceChildren方法，否则可能出现布局异常。</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>既然这样，我们先准备好大致框架</p><p>我们的自定义布局</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CustomLayout</span> &#123;<br>  <span class="hljs-attr">hSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">vSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">showAll</span>: <span class="hljs-built_in">boolean</span><br><br>  <span class="hljs-meta">@Builder</span><br>  <span class="hljs-title function_">doNothingBuilder</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br>  <span class="hljs-meta">@BuilderParam</span> <span class="hljs-attr">builder</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">doNothingBuilder</span>;<br><br>  <span class="hljs-title function_">onMeasureSize</span>(<span class="hljs-attr">selfLayoutInfo</span>: <span class="hljs-title class_">GeometryInfo</span>, <span class="hljs-attr">children</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Measurable</span>&gt;, <span class="hljs-attr">constraint</span>: <span class="hljs-title class_">ConstraintSizeOptions</span>): <span class="hljs-title class_">SizeResult</span>&#123;&#125;<br>  <span class="hljs-title function_">onPlaceChildren</span>(<span class="hljs-params">selfLayoutInfo: GeometryInfo, children: <span class="hljs-built_in">Array</span>&lt;Layoutable&gt;, constraint: ConstraintSizeOptions</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个全局的<code>@Builder</code>修饰的布局,也就是我们的子控件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> <span class="hljs-attr">colors</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;#ff6134&quot;</span>, <span class="hljs-string">&quot;#1b91e0&quot;</span>, <span class="hljs-string">&quot;#39d167&quot;</span>]<br><br><span class="hljs-meta">@Builder</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ColumnChildren</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">ForEach</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>], <span class="hljs-function">(<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123; <span class="hljs-comment">//暂不支持lazyForEach的写法</span><br>    <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;标签&#x27;</span> + index)<br>      .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)<br>      .<span class="hljs-title function_">borderWidth</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">backgroundColor</span>(colors[index%<span class="hljs-number">3</span>])<br><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>一个页面</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">LineLimitFlexPage</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">CustomLayout</span>(&#123;<br>        <span class="hljs-attr">builder</span>: <span class="hljs-title class_">ColumnChildren</span>,<br>        <span class="hljs-attr">hSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">10</span>),<br>        <span class="hljs-attr">vSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">6</span>),<br>        <span class="hljs-attr">maxLine</span>: <span class="hljs-number">3</span><br>      &#125;)<br>    &#125;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就准备好了框架内容，接下来就是处理测量组件大小及布局了</p><h3 id="测量组件"><a href="#测量组件" class="headerlink" title="测量组件"></a>测量组件</h3><p>我们按照上面的思路在<code>onMeasureSize</code>方法中对子组件进行测量，并确认组件大小。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-title function_">onMeasureSize</span>(<span class="hljs-attr">selfLayoutInfo</span>: <span class="hljs-title class_">GeometryInfo</span>, <span class="hljs-attr">children</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Measurable</span>&gt;, <span class="hljs-attr">constraint</span>: <span class="hljs-title class_">ConstraintSizeOptions</span>): <span class="hljs-title class_">SizeResult</span> &#123;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&quot;LineLimitFlexPage&quot;</span>, <span class="hljs-string">`onMeasureSize selfLayoutInfo: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(selfLayoutInfo)&#125;</span>`</span>)<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&quot;LineLimitFlexPage&quot;</span>, <span class="hljs-string">`onMeasureSize constraint: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(constraint)&#125;</span>`</span>)<br><br>  <span class="hljs-keyword">let</span> totalWidth = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> totalHeight = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> lineHeight = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> firstLineHeight = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> lineCount = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; i++) &#123;<br><br>    <span class="hljs-keyword">let</span> child = children[i]<br>    <span class="hljs-comment">//测量当前控件的宽高</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-title class_">MeasureResult</span> = child.<span class="hljs-title function_">measure</span>(&#123;<br>      <span class="hljs-attr">minHeight</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">minWidth</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">maxWidth</span>: selfLayoutInfo.<span class="hljs-property">width</span>,<br>      <span class="hljs-attr">maxHeight</span>: selfLayoutInfo.<span class="hljs-property">height</span><br>    &#125;)<br>    <span class="hljs-comment">//累计当前行宽度</span><br>    totalWidth += result.<span class="hljs-property">width</span><br>    <span class="hljs-comment">//记录当前行的最大高度</span><br>    lineHeight = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(lineHeight, result.<span class="hljs-property">height</span>)<br><br><br>    <span class="hljs-keyword">if</span> (totalWidth &gt; selfLayoutInfo.<span class="hljs-property">width</span>) &#123;<br>      <span class="hljs-comment">//记录一下第一行高度</span><br>      <span class="hljs-keyword">if</span> (firstLineHeight == <span class="hljs-number">0</span>) &#123;<br>        firstLineHeight = lineHeight;<br>      &#125;<br>      <span class="hljs-comment">//如果加上当前控件超过了父控件宽度，则换行</span><br>      lineCount++<br>      <span class="hljs-keyword">if</span> (lineCount &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      totalHeight += lineHeight + <span class="hljs-variable language_">this</span>.<span class="hljs-property">vSpace</span><br>      totalWidth = result.<span class="hljs-property">width</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">vSpace</span><br>      lineHeight = <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//如果加上当前控件没有超过父控件宽度，加上水平间距</span><br>      totalWidth += <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span><br>    &#125;<br><br><br>  &#125;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-title class_">SizeResult</span> = &#123;<br>    <span class="hljs-attr">width</span>: lineCount &gt; <span class="hljs-number">1</span> ? selfLayoutInfo.<span class="hljs-property">width</span> : totalWidth,<br>    <span class="hljs-attr">height</span>: totalHeight + firstLineHeight<br>  &#125;;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>在<code>onPlaceChildren</code>方法中确认每个组件的位置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-title function_">onPlaceChildren</span>(<span class="hljs-params">selfLayoutInfo: GeometryInfo, children: <span class="hljs-built_in">Array</span>&lt;Layoutable&gt;, constraint: ConstraintSizeOptions</span>) &#123;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&quot;LineLimitFlexPage&quot;</span>, <span class="hljs-string">`onPlaceChildren: selfLayoutInfo: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(selfLayoutInfo)&#125;</span>`</span>)<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&quot;LineLimitFlexPage&quot;</span>, <span class="hljs-string">`onPlaceChildren: constraint: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(constraint)&#125;</span>`</span>)<br>  <span class="hljs-keyword">let</span> startX = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> startY = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> lineCount = <span class="hljs-number">1</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> child = children[i]<br>    <span class="hljs-keyword">let</span> childWidth = child.<span class="hljs-property">measureResult</span>.<span class="hljs-property">width</span>;<br>    <span class="hljs-keyword">let</span> childHeight = child.<span class="hljs-property">measureResult</span>.<span class="hljs-property">height</span><br><br><br>    <span class="hljs-keyword">if</span> (startX + childWidth &gt; selfLayoutInfo.<span class="hljs-property">width</span>) &#123;<br>      startX = <span class="hljs-number">0</span><br>      startY += childHeight + <span class="hljs-variable language_">this</span>.<span class="hljs-property">vSpace</span><br>      lineCount++<br>      <span class="hljs-keyword">if</span> (lineCount &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span>) &#123;<br>        <span class="hljs-keyword">break</span><br>      &#125;<br>    &#125;<br>    child.<span class="hljs-title function_">layout</span>(&#123; <span class="hljs-attr">x</span>: startX, <span class="hljs-attr">y</span>: startY &#125;)<br>    startX += childWidth + <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span><br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这样我们就完成了一个简易版的可以指定行数的类 Flex 组件。和 Android 中的自定义布局对比一下，流程几乎是一致的，只不过方法签名不一样而已。对于初学者来讲还是挺友好的。</p><h2 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h2><p>这里扩展一下，我们如何刷新自定义组件？<br>很自然的想到了父子组件传递参数并进行同步的修饰符：在父组件中使用<code>@State</code>修饰变量，在子组件中使用<code>@Prop</code>修饰变量，这样就能实现父子组件单向数据同步，父组件改变变量值时子组件同步刷新。那我们也这么写一下：<br>在父组件中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">LineLimitFlexPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">CustomLayout</span>(&#123;<br>        <span class="hljs-attr">builder</span>: <span class="hljs-title class_">ColumnChildren</span>,<br>        <span class="hljs-attr">hSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">10</span>),<br>        <span class="hljs-attr">vSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">6</span>),<br>        <span class="hljs-attr">maxLine</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span><br>      &#125;).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span> == <span class="hljs-number">2</span>)&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span> =<span class="hljs-number">2</span><br>        &#125;<br>        &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CustomLayout</span> &#123;<br>  <span class="hljs-attr">hSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">vSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样写完了，但是点击之后发现控件并没有刷新，这是啥原因？ 咨询之后了解到因为子控件中的<code>maxLine</code>变量没有直接在子控件的<code>build</code>方法中使用，因此改变它的值不会触发<code>build</code>函数,更不会触发<code>onMeasureSize</code>和<code>onPlaceChildren</code>方法。<br>ArkUI 也没有提供类似<code>invalidate()</code>方法也刷新页面。咨询之后给了个比较魔幻的操作：额外定义一个变量，让这个变量参与<code>build</code>就好了，因此有了下面的代码:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">LineLimitFlexPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">showAll</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span><br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">CustomLayout</span>(&#123;<br>        <span class="hljs-attr">builder</span>: <span class="hljs-title class_">ColumnChildren</span>,<br>        <span class="hljs-attr">hSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">10</span>),<br>        <span class="hljs-attr">vSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">6</span>),<br>        <span class="hljs-attr">maxLine</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span>,<br>        <span class="hljs-attr">showAll</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span><br>      &#125;).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span> = <span class="hljs-number">2</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span><br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span><br>      &#125;<br>      )&#125;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CustomLayout</span> &#123;<br>  <span class="hljs-attr">hSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">vSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">showAll</span>: <span class="hljs-built_in">boolean</span><br>    <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span> ) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">builder</span>()<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">builder</span>()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，这样点击控件的时候就能刷新了。。。。。<br>哈哈哈哈，我先笑一会。</p><p>嗯，或者把这个<code>if</code>判断放在父组件中</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Column</span>() &#123;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span>)&#123;<br>    <span class="hljs-title class_">CustomLayout</span>(&#123;&#125;)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title class_">CustomLayout</span>(&#123;&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>哈哈哈哈哈哈哈， 就先这样吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;千呼万唤始出来的自定义布局功能终于可以用了，这就给了我们更多自由发挥创造的空间，不再局限于使用已有组件做组合。当然，用 NAPI 和 C|C++页可以实现自己绘制所有内容，更别提还有类似&lt;code&gt;XComponent&lt;/code&gt;这种东西了。但假如我们只是需要简单的自己控制子组件所在的位置，不需要接管绘制等逻辑，比如实现一个扇形菜单、实现一个可以控制行数的标签列表等，怎么搞嘞？现在鸿蒙提供了&lt;code&gt;onPlaceChildren&lt;/code&gt;和&lt;code&gt;onMeasureSize&lt;/code&gt;这两个回调方法，使得我们可以按照自己的意愿来摆放组件。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙-验证码输入框的几种实现方式(下)</title>
    <link href="https://blog.huangyuanlove.com/2024/09/13/%E9%B8%BF%E8%92%99-%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E4%B8%8B/"/>
    <id>https://blog.huangyuanlove.com/2024/09/13/%E9%B8%BF%E8%92%99-%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E4%B8%8B/</id>
    <published>2024-09-13T01:25:39.000Z</published>
    <updated>2024-09-14T03:38:13.342Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章<a href="https://juejin.cn/spost/7413607758577106978">鸿蒙-验证码输入框的几种实现方式(上)</a>中介绍了如何使用多个<code>TextInput</code>来实现验证码输入框，<br>本篇文章中介绍另外一种思路：自己代码控制、记录键盘输入内容，使用<code>Text</code>组件展示验证码，当然也可以使用<code>Canvas</code>自己绘制</p><span id="more"></span><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>先放一下效果图</p><div><img src='/image/HarmonyOS/verification_code/four_text_input.gif' width='30%' heigh='30%'/><img src='/image/HarmonyOS/verification_code/four_text.gif' width='30%' heigh='30%'/><img src='/image/HarmonyOS/verification_code/canvas_input.gif' width='30%' heigh='30%'/></div><h2 id="多个-Text-拼接"><a href="#多个-Text-拼接" class="headerlink" title="多个 Text 拼接"></a>多个 Text 拼接</h2><p>主要难点只有一个，也是最核心的问题：<strong>如何记录键盘输入的内容？</strong>。<br>这个问题解决了，就只剩下样式、展示输入内容这些简单的东西了。另外样式问题在上一篇中也提到过如何处理。</p><h3 id="记录输入内容"><a href="#记录输入内容" class="headerlink" title="记录输入内容"></a>记录输入内容</h3><h4 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h4><p>输入的内容我们用字符串记录一下，用 <code>Text</code>来展示，为了方便查看，加一些边框.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-meta">@State</span> inputStr :<span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;80%&#x27;</span>).<span class="hljs-title function_">margin</span>(&#123;<span class="hljs-attr">left</span>:<span class="hljs-string">&#x27;8%&#x27;</span>,<span class="hljs-attr">right</span>:<span class="hljs-string">&#x27;8%&#x27;</span>&#125;).<span class="hljs-title function_">borderRadius</span>(<span class="hljs-number">20</span>).<span class="hljs-title function_">borderWidth</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">borderColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">45</span>)<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="配置输入法"><a href="#配置输入法" class="headerlink" title="配置输入法"></a>配置输入法</h4><p>需要获取到<code>InputMethodController</code>实例，然后设置输入的类型、完成按钮显示的文案等等。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; inputMethod &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.IMEKit&#x27;</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">inputController</span>: inputMethod.<span class="hljs-property">InputMethodController</span> = inputMethod.<span class="hljs-title function_">getController</span>();<br><span class="hljs-comment">// 软键盘相关设置</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">textConfig</span>: inputMethod.<span class="hljs-property">TextConfig</span> = &#123;<br><span class="hljs-attr">inputAttribute</span>: &#123;<br>    <span class="hljs-attr">textInputType</span>: inputMethod.<span class="hljs-property">TextInputType</span>.<span class="hljs-property">NUMBER</span>,<br>    <span class="hljs-attr">enterKeyType</span>: inputMethod.<span class="hljs-property">EnterKeyType</span>.<span class="hljs-property">DONE</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="监听输入、删除事件"><a href="#监听输入、删除事件" class="headerlink" title="监听输入、删除事件"></a>监听输入、删除事件</h4><p>文档上给出了各种各样的事件，这里就不再一一列举，选择我们需要的<code>insertText</code>和<code>deleteLeft</code>时间进行监听。对其他事件感兴趣的可以自己试一下。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//订阅键盘输入、删除事件</span><br><span class="hljs-title function_">bindKeyboardEvent</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;insertText&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span> += text;<br>  &#125;)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;deleteLeft&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">length</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>.<span class="hljs-property">length</span> - length);<br>  &#125;)<br>&#125;<br><br><span class="hljs-title function_">unbindKeyboardEvent</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;insertText&#x27;</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;deleteLeft&#x27;</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">detach</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，这些时间可以被重复添加监听，添加多次则会回调多次，因此，我们在控件展示的时候添加监听，在控件销毁的时候移除监听。<br><code>inputController.attach()</code>方法的第一个布尔类型的参数表示是否在<code>attch</code>之后弹起软键盘。如果不需要的话可以设置为<code>false</code>,在后续有需要的时候通过<code>inputController.showTextInput()</code>和<code>inputController.hideTextInput()</code>控制软键盘的展示和隐藏。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Text</span>().<span class="hljs-title function_">onAppear</span>(<span class="hljs-keyword">async</span> ()=&gt;&#123;<br>          <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-literal">true</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">textConfig</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bindKeyboardEvent</span>()<br>          &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error:BusinessError</span>)=&gt;</span>&#123;<br>            hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&quot;RecordKeyboardInputPage&quot;</span>,<span class="hljs-string">&quot;输入法绑定出错&quot;</span>)<br>          &#125;)<br>      &#125;)<br>      .<span class="hljs-title function_">onDisAppear</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unbindKeyboardEvent</span>()<br>      &#125;)<br></code></pre></td></tr></table></figure><p>到这里我们就已经能够正确的记录下键盘输入的字符，并且展示在一个<code>Text</code>中了。最大的问题解决了，剩下的就是如何拆到多个<code>Text</code>上展示，这个就简单多了</p><h3 id="展示-1"><a href="#展示-1" class="headerlink" title="展示"></a>展示</h3><p>记录输入已经搞定了，这次用<code>Flex</code>做父布局，<code>Text</code>做子控件来展示一下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Flex</span>(&#123;<br>    <span class="hljs-attr">direction</span>: <span class="hljs-title class_">FlexDirection</span>.<span class="hljs-property">Row</span>,<br>    <span class="hljs-attr">justifyContent</span>: <span class="hljs-title class_">FlexAlign</span>.<span class="hljs-property">SpaceBetween</span>,<br>    <span class="hljs-attr">alignItems</span>: <span class="hljs-title class_">ItemAlign</span>.<span class="hljs-property">End</span>,<br>    <span class="hljs-attr">wrap</span>: <span class="hljs-title class_">FlexWrap</span>.<span class="hljs-property">NoWrap</span>,<br>    <span class="hljs-attr">space</span>: &#123; <span class="hljs-attr">main</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">LengthMetrics</span>(<span class="hljs-number">10</span>) &#125;<br>&#125;) &#123;<br>    <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeIdx</span>, <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>[item])<br>        .<span class="hljs-title function_">flexGrow</span>(<span class="hljs-number">1</span>)<br>        .<span class="hljs-title function_">flexShrink</span>(<span class="hljs-number">1</span>)<br>        .<span class="hljs-title function_">flexBasis</span>(<span class="hljs-number">1</span>)<br>        .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)<br>        .<span class="hljs-title function_">fontColor</span>(<span class="hljs-string">&#x27;#323232&#x27;</span>)<br>        .<span class="hljs-title function_">enabled</span>(<span class="hljs-literal">false</span>)<br>        .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)<br>        .<span class="hljs-title function_">border</span>(&#123;<br>        <span class="hljs-attr">style</span>: <span class="hljs-title class_">BorderStyle</span>.<span class="hljs-property">Solid</span>,<br>        <span class="hljs-attr">width</span>: &#123; <span class="hljs-attr">bottom</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>.<span class="hljs-property">length</span>==item ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span> &#125;,<br>        <span class="hljs-attr">color</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>.<span class="hljs-property">length</span>==item ? <span class="hljs-string">&#x27;#018576&#x27;</span> : <span class="hljs-string">&#x27;#bdbdbd&#x27;</span><br>        &#125;);<br>    &#125;);<br>&#125;<br>.<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>) .<span class="hljs-title function_">onAppear</span>(<span class="hljs-keyword">async</span> ()=&gt;&#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-literal">true</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">textConfig</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bindKeyboardEvent</span>()<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error:BusinessError</span>)=&gt;</span>&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&quot;RecordKeyboardInputPage&quot;</span>,<span class="hljs-string">&quot;输入法绑定出错&quot;</span>)<br>    &#125;)<br>&#125;)<br>.<span class="hljs-title function_">onDisAppear</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unbindKeyboardEvent</span>()<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就完成了一个基础的验证码输入框的功能。<br>哦，还少一个输入完成的回调，这个简单，就在订阅键盘的<code>insertText</code>事件回调里面判断一个字符串长度仿照上一篇做个回调就好了，这里就不再重复说明了。</p><h2 id="使用canvas自绘制"><a href="#使用canvas自绘制" class="headerlink" title="使用canvas自绘制"></a>使用canvas自绘制</h2><p>这个就是闲着写出来的玩的，一般也不会选择这种方案来实现。<br>接着上面的内容，同样的方法记录下键盘的输入内容，在<code>insertText</code>事件回调里面通知 canvas 进行绘制</p><h3 id="过程拆解"><a href="#过程拆解" class="headerlink" title="过程拆解"></a>过程拆解</h3><p>大致上分为两步，画文字，画背景。<br>这里背景就简单的设置为下划线，使用不同颜色来区分是不是焦点(当前需要输入的)。还是以 <code>4</code> 位验证码为例，画布宽度减去三个间隔后再除以 4，就是每条下划线的长度。<br>起点坐标为<code>((lineLength+space)*i,canvasHeight-2)</code>,终点坐标为<code>((lineLength+space)*i+lineLength,canvasHeight-2)</code><br>文字的中心 x 坐标应当和下划线的中心坐标 x 相同，这样画出的字才不会偏。<br>我们可以使用<code>CanvasRenderingContext2D.measureText(text:string)</code>来测量文字尺寸，然后计算出来文字的坐标。这里还得提醒一下，<code>CanvasRenderingContext2D.fillText</code>绘制文字时传入的坐标是文字的左下角坐标，别搞错了。</p><h4 id="第一步：画布参数、需要的变量"><a href="#第一步：画布参数、需要的变量" class="headerlink" title="第一步：画布参数、需要的变量"></a>第一步：画布参数、需要的变量</h4><p>需要记录画布大小已经绘制需要要的参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><span class="hljs-keyword">private</span> canvasWidth = <span class="hljs-number">0</span><br><span class="hljs-keyword">private</span> canvasHeight = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>拆出来画背景和画文字的方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">drawText</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title function_">drawUnderLine</span>(<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>在输入内容发生变化的时候，我们需要调用<code>drawText()</code>和<code>drawUnderLine()</code>方法进行绘制，并且判断输入的文字长度是否为指定长度，打到指定长度后进行回调。这里抽出来方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">onInputChange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">reset</span>()<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawUnderLine</span>()<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawText</span>()<br>  <span class="hljs-comment">// 输入给定位数后做一些操作</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>.<span class="hljs-property">length</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">codeLength</span>) &#123;<br>    promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">`输入的验证码是--&gt;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.verifyCodeStr&#125;</span>`</span> &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在键盘的的<code>insertText</code>和<code>deleteLeft</code>事件监听中调用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;insertText&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span> += text;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onInputChange</span>()<br>&#125;);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;deleteLeft&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onInputChange</span>()<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="画背景"><a href="#画背景" class="headerlink" title="画背景"></a>画背景</h4><p>这里就按照上面拆解过程中画线的方法绘制就行了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">drawUnderLine</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//每个下划线长度</span><br>  <span class="hljs-keyword">let</span> lineWidth = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> - (<span class="hljs-variable language_">this</span>.<span class="hljs-property">codeLength</span> - <span class="hljs-number">1</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span>) / <span class="hljs-number">4</span><br>  <span class="hljs-comment">//画出下划线</span><br>  <span class="hljs-keyword">let</span> y = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> - <span class="hljs-number">2</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">codeLength</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>.<span class="hljs-property">length</span> ==  i) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#39D167&quot;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">3</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#999999&quot;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> startX = (lineWidth + <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span>) * i<br>    <span class="hljs-keyword">let</span> endX = lineWidth + (lineWidth + <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span>) * i<br>    path.<span class="hljs-title function_">moveTo</span>(startX, y)<br>    path.<span class="hljs-title function_">lineTo</span>(endX, y)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>(path)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里也有需要注意的点，划线时我是用的<code>Path2D</code>路径对象保存的下划线信息而不是直接使用<code>CanvasRenderingContext2D.lineTo(x: number, y: number)</code>这样方法。这是因为后者有一些意想不到的问题：比如调用<code>this.CanvasRenderingContext2D.clearRect()</code>后再调用<br><code>CanvasRenderingContext2D.stroke()</code>,你会发现被 clear 的区域又回来了。<br>在上面这个循环中，虽然我们设置了不同的颜色及宽度，但当我们输入第二个文字时，会发现第一个下划线被绘制了两遍，而且是不同颜色叠加在一起。有兴趣的可以自己试一下，不知道是我的写法有问题还是对文档的理解有问题，还是其他原因就不得而知了</p><h4 id="画文字"><a href="#画文字" class="headerlink" title="画文字"></a>画文字</h4><p>这个也不复杂</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">drawText</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//每个下划线长度</span><br>  <span class="hljs-keyword">let</span> lineWidth = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> - (<span class="hljs-variable language_">this</span>.<span class="hljs-property">codeLength</span> - <span class="hljs-number">1</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span>) / <span class="hljs-number">4</span><br>  <span class="hljs-comment">//绘制的文字大小和颜色</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#666666&quot;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">font</span> = <span class="hljs-string">&quot;30vp&quot;</span><br>  <span class="hljs-comment">//文字和下划线的距离</span><br>  <span class="hljs-keyword">let</span> y = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> - <span class="hljs-number">6</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">codeLength</span> &amp;&amp; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-comment">//在每个下划线的中心画数字：（线长的一半+线的起点 - 文字宽度的一半)</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-title class_">TextMetrics</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">measureText</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>[i])<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fillText</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>[i],<br>      lineWidth / <span class="hljs-number">2</span> + (lineWidth + <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span>) * i - result.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, y)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就完成了使用 canvas 绘制的验证码输入框</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么样，验证码输入框是不是看上去很简单，实际上一点也不难？<br>只要有了思路，拆解成小步骤，然后又一步步实现就好了。</p><p>个人认为常用的就是上一篇的<code>TextInput</code>方案和本篇的<code>Text</code>方法， canvas 自绘制一般真用不到，除非是一些奇形怪状的需求</p><hr><p><strong>最后还得吐槽一下，鸿蒙的接口参数中有很多很多需要这种硬编码的配置，搞的很烦，就不能用个常量或者枚举值代替一下么???</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇文章&lt;a href=&quot;https://juejin.cn/spost/7413607758577106978&quot;&gt;鸿蒙-验证码输入框的几种实现方式(上)&lt;/a&gt;中介绍了如何使用多个&lt;code&gt;TextInput&lt;/code&gt;来实现验证码输入框，&lt;br&gt;本篇文章中介绍另外一种思路：自己代码控制、记录键盘输入内容，使用&lt;code&gt;Text&lt;/code&gt;组件展示验证码，当然也可以使用&lt;code&gt;Canvas&lt;/code&gt;自己绘制&lt;/p&gt;</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙-验证码输入框的几种实现方式(上)</title>
    <link href="https://blog.huangyuanlove.com/2024/09/10/%E9%B8%BF%E8%92%99-%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E4%B8%8A/"/>
    <id>https://blog.huangyuanlove.com/2024/09/10/%E9%B8%BF%E8%92%99-%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E4%B8%8A/</id>
    <published>2024-09-10T09:57:30.000Z</published>
    <updated>2024-09-13T01:27:05.693Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做应用鸿蒙化，说白了就是把原来<code>Android</code>、<code>iOS</code>的代码重新用<code>ArkTS</code>写一遍，我负责基础建设和登录模块，有个验证码输入框需要定制一下外观样式。这里详细记录一下探索过程及结果，以及思路和源码。这里给出了三种方案<br>一：多个 InputText 拼接，每个 InputText 只能输入 1 个字符，代码控制焦点移动，<br>二：多个 Text 拼接，通过系统api<code>inputMethod.InputMethodController</code>控制键盘弹起并记录输入内容，刷新到 Text 中展示<br>三：使用 Canvas 自己绘制。<br>由于篇幅较长，这个拆成两篇来介绍。本篇介绍前两种方式，也是最常见的方式。使用Canvas 自己绘制纯粹就是闲着写的东西，后面再介绍。</p><span id="more"></span><h2 id="效果图、优缺点"><a href="#效果图、优缺点" class="headerlink" title="效果图、优缺点"></a>效果图、优缺点</h2><p>先放一下效果图</p><div><img src='/image/HarmonyOS/verification_code/four_text_input.gif' width='30%' heigh='30%'/><img src='/image/HarmonyOS/verification_code/four_text.gif' width='30%' heigh='30%'/><img src='/image/HarmonyOS/verification_code/canvas_input.gif' width='30%' heigh='30%'/></div><h4 id="多TextInput"><a href="#多TextInput" class="headerlink" title="多TextInput"></a>多TextInput</h4><p><strong>优点</strong>：只需要控制焦点就好，键盘的弹起、收起以及输入的内容我们不需要自己去监听，并且除了边框颜色之外，输入框内会有光标闪烁，也能给用户更强一些的提示<br><strong>缺点：需要控制没有获取到焦点的输入框不能点击、不能长按等。尝试多种方案</strong>(设置 enable、focusable 等)均失败后，决定在输入框上面覆盖一个空白透明且大小和输入框相等的 Text 解决这个问题。有其他方案可以告诉我一下</p><h4 id="多-Text"><a href="#多-Text" class="headerlink" title="多 Text"></a>多 Text</h4><p><strong>优点</strong>：不用控制焦点，只需要使用变量控制一下样式就好<br><strong>缺点</strong>：需要自己记录键盘输入的文字，并且没有光标闪烁，当前也可以自己搞个 gif 图或者写个动画来模拟光标</p><h4 id="Canvas-绘制"><a href="#Canvas-绘制" class="headerlink" title="Canvas 绘制"></a>Canvas 绘制</h4><p><strong>优点</strong>：我真的没想到有啥优点，可以自由的绘制边框、底色也算么？但现在的 pai 中有各种各样的Modifier来修改各种属性，实现自己绘制<br><strong>缺点</strong>：全都得自己画，挺麻烦的</p><h2 id="多个-TextInput-拼接"><a href="#多个-TextInput-拼接" class="headerlink" title="多个 TextInput 拼接"></a>多个 TextInput 拼接</h2><p>这里用四位验证码做例子：<br>思路挺简单的，四个<code>TextInput</code>并排放一块，输入框限制输入 1 个字符，用<code>Flex</code>做父控件也行，用<code>Row</code>做父控件也行,无所谓，这不是重点。<br>组件刚出现时，使用<code>getUIContext().getFocusController().requestFocus(key:string)</code>将焦点放在第一个输入框上，键盘就可以弹出来<br>监听<code>TextInput</code>的<code>onDidDelete</code>和<code>onChange</code>或者<code>onDidInsert</code>事件，来判断下一个焦点放在哪个位置<br>当最后一个<code>TextInput</code>有输入字符时，认为输入完成，进行回调。</p><p>下面详细介绍一下每一步怎么做的，以及对应的想法</p><h3 id="放置四个输入框"><a href="#放置四个输入框" class="headerlink" title="放置四个输入框"></a>放置四个输入框</h3><p>当前获取到焦点的输入框颜色要明亮一些，没有焦点的输入框颜色要暗淡一些。我们使用<code>@Extend()</code>做一个公用样式，传入当前是否是焦点控件来控制边框颜色</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Extend</span>(<span class="hljs-title class_">TextInput</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">textInputStyle</span>(<span class="hljs-params">enable:<span class="hljs-built_in">boolean</span></span>)&#123;<br>  .<span class="hljs-title function_">border</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">color</span>: enable?<span class="hljs-string">&quot;#1b91e0&quot;</span>:<span class="hljs-string">&quot;#999999&quot;</span>,<br>    <span class="hljs-attr">radius</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-attr">style</span>: <span class="hljs-title class_">BorderStyle</span>.<span class="hljs-property">Solid</span>,<br>  &#125;).<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)<br>  .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">maxLength</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">maxLines</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">type</span>(<span class="hljs-title class_">InputType</span>.<span class="hljs-property">Number</span>)<br>  .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">40</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>为了在焦点变化的时候输入框背景能同步修改，这里用一个<code>@State</code>修饰的布尔数组表示哪个输入框获取焦点。同时为了省事，也定义了另外一个数组，方便使用 <code>ForEach</code>循环渲染。定义另外一个字符串数组来记录每个输入框的内容</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@State</span> <span class="hljs-attr">inputValue</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]<span class="hljs-comment">// 输入框的内容</span><br><span class="hljs-meta">@State</span> <span class="hljs-attr">inputEnable</span>: <span class="hljs-built_in">boolean</span>[] = [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>] <span class="hljs-comment">//输入框是否获取焦点</span><br><span class="hljs-attr">inputIndex</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">//ForEach渲染用</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<span class="hljs-comment">//这里用 Flex 更方便一些，直接设置间距就好，不用这样设置 margin 了</span><br>      <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>, <span class="hljs-function">(<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-title class_">TextInput</span>(&#123; <span class="hljs-attr">text</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index] &#125;)<br>          .<span class="hljs-title function_">id</span>(index.<span class="hljs-title function_">toString</span>())<span class="hljs-comment">//这里 id 是给FocusController使用</span><br>          .<span class="hljs-title function_">margin</span>(&#123; <span class="hljs-attr">right</span>: index == <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span> &#125;)<br>          .<span class="hljs-title function_">textInputStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index])<br>      &#125;)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>这样我们就画出来了最基本的布局。但我们会发现进入页面后键盘不能自己弹出来，因为输入框没有获取到焦点。<br>这里有两个方案，一个是给其中<code>TextInput</code>设置<code>defaultFocus</code>为 true，或者在页面展示的时候设置焦点</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">TextInput</span>(&#123; <span class="hljs-attr">text</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index] &#125;).<span class="hljs-title function_">defaultFocus</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index])<br><span class="hljs-comment">//或者</span><br><span class="hljs-title class_">Row</span>()&#123;&#125;.<span class="hljs-title function_">onAppear</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>(<span class="hljs-string">&quot;0&quot;</span>)&#125;)<br></code></pre></td></tr></table></figure><p>注意这里<code>requestFocus()</code>方法传入的参数<code>&quot;0&quot;</code>,也就是上面<code>TextInput</code>的<code>id</code>的值.<br>这样我们就做好的基本的属性，并且页面显示的时候也可以弹出键盘了。<br><img src="/image/HarmonyOS/verification_code/four_textinput_base.png"></p><h3 id="焦点移动"><a href="#焦点移动" class="headerlink" title="焦点移动"></a>焦点移动</h3><h4 id="输入时向后移动"><a href="#输入时向后移动" class="headerlink" title="输入时向后移动"></a>输入时向后移动</h4><p>但是这时候我们点击键盘输入的时候，发现光标并不会自动移动到下一个输入框上继续输入。这里需要我们进行控制。这个也比较简单，<code>TextInput</code>有一个输入内容发生变化时，触发的回调：<code>onChange(callback: EditableTextOnChangeCallback)</code>。我们可以在这个方法里面移动焦点</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">TextInput</span>().<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, previewText?: PreviewText</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index] = value <span class="hljs-comment">//记录输入的内容</span><br><span class="hljs-keyword">if</span> (value.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//确认是输入而不是删除</span><br>    <span class="hljs-keyword">if</span> (index != <span class="hljs-number">3</span>) &#123;<span class="hljs-comment">//如果不是最后一个输入框发生的输入事件，就把焦点交给下一个输入框</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index+<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><span class="hljs-comment">//记录下一个输入框获取焦点，改变背景色</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>((index + <span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>())<span class="hljs-comment">//下一个输入框获取焦点</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index] = <span class="hljs-literal">false</span><span class="hljs-comment">//标记当前输入框失去焦点，改变背景色</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果是最后一个输入框发生的输入事件，表示已经输入完了，继续后面流程</span><br>    <span class="hljs-comment">//todo 输入完成，继续后面流程</span><br>    &#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="输入完成回调"><a href="#输入完成回调" class="headerlink" title="输入完成回调"></a>输入完成回调</h4><p>这就很简单了，定义一个函数变量，接收父布局传进来的函数，输入完成时回调这个函数就好</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">onFinishInput?: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>  <span class="hljs-comment">//函数变量</span><br><span class="hljs-comment">//输入完成，进行回调</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onFinishInput</span>) &#123;<span class="hljs-comment">//判断一下空值，然后把保存的值拼接成字符串回调</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        result += <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[i]<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onFinishInput</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，我们已经实现了大部分功能：输入字符、保存字符、焦点向后移动、输入完成时回调。<br>下面要解决的就是删除</p><h4 id="删除时向前移动"><a href="#删除时向前移动" class="headerlink" title="删除时向前移动"></a>删除时向前移动</h4><p>这里需要注意一下：<br>如果当前输入框有内容，点击删除时删除当前输入框内容，焦点不动：仅在最后一个输入框会有这个情况<br>如果当前输入框没有内容，则删除上一个输入框内容，焦点移动到上一个输入框<br>如果当前时第一个输入框，不做处理</p><p>刚开始想着在<code>onChange</code>事件中做处理，但当输入框中没有内容时，点击删除的时是没有回调的。怎么搞，翻翻文档，找到了<code>onWillDelete</code>和<code>onDidDelete</code>,并且这两个回调都是发生在<code>onChange</code>之前。<br>这里我选择了<code>onDidDelete</code>事件中处理，逻辑就是上面说的那样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">TextInput</span>().<span class="hljs-title function_">onDidDelete</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index].<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//不是第一个输入框 且 输入框内没有文字，则删除上一个输入框内容，并且使上一个输入框获取焦点</span><br>    <span class="hljs-keyword">if</span> (index != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index-<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index] = <span class="hljs-literal">false</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index-<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><br><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>((index - <span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>())<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//如果输入框内有文字，则只删除当前输入框内容</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index] = <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>到这里我们就完成了大部分的工作，一个可以正常工作，随便调整背景的验证码输入框就完成了。<br>但似乎还有一点问题，当点击非当前焦点的输入框时，光标会移动到点击的输入框中。这就不太好了</p><h3 id="防止点击"><a href="#防止点击" class="headerlink" title="防止点击"></a>防止点击</h3><p>一开始想法很简单，我们不是有个布尔类型数组保存着当前哪个输入框获取焦点么？没有焦点的输入框设置enable为false就可以了哇，移动焦点的时候先将目标输入框设置enable为true，然后再移动焦点就好了哇。<br>那就给输入框加上这个设置就好了哇</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">TextInput</span>().<span class="hljs-title function_">enabled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index])<br></code></pre></td></tr></table></figure><p>我们在上面的代码中，都是先修改<code>inputEnable</code>数组值，然后再设置焦点，<code>完美</code>。<br>运行一下，页面出现时弹出键盘，除了第一个输入框其他输入框点击都没有反映，<code>很好</code>。<br>试着输入一下，崩了。。。。<br>日志提示组件不存在或者时不可用状态</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">Error message:The component doesn&#x27;t exist, is currently invisible, or has been disabled.<br></code></pre></td></tr></table></figure><p>难道是因为在请求焦点的时候，输入框的属性还没来得及完成修改？<br>做个测试，延迟1s设置焦点，果然是可以的。但这种效果太难受了，键盘会先收起来再弹出来。缩短延迟时间也很难把握时长。那就再翻翻api，找找下一帧之类的回调。<br>还真有，在UIContext这个类中有一个函数<code>postFrameCallback</code>:注册一个在下一帧进行渲染时执行的回调。按照示例把代码撸好，编译运行，尝试输入，又又又崩了，错误信息也一样。<br>没办法了么？只能用延迟么？太难受了哇，来个曲线救国，我们搞个透明没有内容的控件覆盖在没有焦点的输入框上不就行了么。<br>于是我们得到了这样的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Row</span>()&#123;<br>  <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>,<span class="hljs-function">(<span class="hljs-params">index:<span class="hljs-built_in">number</span></span>)=&gt;</span>&#123;<br>    <span class="hljs-title class_">RelativeContainer</span>()&#123;<br>      <span class="hljs-title class_">TextInput</span>(&#123;<span class="hljs-attr">text</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index]&#125;)<br>        <br>      <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index])&#123;<span class="hljs-comment">//没有焦点则覆盖一个空白Text</span><br>        <span class="hljs-title class_">Text</span>().<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Transparent</span>)<br>          .<span class="hljs-title function_">alignRules</span>(&#123;<br>          <span class="hljs-attr">left</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">Start</span>&#125;,<br>          <span class="hljs-attr">top</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">VerticalAlign</span>.<span class="hljs-property">Top</span>&#125;,<br>          <span class="hljs-attr">bottom</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">VerticalAlign</span>.<span class="hljs-property">Bottom</span>&#125;,<br>          <span class="hljs-attr">right</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">End</span>&#125;<br>        &#125;)<br>      &#125;<br>    &#125;.<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">40</span>).<span class="hljs-title function_">margin</span>(&#123;<span class="hljs-attr">right</span>:index == <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>?<span class="hljs-number">0</span>:<span class="hljs-number">10</span>&#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，就解决了点击非焦点输入框的问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看起来挺简单的，实际上一点也不难。<br>还有可以优化的地方：<br>比如输入的内容可以不用数组，直接用字符串就好，删除和添加都是在末尾进行<br>比如焦点也可以不用记录的，直接用输入的字符串长度来判断就好。</p><p>遗留下的一个问题：<br>在上面使用enable来控制是否可点击时，为什么先设置enable为true，然后请求焦点会报错？<br>先设置enable为true，在下一帧时请求焦点还是报错。<br>这就留给大佬翻源码解释了。</p><hr><p>附一个完整代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; hilog &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.PerformanceAnalysisKit&#x27;</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">FourTextInput</span> &#123;<br>  onFinishInput?: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">inputValue</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">inputEnable</span>: <span class="hljs-built_in">boolean</span>[] = [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>]<br>  <span class="hljs-attr">inputIndex</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title class_">Row</span>()&#123;<br>        <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>,<span class="hljs-function">(<span class="hljs-params">index:<span class="hljs-built_in">number</span></span>)=&gt;</span>&#123;<br>          <span class="hljs-title class_">RelativeContainer</span>()&#123;<br>            <span class="hljs-title class_">TextInput</span>(&#123;<span class="hljs-attr">text</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index]&#125;).<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">textInputStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index]).<span class="hljs-title function_">maxLength</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">maxLines</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">id</span>(index.<span class="hljs-title function_">toString</span>()).<span class="hljs-title function_">type</span>(<span class="hljs-title class_">InputType</span>.<span class="hljs-property">Number</span>)<br>              .<span class="hljs-title function_">onDidDelete</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>                hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&quot;InputVerificationCode&quot;</span>,<span class="hljs-string">`第<span class="hljs-subst">$&#123;index&#125;</span>个执行 onDidDelete`</span>)<br>                <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index].<span class="hljs-property">length</span> == <span class="hljs-number">0</span>)&#123;<br>                  <span class="hljs-comment">//不是第一个输入框 且 输入框内没有文字，则删除上一个输入框内容，并且使上一个输入框获取焦点</span><br>                  <span class="hljs-keyword">if</span>(index !=<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index-<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;&quot;</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index] =<span class="hljs-literal">false</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index-<span class="hljs-number">1</span>] =<span class="hljs-literal">true</span><br><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>((index-<span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>())<br>                  &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//如果输入框内有文字，则只删除当前输入框内容</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index]=<span class="hljs-string">&quot;&quot;</span><br>                  &#125;<br>                &#125;<br>              &#125;)<br>              .<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, previewText?: PreviewText</span>)=&gt;</span>&#123;<br>                hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&quot;InputVerificationCode&quot;</span>,<span class="hljs-string">`第<span class="hljs-subst">$&#123;index&#125;</span>个onChange:  value:<span class="hljs-subst">$&#123;value&#125;</span>  previewText: value-&gt; <span class="hljs-subst">$&#123;previewText?.value&#125;</span>    offset-&gt;<span class="hljs-subst">$&#123;previewText?.offset&#125;</span>`</span>   )<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index]= value<br>                <span class="hljs-keyword">if</span>(value.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>)&#123;<br>                  <span class="hljs-keyword">if</span>(index != <span class="hljs-number">3</span>)&#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index+<span class="hljs-number">1</span>] =<span class="hljs-literal">true</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>((index+<span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>())<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index] = <span class="hljs-literal">false</span><br>                    <span class="hljs-comment">// this.inputEnable[index] =false</span><br>                  &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">onFinishInput</span>)&#123;<br>                      <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span><br>                      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>;i&lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>.<span class="hljs-property">length</span>;i++)&#123;<br>                        result += <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[i]<br>                      &#125;<br>                      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onFinishInput</span>(result)<br>                    &#125;<br>                  &#125;<br>                &#125;<br>              &#125;)<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index])&#123;<br>              <span class="hljs-title class_">Text</span>().<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Transparent</span>).<span class="hljs-title function_">alignRules</span>(&#123;<br>                <span class="hljs-attr">left</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">Start</span>&#125;,<br>                <span class="hljs-attr">top</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">VerticalAlign</span>.<span class="hljs-property">Top</span>&#125;,<br>                <span class="hljs-attr">bottom</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">VerticalAlign</span>.<span class="hljs-property">Bottom</span>&#125;,<br>                <span class="hljs-attr">right</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">End</span>&#125;<br>              &#125;)<br>            &#125;<br>          &#125;.<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">40</span>).<span class="hljs-title function_">margin</span>(&#123;<span class="hljs-attr">right</span>:index == <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>?<span class="hljs-number">0</span>:<span class="hljs-number">10</span>&#125;)<br>        &#125;)<br>      &#125;.<span class="hljs-title function_">onAppear</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>(<span class="hljs-string">&quot;0&quot;</span>)<br>      &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Extend</span>(<span class="hljs-title class_">TextInput</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">textInputStyle</span>(<span class="hljs-params">enable: <span class="hljs-built_in">boolean</span></span>) &#123;<br>  .<span class="hljs-title function_">border</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">color</span>: enable ? <span class="hljs-string">&quot;#1b91e0&quot;</span> : <span class="hljs-string">&quot;#999999&quot;</span>,<br>    <span class="hljs-attr">radius</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-attr">style</span>: <span class="hljs-title class_">BorderStyle</span>.<span class="hljs-property">Solid</span>,<br>  &#125;)<br>  .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)<br>  .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">maxLength</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">maxLines</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">type</span>(<span class="hljs-title class_">InputType</span>.<span class="hljs-property">Number</span>)<br>  .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">height</span>(<span class="hljs-number">40</span>)<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; <span class="hljs-title class_">FourTextInput</span> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在做应用鸿蒙化，说白了就是把原来&lt;code&gt;Android&lt;/code&gt;、&lt;code&gt;iOS&lt;/code&gt;的代码重新用&lt;code&gt;ArkTS&lt;/code&gt;写一遍，我负责基础建设和登录模块，有个验证码输入框需要定制一下外观样式。这里详细记录一下探索过程及结果，以及思路和源码。这里给出了三种方案&lt;br&gt;一：多个 InputText 拼接，每个 InputText 只能输入 1 个字符，代码控制焦点移动，&lt;br&gt;二：多个 Text 拼接，通过系统api&lt;code&gt;inputMethod.InputMethodController&lt;/code&gt;控制键盘弹起并记录输入内容，刷新到 Text 中展示&lt;br&gt;三：使用 Canvas 自己绘制。&lt;br&gt;由于篇幅较长，这个拆成两篇来介绍。本篇介绍前两种方式，也是最常见的方式。使用Canvas 自己绘制纯粹就是闲着写的东西，后面再介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>鸿蒙-canvas-刮刮乐</title>
    <link href="https://blog.huangyuanlove.com/2024/08/24/%E9%B8%BF%E8%92%99-canvas-%E5%88%AE%E5%88%AE%E4%B9%90/"/>
    <id>https://blog.huangyuanlove.com/2024/08/24/%E9%B8%BF%E8%92%99-canvas-%E5%88%AE%E5%88%AE%E4%B9%90/</id>
    <published>2024-08-24T13:50:41.000Z</published>
    <updated>2024-09-10T09:59:26.823Z</updated>
    
    <content type="html"><![CDATA[<p>Android 中 canvas 能画出来的东西鸿蒙的 canvas 还画不了，不大可能吧？有个朋友问鸿蒙应用中想实现刮刮乐效果，应该咋画？这个问题，你能在 Android 上用 canvas 画出来，在鸿蒙里面用 canvas 画不出来？还是 api 不熟悉吧？</p><span id="more"></span><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>这个就比较简单了。你先这样这样，然后再那样那样就行了。<br>好吧， 正式点，和Android没什么区别：<br>底层放一张图片或者其他什么控件都行。上面叠一层灰色canvas，手指滑动时记录一下路径，将路径上的颜色去除就行了。和手写签名唯一的区别：签名是按路径添加，刮刮乐是按路径移除。<br>会了的就不用往下看了，太长不想看的直接拖到最后看源码</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>和<code>Android</code>中的<code>PorterDuff.Mode</code>类似，在鸿蒙中也提供了11种不同的画布复合模式：</p><ol><li>source-over: (Default) Draws a new drawing on top of an existing canvas context. 在现有的画布上方绘制新的图形。也是默认行为。</li><li>source-in: The new drawing is drawn only where the new drawing overlaps the target canvas.Everything else is transparent.新的图形只在与目标画布重叠的区域绘制，其他区域为透明。</li><li>source-out: Draws a new drawing where it does not overlap with the existing canvas content. 在不与现有画布内容重叠的区域绘制新的图形。</li><li>source-atop: The new drawing is drawn only where it overlaps the content of the existing canvas. 新的图形只在与现有画布内容重叠的区域绘制。</li><li>destination-over: Draws a new graphic behind the existing canvas content. 在现有画布内容后面绘制新的图形。</li><li>destination-in: Existing canvas content remains where the new drawing overlaps the existing canvas content.Everything else is transparent.仅在新的图形与现有画布内容重叠的区域保留现有画布内容，其他区域为透明。</li><li>destination-out: Existing content remains where the new drawing does not overlap. 仅在新的图形不与现有画布内容重叠的区域保留现有内容。</li><li>destination-atop: The existing canvas retains only the part that overlaps with the new drawing,which is drawn behind the canvas content. 现有画布仅保留与新的图形重叠的部分，并位于画布内容后面绘制。</li><li>lighter: The color of two overlapping shapes is determined by adding the color values. 两个重叠形状的颜色通过相加颜色值来确定。</li><li>copy: Only new graphics are displayed. 仅显示新的图形。</li><li>xor: In the image, those overlaps and other places outside of the normal drawing are transparent. 在图像中，重叠部分和正常绘制范围之外的其他区域为透明。</li></ol><p>看简介也可能是一脸懵，我们直接上代码看效果。先画一个红色的圆，之后设置<code>globalCompositeOperation</code>为不同的值，再画一个蓝色的正方形，直接看效果。<br>具体点将，就是红色圆形半径为画布的四分之一，圆心也在画布的四分之一处。蓝色正方形边长是圆形直径，左上角与圆心重合。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CompositeOperationView</span>&#123;<br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">compositeOperation</span>:<span class="hljs-built_in">string</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">//获取画布宽高</span><br>      <span class="hljs-keyword">let</span> canvasWidth = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">width</span><br>      <span class="hljs-keyword">let</span> canvasHeight = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">height</span><br><br>      <span class="hljs-comment">//计算圆心</span><br>      <span class="hljs-keyword">let</span> circleX = canvasWidth/<span class="hljs-number">4</span><br>      <span class="hljs-keyword">let</span> circleY = canvasHeight/<span class="hljs-number">4</span>;<br>      <span class="hljs-keyword">let</span> circleCenter = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(circleX,circleY)<br><br>      <span class="hljs-comment">//画红色圆形</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#FF0000&quot;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(circleCenter,circleCenter,circleCenter,<span class="hljs-number">0</span>,<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>()<br><br>      <span class="hljs-comment">//设置画布复合操作方式</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">compositeOperation</span><br><br>      <span class="hljs-comment">//画蓝色正方形</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#0000FF&quot;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fillRect</span>(circleCenter, circleCenter, circleCenter*<span class="hljs-number">2</span>, circleCenter*<span class="hljs-number">2</span>)<br><br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span>&#123;<span class="hljs-title class_">CompositeOperationView</span>&#125;<br></code></pre></td></tr></table></figure><p>这里一共有11种复合操作方式，为了方便对比，我们把这11种方式都画在同一个屏幕上。<br>因此，在<code>CompositeOperationView</code>中，我们将<code>compositeOperation</code>使用<code>@Prop</code>修饰，由父级控件传进来。  </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CanvasCompositeOperationPage</span>&#123;<br>  <span class="hljs-attr">compositeOperation</span>:<span class="hljs-built_in">string</span>[]=[<span class="hljs-string">&quot;source-over&quot;</span>,<span class="hljs-string">&quot;source-in&quot;</span>,<span class="hljs-string">&quot;source-out&quot;</span>,<span class="hljs-string">&quot;source-atop&quot;</span>,<span class="hljs-string">&quot;destination-over&quot;</span>,<span class="hljs-string">&quot;destination-in&quot;</span>,<span class="hljs-string">&quot;destination-out&quot;</span>,<span class="hljs-string">&quot;destination-atop&quot;</span>,<span class="hljs-string">&quot;lighter&quot;</span>,<span class="hljs-string">&quot;copy&quot;</span>,<span class="hljs-string">&quot;xor&quot;</span>]<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Flex</span>(&#123; <span class="hljs-attr">direction</span>: <span class="hljs-title class_">FlexDirection</span>.<span class="hljs-property">Row</span>, <span class="hljs-attr">wrap</span>: <span class="hljs-title class_">FlexWrap</span>.<span class="hljs-property">Wrap</span>, &#125;)&#123;<br>      <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compositeOperation</span>,<span class="hljs-function">(<span class="hljs-params">item:<span class="hljs-built_in">string</span></span>)=&gt;</span>&#123;<br>        <span class="hljs-title class_">Column</span>()&#123;<br>          <span class="hljs-title class_">Text</span>(item)<br>          <span class="hljs-title class_">CompositeOperationView</span>(&#123;<span class="hljs-attr">compositeOperation</span>:item&#125;).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;80%&quot;</span>)<br>        &#125;.<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;30%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;20%&quot;</span>)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里我们用<code>ForEach</code>循环来进行绘制，这里就不在过多介绍，不清楚的可以去看鸿蒙开发文档中的指南。<br>我们最终得到这样的一张图<br><img src="/image/HarmonyOS/compositeOperation.png"><br>这就一目了然了，我们可以选用<code>destination-out</code>来实现刮刮乐效果</p><h2 id="刮刮乐效果"><a href="#刮刮乐效果" class="headerlink" title="刮刮乐效果"></a>刮刮乐效果</h2><p>就和文章开始说的一样，先放一张图，然后canvas绘制蒙层，画布复合操作模式为<code>destination-out</code>，记录手指移动路径，绘制到canvas上，结束。<br>详细一点就是：</p><ol><li>外层Stack层叠布局，子控件先放一个Image然后再放一个Canvas</li><li>Canvas上我们可以绘制上纯颜色，也可以绘制另外一张图片</li><li>画布复合操作模式为<code>destination-out</code>，</li><li>在Canvas的<code>onTouch</code>事件中，当<code>TouchType.Move</code>时，在当前坐标画一个小圆。</li><li>结束</li></ol><p>按照这个思路，整体代码就是这样的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Preview</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">ScratchOffView</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">path</span>: <span class="hljs-title class_">Path2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Stack</span>() &#123;<br>      <span class="hljs-title class_">Image</span>($r(<span class="hljs-string">&quot;app.media.cat&quot;</span>))<br>      <span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> canvasWidth = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">width</span><br>        <span class="hljs-keyword">let</span> canvasHeight = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">height</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#aaf7f7f7&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvasWidth, canvasHeight)<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#00000000&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#000000&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-string">&quot;destination-out&quot;</span><br><br><br>      &#125;).<span class="hljs-title function_">onTouch</span>(<span class="hljs-function">(<span class="hljs-params">event: TouchEvent</span>) =&gt;</span> &#123;<br><br>        <span class="hljs-keyword">let</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>        <span class="hljs-keyword">let</span> prex = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">let</span> prey = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">switch</span> (event.<span class="hljs-property">type</span>) &#123;<br>          <span class="hljs-keyword">case</span> <span class="hljs-title class_">TouchType</span>.<span class="hljs-property">Down</span>:<br>            prex = event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">x</span><br>            prey = event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">y</span><br>            path.<span class="hljs-title function_">moveTo</span>(prex, prey)<br>            <span class="hljs-keyword">break</span><br>          <span class="hljs-keyword">case</span> <span class="hljs-title class_">TouchType</span>.<span class="hljs-property">Move</span>:<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">path</span>.<span class="hljs-title function_">moveTo</span>(event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">x</span>, event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">y</span>)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">path</span>.<span class="hljs-title function_">arc</span>(event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">x</span>, event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">y</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>*<span class="hljs-number">2</span>, <span class="hljs-literal">false</span>)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">path</span>)<br>            <br>            <span class="hljs-keyword">break</span><br>          <span class="hljs-keyword">case</span> <span class="hljs-title class_">TouchType</span>.<span class="hljs-property">Up</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;)<br>    &#125;.<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>)<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后放张效果图吧</p><p><img src="/image/HarmonyOS/ScratchOffView.gif"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实canvas并没有那么麻烦那么困难，我们只要熟悉了鸿蒙canvas的api，在Android上能实现的功能，鸿蒙能基本都能实现。比如手写签名、贝塞尔曲线、图片翻转、九宫格图片等等。<br>并不像我们想象中的那么困难，总之，先动手rua代码试试呗</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android 中 canvas 能画出来的东西鸿蒙的 canvas 还画不了，不大可能吧？有个朋友问鸿蒙应用中想实现刮刮乐效果，应该咋画？这个问题，你能在 Android 上用 canvas 画出来，在鸿蒙里面用 canvas 画不出来？还是 api 不熟悉吧？&lt;/p&gt;</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="https://blog.huangyuanlove.com/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>使用无障碍服务完成一键拨打微信视频电话</title>
    <link href="https://blog.huangyuanlove.com/2024/08/16/%E4%BD%BF%E7%94%A8%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%80%E9%94%AE%E6%8B%A8%E6%89%93%E5%BE%AE%E4%BF%A1%E8%A7%86%E9%A2%91%E7%94%B5%E8%AF%9D%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>https://blog.huangyuanlove.com/2024/08/16/%E4%BD%BF%E7%94%A8%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%80%E9%94%AE%E6%8B%A8%E6%89%93%E5%BE%AE%E4%BF%A1%E8%A7%86%E9%A2%91%E7%94%B5%E8%AF%9D%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2024-08-16T02:10:35.000Z</published>
    <updated>2024-08-19T10:31:45.624Z</updated>
    
    <content type="html"><![CDATA[<p>无障碍服务适配大家应该多多少少的都遇到过，简单点讲就是给图片、文本等控件加上 <code>android:contentDescription=&quot;&quot;</code>标签，这样在使用无障碍服务(比如手机自带的 talkback)时，可以将<code>contentDescription</code>的内容以声音的方式读出来，方便视障用户使用我们的 app。</p><p>这不是本文的重点，重点是在无障碍–&gt;已安装的服务中中发现了一些其他的应用也提供了一些无障碍服务，比如某输入法提供了”智能回复”、”智能应答”等服务，某些应用还提供了类似于一键进行微信视频通话功能，这玩意咋搞的？我们能不能搞？能不能给老人做一个简单的工具，去掉那些花里胡哨的功能，点个按钮就能和我们进行视频通话？<br><strong>不要用无障碍服务做违法的事情！！！不要用无障碍服务做违法的事情！！！不要用无障碍服务做违法的事情！！!</strong></p><span id="more"></span><p>查了一些资料，我们可以使用<code>AccessibilityService</code>来实现该功能。该服务可以在页面切换或者发生其他变化时回调某些方法，我们可以根据这些回调，获取到页面的节点(控件)信息，来进行点击、长按等操作。</p><h2 id="第一步：创建与配置"><a href="#第一步：创建与配置" class="headerlink" title="第一步：创建与配置"></a>第一步：创建与配置</h2><p>我们需要自定义一个继承自<code>AccessibilityService</code>的 service，然后在<code>AndroidManifest.xml</code>文件中注册一下，就想普通的 service 差不多，这里有三个可以被重写方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> android.accessibilityservice.AccessibilityService;<br><span class="hljs-keyword">import</span> android.view.accessibility.AccessibilityEvent;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAccessibilityService</span> <span class="hljs-title">extends</span> <span class="hljs-title">AccessibilityService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> void onAccessibilityEvent(AccessibilityEvent event) &#123;<br>        <span class="hljs-comment">// 处理接收到的辅助功能事件</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> void onInterrupt() &#123;<br>        <span class="hljs-comment">// 处理服务被中断的情况</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void onServiceConnected() &#123;<br>        <span class="hljs-keyword">super</span>.onServiceConnected();<br>        <span class="hljs-comment">// 初始化服务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在清单文件中注册一下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyAccessibilityService&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:permission</span>=<span class="hljs-string">&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.accessibilityservice.AccessibilityService&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.accessibilityservice&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/accessibility_service_config&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意这里的<code>meta-data</code>标签，其中的<code>name</code>属性值是固定的，<code>resource</code>属性则是我们为无障碍服务提供的配置文件。大致有这么一些属性<br><code>accessibility_service_config.xml</code> 是一个用于配置 <code>AccessibilityService</code> 的 XML 文件，其中包含了许多属性，用于定义服务的行为和特性。以下是这些属性的详细介绍和示例说明：</p><h3 id="1-android-description"><a href="#1-android-description" class="headerlink" title="1. android:description"></a>1. <code>android:description</code></h3><p>描述服务的用途，通常是一个字符串资源的引用。这个值会展示在开启无障碍服务时的帮助说明中</p><h3 id="2-android-accessibilityEventTypes"><a href="#2-android-accessibilityEventTypes" class="headerlink" title="2. android:accessibilityEventTypes"></a>2. <code>android:accessibilityEventTypes</code></h3><p>定义服务要监听的事件类型。可以是以下之一或多个的组合：</p><ul><li><code>typeAllMask</code></li><li><code>typeViewClicked</code></li><li><code>typeViewFocused</code></li><li><code>typeViewLongClicked</code></li><li><code>typeViewSelected</code></li><li><code>typeViewTextChanged</code></li><li><code>typeWindowContentChanged</code></li><li><code>typeWindowStateChanged</code>。</li></ul><p>这里我们只需要监听 <code>typeWindowContentChanged</code> 和 <code>typeWindowStateChanged</code> 就足够了</p><h3 id="3-android-packageNames"><a href="#3-android-packageNames" class="headerlink" title="3. android:packageNames"></a>3. <code>android:packageNames</code></h3><p>指定服务要监听的应用包名。多个包名可以用逗号分隔。这个没啥好说的</p><h3 id="4-android-accessibilityFeedbackType"><a href="#4-android-accessibilityFeedbackType" class="headerlink" title="4. android:accessibilityFeedbackType"></a>4. <code>android:accessibilityFeedbackType</code></h3><p>定义服务的反馈类型，就是如何给用户反馈，可以是以下之一或多个的组合：</p><ul><li><code>feedbackSpoken</code> ： 适用于需要将信息通过语音读出来的情况，例如屏幕阅读器。</li><li><code>feedbackHaptic</code> ： 适用于需要通过振动提醒用户的情况，例如通知用户某个操作成功或失败。</li><li><code>feedbackAudible</code> ： 适用于需要通过音效提醒用户的情况，例如提示音。</li><li><code>feedbackVisual</code> ： 适用于需要通过视觉效果（如闪烁、颜色变化）提醒用户的情况。</li><li><code>feedbackGeneric</code> ： 适用于不特定于某一种反馈类型的情况。</li><li><code>feedbackBraille</code> : 适用于需要将信息传递给盲文设备用户的情况。</li></ul><h3 id="5-android-notificationTimeout"><a href="#5-android-notificationTimeout" class="headerlink" title="5. android:notificationTimeout"></a>5. <code>android:notificationTimeout</code></h3><p>定义服务在处理连续事件之间的最短时间间隔，以毫秒为单位。当辅助功能服务接收到大量的连续事件时，可能会导致性能问题或用户体验不佳。通过设置 <code>notificationTimeout</code>，可以指定一个时间窗口，在这个时间窗口内重复的事件将被合并为一个事件，从而减少处理的频率。</p><h3 id="6-android-canRetrieveWindowContent"><a href="#6-android-canRetrieveWindowContent" class="headerlink" title="6. android:canRetrieveWindowContent"></a>6. <code>android:canRetrieveWindowContent</code></h3><p>定义服务是否可以检索窗口内容。设置为 <code>true</code> 表示服务可以访问窗口内容。</p><h3 id="7-android-settingsActivity"><a href="#7-android-settingsActivity" class="headerlink" title="7. android:settingsActivity"></a>7. <code>android:settingsActivity</code></h3><p>指定一个设置活动的类名，用户可以通过辅助功能设置页面进入该活动。配置了该属性之后，用户可以在开启无障碍服务页面点击更多设置直接进入到该页面</p><h3 id="8-android-canRequestTouchExplorationMode"><a href="#8-android-canRequestTouchExplorationMode" class="headerlink" title="8. android:canRequestTouchExplorationMode"></a>8. <code>android:canRequestTouchExplorationMode</code></h3><p>属性用于指定辅助功能服务是否可以请求触摸探索模式。触摸探索模式是一种特殊的输入模式，通常用于帮助视力障碍用户使用触摸屏设备<br>这里也需要我们在代码中设置一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onServiceConnected()<br>    <span class="hljs-keyword">val</span> info = AccessibilityServiceInfo()<br>    info.flags = AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE<br>    serviceInfo = info<br>&#125;<br></code></pre></td></tr></table></figure><p>并且，在处理事件中我们也需要处理更多的事件</p><blockquote><p>启用时：应用需要处理更多的辅助功能事件，如 TYPE_TOUCH_EXPLORATION_GESTURE_START 和 TYPE_TOUCH_EXPLORATION_GESTURE_END。这些事件帮助应用确定用户正在进行触摸探索。<br>未启用时：应用只需处理标准的触摸事件。</p></blockquote><h3 id="9-android-canRequestEnhancedWebAccessibility"><a href="#9-android-canRequestEnhancedWebAccessibility" class="headerlink" title="9. android:canRequestEnhancedWebAccessibility"></a>9. <code>android:canRequestEnhancedWebAccessibility</code></h3><p>定义服务是否可以请求增强的网页辅助功能。</p><h3 id="10-android-canRequestFilterKeyEvents"><a href="#10-android-canRequestFilterKeyEvents" class="headerlink" title="10. android:canRequestFilterKeyEvents"></a>10. <code>android:canRequestFilterKeyEvents</code></h3><p>用于指定辅助功能服务是否可以请求过滤键事件（key events）。这对于开发辅助功能服务（如屏幕阅读器或其他辅助工具）非常重要，因为它允许这些服务拦截和处理按键事件，以提供更好的用户体验和辅助功能支持。同样的，不仅要在配置文件中声明，也需要在代码中设置</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onServiceConnected()<br>    <span class="hljs-keyword">val</span> info = AccessibilityServiceInfo()<br>    info.flags = AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS<br>    serviceInfo = info<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-android-canPerformGestures"><a href="#11-android-canPerformGestures" class="headerlink" title="11. android:canPerformGestures"></a>11. <code>android:canPerformGestures</code></h3><p>定义服务是否可以执行手势。如果为 true，我们可以这样执行手势</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 执行点击手势</span><br><span class="hljs-keyword">private</span> void performClick(float x, float y) &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;<br>        Path clickPath = new Path();<br>        clickPath.moveTo(x, y);<br>        GestureDescription.StrokeDescription clickStroke = new GestureDescription.StrokeDescription(clickPath, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>        GestureDescription gestureDescription = new GestureDescription.Builder().addStroke(clickStroke).build();<br>        dispatchGesture(gestureDescription, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-android-accessibilityFlags"><a href="#12-android-accessibilityFlags" class="headerlink" title="12. android:accessibilityFlags"></a>12. <code>android:accessibilityFlags</code></h3><p>定义服务的辅助功能标志，这些标志定义了服务的行为和特性。通过设置不同的标志，开发者可以控制辅助功能服务如何与系统和应用交互。可以是以下之一或多个的组合：</p><ol><li><p>**<code>flagIncludeNotImportantViews</code>**：</p><ul><li><strong>作用</strong>：包括那些通常被认为不重要的视图（如布局视图）在辅助功能事件中。</li><li><strong>使用场景</strong>：当需要确保所有视图都被辅助功能服务处理时使用。</li></ul></li><li><p>**<code>flagRequestTouchExplorationMode</code>**：</p><ul><li><strong>作用</strong>：请求触摸探索模式，这对于视力障碍用户非常有用。</li><li><strong>使用场景</strong>：当辅助功能服务需要解释触摸事件并提供反馈时使用。</li></ul></li><li><p>**<code>flagReportViewIds</code>**：</p><ul><li><strong>作用</strong>：报告视图的资源 ID。</li><li><strong>使用场景</strong>：当辅助功能服务需要识别和操作特定视图时使用。</li></ul></li><li><p>**<code>flagRetrieveInteractiveWindows</code>**：</p><ul><li><strong>作用</strong>：允许辅助功能服务检索交互窗口。</li><li><strong>使用场景</strong>：当需要处理多个窗口或弹出窗口时使用。</li></ul></li></ol><p>当然我们也可以在代码中设置标志</p><p>在你的 <code>AccessibilityService</code> 中，你可以使用 <code>AccessibilityServiceInfo</code> 来设置标志：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onServiceConnected()<br>    <span class="hljs-keyword">val</span> info = AccessibilityServiceInfo()<br>    info.flags = (AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS<br>            or AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS<br>            or AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS)<br>    serviceInfo = info<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示例完整配置文件"><a href="#示例完整配置文件" class="headerlink" title="示例完整配置文件"></a>示例完整配置文件</h3><p>下面是我们这次需要用到的配置文件内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">accessibility-service</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:accessibilityEventTypes</span>=<span class="hljs-string">&quot;typeWindowContentChanged|typeWindowStateChanged&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:accessibilityFeedbackType</span>=<span class="hljs-string">&quot;feedbackGeneric&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:accessibilityFlags</span>=<span class="hljs-string">&quot;flagIncludeNotImportantViews|flagReportViewIds&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:canRetrieveWindowContent</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:canRequestTouchExplorationMode</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:canRequestFilterKeyEvents</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:canPerformGestures</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:packageNames</span>=<span class="hljs-string">&quot;com.tencent.mm&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:settingsActivity</span>=<span class="hljs-string">&quot;com.huangyuanlove.auxiliary.SettingActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:description</span>=<span class="hljs-string">&quot;@string/wx_make_call_service_helper&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:notificationTimeout</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>通过配置这些属性，你可以精确地控制 <code>AccessibilityService</code> 的行为，以满足特定的需求和用例。</p><p><img src="/image/accessibility/accessibility_setting_honor.png" alt="荣耀v10开启无障碍服务弹窗提示"><br><img src="/image/accessibility/accessibility_setting_k30.png" alt="红米k30p开启无障碍服务弹窗提示"></p><h2 id="第二步：rua代码"><a href="#第二步：rua代码" class="headerlink" title="第二步：rua代码"></a>第二步：rua代码</h2><p>在上面我们已经做好了基础配置，下面开始rua 代码，看看我们应该怎么做。</p><h3 id="分析路径流程"><a href="#分析路径流程" class="headerlink" title="分析路径流程"></a>分析路径流程</h3><p>我们先做好微信的前期准备工作：通话双方是好友、微信已经登录。<br>那么我们的使用流程大致时这样的：<br>打开微信<br>点击底部通讯录<br>找到这个好友(可能需要滑动通讯录列表)点击一下进入到好友信息页面<br>点击信息页面的音视频通话<br>在底部弹窗中点击视频通话或者语音通话</p><h3 id="简单的-API-调用准备"><a href="#简单的-API-调用准备" class="headerlink" title="简单的 API 调用准备"></a>简单的 API 调用准备</h3><h4 id="onAccessibilityEvent"><a href="#onAccessibilityEvent" class="headerlink" title="onAccessibilityEvent"></a>onAccessibilityEvent</h4><p>当触发了我们在配置文件中指定的事件时，系统会回调<code>AccessibilityService#onAccessibilityEvent(event: AccessibilityEvent)</code>这个方法。<br>我们可以通过<code>event</code>对象获取触发这个事件的包名，触发的事件类型等，</p><h4 id="getRootInActiveWindow"><a href="#getRootInActiveWindow" class="headerlink" title="getRootInActiveWindow"></a>getRootInActiveWindow</h4><p>我们可以在<code>AccessibilityService</code>中调用这个方法获取当前页面的根节点，这个节点可以看做是当前视图树的根节点，这样我们就可以遍历整个视图树了。<br>同样的，我们也可以通过<code>AccessibilityNodeInfo</code>实例来获取对应节点的属性，比如是否可以点击(isClickable)、类型(className)、按钮|文本内容(text)、无障碍服务标签内容(contentDescription)等。我们可以根据这些属性来判断是不是我们需要的节点(控件)</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>就像我们平时开发一样，有些事件并不是直接设置在 TextView 或者 Button 上的，可能是设置在它们的父级组件上，比如LinearLayout或者RelativeLayout等。所以当我们获取到对应的节点后，需要判断一下是不是我们需要的节点，如果不是的话，就在找找父级是不是我们需要的节点。<br>当然如果我们知道某个页面某个节点的id，就不需要这么麻烦了，直接根据 id 查找就好了。</p><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>需要开启无障碍服务才可以进行对应的操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isServiceEnabled</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    (context.getSystemService(Context.ACCESSIBILITY_SERVICE) <span class="hljs-keyword">as</span> AccessibilityManager)<br>            .getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_ALL_MASK)<br>            .filter &#123; it.id == <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;context.packageName&#125;</span>/<span class="hljs-subst">$&#123;MakeWeChatCallService::class.java.name&#125;</span>&quot;</span> &#125;<br>            .let &#123; <span class="hljs-keyword">return</span> it.isNotEmpty() &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//跳转到开启无障碍服务页面</span><br>startActivity(Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)) <br></code></pre></td></tr></table></figure><h3 id="动手开工"><a href="#动手开工" class="headerlink" title="动手开工"></a>动手开工</h3><h4 id="打开微信"><a href="#打开微信" class="headerlink" title="打开微信"></a>打开微信</h4><p>这个很简单哇，知道微信的包名就好了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = packageManager.getLaunchIntentForPackage(WX_PACKAGE_NAME)<br>intent?.let &#123;<br>    startActivity(intent)<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们打开微信后，标记接下来需要点击通讯录按钮：current_step&#x3D; click_contacts;</p><h3 id="点击底部通讯录"><a href="#点击底部通讯录" class="headerlink" title="点击底部通讯录"></a>点击底部通讯录</h3><p>这个就需要用到上面准备好的<code>AccessibilityService</code>了，按照上面的配置，当我们打开微信之后，就开始回调<code>onAccessibilityEvent(event: AccessibilityEvent)</code>这个方法了。</p><p>我们假设用户使用的是中文，我们需要找到”通讯录”这个按钮对应的AccessibilityNodeInfo实例，然后调用<code>performAction(AccessibilityNodeInfo.ACTION_CLICK)</code>进行点击就好了。<br>注意，这个的<code>通讯录</code>文本并不是可以点击的，我们打开<code>无障碍服务talkback</code>将框框移动到通讯录这里，就可以看到<code>通讯录</code>和上面的图标是一体的。但我们也不清楚他们到底是怎么实现的，所以我们查找这个文本的父级控件，看是否能点，不能点击就再往上查找。多次尝试之后，发现需要向上查找两次。这里写了一个扩展方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> AccessibilityNodeInfo.<span class="hljs-title">clickNodeByText</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    textList: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    parentCount: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">var</span> node = getNodeByText(textList)<br>    repeat(parentCount) &#123;<br>        node = node?.parent<br>    &#125;<br>    node?.let &#123;<br>        <span class="hljs-keyword">return</span> it.performAction(AccessibilityNodeInfo.ACTION_CLICK)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的参数<code>parentCount</code>表示需要向上查找几次。<br>我们点击通讯录的时候调用<code>rootInActiveWindow.clickNodeByText(arrayOf(&quot;通讯录&quot;), 2)</code>就可以了.<br>点击成功后，我们标记接下来需要点击联系人：current_step&#x3D;click_contact;</p><h3 id="找到好友"><a href="#找到好友" class="headerlink" title="找到好友"></a>找到好友</h3><p>通讯录是个列表，我们猜要不是 ListView，要不是 RecyclerView，我觉得不大可能是 ScrollView。要注意。右侧还有一个字母列表，不要搞错了。<br>我们先从当前可看到的页面查找联系人。<br>这里也搞了个扩展方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> AccessibilityNodeInfo.<span class="hljs-title">getNodeByText</span><span class="hljs-params">(textList: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>: AccessibilityNodeInfo? &#123;<br>    <span class="hljs-keyword">var</span> node: AccessibilityNodeInfo? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (index &lt; textList.size &amp;&amp; node === <span class="hljs-literal">null</span>) &#123;<br>        node = <span class="hljs-keyword">this</span>.findAccessibilityNodeInfosByText(textList[index]).getOrNull(<span class="hljs-number">0</span>)<br>        index++<br>    &#125;<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure><p>查找这个联系人</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> contactNode = rootInActiveWindow.getNodeByText(arrayOf(cantactName))<br></code></pre></td></tr></table></figure><p>如果<code>contactNode</code>为空，表示当前可视内容中没有这个联系人，我们需要滑动列表。<br>首先，找到联系人列表的<code>RecyclerView</code>,别问为啥是<code>RecyclerView</code>,试了好多次试出来的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getContactListView</span><span class="hljs-params">()</span></span>: AccessibilityNodeInfo? &#123;<br>    <span class="hljs-keyword">val</span> queue = LinkedList&lt;AccessibilityNodeInfo&gt;()<br>    queue.offer(rootInActiveWindow)<br>    <span class="hljs-keyword">var</span> info: AccessibilityNodeInfo?<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        info = queue.poll()<br>        <span class="hljs-keyword">if</span> (info == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (info.className.equals(<span class="hljs-string">&quot;androidx.recyclerview.widget.RecyclerView&quot;</span>) &amp;&amp; info.isScrollable) &#123;<br>            <span class="hljs-keyword">return</span> info<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until info.childCount) &#123;<br>            queue.offer(info.getChild(i))<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>找到列表控件后滑动一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> contactListNode = getContactListView()<br>contactListNode?.performAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD)<br></code></pre></td></tr></table></figure><p>注意，这里列表的滑动同样会触发<code>onAccessibilityEvent</code>这个方法，我们再重复上面的流程，直到找到这个联系人控件。需要注意的是，这里的联系人显示的名字要是单个英文字母，这会和列表分组上面的单个英文字母相同，导致查找到的控件不是我们想要的</p><p>当我们找到这个联系人控件后，进行点击</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> contactNode = rootInActiveWindow.getNodeByText(arrayOf(cantactName))<br>repeat(<span class="hljs-number">6</span>) &#123;<span class="hljs-comment">//别问这里为啥是 6，试出来的，或者可以遍历一下视图树，自己数一下层级</span><br>    contactNode = contactNode?.parent<br>&#125;<br>contactNode?.let &#123;<br>    <span class="hljs-keyword">val</span> result = it.performAction(AccessibilityNodeInfo.ACTION_CLICK)<br>    <span class="hljs-keyword">if</span>(result)&#123;<br>        <span class="hljs-comment">//标记接下来需要在联系人详情页面点击音视频通话</span><br>        current_step= click_video;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="点击音视频通话"><a href="#点击音视频通话" class="headerlink" title="点击音视频通话"></a>点击音视频通话</h3><p>这个就比较简单了，还是调用我们上面写的扩展方法找到按钮，然后点击就行了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> contactNode = rootInActiveWindow.getNodeByText(arrayOf(<span class="hljs-string">&quot;音视频通话&quot;</span>))<br>repeat(<span class="hljs-number">2</span>) &#123;<br>    contactNode = contactNode?.parent<br>&#125;<br>contactNode?.let &#123;<br>    <span class="hljs-keyword">val</span> result = it.performAction(AccessibilityNodeInfo.ACTION_CLICK)<br>    <span class="hljs-keyword">if</span>(result)&#123;<br>        <span class="hljs-comment">//标记接下来需要点击弹窗中的视频通话</span><br>        current_step= click_video_on_dialog;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="点击弹窗中的视频通话"><a href="#点击弹窗中的视频通话" class="headerlink" title="点击弹窗中的视频通话"></a>点击弹窗中的视频通话</h3><p>这个就更简单了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">rootInActiveWindow.clickNodeByText(arrayOf(<span class="hljs-string">&quot;语音通话&quot;</span>), <span class="hljs-number">3</span>)<br>rootInActiveWindow.clickNodeByText(arrayOf(<span class="hljs-string">&quot;视频通话&quot;</span>), <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>一个语音通话，一个视频通话。<br>到这里我们就可以进行视频通话了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的流程是最理想的状态，还有一些奇奇怪怪的问题：<br>比如我们视频通话结束后，需要返回到列表页，也就是在通话结束后点击左上角的返回，这个功能没有写。<br>比如打开微信的时候不是在首页，比如在浏览公众号信息怎么办？同样需要找到左上角的返回按钮，一直到首页之后才可以进行点击通讯录的操作。<br>比如联系人的名字就是单个英文字母，上面也提到，这种情况下查找到的会是分组的名称，无法进行点击。<br>或者我们可以从首页点击右上角的搜索，输入联系人名字，然后在搜索列表中点击联系人，进入到聊天页面，然后点击左下角加号，在更多菜单里面点击音视频通话也行。<br>放个最终效果的视频吧</p><video width="320" height="240" autoplay muted>  <source src="image/accessibility/accessibility_video.mp4" type="video/mp4"><p>Your browser does not support the video tag.<br></video></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;无障碍服务适配大家应该多多少少的都遇到过，简单点讲就是给图片、文本等控件加上 &lt;code&gt;android:contentDescription=&amp;quot;&amp;quot;&lt;/code&gt;标签，这样在使用无障碍服务(比如手机自带的 talkback)时，可以将&lt;code&gt;contentDescription&lt;/code&gt;的内容以声音的方式读出来，方便视障用户使用我们的 app。&lt;/p&gt;
&lt;p&gt;这不是本文的重点，重点是在无障碍–&amp;gt;已安装的服务中中发现了一些其他的应用也提供了一些无障碍服务，比如某输入法提供了”智能回复”、”智能应答”等服务，某些应用还提供了类似于一键进行微信视频通话功能，这玩意咋搞的？我们能不能搞？能不能给老人做一个简单的工具，去掉那些花里胡哨的功能，点个按钮就能和我们进行视频通话？&lt;br&gt;&lt;strong&gt;不要用无障碍服务做违法的事情！！！不要用无障碍服务做违法的事情！！！不要用无障碍服务做违法的事情！！!&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>kotlin中的内联函数</title>
    <link href="https://blog.huangyuanlove.com/2024/06/26/kotlin%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    <id>https://blog.huangyuanlove.com/2024/06/26/kotlin%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</id>
    <published>2024-06-26T07:06:32.000Z</published>
    <updated>2024-06-28T06:56:27.759Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，在 kotlin 中函数是一等公民，在源码、各种框架中都能看到高阶函数的身影，我们也发现伴随着高阶函数的还有几个关键字：<code>inline</code>,<code>noinline</code>,<code>crossinline</code>。那这些关键字有什么作用？应该如何使用？</p><span id="more"></span><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p><code>inline</code>关键字用于指示编译器将函数及其参数内联展开到调用处。内联函数可以减少函数调用的开销，并允许非局部返回<br><strong>作用</strong>：</p><ul><li>减少函数调用开销：通过内联展开，消除了函数调用的开销。</li><li>允许非局部返回：内联函数的 lambda 参数可以使用 return 从外部函数返回。</li></ul><p>先看一下没有<code>inline</code>修饰的情况</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHi</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;hi&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    hello()<br>    sayHi()<br>&#125;<br></code></pre></td></tr></table></figure><p>再看一下反编译成 java 代码的样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InlineKt</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">$i$f$hello</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>      System.out.println(var1);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hi&quot;</span>;<br>      System.out.println(var0);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">$i$f$hello</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>      System.out.println(var1);<br>      sayHi();<br>   &#125;<br><br>   <span class="hljs-comment">// $FF: synthetic method</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      main();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，被<code>inline</code>修饰的代码直接展开复制到了调用的地方，好处是什么？少了一层调用栈，减少了开销。坏处：函数体被展开复制到了调用的地方，编译后的产物体积肯定会增大。<br>那这样的话，为啥也要有<code>inline</code>关键字嘞，看着也没啥用。其实除了可以<strong>内联自己内部的代码</strong>，还可以<strong>内联作为参数的方法代码</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(postAction:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    postAction()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHi</span><span class="hljs-params">(postAction:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;hi&quot;</span>)<br>    postAction()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    hello &#123; println(<span class="hljs-string">&quot;hello lambda&quot;</span>) &#125;<br>    sayHi &#123; println(<span class="hljs-string">&quot;sayHi lambda&quot;</span>) &#125;<br><br>    hello (<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    &#125;)<br>    sayHi (<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;sayHi&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>众所众知，Java 中是不支持函数作为参数传递的，但 kotlin 可以，那么转成字节码运行在 jvm 上是怎么处理的？办法是将其包装成一个对象来调用。<br>看反编译成 java 的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">$i$f$hello</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>  System.out.println(var1);<br>  <span class="hljs-type">int</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello lambda&quot;</span>;<br>  System.out.println(var3);<br>  sayHi((Function0)<span class="hljs-literal">null</span>.INSTANCE);<br>  $i$f$hello = <span class="hljs-literal">false</span>;<br>  var1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>  System.out.println(var1);<br>  var2 = <span class="hljs-literal">false</span>;<br>  var3 = <span class="hljs-string">&quot;hello&quot;</span>;<br>  System.out.println(var3);<br>  sayHi((Function0)<span class="hljs-literal">null</span>.INSTANCE);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在调用<code>sayHi</code>的地方实际是创建了一个<code>Function0</code>对象进去，也许创建者一次对象的开销可以湖绿，但如果是用在频繁调用的场景下呢？比如页面刷新绘制、循环等等等等。如果真的是这样，这不就有可能会造成面试中经常问到的<code>内存抖动</code>么。<br>所以，这种时候，我们使用<code>inline</code>可以减少参数对象的创建，从而避免出现一些问题。<br>但是，我们也不能看见频繁调用的函数就加上<code>inline</code>，毕竟谁也不会为了减少一次调用栈，把函数体直接复制到每个调用的地方吧？主要还是用在高阶函数上，并且根据函数调用的情况综合来判断是否可以使用<code>inline</code>。</p><h3 id="noinline"><a href="#noinline" class="headerlink" title="noinline"></a>noinline</h3><p>noinline 关键字用于标记不应该内联的 lambda 参数。默认情况下，内联函数的所有 lambda 参数都会被内联展开，但有时我们可能希望某些 lambda 参数不被内联。</p><p><strong>作用</strong>：</p><ul><li>防止内联：阻止特定的 lambda 参数被内联展开。</li><li>保留 lambda 参数：适用于需要将 lambda 参数作为对象传递的情况。</li></ul><p>既然<code>inline</code>是一种优化，假设使用者也经过考虑，将函数用<code>inline</code>修饰，那为什么还会有<code>noinline</code>这个关键字？<br>先来思考一个问题：kotlin 中一切都是对象，函数也能作为参数或者返回值，那被内联的函数参数作为参数或者返回值时会怎么样？<br>答案是不可以，因为被内联的函数已经被展开了，不再是一个对象了，那怎么办？加上<code>noinline</code>，告诉编译器，这个函数参数不要进行内联。<br>这里也有一个例外情况，被内联的函数参数，可以作为其他内联函数的参数。为啥？因为被内联函数被展开复制到调用处了哇。<br>看个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(preAction:()-&gt;<span class="hljs-type">Unit</span>, postAction:()-&gt;<span class="hljs-type">Unit</span>)</span></span>:()-&gt;<span class="hljs-built_in">Unit</span>&#123;<br>    preAction()<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    postAction()<br>    another(postAction)<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Illegal usage of inline-parameter &#x27;postAction&#x27; in &#x27;public inline fun hello(preAction: () -&gt; Unit, postAction: () -&gt; Unit): () -&gt; Unit defined in root package in file Inline.kt&#x27;. Add &#x27;noinline&#x27; modifier to the parameter declaration</span><br><span class="hljs-comment">     */</span><br>    anotherInline(postAction)<br>    <span class="hljs-keyword">return</span> postAction<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Illegal usage of inline-parameter &#x27;postAction&#x27; in &#x27;public inline fun hello(preAction: () -&gt; Unit, postAction: () -&gt; Unit): () -&gt; Unit defined in root package in file Inline.kt&#x27;. Add &#x27;noinline&#x27; modifier to the parameter declaration</span><br><span class="hljs-comment">     */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">another</span><span class="hljs-params">(action:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;<br>    action()<br>&#125;<br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">anotherInline</span><span class="hljs-params">(action:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;<br>    action()<br>&#125;<br></code></pre></td></tr></table></figure><p>这里调用<code>another(postAction)</code> 和 <code>return postAction</code>时，IDE 会报错，提示需要加上<code>noinline</code>。<br>也就是说，如果 inline 函数参数中有函数对象，并且这个函数对象需还需要充当其他非 inline 函数的参数或者充当返回值，那么就需要加上<code>noinline</code>,还有个偷懒的办法，IDE告诉你需要加，那就加上。</p><h3 id="crossinline"><a href="#crossinline" class="headerlink" title="crossinline"></a>crossinline</h3><p>crossinline 关键字用于标记 lambda 参数，保证它们不会进行非局部返回。crossinline 参数不能使用 return 从外部函数返回。<br><strong>作用</strong>：<br> 防止非局部返回：确保 lambda 参数不会从外部函数返回。<br> 安全性：在某些情况下，防止非局部返回可以避免编译错误或逻辑问题。</p><p>这里有个词是<code>非局部返回</code>,什么意思呢？先看个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">( postAction: () -&gt; <span class="hljs-type">String</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    postAction()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    hello &#123;<br>        println(<span class="hljs-string">&quot;second hi&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">//猜这里是哪个函数的返回</span><br>    &#125;<br>    println(<span class="hljs-string">&quot;after second hi\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>会发现<code>after second hi</code>没有打印，结束的是<code>main</code>函数而不是<code>hello</code>函数，但这里就会有个歧义，<code>return</code>结束哪个函数，需要看调用者是不是<code>inline</code>,这就挺郁闷的，所以这里就有了一个规定：</p><blockquote><p>lambda表达式中不允许直接 return，除非是当做内联函数的参数。<br>不能直接 return，但允许使用 return@label方式进行返回，结束 label 处的函数,这里的 label值可以自定义，但一般默认是调用的函数名字</p></blockquote><p>所以当我们这么写的时候</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hi</span><span class="hljs-params">( postAction: ()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;hi&quot;</span>)<br>    postAction()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    hi &#123;<br>        println(<span class="hljs-string">&quot;hi&quot;</span>)<br>        <span class="hljs-keyword">return</span><span class="hljs-comment">//错误，提示 &#x27;return&#x27; is not allowed here</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 return 处会提示<code>&#39;return&#39; is not allowed here</code>,但如果我们一定要写，可以写成</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">hi &#123;<br>    println(<span class="hljs-string">&quot;hi&quot;</span>)<br>    <span class="hljs-keyword">return</span><span class="hljs-symbol">@hi</span><br>&#125;<br></code></pre></td></tr></table></figure><p>到这里还没有<code>crossinline</code>的什么事，但想一想，如果多套一层：传入的函数参数，又作为其他函数的参数调用呢？比如这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(postAction: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    doAction &#123; postAction() &#125;<span class="hljs-comment">//注意这里</span><br>    run &#123; postAction() &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">(postAction: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    postAction()<br>&#125;<br></code></pre></td></tr></table></figure><p>注意上面 doAction 的调用，是不允许这样写的，会给出报错提示：</p><blockquote><p>Can’t inline ‘postAction’ here: it may contain non-local returns. Add ‘crossinline’ modifier to parameter declaration ‘postAction’</p></blockquote><p>意思是这种<code>间接调用</code>可能会导致非本地返回问题，也就是说我不知道你传入的函数参数中有没有 return，如果有的话，又会造成上面说的那个问题。那怎么办？在postAction参数前面加上<code>crossinline</code>修饰符，这样就可以间接调用了。不过这又带来了一个新问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> postAction: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    doAction &#123; postAction() &#125;<br>    run &#123; postAction() &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">(postAction: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    postAction()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  hello &#123;<br>    println(<span class="hljs-string">&quot;hi&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">//错误 提示：&#x27;return&#x27; is not allowed here</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会发现传入的Lambda 表达式中不允许这种直接 return 了，但还是可以使用 return@label 进行返回的。<br>但是你说：我既要又要怎么办？<br>抱歉，没办法，自己玩吧.</p><hr><p>参考<br><a href="https://book.kotlincn.net/text/inline-functions.html">内联函数</a>建议把函数这一节都看一下<br><a href="https://kotlinlang.org/docs/inline-functions.html">Inline functions</a><br><a href="https://rengwuxian.com/kotlin-source-noinline-crossinline/">Kotlin 源码里成吨的 noinline 和 crossinline 是干嘛的？看完这个视频你转头也写了一吨</a>  </p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>泛型</p><ul><li><input type='checkbox' disabled='true' checked>逆变</input></li><li><input type='checkbox' disabled='true' checked>协变</input></li><li><input type='checkbox' disabled='true' checked>类型投影</input></li><li><input type='checkbox' disabled='true' checked>星投影</input></li><li><input type='checkbox' disabled='true' checked>泛型约束</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li><li><input type='checkbox' disabled='true' checked>object:匿名内部类、单例模式、伴生对象</input></li><li><input type='checkbox' disabled='true' checked>Unit、Nothing</input></li><li><input type='checkbox' disabled='true' checked>inline,noinline,crossinline</input></li></ul></li><li><p>委托</p><ul><li><input type='checkbox' disabled='true' checked>委托类</input></li><li><input type='checkbox' disabled='true' checked>委托属性</input></li><li><input type='checkbox' disabled='true' checked>自定义委托</input></li></ul></li></ul><p>未学习：</p><ul><li>协程<ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，在 kotlin 中函数是一等公民，在源码、各种框架中都能看到高阶函数的身影，我们也发现伴随着高阶函数的还有几个关键字：&lt;code&gt;inline&lt;/code&gt;,&lt;code&gt;noinline&lt;/code&gt;,&lt;code&gt;crossinline&lt;/code&gt;。那这些关键字有什么作用？应该如何使用？&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin中的Unit和Nothing 关键字</title>
    <link href="https://blog.huangyuanlove.com/2024/06/14/kotlin%E4%B8%AD%E7%9A%84Unit%E5%92%8CNothing-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://blog.huangyuanlove.com/2024/06/14/kotlin%E4%B8%AD%E7%9A%84Unit%E5%92%8CNothing-%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2024-06-14T02:05:54.000Z</published>
    <updated>2024-06-26T06:42:35.749Z</updated>
    
    <content type="html"><![CDATA[<p>让我们先从 kotlin 的类型继承关系开始：众所周知，kotlin 中所有东西都有类型，对象、函数等等，就连 Unit，Nothing 也有对应的类型。我们来看一下kotlin 中的类型层次结构。</p><span id="more"></span><h3 id="从顶部开始"><a href="#从顶部开始" class="headerlink" title="从顶部开始"></a>从顶部开始</h3><p>所有类型的 Kotlin 对象都被组织成子类型&#x2F;超类型关系的层次结构。该层次结构的“顶部”是抽象类Any。例如，String 和 Int 类型都是的子类型Any。</p><pre><code class="mermaid" >graph BTString-->AnyInt-->Any</code></pre><p>这里的 Any 相当于 java 中的 Object，同样的，如果我们声明一个类，没有显式指定继承自哪个类，那这个类就是 Any 的直接子类。<br>如果该类指定了父类，那么 Any 会是该类的最终父类(祖先)</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>(name:String):Person(name)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span></span>(name:String):Person(name)<br></code></pre></td></tr></table></figure><pre><code class="mermaid" >graph BTPerson --> AnyStudent-->PersonTeacher-->Person</code></pre><p>如果一个类实现了多个接口，那么它就会有多个直接父类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Run</span></span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fly</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> : <span class="hljs-type">Run</span>,<span class="hljs-type">Fly</span></span><br></code></pre></td></tr></table></figure><pre><code class="mermaid" >graph BTRun --> AnyFly --> AnyBird-->RunBird-->Fly</code></pre><p>Kotlin 类型检查器强制执行子类型&#x2F;父类型关系，我们可以将子类型存储到超类型变量中，反过来则不行，这和 java 是一样的逻辑。<br>另外，kotlin 中还有可空类型，上面我们提到的类型都是非空类型，可空类型只是在可空类型后面加了一个 <strong>?</strong>,</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> name :String =<span class="hljs-literal">null</span> <span class="hljs-comment">//错误：Null can not be a value of a non-null type String</span><br><span class="hljs-keyword">val</span> name :String? =<span class="hljs-literal">null</span> <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">var</span> s: String? = <span class="hljs-literal">null</span><br><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&quot;a&quot;</span><br>s = s2<br>s = <span class="hljs-literal">null</span><br>s2 = s<span class="hljs-comment">//错误：Type mismatch.Required:String， Found:String?</span><br><br></code></pre></td></tr></table></figure><p>从这个角度来看，我们可以认为(仅仅是可以认为)非空类型是对应可空类型的子类，因为非空类型可以赋值给对应的可空类型，反之则不行。</p><pre><code class="mermaid" >graph BTAny --> Any?String? --> Any?String-->AnyString-->String?</code></pre><h3 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h3><p>Kotlin中的Unit即相当于Java中的void关键字，用于表示返回空结果的函数。但这里有一些不一样的地方，当 Unit 用于函数返回值时，是可以省略不写的，但kotlin 还是会认为返回了 Unit。其次，Unit 是一个真实存在的类型，并且是一个单例的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun1</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun1&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun2</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun2&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Unit</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun3</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun3&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun4</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun3&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Unit</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> <span class="hljs-built_in">Unit</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;kotlin.Unit&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们发现，上面这几种写法，效果是一样的。但这里有一个点需要注意一下：<br>对于<code>unitFun2()</code>这个函数，跟在函数名后面的<code>Unit</code>表示返回值类型，而函数体里面的<code>return Unit</code>中的 Unit 是一个单例对象。虽然看起来什么也没有返回，但它确实返回的一个单例对象。<br>回到我们上面提到的可空类型上，一个比较边缘的 case:Unit?类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> nullableUnit:<span class="hljs-built_in">Unit</span>? = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>这个东西我从来没有使用过，是 kotlin 类型一致性的结果</p><pre><code class="mermaid" >graph BTAny --> Any?Unit? --> Any?Unit-->AnyUnit-->Unit?</code></pre><p>那 Unit 这个东西有什么用呢？为啥不沿用 java 中的 void ？<br>扔物线大佬在他的文章中给出了具体的回答：去特殊化，<code>Unit</code>去掉了无返回值的函数的特殊性，消除了有返回值和无返回值的函数的本质区别，这样很多事做起来就会更简单了。<br>例：有返回值的函数在重写时没有返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">make</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-comment">// 合法</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Apple <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewWorldMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-comment">// 非法</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>    world.refresh();<br>  &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewWorldMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>    world.refresh();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//只能去写一行 return null 来手动实现接近于「什么都不返回」的效果</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maker</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: Any<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleMaker</span> : <span class="hljs-type">Maker</span></span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: Apple &#123;<br>    <span class="hljs-keyword">return</span> Apple()<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewWorldMaker</span> : <span class="hljs-type">Maker</span></span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span> &#123;<br>    world.refresh()<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maker</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: T<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleMaker</span> : <span class="hljs-type">Maker</span>&lt;<span class="hljs-type">Apple</span>&gt;</span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: Apple &#123;<br>    <span class="hljs-keyword">return</span> Apple()<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewWorldMaker</span> : <span class="hljs-type">Maker</span>&lt;<span class="hljs-type">Unit</span>&gt;</span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span> &#123;<br>    world.refresh()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例：函数类型的函数参数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runTask</span><span class="hljs-params">(task: () -&gt; <span class="hljs-type">Any</span>)</span></span> &#123;<br>  <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = task()) &#123;<br>    <span class="hljs-built_in">Unit</span> -&gt; println(<span class="hljs-string">&quot;result is Unit&quot;</span>)<br>    String -&gt; println(<span class="hljs-string">&quot;result is a String: <span class="hljs-variable">$result</span>&quot;</span>)<br>    <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;result is an unknown type&quot;</span>)<br>  &#125;<br>&#125;<br><br>...<br><br>runTask &#123; &#125; <span class="hljs-comment">// () -&gt; Unit</span><br>runTask &#123; println(<span class="hljs-string">&quot;完成！&quot;</span>) &#125; <span class="hljs-comment">// () -&gt; String</span><br>runTask &#123; <span class="hljs-number">1</span> &#125; <span class="hljs-comment">// () -&gt; Int</span><br></code></pre></td></tr></table></figure><h3 id="Nothing"><a href="#Nothing" class="headerlink" title="Nothing"></a>Nothing</h3><p>这里抛出一个引子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fail</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Something went wrong&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法的返回值是什么？它真的有返回值么？如果有，是什么类型？<br>实际上这个方法的返回值类型是<code>Nothing</code><br>kotlin中有这么一个方法:<code>TODO</code>,注意，这里的 TODO 是一个方法，而不是<code>//todo</code>这一个</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Nothing</span> = <span class="hljs-keyword">throw</span> NotImplementedError()<br></code></pre></td></tr></table></figure><p>我们来看一下 Nothing 定义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Nothing has no instances. You can use Nothing to represent &quot;a value that never exists&quot;: for example,</span><br><span class="hljs-comment"> * if a function has the return type of Nothing, it means that it never returns (always throws an exception).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nothing</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>()<br></code></pre></td></tr></table></figure><p>这个类无法创建出任何实例，所以所有 Nothing 类型的变量或者函数，都找不到可用的值。那这个东西有啥用？正如它的注释所说， 它可以作为函数「永不返回」的提示，也就是总是抛出异常。<br>那这个东西有啥用？<br>第一个作用就是作为函数「永不返回」的提示<br>第二个作用就是作为泛型对象的临时空白填充，比如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> emptyList: List&lt;<span class="hljs-built_in">Nothing</span>&gt; = listOf()<br><span class="hljs-keyword">var</span> apples: List&lt;Apple&gt; = emptyList<br><span class="hljs-keyword">var</span> users: List&lt;User&gt; = emptyList<br><span class="hljs-keyword">var</span> phones: List&lt;Phone&gt; = emptyList<br><span class="hljs-keyword">var</span> images: List&lt;Image&gt; = emptyList<br></code></pre></td></tr></table></figure><p>既省事，又省内存。当然也可以用在 Set、Map 中<br>第三个作用：语法的完整化<br>Nothing 的「是所有类型的子类型」这个特点，还帮助了 Kotlin 语法的完整化。在 Kotlin 的下层逻辑里，throw 这个关键字是有返回值的，它的返回值类型就是 Nothing。虽然说由于抛异常这件事已经跳出了程序的正常逻辑，所以 throw 返回不返回值、返回值类型是不是 Nothing 对于它本身都不重要，但它让类似 <code>TODO()</code>函数的写法成为了合法的。</p><pre><code class="mermaid" >graph BTString --> AnyInt --> AnyUnit --> AnyPerson --> AnyNothing --> PersonNothing --> UnitNothing --> IntNothing --> String</code></pre><p>参考<br><a href="http://natpryce.com/articles/000818.html">A Whirlwind Tour of the Kotlin Type Hierarchy</a><br><a href="https://rengwuxian.com/kotlin-unit/">Unit 为啥还能当函数参数？面向实用的 Kotlin Unit 详解</a><br><a href="https://rengwuxian.com/kotlin-nothing/">这玩意真的有用吗？对，是的！Kotlin 的 Nothing 详解</a></p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>泛型</p><ul><li><input type='checkbox' disabled='true' checked>逆变</input></li><li><input type='checkbox' disabled='true' checked>协变</input></li><li><input type='checkbox' disabled='true' checked>类型投影</input></li><li><input type='checkbox' disabled='true' checked>星投影</input></li><li><input type='checkbox' disabled='true' checked>泛型约束</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li><li><input type='checkbox' disabled='true' checked>object:匿名内部类、单例模式、伴生对象</input></li><li><input type='checkbox' disabled='true' checked>Unit、Nothing</input></li></ul></li><li><p>委托</p><ul><li><input type='checkbox' disabled='true' checked>委托类</input></li><li><input type='checkbox' disabled='true' checked>委托属性</input></li><li><input type='checkbox' disabled='true' checked>自定义委托</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>inline,noinline,crossinline</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;让我们先从 kotlin 的类型继承关系开始：众所周知，kotlin 中所有东西都有类型，对象、函数等等，就连 Unit，Nothing 也有对应的类型。我们来看一下kotlin 中的类型层次结构。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin中的 object 关键字</title>
    <link href="https://blog.huangyuanlove.com/2024/05/31/kotlin%E4%B8%AD%E7%9A%84-object-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://blog.huangyuanlove.com/2024/05/31/kotlin%E4%B8%AD%E7%9A%84-object-%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2024-05-31T01:45:56.000Z</published>
    <updated>2024-06-13T09:13:49.726Z</updated>
    
    <content type="html"><![CDATA[<p>kotlin 中的<code>object</code>关键字用处比较广泛，在官方文档<a href="https://book.kotlincn.net/text/object-declarations.html">对象表达式与对象声明</a>有详细的介绍，比如：创建匿名对象、创建匿名内部类并继承某个类，实现多个接口、使用匿名对象作为返回和值类型、从匿名对象访问变量、单例模式、数据对象、伴生对象等，不过文章是从<code>对象表达式</code>和<code>对象声明</code>角度来区分的。</p><span id="more"></span><h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>对象表达式可以用来创建匿名类，就是不用<code>class</code>来声明的类，当这个类只用一次的时候是很有帮助的。我们可以从头开始定义匿名类，也可以从现有类继承，还可以实现接口。匿名类的实例也称为匿名对象，因为它们是由表达式而不是名称定义的。</p><h4 id="创建匿名类"><a href="#创建匿名类" class="headerlink" title="创建匿名类"></a>创建匿名类</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> helloWorld = <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> hello = <span class="hljs-string">&quot;Hello&quot;</span><br>        <span class="hljs-keyword">val</span> world = <span class="hljs-string">&quot;World&quot;</span><br>        <span class="hljs-comment">//object expressions extend Any, so `override` is required on `toString()`</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-variable">$hello</span> <span class="hljs-variable">$world</span>&quot;</span><br>        &#125;<br>    &#125;<br>    println(helloWorld)<br>    println(helloWorld.javaClass.simpleName)<br>    println(helloWorld.javaClass.name)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这种方式在某种意义上和 js 中创建对象差不多，<code>helloWorld</code>这个实例的<code>helloWorld.javaClass.simpleName</code>是空的。当然了匿名类也是类，只是没有名字而已，当然做了继承其他类，实现其他接口。注意，同样只能单继承多实现，并且父类构造函数需要参数时可以传适当的构造参数。<br>比如这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnClickListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span>  <span class="hljs-title">OnLongClickListener</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLongClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span><br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnScroll</span></span>&#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onScroll</span><span class="hljs-params">(direction: <span class="hljs-type">Int</span>)</span></span><br>&#125;<br><span class="hljs-keyword">val</span> viewListener = <span class="hljs-keyword">object</span> : OnScroll(),OnLongClickListener, OnClickListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onScroll</span><span class="hljs-params">(direction: <span class="hljs-type">Int</span>)</span></span> &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;view clicked&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLongClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以直接当成参数传入调用的方法，都是一样的。本质上都是创建了一个对象。</p><h4 id="使用匿名对象作为返回值或类型"><a href="#使用匿名对象作为返回值或类型" class="headerlink" title="使用匿名对象作为返回值或类型"></a>使用匿名对象作为返回值或类型</h4><p>当匿名对象被用作局部或私有但非内联声明（函数或属性）的类型时，其所有成员都可通过该函数或属性访问：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span>= <span class="hljs-keyword">object</span> &#123;<br>       <span class="hljs-keyword">val</span> x = <span class="hljs-string">&quot;x&quot;</span><br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      println(getObject().x)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果方法供或者属性是 public 或者 private inline 时，它的实际类型可能如下：</p><ul><li>如果没有明确声明类型，则是<code>Any</code></li><li>如果只有一个父类或者一个接口，则是改父类或者接口类型</li><li>如果有一个父类和多个接口，则是方法明确返回的类型<br>比如<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC</span> </span>&#123;<br>    <span class="hljs-comment">// 返回值类型是 Any; 不能在其他方法中访问 x</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> x: String = <span class="hljs-string">&quot;x&quot;</span><br>    &#125;<br><br>    <span class="hljs-comment">// 返回值类型是 AA; 不能在其他方法中访问 x</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObjectAA</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span>: AA &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">funFromA</span><span class="hljs-params">()</span></span> &#123;&#125;<br>        <span class="hljs-keyword">val</span> x: String = <span class="hljs-string">&quot;x&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-comment">//这里会报错，访问不到 x 属性</span><br>            println(getObject().x)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回值类型是 BB; 不能在其他方法中访问 x</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObjectBB</span><span class="hljs-params">()</span></span>: BB = <span class="hljs-keyword">object</span>: AA, BB &#123; <span class="hljs-comment">// explicit return type is required</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">funFromA</span><span class="hljs-params">()</span></span> &#123;&#125;<br>        <span class="hljs-keyword">val</span> x: String = <span class="hljs-string">&quot;x&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-comment">//这里会报错，访问不到 x 属性</span><br>            println(getObject().x)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名对象访问变量"><a href="#匿名对象访问变量" class="headerlink" title="匿名对象访问变量"></a>匿名对象访问变量</h4>对象表达式中的代码可以访问来自包含它的作用域的变量：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AAA</span></span>&#123;<br>    <span class="hljs-keyword">val</span> x = <span class="hljs-string">&quot;x&quot;</span><br>    <span class="hljs-keyword">val</span> y = <span class="hljs-string">&quot;y&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> xx = x<span class="hljs-comment">//不报错</span><br>        <span class="hljs-keyword">val</span> yy = y<span class="hljs-comment">//不报错</span><br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AAAA</span></span>&#123;<br>        <span class="hljs-keyword">val</span> xx = x <span class="hljs-comment">//报错</span><br>    &#125;<br>    <span class="hljs-keyword">object</span> BBBB&#123;<br>        <span class="hljs-keyword">val</span> xx = x<span class="hljs-comment">//报错</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><h4 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h4><p>在Kotlin当中，要实现<code>单例模式</code>其实非常简单，我们直接用<code>object</code>修饰类即可,当然这个单例类也是可以有父类的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MyViewListener : OnClickListener, OnLongClickListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;view clicked&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLongClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;view long clicked&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;test&quot;</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调用的时候直接<code>类名.方法名</code>即可。这里有个注意点：对象声明不能在局部作用域（即不能直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中。</p><h4 id="数据对象-data-object"><a href="#数据对象-data-object" class="headerlink" title="数据对象(data object)"></a>数据对象(data object)</h4><p>当我们想要打印<code>object</code>对象声明时，字符串表示同时包含其名称和对象的哈希：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MyObject<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(MyObject) <span class="hljs-comment">// MyObject@3ac3fd8b</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以还用<code>data</code>关键字来修饰它</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">object</span>  MyDataObject&#123;<br>    <span class="hljs-keyword">val</span> x = <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，编译器会为这个对象生成<code>toString()</code>方法，该方法只会返回对象名字。还有成对出现的<code>equals()/hashCode()</code>.这里有一点需要注意：<br>被重写的<code>equals()</code>方法会将所有相同名字的<code>data object</code>都返回<code>true</code>,这个解释不是太严谨，因为绝大部分情况下，<code>data object</code>是单例的，在运行时只会有一个对象，但我们可以通过平台相关的方法创建另外一个实例对象，比如 jvm 上的反射、序列化和反序列化等。因此，在比较<code>data object</code>是否相同时，请使用<code>==</code>而不是<code>===</code></p><h5 id="data-class-和-data-object-的不同"><a href="#data-class-和-data-object-的不同" class="headerlink" title="data class 和 data object 的不同"></a>data class 和 data object 的不同</h5><p>虽然数据类和数据对象经常一起使用，并且有一些相同点，但有些函数在<code>data object</code>中是不会生成的</p><ul><li>没有<code>copy()</code>方法，因为<code>data object</code>用作单例对象，所以不会生成该方法。如果允许创建另外个实例对象，则违反了该模式。</li><li>没有<code>componentN()</code>方法，该方法的一个简单的用法就是用于结构对象，允许一次性获取对象的所有属性值，并将它们作为单独的参数传递给函数或构造器。但由于<code>data object</code>没有属性，生成这些方法是没有意义的。</li></ul><h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><p>在<code>kotlin</code>中并没有<code>static</code>关键字,那么我们如何实现静态方法的效果？我们可以使用<code>companion</code>和<code>object</code>关键字达到这个效果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">MyClassOne</span></span>&#123;<br>    <span class="hljs-keyword">object</span> A&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createA</span><span class="hljs-params">()</span></span>: MyClassOne = MyClassOne()<br>    &#125;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> AA&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createAA</span><span class="hljs-params">()</span></span>: MyClassOne = MyClassOne()<br>    &#125;<br>&#125;<br>MyClassOne.A.createA()<br>MyClassOne.createAA()<br></code></pre></td></tr></table></figure><p>但是看反编译之后的代码，编译器还是为我们创建了<code>A</code>和<code>AA</code>两个类。如果在<code>jvm</code>平台，我们可以使用<code>@JvmStatic</code>注解，将伴生对象的成员生成为真正的静态方法和字段。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassOneJVMStatic</span></span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> AAA &#123;<br>        <span class="hljs-meta">@JvmStatic</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: MyClassOneJVMStatic = MyClassOneJVMStatic()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，对于上面<code>MyClassOne</code>中的<code>AA</code>是可以省略名字的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassTwo</span></span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: MyClassTwo = MyClassTwo()<br>    &#125;<br>&#125;<br>MyClassTwo.Companion.create()<span class="hljs-comment">//正确，但会提示Companion是不必要的</span><br>MyClassTwo.create()<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><p>请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: T<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> : Factory&lt;MyClass&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: MyClass = MyClass()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> f: Factory&lt;MyClass&gt; = MyClass<br></code></pre></td></tr></table></figure><h3 id="对象表达式和对象声明之间的语义差异"><a href="#对象表达式和对象声明之间的语义差异" class="headerlink" title="对象表达式和对象声明之间的语义差异"></a>对象表达式和对象声明之间的语义差异</h3><p>对象表达式和对象声明之间有一个重要的语义差别：</p><ul><li>对象表达式是在使用他们的地方立即执行（及初始化）的。</li><li>对象声明是在第一次被访问到时延迟初始化的。</li><li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配 。</li></ul><p>参考：<br><a href="https://book.kotlincn.net/text/object-declarations.html">对象表达式与对象声明</a><br><a href="https://kotlinlang.org/docs/object-declarations.html">Object expressions and declarations</a><br><a href="https://book.kotlincn.net/text/java-to-kotlin-interop.html#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5">静态字段</a></p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>泛型</p><ul><li><input type='checkbox' disabled='true' checked>逆变</input></li><li><input type='checkbox' disabled='true' checked>协变</input></li><li><input type='checkbox' disabled='true' checked>类型投影</input></li><li><input type='checkbox' disabled='true' checked>星投影</input></li><li><input type='checkbox' disabled='true' checked>泛型约束</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li><li><input type='checkbox' disabled='true' checked>object:匿名内部类、单例模式、伴生对象</input></li></ul></li><li><p>委托</p><ul><li><input type='checkbox' disabled='true' checked>委托类</input></li><li><input type='checkbox' disabled='true' checked>委托属性</input></li><li><input type='checkbox' disabled='true' checked>自定义委托</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>Unit</li><li>Nothing</li><li>inline,noinline,crossinline</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;kotlin 中的&lt;code&gt;object&lt;/code&gt;关键字用处比较广泛，在官方文档&lt;a href=&quot;https://book.kotlincn.net/text/object-declarations.html&quot;&gt;对象表达式与对象声明&lt;/a&gt;有详细的介绍，比如：创建匿名对象、创建匿名内部类并继承某个类，实现多个接口、使用匿名对象作为返回和值类型、从匿名对象访问变量、单例模式、数据对象、伴生对象等，不过文章是从&lt;code&gt;对象表达式&lt;/code&gt;和&lt;code&gt;对象声明&lt;/code&gt;角度来区分的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin委托</title>
    <link href="https://blog.huangyuanlove.com/2024/05/27/kotlin%E5%A7%94%E6%89%98/"/>
    <id>https://blog.huangyuanlove.com/2024/05/27/kotlin%E5%A7%94%E6%89%98/</id>
    <published>2024-05-27T02:30:07.000Z</published>
    <updated>2024-05-30T08:55:33.981Z</updated>
    
    <content type="html"><![CDATA[<p>经常在 Kotlin 的源码三方库中看到<code>by</code>关键字，这种写法就是委托，主要有两个应用场景，一个是委托类，另一个是委托属性，每个场景中又有不同的用法，我们可以对比 Java 的委托来学习 Kotlin 的委托。</p><span id="more"></span><h3 id="委托-类委托、接口委托"><a href="#委托-类委托、接口委托" class="headerlink" title="委托(类委托、接口委托)"></a>委托(类委托、接口委托)</h3><p>其实我们在 Java 和 Android 中经常会用到委托，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Delegated</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Base</span>&#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Base</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseImpl</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>            <span class="hljs-built_in">this</span>.x = x;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Base</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Base base;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Derived</span><span class="hljs-params">(Base base)</span> &#123;<br>            <span class="hljs-built_in">this</span>.base = base;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            base.print();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们有一个接口<code>Base</code>，一个实现类<code>BaseImpl</code>。假如我们想要在实现类中添加一些方法，但又不想重新写一遍接口实现，第一种我们可以继承<code>BaseImpl</code>,另外一种就是实现接口<code>Base</code>，传入一个实现类的实例，将所有的接口请求都交给实现类的实例来完成。<br>虽然官方说<strong>委托模式已经证明是实现继承的一个很好的替代方式(The Delegation pattern has proven to be a good alternative to implementation inheritance)</strong>,但选择权还是在大家手上，看情况而定，没有银弹。<br>那么在 kotlin 中应该怎么写呢？如果我们用 java 的思想来写，无非就是换换关键字，然后一坨模板代码，其实在 kotlin 中是可以通过<code>by</code>关键字零模板代码支持的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseImpl</span></span>(<span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span>) : Base &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> &#123;<br>        println(x)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span></span>(b: Base) : Base <span class="hljs-keyword">by</span> b<br></code></pre></td></tr></table></figure><p><code>Derived</code>的超类型列表中的<code>by</code>子句表示<code>b</code>将会在<code>Derived</code>中内部存储， 并且编译器将生成转发给<code>b</code>的所有<code>Base</code>的方法。<br>这个就是 kotlin 中的委托，有的地方也叫委托类或者委托接口。<br>这里有一点需要注意下，覆盖(override)是符合预期的：编译器会使用 override 覆盖的实现而不是委托对象中的.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessageLine</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseImpl</span></span>(<span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span>) : Base &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span> &#123; println(x) &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessageLine</span><span class="hljs-params">()</span></span> &#123; println(x) &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived2</span></span>(b: Base) : Base <span class="hljs-keyword">by</span> b &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span> &#123; println(<span class="hljs-string">&quot;abc&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> b = BaseImpl(<span class="hljs-number">10</span>)<br>    Derived2(b).printMessage()<br>    Derived2(b).printMessageLine()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在<code>Derived2</code>中覆写了<code>printMessage</code>这个方法，那么在调用的时候，就是用的我们覆写的方法。</p><h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> p: String <span class="hljs-keyword">by</span> Delegate()<br>&#125;<br></code></pre></td></tr></table></figure><p>语法是：<code>val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</code>。在<code>by</code>后面的表达式是该<code>委托</code>， 因为属性对应的<code>get()</code>（与<code>set()</code>）会被委托给它的<code>getValue()</code>与<code>setValue()</code>方法。 属性的委托不必实现接口，但是需要提供一个<code>getValue()</code>函数（对于<code>var</code>属性还有<code>setValue()</code>）。<br>先从最简单的委托开始，最后再看自定义委托。</p><h4 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h4><p>借用官网的一个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>   <span class="hljs-keyword">var</span> newName: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>   <span class="hljs-meta">@Deprecated(<span class="hljs-string">&quot;Use &#x27;newName&#x27; instead&quot;</span>, ReplaceWith(<span class="hljs-string">&quot;newName&quot;</span>)</span>)<br>   <span class="hljs-keyword">var</span> oldName: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">this</span>::newName<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">val</span> myClass = MyClass()<br>   <span class="hljs-comment">// 通知：&#x27;oldName: Int&#x27; is deprecated.</span><br>   <span class="hljs-comment">// Use &#x27;newName&#x27; instead</span><br>   myClass.oldName = <span class="hljs-number">42</span><br>   println(myClass.newName) <span class="hljs-comment">// 42</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是一种最简单的委托方式。通过查看对应的 java 代码，发现其实就是对同一个成员变量的读写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> newName;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNewName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.newName;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNewName</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>      <span class="hljs-built_in">this</span>.newName = var1;<br>   &#125;<br><br>   <span class="hljs-comment">/** <span class="hljs-doctag">@deprecated</span> */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOldName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.newName;<br>   &#125;<br><br>   <span class="hljs-comment">/** <span class="hljs-doctag">@deprecated</span> */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOldName</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>      <span class="hljs-built_in">this</span>.newName = var1;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MyClass</code>中的四个方法都是对<code>newName</code>这个字段的读写。</p><p>除此之外，委托属性可以是：</p><ul><li>顶层属性</li><li>同一个类的成员或扩展属性</li><li>另一个类的成员或扩展属性</li></ul><p>比如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> topLevelInt: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassWithDelegate</span></span>(<span class="hljs-keyword">val</span> anotherClassInt: <span class="hljs-built_in">Int</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>(<span class="hljs-keyword">var</span> memberInt: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> anotherClassInstance: ClassWithDelegate) &#123;<br>    <span class="hljs-keyword">var</span> delegatedToMember: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">this</span>::memberInt<span class="hljs-comment">//同一个类的成员</span><br>    <span class="hljs-keyword">var</span> delegatedToTopLevel: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> ::topLevelInt<span class="hljs-comment">//顶层属性</span><br><br>    <span class="hljs-keyword">val</span> delegatedToAnotherClass: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> anotherClassInstance::anotherClassInt<span class="hljs-comment">//另一个类的成员</span><br>&#125;<br><span class="hljs-keyword">var</span> MyClass.extDelegated: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> ::topLevelInt<span class="hljs-comment">//顶层属性</span><br></code></pre></td></tr></table></figure><p>这种委托方式在我们做版本升级修改字段时是挺常用的,将旧字段委托给新字段，并将旧字段标记为过时。</p><h4 id="懒加载委托"><a href="#懒加载委托" class="headerlink" title="懒加载委托"></a>懒加载委托</h4><p>这种方式就是当我们首次访问这个属性的时候才会去初始化这个属性，从而避免不必要的资源消耗，和我们用 java 写单例模式的懒加载是一样的。<br>只会在首次访问的时候初始化这个属性，然后缓存起来，下次访问时直接返回。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> lazyValue: String <span class="hljs-keyword">by</span> lazy &#123;<br>    println(<span class="hljs-string">&quot;computed!&quot;</span>)<br>    <span class="hljs-string">&quot;Hello&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(lazyValue)<br>    println(lazyValue)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 lazy 是一个高阶函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">lazy</span><span class="hljs-params">(initializer: () -&gt; <span class="hljs-type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">lazy</span><span class="hljs-params">(mode: <span class="hljs-type">LazyThreadSafetyMode</span>, initializer: () -&gt; <span class="hljs-type">T</span>)</span></span>: Lazy&lt;T&gt; =<br>    <span class="hljs-keyword">when</span> (mode) &#123;<br>        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)<br>        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)<br>        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到，lazy接收一个 mode 参数，如果没有传入的话，默认是<code>SynchronizedLazyImpl</code>线程安全的：该值只在一个线程中计算，但所有线程都会看到相同的值。如果初始化委托的同步锁不是必需的，这样可以让多个线程同时执行，那么将<code>LazyThreadSafetyMode.PUBLICATION</code>作为参数传给 lazy()。<br>如果我们确定初始化将总是发生在与属性使用位于相同的线程， 那么可以使用<code>LazyThreadSafetyMode.NONE</code>模式。它不会有任何线程安全的保证以及相关的开销。<br>所以这个参数的选择也要看具体应用场景。</p><h4 id="可观察委托"><a href="#可观察委托" class="headerlink" title="可观察委托"></a>可观察委托</h4><p>如果我们想要观察属性值的变化，可以使用<code>Delegates.observable()</code>，它接受两个参数：初始值与修改时处理程序（handler）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">ObservableItem</span></span>&#123;<br>    <span class="hljs-keyword">var</span> name :String <span class="hljs-keyword">by</span> Delegates.observable(<span class="hljs-string">&quot;initialValue&quot;</span>)&#123;<br>        prop,old,new-&gt;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$prop</span>  <span class="hljs-variable">$old</span> -&gt; <span class="hljs-variable">$new</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们给<code>name</code>赋值的时候，就会触发传入的处理程序，但这里我们只能观察到赋值，但并不能做拦截，如果想要截获取值并<strong>否决</strong>,可以使用<code>vetoable()</code></p><h4 id="可否决委托"><a href="#可否决委托" class="headerlink" title="可否决委托"></a>可否决委托</h4><p>如果我们想在观察属性值变化的同时决定是否使用新的值，可以使用<code>Delegates.vetoable</code>,同样的，它也接受两个参数：它接受两个参数：初始值与修改时处理程序（handler）。只不过这里的 handler 需要返回一个布尔值，告诉程序是否使用新值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VetoableItem</span></span>&#123;<br>    <span class="hljs-keyword">var</span> name :String <span class="hljs-keyword">by</span> Delegates.vetoable(<span class="hljs-string">&quot;initialValue&quot;</span>)&#123;<br>        prop,old,new-&gt;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$prop</span>  <span class="hljs-variable">$old</span> -&gt; <span class="hljs-variable">$new</span>&quot;</span>)<br>        new.length &gt; <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> vetoableItem = VetoableItem()<br>    println(vetoableItem.name)<br>    vetoableItem.name = <span class="hljs-string">&quot;123&quot;</span><br>    println(vetoableItem.name)<br>    vetoableItem.name = <span class="hljs-string">&quot;1234&quot;</span><br>    println(vetoableItem.name)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">// initialValue</span><br><span class="hljs-comment">// var com.huangyuanlove.VetoableItem.name: kotlin.String  initialValue -&gt; 123</span><br><span class="hljs-comment">// initialValue</span><br><span class="hljs-comment">// var com.huangyuanlove.VetoableItem.name: kotlin.String  initialValue -&gt; 1234</span><br><span class="hljs-comment">// 1234</span><br></code></pre></td></tr></table></figure><p>在这里，只有当<code>new</code>的长度大于 3 时，我们才会将<code>new</code>赋值给<code>name</code>，</p><h4 id="将属性储存在映射中"><a href="#将属性储存在映射中" class="headerlink" title="将属性储存在映射中"></a>将属性储存在映射中</h4><p>一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者执行其他“动态”任务的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapItem</span></span>(map: Map&lt;String,Any?&gt;)&#123;<br>    <span class="hljs-keyword">val</span> name: String <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">val</span> age:<span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">val</span> address:String <span class="hljs-keyword">by</span> map<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">val</span> map:Map&lt;String,Any?&gt; = mapOf(<br>    <span class="hljs-string">&quot;name&quot;</span> to <span class="hljs-string">&quot;xuan&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span> to <span class="hljs-number">18</span>,<br>  )<br>  <span class="hljs-keyword">val</span> mapItem = MapItem(map)<br>  println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mapItem.age&#125;</span>&quot;</span>)<br>  println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mapItem.age&#125;</span>  <span class="hljs-subst">$&#123;mapItem.address&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意，假如我们传入的<code>map</code>里面没有对应属性，当程序运行时，这个属性没有被使用是没问题的，比如上面打印<code>name</code>和<code>age</code>。但是当我们使用这个属性的时候，就是上面打印<code>address</code>,会抛出异常<code>Key address is missing in the map.</code>.另外一方面，我们将传入的 map 的值声明为了可空，这就意味着在调用出传入了空值，比如<code>&quot;address&quot; to null,</code>,代码是可以运行的，但对<code>address</code>这个属性做处理的时候会报空指针异常，这些都是需要额外注意的地方。<br>还有一点需要注意，如果是对于<code>var</code>属性，需要将<code>Map</code>替换成<code>MutableMap</code>,但是这样的话它们两个可是双向绑定的哟，比如下面这种</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutableMapItem</span></span>(map:MutableMap&lt;String,Any?&gt;)&#123;<br>    <span class="hljs-keyword">var</span> name: String <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">var</span> address: String <span class="hljs-keyword">by</span> map<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">val</span> map:MutableMap&lt;String,Any?&gt; = mutableMapOf(<br>        <span class="hljs-string">&quot;name&quot;</span> to <span class="hljs-string">&quot;xuan&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span> to <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&quot;address&quot;</span> to <span class="hljs-string">&quot;beijing&quot;</span><br>    )<br>    <span class="hljs-keyword">val</span> mutableMapItem = MutableMapItem(map)<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mutableMapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mutableMapItem.age&#125;</span> <span class="hljs-subst">$&#123;mutableMapItem.address&#125;</span>&quot;</span>)<br>    println(map)<br>    mutableMapItem.name = <span class="hljs-string">&quot;huang&quot;</span><br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mutableMapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mutableMapItem.age&#125;</span> <span class="hljs-subst">$&#123;mutableMapItem.address&#125;</span>&quot;</span>)<br>    println(map)<br>    mutableMapItem.name = <span class="hljs-string">&quot;yuan&quot;</span><br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mutableMapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mutableMapItem.age&#125;</span> <span class="hljs-subst">$&#123;mutableMapItem.address&#125;</span>&quot;</span>)<br>    println(map)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">// xuan  18 beijing</span><br><span class="hljs-comment">// &#123;name=xuan, age=18, address=beijing&#125;</span><br><span class="hljs-comment">// huang  18 beijing</span><br><span class="hljs-comment">// &#123;name=huang, age=18, address=beijing&#125;</span><br><span class="hljs-comment">// yuan  18 beijing</span><br><span class="hljs-comment">// &#123;name=yuan, age=18, address=beijing&#125;</span><br></code></pre></td></tr></table></figure><h4 id="局部属性委托"><a href="#局部属性委托" class="headerlink" title="局部属性委托"></a>局部属性委托</h4><p>可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">(computeFoo: () -&gt; <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> memoizedFoo <span class="hljs-keyword">by</span> lazy(computeFoo)<br>    <span class="hljs-keyword">val</span> someCondition = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">if</span> (someCondition &amp;&amp; memoizedFoo&gt;<span class="hljs-number">0</span> ) &#123;<br>        println(memoizedFoo+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>memoizedFoo</code>变量只会在第一次访问时计算。 如果<code>someCondition</code>失败，那么该变量根本不会计算。</p><h4 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h4><p>先看一下自定义委托的要求有哪些，示例是这样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Owner</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> varResource: Resource <span class="hljs-keyword">by</span> ResourceDelegate()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceDelegate</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> resource: Resource = Resource()) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: Resource &#123;<br>        <span class="hljs-keyword">return</span> resource<br>    &#125;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">Any</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">is</span> Resource) &#123;<br>            resource = value<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下</p><ol><li>对于<code>var</code>修饰的属性，我们必须要有<code>getValue</code>、<code>setValue</code>这两个方法，同时，这两个方法必须用<code>operator</code>关键字修饰。</li><li>由于<code>varResource</code>是<code>Owner</code>,因此<code>getValue</code>、<code>setValue</code>这两个方法中的<code>thisRef</code>的类型，必须要是<code>Owner</code>或者是<code>Owner的父类</code>。一般来说，这三处的类型是一致的，当我们不确定委托属性会处于哪个类的时候，就可以将<code>thisRef</code>的类型定义为<code>Any?</code>。</li><li>由于委托的属性是<code>Resource</code>类型，那么对于自定义委托中的<code>getValue</code>、<code>setValue</code>参数及返回值需要是<code>String类型或者是它的父类</code></li></ol><p>我们可以把上面的代码当成模板代码，都是这样写就好了。如果觉得麻烦，可以使用标准库中的接口<code>ReadOnlyProperty</code>和<code>ReadWriteProperty</code>将委托创建为匿名对象，而无需创建新类。它们提供所需的方法:<code>getValue()</code>在<code>ReadOnlyProperty</code>中声明；<code>ReadWriteProperty</code>扩展了它并添加了<code>setValue()</code>。这意味着可以在需要<code>ReadOnlyProperty</code>时传递 <code>ReadWriteProperty</code>。<br>比如像这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resourceDelegate</span><span class="hljs-params">(resource: <span class="hljs-type">Resource</span>= Resource()</span></span>) :ReadWriteProperty&lt;Owner,Resource&gt; =<br>    <span class="hljs-keyword">object</span>:ReadWriteProperty&lt;Owner,Resource&gt;&#123;<br>        <span class="hljs-keyword">var</span> curValue = resource<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: Resource=curValue<br>        <br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">Resource</span>)</span></span> &#123;<br>            curValue = value<br>        &#125;<br><br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Owner</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> readOnlyResource: Resource <span class="hljs-keyword">by</span> resourceDelegate()  <span class="hljs-comment">// ReadWriteProperty as val</span><br>    <span class="hljs-keyword">var</span> readWriteResource: Resource <span class="hljs-keyword">by</span> resourceDelegate()<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="提供委托"><a href="#提供委托" class="headerlink" title="提供委托"></a>提供委托</h4><p>通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数， 那么会调用该函数来创建属性委托实例。比如在初始化之前检查一致性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceDelegate</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">ReadOnlyProperty</span>&lt;<span class="hljs-type">MyUI, T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">MyUI</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: T &#123; ... &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceLoader</span>&lt;<span class="hljs-type">T</span>&gt;</span>(id: ResourceID&lt;T&gt;) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDelegate</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            thisRef: <span class="hljs-type">MyUI</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            prop: <span class="hljs-type">KProperty</span>&lt;*&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: ReadOnlyProperty&lt;MyUI, T&gt; &#123;<br>        checkProperty(thisRef, prop.name)<br>        <span class="hljs-comment">// 创建委托</span><br>        <span class="hljs-keyword">return</span> ResourceDelegate()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkProperty</span><span class="hljs-params">(thisRef: <span class="hljs-type">MyUI</span>, name: <span class="hljs-type">String</span>)</span></span> &#123; …… &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUI</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">bindResource</span><span class="hljs-params">(id: <span class="hljs-type">ResourceID</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: ResourceLoader&lt;T&gt; &#123; …… &#125;<br><br>    <span class="hljs-keyword">val</span> image <span class="hljs-keyword">by</span> bindResource(ResourceID.image_id)<br>    <span class="hljs-keyword">val</span> text <span class="hljs-keyword">by</span> bindResource(ResourceID.text_id)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>provideDelegate</code>的参数与<code>getValue</code>的相同：</p><ul><li><code>thisRef</code>必须与<code>属性所有者</code>类型（对于扩展属性必须是被扩展的类型）相同或者是它的超类型；</li><li><code>property</code>必须是类型<code>KProperty&lt;*&gt;</code>或其超类型。</li></ul><hr><p>参考：</p><p><a href="https://book.kotlincn.net/text/delegation.html">委托</a><br><a href="https://kotlinlang.org/docs/delegation.html">Delegation</a></p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>泛型</p><ul><li><input type='checkbox' disabled='true' checked>逆变</input></li><li><input type='checkbox' disabled='true' checked>协变</input></li><li><input type='checkbox' disabled='true' checked>类型投影</input></li><li><input type='checkbox' disabled='true' checked>星投影</input></li><li><input type='checkbox' disabled='true' checked>泛型约束</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li></ul></li><li><p>委托</p><ul><li><input type='checkbox' disabled='true' checked>委托类</input></li><li><input type='checkbox' disabled='true' checked>委托属性</input></li><li><input type='checkbox' disabled='true' checked>自定义委托</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>object</li><li>Unit</li><li>Nothing</li><li>inline,noinline,crossinline</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;经常在 Kotlin 的源码三方库中看到&lt;code&gt;by&lt;/code&gt;关键字，这种写法就是委托，主要有两个应用场景，一个是委托类，另一个是委托属性，每个场景中又有不同的用法，我们可以对比 Java 的委托来学习 Kotlin 的委托。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin泛型:逆变与协变</title>
    <link href="https://blog.huangyuanlove.com/2024/04/30/kotlin%E6%B3%9B%E5%9E%8B-%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/"/>
    <id>https://blog.huangyuanlove.com/2024/04/30/kotlin%E6%B3%9B%E5%9E%8B-%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/</id>
    <published>2024-04-30T02:59:38.000Z</published>
    <updated>2024-05-28T02:46:59.952Z</updated>
    
    <content type="html"><![CDATA[<p>泛型中涉及到的概念也不少,型变(Variance)、逆变(Contravariance)、协变(Covariance)、不变(Invariant).在 kotlin 中还有三个关键字<code>in</code>、<code>out</code>、<code>where</code>、<code>reified</code>等,在java中同样也有<code>? extends</code>、<code>? super</code>、<code>?</code><br>这些概念是啥意思嘞？引用点概念说明</p><blockquote><p>型变(Variance)、协变(Covariance)、逆变(Contravariance)和不变(Invariant)是相关但不同的概念.</p></blockquote><blockquote><p>型变是指泛型类型参数在子类型关系中的行为.它描述了一个泛型类型是否允许类型参数的子类型关系与泛型类型参数的子类型关系保持一致.在泛型中,可以有三种型变类型：协变、逆变和不变.</p></blockquote><blockquote><p>协变是指如果一个泛型类型的子类型关系与其类型参数的子类型关系保持一致,则该泛型类型是协变的.简而言之,如果子类型的泛型参数是父类型泛型参数的子类型,就可以说该泛型类型是协变的.</p></blockquote><blockquote><p>逆变是指如果一个泛型类型的子类型关系与其类型参数的子类型关系相反,则该泛型类型是逆变的.简而言之,如果子类型的泛型参数是父类型泛型参数的超类型,就可以说该泛型类型是逆变的.</p></blockquote><blockquote><p>不变是指一个泛型类型的子类型关系与其类型参数无关,即类型参数的子类型关系与泛型类型的子类型关系无关.在不变的情况下,不能将父类型的对象赋值给子类型的对象,也不能将子类型的对象赋值给父类型的对象.</p></blockquote><blockquote><p>因此,可以说协变和逆变是型变的两种具体形式,而不变则是型变的一种特殊情况.</p></blockquote><blockquote><p>总结起来,协变、逆变和不变描述了泛型类型参数与泛型类型之间子类型关系的不同行为.协变和逆变是对子类型关系的具体约束,而不变则是没有任何子类型关系的约束.它们之间是互相排斥的关系,不是包含关系.</p></blockquote><p>一脸懵了吧😳?问题不大,结合代码具体看一下就差不多了</p><p>我们还是结合 java 和 kotlin 对比来看一下</p><h3 id="Java中的泛型"><a href="#Java中的泛型" class="headerlink" title="Java中的泛型"></a>Java中的泛型</h3><p>我们先用Java代码来看一下,假如我们有如下三个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Poodle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dog</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 java 的多态性,我们可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animalDog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><span class="hljs-type">Animal</span> <span class="hljs-variable">animalBird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>ArrayList&lt;Animal&gt; animalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>animalList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>());<br>animalList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br></code></pre></td></tr></table></figure><p>这么写是没问题的,我们可以把子类添加到父类列表中,但当我们在<code>animalList</code>中获取数据时返回的是<code>Animal</code>类型,如果用到子类的特性,还需要使用<code>instanceof</code>来判断一下类型.<br>但如果我们这么写是不行的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">ArrayList&lt;Animal&gt; animalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br></code></pre></td></tr></table></figure><p>因为 java 的泛型具有不变性,在Java 里面认为<code>ArrayList&lt;Animal&gt;</code>和<code>ArrayList&lt;Dog&gt;</code>没啥关系.<br>同样的,当我们想要用方法重载时也会遇到这种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">animal</span><span class="hljs-params">(ArrayList&lt;Dog&gt; dogs)</span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">animal</span><span class="hljs-params">(ArrayList&lt;Bird&gt; birds)</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们这么写的话会报错,IDE 会提示我们相应的信息</p><blockquote><p>animal(ArrayList<Dog>)’ clashes with ‘animal(ArrayList<Bird>)’; both methods have same erasure</p></blockquote><p>两个方法的参数有相同的擦除类型,编译后会被认为是同一个方法.<br>同样的,我们在<strong>捕获泛型异常</strong>时也会有类似的报错信息.</p><h3 id="Java中的泛型擦除"><a href="#Java中的泛型擦除" class="headerlink" title="Java中的泛型擦除"></a>Java中的泛型擦除</h3><p>面试常见的八股文,我们来复习一下,这部分可以跳过不看.<br>比如我们在C#中有如下代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params">String[] args</span>)</span>&#123; <br>        test&lt;<span class="hljs-built_in">string</span>&gt;(); <br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>&lt;<span class="hljs-title">T</span>&gt;()</span>&#123; <br>        Console.WriteLine(<span class="hljs-keyword">typeof</span>(T)); <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>这里的泛型 T 类型string 是可以在运行时获取到的,并且在这里是一个真实可用的类型.<br>但在Java是不行的,由于向上兼容历史代码的原因 Java 采用了<code>Code sharing</code>的策略,使得泛型只存在于源码阶段,编译过后的Class文件并不存在泛型,虚拟机并不知道泛型的存在,所以说Java中的泛型是一种伪泛型,这种参数类型只存在于源码阶段在编译后并不存在的机制我们叫做<strong>泛型擦除</strong>.为了保持泛型继承或实现关系的正确性,java 中还有一种策略：<strong>桥方法生成(Bridge Method Generation)</strong>:<br>一个简单的例子来说明桥方法生成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(T shape)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing shape: &quot;</span> + shape.toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(String shape)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing circle: &quot;</span> + shape);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类型擦除后,编译器会生成桥方法来保持泛型继承关系的正确性.在这个示例中,编译器会生成一个桥方法,使得Circle类的方法签名与父类的方法签名保持一致,但返回类型被擦除为父类的类型参数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(String shape)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing circle: &quot;</span> + shape);<br>    &#125;<br><br>    <span class="hljs-comment">// 生成的桥方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Object shape)</span> &#123;<br>        draw((String) shape);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过生成的桥方法,即draw(Object shape),在类型擦除后仍然能够正确地调用泛型方法.这样,即使在编译器看不到具体的泛型类型信息,仍然可以通过桥方法来调用正确的方法实现.<br>感兴趣的话可以搜一下关键字:泛型擦除、桥方法生成、Code sharin、Code specialization</p><h3 id="Java-中的泛型通配符"><a href="#Java-中的泛型通配符" class="headerlink" title="Java 中的泛型通配符"></a>Java 中的泛型通配符</h3><p>假如我们真的有像上面那种赋值需求怎么搞？java 给我们提供了<code>泛型通配符</code>: <strong>? extends</strong> 和 <strong>? super</strong> 来解决这个问题.<br>啰嗦一下：在继承关系上,一般情况下将父类放在上方,子类放在下方.比如上面定义的类</p><pre><code class="mermaid" >graph TBA(Animal)A10(Dog)A11(Bird)A20(Poodle)A-->A10A-->A11A10-->A20</code></pre><h4 id="extends"><a href="#extends" class="headerlink" title="? extends"></a>? extends</h4><p>我们可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt; arrayList ;<br>arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Bird&gt;();<br>arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br>arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();<br></code></pre></td></tr></table></figure><p>这里的<code>? extends</code>叫做<strong>上界通配符</strong>,可以使 Java 泛型具有<strong>协变性 Covariance</strong>,协变就是允许上面的赋值是合法的.<br>不过这里的<code>extends</code>和我们定义<code>class</code>时继承某个类用的<code>extends</code>有一点点不一样,除了上界所有的直接子类、间接子类还包含它本身,并且上界也可以是 interface.<br>在上面的例子中,<code>ArrayList&lt;? extends Animal&gt;</code>表示列表中可以存放 Animal 及其子类、间接子类的类型.也就是确认了它的上限能到哪一层.<br>但我们在使用的泛型通配符之后,在使用上会有一些小问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<span class="hljs-comment">//error</span><br>arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>());<span class="hljs-comment">//error</span><br>arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>());<span class="hljs-comment">//error</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span>  arrayList.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure><p>由于<code>arrayList</code>中存放的可以是<strong>Animal 及其子类、间接子类的类型</strong>,所以我们并不确定是哪种类型,因此我们无法向列表中添加元素,但可以确定的是,将列表中的元素赋值给 Animal类型的变量是没问题的.<br>像这种只能从列表中读取数据提供,但不能向列表中写入的情况我们称之为<code>生产者</code></p><h4 id="super"><a href="#super" class="headerlink" title="? super"></a>? super</h4><p>我们可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-built_in">super</span> Dog&gt; list ;<br>list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br>list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();<br>list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Poodle&gt;();<span class="hljs-comment">//error</span><br><br></code></pre></td></tr></table></figure><p>这里的<code>? super</code>叫做<strong>下界通配符</strong>,可以使Java泛型具<strong>逆变性 Contravariance</strong>,逆变就是允许上面的赋值是合法的.<br>通过代码我们可以看到下界通配符确定了列表的下限,也就是确认了下限在哪一层,我们可以将该层及以上的类型赋值给 list.同样的,我们在使用上也有一点点小问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Poodle</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>());<span class="hljs-comment">//error</span><br><br><span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>因为list 中存放的肯定是<strong>Dog或者其父类、间接父类</strong>,根据里氏替换原则,任何使用父类的地方可以被它的子类替换,所以我们可以向 list 中添加<strong>Dog或其子类、间接子类</strong>.但是当我们从 list 中取数据的时候,由于不知道 list 中存放的具体是什么类型,在 java 中 Object 是所有类型的父类,所以这里取到的数据返回的<strong>Object</strong>类型.</p><p>一般情况下,我们获取到Object可以通过<code>className</code>或者<code>instanceof</code>来判断具体类型,但我们就先忽略吧.<br>像这种只写入而不读取的泛型类型声明情况称之为<strong>消费者 Consumer</strong>.</p><h4 id="无边界通配符"><a href="#无边界通配符" class="headerlink" title="无边界通配符"></a>无边界通配符</h4><p>还有一种无边界通配符,用单问号表示：List&lt;?&gt;,也就是没有任何限定,相当于<code>? extends Object</code>.需要注意的是,它和不使用类型的 List 还是有区别的：</p><ul><li>List&lt;?&gt; list表示的是列表保存某个特定类型的对象,但我们不能向其中添加任何元素,因为我们不清楚 list 中保存的是那种类型</li><li>没有泛型参数的 List 表示该列表持有的元素类型是 Object,因此可以添加任何类型的对象,但编译器会有警告信息.</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>小小的总结一下：<br>利用<code>? extends</code>形式的通配符可以实现泛型的向上转型,也就是支持协变.但使用上通配符后编译器为了保证运行时的安全,会限定对其写的操作,开放读的操作也就是<strong>只能读取不能修改</strong><br>利用<code>? super T</code>形式的通配符可以实现泛型的向下转型,也就是支持逆变,与上通配符相反,下边界通配符通常限定读的操作,开放写的操作,也就是<strong>只能修改不能读取</strong></p><p>Joshua Bloch 在其著作《Effective Java》第三版 中很好地解释了该问题 (第 31 条：“利用有限制通配符来提升 API 的灵活性”). 他称那些你只能从中读取的对象为生产者, 并称那些只能向其写入的对象为消费者.他建议：</p><blockquote><p>为了灵活性最大化,在表示生产者或消费者的输入参数上使用通配符类型.</p></blockquote><p>他还提出了以下助记符：PECS 代表生产者-Extends、消费者-Super(Producer-Extends, Consumer-Super).</p><h3 id="kotlin-中的泛型通配符"><a href="#kotlin-中的泛型通配符" class="headerlink" title="kotlin 中的泛型通配符"></a>kotlin 中的泛型通配符</h3><p>理清楚了 java 中的泛型通配符,接着我们看一下 kotlin 中的通配符,相对于 Java 的通配符提出了一种新的定义：<strong>声明处型变(declaration-site variance)<strong>与</strong>类型投影(type projections)</strong><br>先从 kotlin 中的通配符说起：<br>和 java 泛型一样，kotlin 中的泛型也是不变的，同样的，也提供了相应的关键字来支持<strong>协变</strong>和<strong>逆变</strong></p><ul><li>使用关键字<code>out</code>来支持协变，等同于 Java 中的上界通配符<code>? extends</code>。</li><li>使用关键字<code>in</code>来支持逆变，等同于 Java 中的下界通配符<code>? super</code>。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> outList: MutableList&lt;<span class="hljs-keyword">out</span> TestMain.Animal&gt; = mutableListOf()<br><span class="hljs-keyword">val</span> outListItem: TestMain.Animal = outList[<span class="hljs-number">0</span>]<br><br><br><span class="hljs-keyword">val</span> inList: MutableList&lt;<span class="hljs-keyword">in</span> TestMain.Animal&gt; = mutableListOf()<br>inList.add(TestMain.Dog())<br>inList.add(TestMain.Bird())<br>inList.add(TestMain.Poodle())<br><span class="hljs-keyword">val</span> inListItem: Any? = inList[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>无非是换了个写法而已，没多大差别.不过需要注意一下，kotlin 同时支持使用处型变和声明处型变。<br>举一个用烂了的例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span>&lt;<span class="hljs-type">out T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> T<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(t)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> producer: Producer&lt;TestMain.Animal&gt; = Producer()<br><span class="hljs-keyword">val</span> animal: TestMain.Animal = producer.produce()<br><br><span class="hljs-keyword">val</span> consumer: Consumer&lt;TestMain.Animal&gt; = Consumer()<br>consumer.consume(TestMain.Dog())<br></code></pre></td></tr></table></figure><p>如果我们确认泛型参数只用来输入或者输出，可以在声明处直接添加<code>in</code>或者<code>out</code>.当然也可以在使用处添加声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer1</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T? &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(t)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> producer1: Producer1&lt;<span class="hljs-keyword">out</span> TestMain.Animal&gt; = Producer1()<br><span class="hljs-keyword">val</span> animal1: TestMain.Animal? = producer1.produce()<br><br><span class="hljs-keyword">val</span> consumer1: Consumer1&lt;<span class="hljs-keyword">in</span> TestMain.Animal&gt; = Consumer1()<br>consumer1.consume(TestMain.Dog())<br></code></pre></td></tr></table></figure><p>这里也就是经常说的 <strong>消费者 in, 生产者 out</strong></p><h4 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h4><p>这个东西可以理解为就是一个概念，根据官方描述是这样的:<br>将类型参数<code>T</code>声明为<code>out</code>非常简单，并且能避免使用处子类型化的麻烦，但是有些类实际上不能限制为只返回<code>T</code>！一个很好的例子是<code>Array</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: T &#123; …… &#125;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">set</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>, value: <span class="hljs-type">T</span>)</span></span> &#123; …… &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该类在<code>T</code>上既不能是协变的也不能是逆变的。这造成了一些不灵活性。考虑下述函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Any</span>&gt;, to: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Any</span>&gt;)</span></span> &#123;<br>    assert(from.size == to.size)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> from.indices)<br>        to[i] = from[i]<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数应该将项目从一个数组复制到另一个数组。让我们尝试在实践中应用它：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> ints: Array&lt;<span class="hljs-built_in">Int</span>&gt; = arrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">val</span> any = Array&lt;Any&gt;(<span class="hljs-number">3</span>) &#123; <span class="hljs-string">&quot;&quot;</span> &#125; <br>copy(ints, any)<br><span class="hljs-comment">//   ^ 其类型为 Array&lt;Int&gt; 但此处期望 Array&lt;Any&gt;</span><br></code></pre></td></tr></table></figure><p>这里我们遇到同样熟悉的问题：<code>Array&lt;T&gt;</code>在<code>T</code>上是<strong>不型变</strong>的，因此<code>Array&lt;Int&gt;</code> 与 <code>Array&lt;Any&gt;</code> 都不是另一个的子类型。为什么？ 再次重复，因为<code>copy</code>可能有非预期行为，例如它可能尝试写一个<code>String</code>到<code>from</code>，并且如果我们实际上传递一个<code>Int</code>的数组，以后会抛<code>ClassCastException</code>异常。<br>如果需要禁止<code>copy</code>功能写入<code>from</code>，可以执行以下操作:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Any</span>&gt;, to: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Any</span>&gt;)</span></span> &#123; …… &#125;<br></code></pre></td></tr></table></figure><p>这就是类型投影：意味着<code>from</code>不仅仅是一个数组，而是一个<code>受限制</code>的<strong>（投影的）</strong>数组。 只可以调用返回类型为类型参数<code>T</code>的方法，如上，这意味着只能调用<code>get()</code>。 这就是使用处型变的用法，并且是对应于 Java 的 <code>Array&lt;? extends Object&gt;</code>, 但更简单。</p><p>你也可以使用<code>in</code>投影一个类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fill</span><span class="hljs-params">(dest: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">String</span>&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123; …… &#125;<br></code></pre></td></tr></table></figure><p><code>Array&lt;in String&gt;</code> 对应于 Java 的<code>Array&lt;? super String&gt;</code>，也就是说，你可以传递一个<code>CharSequence</code>数组或一个<code>Object</code>数组给<code>fill()</code>函数。<br><strong>以上信息来自 <a href="(https://book.kotlincn.net/text/generics.html)">kotlin 中文网</a></strong></p><h4 id="星投影"><a href="#星投影" class="headerlink" title="星投影"></a>星投影</h4><p>有时你想说，你对类型参数一无所知，但仍然希望以安全的方式使用它。 这里的安全方式是定义泛型类型的这种投影，该泛型类型的每个具体实例化都会是该投影的子类型。</p><p>Kotlin 为此提供了所谓的<strong>星投影</strong>语法：</p><ul><li>对于<code>Foo &lt;out T : TUpper&gt;</code>，其中<code>T</code>是一个具有上界<code>TUpper</code>的协变类型参数，<code>Foo &lt;*&gt;</code>等价于<code>Foo &lt;out TUpper&gt;</code>。 意味着当<code>T</code>未知时，你可以安全地从<code>Foo &lt;*&gt;</code>读取<code>TUpper</code>的值。</li><li>对于<code>Foo &lt;in T&gt;</code>，其中<code>T</code>是一个逆变类型参数，<code>Foo &lt;*&gt;</code>等价于<code>Foo &lt;in Nothing&gt;</code>。 意味着当<code>T</code>未知时， 没有什么可以以安全的方式写入<code>Foo &lt;*&gt;</code>。</li><li>对于<code>Foo &lt;T : TUpper&gt;</code>，其中<code>T</code>是一个具有上界<code>TUpper</code>的不型变类型参数,<code>Foo&lt;*&gt;</code>对于读取值时等价于<code>Foo&lt;out TUpper&gt;</code> 而对于写值时等价于<code>Foo&lt;in Nothing&gt;</code>。</li></ul><p>如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。 例如，如果类型被声明为 interface Function &lt;in T, out U&gt;，可以使用以下星投影：</p><ul><li><code>Function&lt;*, String&gt;</code> 表示<code>Function&lt;in Nothing, String&gt;</code>。</li><li><code>Function&lt;Int, *&gt;</code> 表示<code>Function&lt;Int, out Any?&gt;</code>。</li><li><code>Function&lt;*, *&gt;</code> 表示<code>Function&lt;in Nothing, out Any?&gt;</code>。</li></ul><p><strong>以上信息来自 <a href="(https://book.kotlincn.net/text/generics.html)">kotlin 中文网</a></strong></p><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">singletonList</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; &#123;<br>    <span class="hljs-comment">// ……</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">basicToString</span><span class="hljs-params">()</span></span>: String &#123; <span class="hljs-comment">// 扩展函数</span><br>    <span class="hljs-comment">// ……</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要调用泛型函数，在调用处函数名之后指定类型参数即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> l = singletonList&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>可以省略能够从上下文中推断出来的类型参数，所以以下示例同样适用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> l = singletonList(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>能够替换给定类型参数的所有可能类型的集合可以由<strong>泛型约束</strong>限制。<br>最常见的约束类型是上界，与Java的<code>extends</code>关键字对应：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="hljs-title">sort</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;  …… &#125;<br></code></pre></td></tr></table></figure><p>冒号之后指定的类型是上界，表明只有<code>Comparable&lt;T&gt;</code>的子类型可以替代<code>T</code>。 例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">sort(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span><br>sort(listOf(HashMap&lt;<span class="hljs-built_in">Int</span>, String&gt;())) <span class="hljs-comment">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span><br></code></pre></td></tr></table></figure><p>默认的上界（如果没有声明）是 Any?。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，需要一个单独的 where-子句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">copyWhenGreater</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;, threshold: <span class="hljs-type">T</span>)</span></span>: List&lt;String&gt;<br>    <span class="hljs-keyword">where</span> T : CharSequence,<br>          T : Comparable&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所传递的类型必须同时满足<code>where</code>子句的所有条件。在上述示例中，类型<code>T</code>必须<strong>既实现了 CharSequence 也实现了 Comparable</strong>。<br>这里需要注意的是，where 子句后面的第一个类型可以是接口也可以是抽象类、实现类，后续的类型只能是接口。在 Java 中也一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAbstractClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyInterface</span> &amp; MyAbstractClass&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>&#123; <span class="hljs-comment">//errpr</span><br>    t.test();<br>&#125;<br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">MyAbstractClass</span> &amp; MyInterface &gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>&#123;<br>    t.test();<br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>原因就是 java 中不可以多继承但可以多实现</p><h4 id="UnsafeVariance"><a href="#UnsafeVariance" class="headerlink" title="@UnsafeVariance"></a>@UnsafeVariance</h4><p>差点忘了这东西，这个注解就是告诉编译器我知道我在做什么，并且保证不会出问题，忽略协变和逆变的约束就好了<br>比如 kotlin 中的<code>Collection</code>这个类中的<code>contains</code>、<code>containsAll</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-type">out E</span>&gt; : <span class="hljs-type">Iterable</span>&lt;<span class="hljs-type">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contains</span><span class="hljs-params">(element: @<span class="hljs-type">UnsafeVariance</span> <span class="hljs-type">E</span>)</span></span>: <span class="hljs-built_in">Boolean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;@<span class="hljs-type">UnsafeVariance</span> <span class="hljs-type">E</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于协变的类型，通常我们是不允许将泛型类型作为传入参数的类型的，或者说，对于协变类型，我们通常是不允许其涉及泛型参数的部分被改变的。<br>这也很容易解&gt;释为什么 MutableCollection 是不变的，而 Collection 是协变的，因为在 Kotlin 当中，前者是可被修改的，后者是不可被修改的。<br>逆变的情形正好相反，即不可以将泛型参数作为方法的返回值。</p></blockquote><p>比如这种情形，为了让编译器放过一马，我们就可以用 @UnsafeVariance 来告诉编译器：“我知道我在干啥，保证不会出错，你不用担心”。<br><strong>以上信息来自<a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></strong></p><h4 id="reified-关键字"><a href="#reified-关键字" class="headerlink" title="reified 关键字"></a>reified 关键字</h4><p>由于存在类型擦除，导致我们无法在运行时获取泛型的具体类型，有些操作无法实现，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">testOne</span><span class="hljs-params">(Object param)</span>&#123;<br>    <span class="hljs-keyword">if</span>(param <span class="hljs-keyword">instanceof</span> T)&#123;<br>        System.out.println(<span class="hljs-string">&quot;T&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，在 kotlin 中也不行。<br>但在 java 中我们通常会传入一个<code>Class&lt;T&gt;</code>来做相应的操作，在 kotlin 中同样也可以，不过 kotlin 中有一个更简单的方法:使用<code>reified</code>配合<code>inline</code>来实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">printIfTypeMatch</span><span class="hljs-params">(item: <span class="hljs-type">Any</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (item <span class="hljs-keyword">is</span> T) &#123; <span class="hljs-comment">// 👈 这里就不会在提示错误了</span><br>        println(item)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们经常用的 gson解析数据、反序列化的时候经常遇到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">fromJson</span><span class="hljs-params">(String json, Class&lt;T&gt; classOfT)</span> <span class="hljs-keyword">throws</span> JsonSyntaxException &#123; <br>    <br>&#125; <br></code></pre></td></tr></table></figure><p>这里就是通过多传入一个<code>Class&lt;T&gt;</code>来解决这个问题，在 kotlin 中我们可以通过扩展来变化一下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> Gson.<span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">String</span>)</span></span>: T&#123; <br>     <span class="hljs-keyword">return</span> fromJson(json, T::<span class="hljs-keyword">class</span>.java) <br> &#125; <br></code></pre></td></tr></table></figure><p>我们给 Gson 添加了一个扩展方法，在这个方法中，通过<code>inline</code>和<code>reified</code>关键字将泛型<code>T</code>变成了一个真实可用的类型，这两个关键字缺一不可。这里就简单的认为内联方法(inline)是将方法在编译时复制到调用处，使得泛型 T 的类型在编译时就可以确定。当然这么理解不是特别正确。后面学到<code>inline</code>、<code>noinline</code>、<code>crossinline</code>这几个关键字的时候再说吧</p><p>参考：</p><p><a href="https://book.kotlincn.net/text/generics.html">泛型：in、out、where</a><br><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a><br><a href="https://ethanhua.github.io/2018/01/09/genericity/">深入理解Java和Kotlin中的泛型</a><br><a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>泛型</p><ul><li><input type='checkbox' disabled='true' checked>逆变</input></li><li><input type='checkbox' disabled='true' checked>协变</input></li><li><input type='checkbox' disabled='true' checked>类型投影</input></li><li><input type='checkbox' disabled='true' checked>星投影</input></li><li><input type='checkbox' disabled='true' checked>泛型约束</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>object</li><li>Unit</li><li>Nothing</li><li>inline,noinline,crossinline</li></ul></li><li><p>委托</p><ul><li>委托类</li><li>委托属性</li><li>自定义委托</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;泛型中涉及到的概念也不少,型变(Variance)、逆变(Contravariance)、协变(Covariance)、不变(Invariant).在 kotlin 中还有三个关键字&lt;code&gt;in&lt;/code&gt;、&lt;code&gt;out&lt;/code&gt;、&lt;code&gt;where&lt;/</summary>
      
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>kotlin作用域函数:run、let、also、apply、with</title>
    <link href="https://blog.huangyuanlove.com/2024/04/28/kotlin%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0-run%E3%80%81let%E3%80%81also%E3%80%81apply%E3%80%81with/"/>
    <id>https://blog.huangyuanlove.com/2024/04/28/kotlin%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0-run%E3%80%81let%E3%80%81also%E3%80%81apply%E3%80%81with/</id>
    <published>2024-04-28T08:23:11.000Z</published>
    <updated>2024-04-30T02:54:43.487Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始学习 kotlin 的时候，对于这些作用域函数一头雾水，搞不明白为什么要弄出来这么多东西。现在来看看他们具体的区别以及适用的场景。<br>Kotlin 标准库包含几个函数，它们的唯一目的是在对象的上下文中执行代码块。 当对一个对象调用这样的函数并提供一个<code>lambda表达式</code>时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。这些函数称为作用域函数。 共有以下五种：<code>let</code>、<code>run</code>、<code>with</code>、<code>apply</code>以及<code>also</code>。<br>废话不多说，先把从 kotlin 官方上扒拉下来的结论放这里</p><span id="more"></span><p><a href="https://book.kotlincn.net/text/scope-functions.html">作用域函数中文版</a><br><a href="https://kotlinlang.org/docs/scope-functions.html">作用域函数英文版</a></p><h3 id="总结在前面"><a href="#总结在前面" class="headerlink" title="总结在前面"></a>总结在前面</h3><p>文章太长太啰嗦，直接看这里的结论：</p><table><thead><tr><th>函数</th><th>对象引用</th><th>返回值</th><th>是否是扩展函数</th></tr></thead><tbody><tr><td>let</td><td>it</td><td>Lambda表达式结果</td><td>是</td></tr><tr><td>run</td><td>this</td><td>Lambda表达式结果</td><td>是</td></tr><tr><td>run</td><td>-</td><td>Lambda表达式结果</td><td>不是：调用无需上下文对象</td></tr><tr><td>with</td><td>this</td><td>Lambda表达式结果</td><td>不是：把上下文对象当做参数</td></tr><tr><td>apply</td><td>this</td><td>上下文对象</td><td>是</td></tr><tr><td>also</td><td>it</td><td>上下文对象</td><td>是</td></tr></tbody></table><p>以下是根据预期目的选择作用域函数的简短指南：</p><ul><li>对一个非空（non-null）对象执行 lambda 表达式：let</li><li>将表达式作为变量引入为局部作用域中：let</li><li>对象配置：apply</li><li>对象配置并且计算结果：run</li><li>在需要表达式的地方运行语句：非扩展的 run</li><li>附加效果：also</li><li>一个对象的一组函数调用：with<br>不同作用域函数的使用场景存在重叠，可以根据项目或团队中使用的特定约定来选择使用哪些函数。</li></ul><p><font color='red'>虽然作用域函数可以让代码更加简洁，但是要避免过度使用它们：这会使代码难以阅读并可能导致错误。 我们还建议避免嵌套作用域函数，同时链式调用它们时要小心：因为很容易混淆当前上下文对象与<code>this</code>或<code>it</code>的值。</font></p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假如我们有这么一个数据类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> price: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changePrice</span><span class="hljs-params">(price: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.price = price<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> book = Book(<span class="hljs-string">&quot;book name&quot;</span>, <span class="hljs-number">68</span>)<br></code></pre></td></tr></table></figure><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">run</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">run</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> <span class="hljs-title">with</span><span class="hljs-params">(receiver: <span class="hljs-type">T</span>, block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure><p>我们把看起来相近的作用域函数的声明放在一块对比着看，看到这里就清楚了的就不要往下看了，看了也是浪费时间。</p><h4 id="also"><a href="#also" class="headerlink" title="also"></a>also</h4><p>函数声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T<br></code></pre></td></tr></table></figure><p><code>also</code>函数是对泛型 T 的扩展函数，接收一个参数类型为T、无返回值(返回值为Unit类型)的函数，且<code>also</code>函数的返回值就是调用者。</p><ul><li>上下文对象作为 lambda 表达式的参数（it）来访问。</li><li>返回值是上下文对象本身。</li></ul><p>对于执行一些将上下文对象作为参数的操作很有用。 对于需要引用对象而不是其属性与函数的操作，或者不想屏蔽来自外部作用域的 this 引用时，请使用 also。<br>当你在代码中看到 also 时，可以将其理解为<strong>并且用该对象执行以下操作</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> alsoResult = book.also &#123;<br>    it.changePrice(<span class="hljs-number">20</span>)<br>    it.name = <span class="hljs-string">&quot;alsoResult&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;alsoResult <span class="hljs-variable">$alsoResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里打印结果是<code>alsoResult Book(name=alsoResult, price=20)</code>,看源码的话，可以简单的里面为调用了一下传入的函数，然后返回了调用者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    block(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>函数声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T<br></code></pre></td></tr></table></figure><p>可以看得出来<code>apply</code>是泛型 T 的扩展函数，接收一个带有 T 类型接收者的无参、无返回值的函数，并且<code>apply</code>函数返回值就是 T 类型，也就是调用者的类型。因为这里参数中的 T 是作为接收者类型，而不是参数，所以在传入的函数中需要用<code>this</code>而非<code>it</code>来指代调用者。<br>用法和<code>also</code>相差无几，只不过一个是接收者类型，一个是参数。</p><ul><li>上下文对象 作为接收者（this）来访问。</li><li>返回值 是上下文对象本身。</li></ul><p>对于不返回值且主要在接收者（this）对象的成员上运行的代码块使用它。apply最常见的使用场景是用于对象配置。这样的调用可以理解为<strong>将以下赋值操作应用于对象</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> applyResult = book.apply &#123;<br>    changePrice(<span class="hljs-number">200</span>)<br>    name = <span class="hljs-string">&quot;applyResult&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;applyResult <span class="hljs-variable">$applyResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里打印的结果是<code>applyResult Book(name=applyResult, price=200)</code>.<br>源码也和<code>also</code>几乎一样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    block(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>函数类型声明如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure><p>可以看到，let 是对泛型 T 的扩展函数，该扩展函数接收一个函数参数，并且函数参数的接收一个 T 类型的参数，且返回值是 R 类型，也是<code>let</code>这个扩展函数的返回值类型。</p><ul><li>上下文对象作为 lambda 表达式的参数（it）来访问。</li><li>返回值是 lambda 表达式的结果。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>    it.changePrice(<span class="hljs-number">100</span>)<br>    it.name = <span class="hljs-string">&quot;letResult&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;letResult <span class="hljs-variable">$letResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里传入的是一个 Lambda 表达式，前面说过，对于单参数值的Lambda 表达式，参数会被隐式声明为<code>it</code>,当然我们也可以指定一个具名意义的变量，比如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letResult = book.let &#123; bookEntry: Book -&gt;<br>    bookEntry.changePrice(<span class="hljs-number">100</span>)<br>    bookEntry.name = <span class="hljs-string">&quot;letResult&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里打印的结果是<code>letResult kotlin.Unit</code>。因为对于 Lambda 表达式来讲，如果最后一条语句是非赋值语句，则返回该语句的值；如果是赋值语句，则返回 Unit。<br>我们可以这么写来返回我们需要的值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>    it<span class="hljs-comment">//返回值就是传入的 book 对象</span><br>&#125;<br><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>    <span class="hljs-number">1</span><span class="hljs-comment">//返回值就是1</span><br>&#125;<br><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>     <span class="hljs-keyword">return</span><span class="hljs-symbol">@let</span> <span class="hljs-number">1</span><span class="hljs-comment">//之前的文章中说过的显示指定返回值，是 1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从另外一个角度看，<code>let</code>和 <code>also</code>、<code>apply</code>也差不多，只不过多了一个返回值类型，返回值就是传入的 Lambda 表达式的返回值<br>源码也差不了多少</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block(<span class="hljs-keyword">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>let 可用于在调用链的结果上调用一个或多个函数。</li><li>let 经常用于执行包含非空值代码块。如需对非空对象执行操作， 可对其使用安全调用操作符<code>?.</code>并调用 let 在 lambda 表达式中执行操作。</li></ul><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p><code>run</code>这个函数给了两种方式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">run</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">run</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure><p>先看第一种，看起来就是把<code>let</code>中函数参数中的 T 类型参数改成了接收者类型，也是返回 R 类型；这和<code>apply</code>与<code>also</code>的区别是一样的。</p><ul><li>上下文对象 作为接收者（this）来访问。</li><li>返回值 是 lambda 表达式结果。</li></ul><p>当 lambda 表达式同时初始化对象并计算返回值时，run 很有用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> runResult = book.run &#123;<br>    name = <span class="hljs-string">&quot;runResult&quot;</span><br>    changePrice(<span class="hljs-number">110</span>)<br>    <span class="hljs-keyword">this</span> <span class="hljs-comment">//作为返回值</span><br>&#125;<br>println(<span class="hljs-string">&quot;runResult <span class="hljs-variable">$runResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>源码是这样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">run</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block()<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> otherRunResult =  run &#123;<br>    Book(<span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-number">120</span>) <span class="hljs-comment">//作为返回值</span><br>&#125;<br>println(<span class="hljs-string">&quot;otherRunResult <span class="hljs-variable">$otherRunResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>源码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">run</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block()<br>&#125;<br></code></pre></td></tr></table></figure><p>这也没啥好说的，只不过是这里并没有输入参数，只是可以使你在需要表达式的地方就可以执行一个语句。</p><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>函数声明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> <span class="hljs-title">with</span><span class="hljs-params">(receiver: <span class="hljs-type">T</span>, block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure><p><code>with</code>并不是扩展函数，需要传入一个T 类型的receiver，可以在 block 中访问这个receiver的方法和属性，</p><ul><li>上下文对象作为接收者（this）使用。</li><li>返回值是 lambda 表达式结果。</li></ul><p>建议当不需要使用 lambda 表达式结果时，使用 with 来调用上下文对象上的函数。 在代码中，with 可以理解为<strong>对于这个对象，执行以下操作.</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> withResult = with(book) &#123;<br>    changePrice(<span class="hljs-number">300</span>)<br>    name = <span class="hljs-string">&quot;withResult&quot;</span><br>    <span class="hljs-keyword">this</span> <span class="hljs-comment">//作为返回值</span><br>&#125;<br>println(<span class="hljs-string">&quot;withResult <span class="hljs-variable">$withResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里的打印结果是<code>withResult Book(name=withResult, price=300)</code></p><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>这里再搬运一个总结的表格</p><table>    <tr>         <th >函数名</th>         <th >作用</th>         <th >应用场景</th>         <th >备注</th>     </tr>    <tr>      <td>let</td>      <td rowspan="2">定义一个变量在特定作用域内<br/>统一做判空处理</td>      <td rowspan="2">明确一个变量所处特定的作用域范围内可使用<br/>针对一个可空对象统一做判空处理</td>      <td rowspan="2">区别在于返回值<br/>let函数：返回值=最后一行|return的表达式<br/>also函数：返回值=传入对象本身</td>    </tr>    <tr>      <td>also</td>    </tr>    <tr>      <td>with</td>      <td>调用同一个对象的多个方法|属性时，可以省去对象名，直接调用方法、访问属性</td>      <td>需要多次调用同一个对象的属性|方法</td>      <td>返回值=最后一行|return表达式</td>    </tr>    <tr>      <td>run</td>      <td rowspan="2">结合了let 函数和 with 函数的作用</td>      <td>1.调用同一个对象的多个方法/属性时可以省去对象名重复，直接调用方法名 /属性即可<br/>2.定义一个变量在特定作用域内<br/>3.统一做判空处</</td>      <td>优点:避免了let函数必须使用it参数替代对象弥补了with函数无法判空的缺点</td>    </tr>    <tr>      <td>apply</td>      <td>对象实例初始化时需要对对象中的属性进行赋值且返回该对象</td>      <td>二者区别在于返回值:<br/>run函数返回最后一行的值|表达式<br/>apply函数返回传入的对象的本身</td>    <tr></table><h3 id="另外一个角度的选择"><a href="#另外一个角度的选择" class="headerlink" title="另外一个角度的选择"></a>另外一个角度的选择</h3><h4 id="it-or-this"><a href="#it-or-this" class="headerlink" title="it or this"></a>it or this</h4><p>每个作用域函数都使用以下两种方式之一来引用上下文对象</p><ol><li>作为 lambda 表达式的接收者 （this）</li><li>作为 lambda 表达式的参数（it）</li></ol><p>两者都提供了同样的功能，<code>run</code>、<code>with</code>以及<code>apply</code>通过关键字<code>this</code>将上下文对象引用为<code>lambda</code>表达式的接收者。 因此，在它们的<code>lambda表达式</code>中可以像在普通的类函数中一样访问上下文对象。在大多数场景，当你访问接收者对象时你可以省略<code>this</code>， 来让你的代码更简短。 相对地，如果省略了<code>this</code>，就很难区分接收者对象的成员及外部对象或函数。因此，对于主要对对象的成员进行操作（调用其函数或赋值其属性）的lambda表达式， 建议将上下文对象作为接收者（this）。<br>反过来，<code>let</code>及<code>also</code>将上下文对象引用为<code>lambda表达式参数</code>。如果没有指定参数名，对象可以用隐式默认名称<code>it</code>访问。<code>it</code>比<code>this</code>简短，带有<code>it</code>的表达式通常更易读。不过，当调用对象函数或属性时，不能像<code>this</code>这样隐式地访问对象。 因此，当上下文对象在作用域中主要用作函数调用中的参数时，通过<code>it</code>访问上下文对象会更好。 在代码块中使用多个变量时，<code>it</code>也更好一些。</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>根据返回结果，作用域函数可以分为以下两类：</p><p>apply 及 also 返回上下文对象。<br>let、run 及 with 返回 lambda 表达式结果.<br>apply 及 also 的返回值是上下文对象本身。因此，它们可以作为辅助步骤包含在调用链中：可以继续在同一个对象上一个接一个地进行链式函数调用。</p><h3 id="写在最后的注意事项"><a href="#写在最后的注意事项" class="headerlink" title="写在最后的注意事项"></a>写在最后的注意事项</h3><p>在最开始的红色部分也提高过尽量不要嵌套使用作用域函数，警惕引发的上下文混淆。看下面的代码猜一下打印结果是什么。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> length = <span class="hljs-number">0</span><br>    <span class="hljs-string">&quot;hello&quot;</span>.apply &#123;<br>        println(<span class="hljs-string">&quot;this is apply <span class="hljs-variable">$length</span>&quot;</span>)<br>        println(<span class="hljs-string">&quot;this is apply <span class="hljs-subst">$&#123;this.length&#125;</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-string">&quot;hello&quot;</span>.let &#123;<br>        println(<span class="hljs-string">&quot;this is let <span class="hljs-variable">$it</span>&quot;</span>)<br>        <span class="hljs-string">&quot;world&quot;</span>.also &#123;<br>            println(<span class="hljs-string">&quot;this is run <span class="hljs-variable">$it</span>&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerFunc</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-string">&quot;hi&quot;</span>.apply &#123;<br>            println(<span class="hljs-string">&quot;this is innerFunc apply <span class="hljs-variable">$length</span>&quot;</span>)<br>            println(<span class="hljs-string">&quot;this is innerFunc apply <span class="hljs-subst">$&#123;this.length&#125;</span>&quot;</span>)<br><br>        &#125;<br>    &#125;<br>    innerFunc()<br>&#125;<br></code></pre></td></tr></table></figure><p>结果是如下：</p><blockquote><p>this is apply 0<br>this is apply 5<br>this is let hello<br>this is run world<br>this is innerFunc apply 0<br>this is innerFunc apply 2</p></blockquote><p>这里我们在写代码的时候，IDE 给了提示:<strong>Implicit parameter ‘it’ of enclosing lambda is shadowed</strong><br><img src="/image/kotlin/scope_func_implicit_param.png" alt="Implicit parameter &#39;it&#39; of enclosing lambda is shadowed "><br>我们可以通过修改隐式 it 的名字来避免这个问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-string">&quot;hello&quot;</span>.let &#123;<br>    println(<span class="hljs-string">&quot;this is let <span class="hljs-variable">$it</span>&quot;</span>)<br>    <span class="hljs-string">&quot;world&quot;</span>.also &#123; world-&gt;<br>        println(<span class="hljs-string">&quot;this is run <span class="hljs-variable">$world</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但最好还是避免这种嵌套调用的情况</p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li><li><p>关键字</p><ul><li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>object</li><li>Unit</li><li>Nothing</li><li>inline,noinline,crossinline</li></ul></li><li><p>泛型</p><ul><li>逆变</li><li>协变</li></ul></li><li><p>委托</p><ul><li>委托类</li><li>委托属性</li><li>自定义委托</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;刚开始学习 kotlin 的时候，对于这些作用域函数一头雾水，搞不明白为什么要弄出来这么多东西。现在来看看他们具体的区别以及适用的场景。&lt;br&gt;Kotlin 标准库包含几个函数，它们的唯一目的是在对象的上下文中执行代码块。 当对一个对象调用这样的函数并提供一个&lt;code&gt;lambda表达式&lt;/code&gt;时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。这些函数称为作用域函数。 共有以下五种：&lt;code&gt;let&lt;/code&gt;、&lt;code&gt;run&lt;/code&gt;、&lt;code&gt;with&lt;/code&gt;、&lt;code&gt;apply&lt;/code&gt;以及&lt;code&gt;also&lt;/code&gt;。&lt;br&gt;废话不多说，先把从 kotlin 官方上扒拉下来的结论放这里&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的函数类型及 Lambda 表达式</title>
    <link href="https://blog.huangyuanlove.com/2024/04/23/Kotlin%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8F%8A-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blog.huangyuanlove.com/2024/04/23/Kotlin%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8F%8A-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2024-04-23T03:41:47.000Z</published>
    <updated>2024-04-28T03:46:21.614Z</updated>
    
    <content type="html"><![CDATA[<p>继续上次在扩展函数中遗留下的问题：函数类型。总所周知，在Kotlin 中函数是一等公民。那么什么是高阶函数嘞？到处翻了翻，发现差不多是这么个意思：<strong>接受一个或多个函数作为参数，或者返回一个函数。</strong>在 Kotlin 协程中的 launch、async函数以及各种各样的框架中到处都是高阶函数的影子，称高阶函数是 Kotlin函数式编程、各大框架的基石也不过分。</p><span id="more"></span><p>不得不说，这里面概念挺多的，有的时候我们会用，但并不知道叫什么名字。有的知道名字但不知道是什么东西。</p><ul><li>高阶函数</li><li>扩展函数</li><li>Lambda</li><li>SAM转换</li><li>带接收者的函数类型</li><li>带有接收者的函数字面值</li></ul><p>问题不大，慢慢整，慢慢理解，多读几遍文档，参考一下别人的看法，也就熟悉了。</p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>这里想表达的并不是说kotlin 中的函数分类，比如什么内联函数、扩展函数、标准函数、高阶函数等等这种分类，而是说在函数作为返回值或者参数的时候，我们怎么确认这个函数就是我们想要的类型，或者说如何使用编程语言来描述一个函数。比如我们在调用函数的时候传入的参数，我们会讲这个函数需要一个 Int 类型的参数，那如果我们调用的函数需要另外一个函数作为参数我们应该怎么表示嘞？这里就引出了函数类型。<br>举个例子</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionA</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Unit</span>&#123;<br>    println(<span class="hljs-string">&quot;functionA&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionA1</span><span class="hljs-params">(name:<span class="hljs-type">String</span>)</span></span>:<span class="hljs-built_in">Unit</span>&#123;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionA11</span><span class="hljs-params">(name:<span class="hljs-type">String</span>)</span></span>:String&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi <span class="hljs-variable">$name</span>&quot;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们应该如何描述上面的三个方法嘞？</p><blockquote><p>functionA,不需要参数，返回值为 Unit<br>functionA1, 需要一个String 类型的参数，返回值为 Unit<br>functionA11,需要一个String 类型的参数，返回值为 String</p></blockquote><p>那么在 kotlin 编程语言中又是如何描述的？<br><img src="/image/kotlin/kotlin_function0%3CUnit%3E.png"><br><img src="/image/kotlin/kotlin_function1%3CString,Unit%3E.png"><br><img src="/image/kotlin/kotlin_function1%3CString,String%3E.png"></p><p>上面的图是将鼠标悬停在变量上就会出现，当然也可以选中变量或者表达式，按 ctrl+shift+p来显示类型</p><p>可以看到在<code>kotlin</code>中是用<code>KFunction0&lt;Unit&gt;</code>、<code>KFunction1&lt;String, Unit&gt;</code>、<code>KFunction1&lt;String, String&gt;</code>这种形式来描述一个函数。这里的 KFunction 后面的数字表示这个函数的参数个数，尖括号中的类型表示参数的类型，最后一个类型表示函数的返回值类型。比如<code>KFunction1&lt;String, Unit&gt;</code>表示这个函数需要<code>1</code>个<code>String</code>类型的参数，返回值类型为<code>Unit</code>。而<code>KFunction1&lt;String, String&gt;</code>表示这个函数需要<code>1</code>个<code>String</code>类型的参数，返回值为<code>String</code>。<br>如果函数是挂起函数(被suspend修饰)，则对应的类型为<code> KSuspendFunction0&lt;Unit&gt;</code>,以此类推。<br>那么如果是高阶函数嘞？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionC</span><span class="hljs-params">(method:()-&gt;<span class="hljs-type">String</span>)</span></span>:String&#123;<br>    <span class="hljs-keyword">return</span> method()<br>&#125;<br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span>  <span class="hljs-title">suspendFunctionC</span><span class="hljs-params">(method: () -&gt; <span class="hljs-type">String</span>)</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> method()<br>&#125;<br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span>  <span class="hljs-title">suspendFunctionC1</span><span class="hljs-params">(method:<span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">String</span>)</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> method()<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的方法，我们可以看到</p><blockquote><p><code>functionC</code>对应的描述是<code>KFunction1&lt;() -&gt; String, String&gt;</code><br><code>suspendFunctionC</code>对应的描述是<code> KSuspendFunction1&lt;() -&gt; String, String&gt;</code><br><code>suspendFunctionC1</code>对应的描述是<code> KSuspendFunction1&lt;suspend () -&gt; String, String&gt;</code>。</p></blockquote><p>对于扩展函数也一样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">A1</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-keyword">this</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">A11</span><span class="hljs-params">()</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;    <br><span class="hljs-keyword">val</span> stringA1 = String::A1 <span class="hljs-comment">// KFunction1&lt;String, Unit&gt;</span><br><span class="hljs-keyword">val</span> stringA11 = String::A11 <span class="hljs-comment">// KFunction1&lt;String, String&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>，我们还可以使用<code>typealias</code>给函数类型取一个别名<br><code>typealias ClickHandler = (Button, ClickEvent) -&gt; Unit</code></p><h3 id="带接收者的函数类型"><a href="#带接收者的函数类型" class="headerlink" title="带接收者的函数类型"></a>带接收者的函数类型</h3><p>一种特殊的函数类型，它允许您在函数类型中指定一个接收者对象，使得在函数体内可以直接访问该接收者对象的成员函数和属性。这种函数类型的语法是在函数类型声明之前添加接收者类型。<br>带接收者的函数类型的语法如下：</p><blockquote><p>接收者类型.() -&gt; 返回类型</p></blockquote><p>通过使用带接收者的函数类型，我们可以创建具有接收者的函数变量、函数参数或函数返回类型，以便在调用函数时可以直接操作接收者对象。这样可以实现一种类似扩展函数的效果。举个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String)<br><br><span class="hljs-comment">// 带接收者的函数类型</span><br><span class="hljs-keyword">val</span> greeting: Person.() -&gt; String = &#123;<br>    <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>!&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 扩展函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Person.<span class="hljs-title">greet</span><span class="hljs-params">()</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>!&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person: Person = Person(<span class="hljs-string">&quot;huang&quot;</span>)<br><br>    <span class="hljs-comment">// 使用带接收者的函数类型调用函数</span><br>    <span class="hljs-keyword">val</span> message1 = person.greeting()<br><br>    <span class="hljs-comment">// 使用扩展函数调用函数</span><br>    <span class="hljs-keyword">val</span> message2 = person.greet()<br><br>    println(message1) <span class="hljs-comment">// 输出: Hello, huang!</span><br>    println(message2) <span class="hljs-comment">// 输出: Hello, huang!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结起来，带接收者的函数类型更适合在函数类型的声明和传递中使用，以提供特定上下文的函数操作。而扩展函数则更适合在已有类上添加新的函数，使得在调用该类时可以使用这些额外的函数。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>先小小的总结一下：</p><ul><li>所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型：(A, B) -&gt; C 表示接受类型分别为 A 与 B 两个参数并返回一个 C 类型值的函数类型。 参数类型列表可以为空，如 () -&gt; A。Unit 返回类型不可省略。</li><li>函数类型可以有一个额外的接收者类型，它在表示法中的点之前指定： 类型 A.(B) -&gt; C 表示可以在 A 的接收者对象上以一个 B 类型参数来调用并返回一个 C 类型值的函数。 <code>带有接收者的函数字面值</code>通常与这些类型一起使用。</li><li>挂起函数属于函数类型的特殊种类，它的表示法中有一个 suspend 修饰符 ，例如 suspend () -&gt; Unit 或者 suspend A.(B) -&gt; C。</li><li>如需将函数类型指定为可空，请使用圆括号，如下所示： ((Int, Int) -&gt; Int)?。</li></ul><p>这样我们在看其他框架的时候就知道框架中的高阶函数怎么调用了：</p><blockquote><p>当参数类型为<code>() -&gt; String</code>时，我们需要传入一个没有参数且返回值为String类型的函数，对应的类型是<code>KFunction0&lt;String&gt;</code></p></blockquote><h3 id="函数实例化"><a href="#函数实例化" class="headerlink" title="函数实例化"></a>函数实例化</h3><p>既然函数也是对象，那么理所当然的可以被实例化。我们可以使用以下几种方式获取函数类型的实例</p><ul><li>使用函数字面值的代码块<ul><li>lambda 表达式: { a, b -&gt; a + b },</li><li>匿名函数: fun(s: String): Int { return s.toIntOrNull() ?: 0 }</li></ul></li><li>使用已有声明的可调用引用<ul><li>顶层、局部、成员、扩展函数：::isOdd、 String::toInt，</li><li>顶层、成员、扩展属性：List<Int>::size，</li><li>构造函数：::Regex</li></ul></li><li>使用实现函数类型接口的自定义类的实例：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntTransformer</span>: <span class="hljs-type"></span></span>(<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = TODO()<br>&#125;<br><span class="hljs-keyword">val</span> intFunction: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = IntTransformer()<br></code></pre></td></tr></table></figure></li></ul><h3 id="有无Receiver的函数相互转化"><a href="#有无Receiver的函数相互转化" class="headerlink" title="有无Receiver的函数相互转化"></a>有无Receiver的函数相互转化</h3><p>带与不带接收者的函数类型非字面值可以互换，其中接收者可以替代第一个参数，反之亦然。例如，(A, B) -&gt; C 类型的值可以传给或赋值给期待 A.(B) -&gt; C 类型值的地方，反之亦然。这也是为什么<code>String.A1()</code>明明没有声明需要参数，为啥和上面的<code>functionA1</code>方法是相同的类型嘞？可以这么认为:Kotlin中的扩展函数将接收者本身当做第一个参数传入，要不然为啥在<code>String.A1()</code>里面可以使用<code>this</code>来代替调用者本身嘞？<br>那既然这样的话，也就是说这两者是可以互换的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">d</span><span class="hljs-params">(block :(<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>   block(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br>d(String::A1)<br>d(::functionA1)<br></code></pre></td></tr></table></figure><p>需要注意的是，这里仅针对在引用和调用时可以互相转换，比如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sayHi: (String) -&gt; <span class="hljs-built_in">Unit</span> = &#123; name:String-&gt;  println(<span class="hljs-string">&quot;hi <span class="hljs-variable">$name</span>&quot;</span>) &#125;<br>sayHi.invoke(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br>sayHi(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br><br><span class="hljs-keyword">val</span> sayHello: String.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; println(<span class="hljs-string">&quot;hello <span class="hljs-variable">$this</span>&quot;</span>) &#125;<br>sayHello.invoke(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br>sayHello(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br><span class="hljs-string">&quot;huangyuan&quot;</span>.sayHello()<br><br><span class="hljs-keyword">val</span> sayHiRef:(String)-&gt;<span class="hljs-built_in">Unit</span> =sayHi<br><span class="hljs-keyword">val</span> sayHiRef1: String.() -&gt; <span class="hljs-built_in">Unit</span> = sayHi<br></code></pre></td></tr></table></figure><p>但是如果将 sayHello 和sayHi这两个函数等号右边互换一下则会报错。</p><p>需要注意的是这里还有一个概念：<code>带接收者的函数字面值</code>（Function Literals with Receiver），也称为带接收者的 Lambda 表达式，是一种特殊的 Lambda 表达式。它允许在 Lambda 表达式中访问特定类型的对象的成员，就像在该对象的成员函数中一样。通过使用带接收者的函数字面值，可以在 Lambda 表达式中以更简洁的方式操作特定类型的对象。上面对<code>sayHello</code>的定义就属于这种形式。<br>也就是说：带有接收者的函数类型，例如 A.(B) -&gt; C，可以用特殊形式的函数字面值实例化—-带有接收者的函数字面值。<br>这里解释一下：所谓的字面量，就是不用变量名称直接用相对应的值写出来。比如“hello world”就是一个字符串字面量、12.23是一个 Double 的字面量、4是一个 Int 的字面量。</p><h3 id="函数类型实例调用"><a href="#函数类型实例调用" class="headerlink" title="函数类型实例调用"></a>函数类型实例调用</h3><p>既然能获取到函数类型的实例，那么肯定就可以调用了。<br>这里调用方式有两种，一种是通过<code>invoke()</code>，比如<code>func.invoke()</code>,或者直接在引用后面加上括号<code>func()</code>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> functionOne: <span class="hljs-built_in">Int</span>.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; println(<span class="hljs-string">&quot;aaFunRefRec <span class="hljs-variable">$this</span>  &quot;</span>) &#125;<br>functionOne.invoke(<span class="hljs-number">10001</span>)<br>functionOne(<span class="hljs-number">10001</span>)<br><br><span class="hljs-keyword">val</span> functionTwo: <span class="hljs-built_in">Int</span>.(String) -&gt; <span class="hljs-built_in">Unit</span> = &#123; println(<span class="hljs-string">&quot;other <span class="hljs-variable">$this</span>  &quot;</span>) &#125;<br>functionTwo.invoke(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;other&quot;</span>)<br>functionTwo(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;other&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>我们在使用Java语言开发Android 应用的时候可能已经体验过 Lambda 表达式了，最常见的就是给 View 设置点击监听的时候<br><img src="/image/kotlin/replace_with_lambda_tip.png" alt="replace_with_lambda_tip"><br>当我们点击了之后，代码就成了这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">llShowMoreDialog.setOnClickListener(v -&gt; showToast(<span class="hljs-string">&quot;点击了&quot;</span>));<br></code></pre></td></tr></table></figure><p>目前在 java 中只能简化成这样的，kotlin 中还可以进一步简化，后面再说。这里先看看Lambda表达式语法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<br></code></pre></td></tr></table></figure><ul><li>lambda 表达式总是括在花括号中。</li><li>完整语法形式的参数声明放在花括号内，并有可选的类型标注。</li><li>函数体跟在一个 -&gt; 之后。</li><li>如果推断出的该 lambda 的返回类型不是 Unit，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。</li></ul><p>如果Lambda 表达式的参数可以推断出来，我们可以省略一些类型，比如上面的 sum 函数可以省略为</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum1 = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<br><span class="hljs-keyword">val</span> sum2: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x, y -&gt; x + y &#125;<br></code></pre></td></tr></table></figure><p>我们在写 Android 时经常会用到给某个控件设置点击事件，就像上面的例子一样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener(<span class="hljs-keyword">object</span> :View.OnClickListener&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;view?.id&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;)<br>view.setOnClickListener &#123; println(<span class="hljs-string">&quot;click <span class="hljs-variable">$it</span> &quot;</span>) &#125;<br></code></pre></td></tr></table></figure><h4 id="SAM转换"><a href="#SAM转换" class="headerlink" title="SAM转换"></a>SAM转换</h4><p>那么它是怎么从上面使用匿名内部类变成下面样子的？这里就要提一下<code>SAM转换</code>了：SAM是Single Abstract Method的缩写，意思就是只有一个抽象方法的类或者接口。但在Kotlin和Java 8里，SAM代表着只有一个抽象方法的接口。只要是符合SAM要求的接口，编译器就能进行SAM转换，也就是我们可以使用Lambda表达式，来简写接口类的参数。<br>需要注意的是，Java 8中的SAM有明确的名称，叫做<code>函数式接口(FunctionalInterface)</code>。FunctionalInterface的限制如下，缺一不可：</p><ul><li>必须是接口，抽象类不行；</li><li>该接口有且仅有一个抽象的方法，抽象方法个数必须是1，默认实现的方法可以有多个。</li></ul><p>同样的，在kotlin中也有限制：</p><ul><li>必须是函数接口，也就是声明为<code>fun interface</code></li><li>只能包含一个抽象方法，并且不能包含默认方法</li></ul><p>因此,kotlin 编译器会将该方法自动转化为<code>fun setOnClickListener(l: ((View!) -&gt; Unit)?)</code>，我们才得以使用 Lambda表达式来简化代码。可以将代码写成这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener(&#123;view:View?-&gt; println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;view?.id&#125;</span>&quot;</span>)&#125;)<br></code></pre></td></tr></table></figure><p>这种情况下，由于 kotlin 支持类型推导，所以我们可以将<code>View?</code>也省略掉，接着还会触发一个被称之为<code>单个参数的隐式名称</code>的东西，原话是这么说的</p><blockquote><p>If the compiler can parse the signature without any parameters, the parameter does not need to be declared and -&gt; can be omitted. 该参数会隐式声明为 it<br>因此，我们得到了这样子的代码</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener(&#123;println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;it?.id&#125;</span>&quot;</span>)&#125;)<br></code></pre></td></tr></table></figure><p>按照 Kotlin 惯例，如果函数的最后一个参数是函数，那么作为相应参数传入的 lambda 表达式可以放在圆括号之外：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener()&#123;println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;it?.id&#125;</span>&quot;</span>)&#125;<br></code></pre></td></tr></table></figure><p>这种语法也称为<code>拖尾lambda(trailing lambda)</code>表达式。<br>如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以完全省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener&#123;println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;it?.id&#125;</span>&quot;</span>)&#125;<br></code></pre></td></tr></table></figure><p>这就是我们最终得到的代码样子</p><h4 id="从lambda表达式中返回一个值"><a href="#从lambda表达式中返回一个值" class="headerlink" title="从lambda表达式中返回一个值"></a>从lambda表达式中返回一个值</h4><p>这里有两种方式，一种是隐式返回：如果我们什么都不做，将返回最后一个表达式的值。<br>另外一种就是使用限定的返回语法从lambda显式返回一个值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ints.filter &#123;<br>    <span class="hljs-keyword">val</span> shouldFilter = it &gt; <span class="hljs-number">0</span><br>    shouldFilter<br>&#125;<br><br>ints.filter &#123;<br>    <span class="hljs-keyword">val</span> shouldFilter = it &gt; <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span><span class="hljs-symbol">@filter</span> shouldFilter<br>&#125;<br></code></pre></td></tr></table></figure><p>这两种方式是等价的。<br>那么这个标签 <strong>@filter</strong>是怎么来的呢？<br>在 Kotlin 中任何表达式都可以用标签来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@。 要为一个表达式加标签，我们只要在其前加标签即可.<br>比如我们在嵌套函数中，标签限定的 return 允许我们从外层函数返回，比如从 Lambda 表达式中返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// 非局部直接返回到 foo() 的调用者</span><br>        print(it)<br>    &#125;<br>    println(<span class="hljs-string">&quot;this point is unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach <span class="hljs-symbol">lit@</span>&#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@lit</span> <span class="hljs-comment">// 局部返回到该 lambda 表达式的调用者——forEach 循环</span><br>        print(it)<br>    &#125;<br>    print(<span class="hljs-string">&quot; done with explicit label&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通常情况下使用<strong>隐式标签</strong>更方便，因为该标签与接受该 lambda 的函数同名。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@forEach</span> <span class="hljs-comment">// 局部返回到该 lambda 表达式的调用者——forEach 循环</span><br>        print(it)<br>    &#125;<br>    print(<span class="hljs-string">&quot; done with implicit label&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>官方这里也给了一个提示：<strong>注意，这种非局部的返回只支持传给内联函数的 lambda 表达式</strong>，这个问题后面再说把，就是<code>inline</code>、<code>noinline</code>、<code>crossinline</code>这三个关键字带来的优化以及滥用的坏处。<br>另外这里还有一个小 tip：如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">map.forEach &#123; (_, value) -&gt; println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span>!&quot;</span>) &#125;<br></code></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>上文中的 Lambda 表达式缺少指定返回类型的能力，虽然大部分情况下返回值类型可以推导出来，但如果确实需要指定，我们可以使用<strong>匿名函数</strong>，<br>它看起来非常像一个常规函数声明，除了其名称省略了。其函数体既可以是表达式也可以是代码块：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = x + y<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure><p>如果参数类型可以推断出来，则参数类型可以省略</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ints.filter(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(item)</span></span> = item &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><hr><p>对于上面的内容<br>函数式（SAM）接口 英文版: <a href="https://kotlinlang.org/docs/fun-interfaces.html">Functional (SAM) interfaces</a><br>函数式（SAM）接口 中文版: <a href="https://book.kotlincn.net/text/fun-interfaces.html">函数式（SAM）接口</a><br>高阶函数和Lambda 英文版: <a href="https://kotlinlang.org/docs/lambdas.html">Higher-order functions and lambdas</a><br>高阶函数和Lambda 中文版: <a href="https://book.kotlincn.net/text/lambdas.html">高阶函数与 lambda 表达式</a><br>返回与跳转 中文版: <a href="https://book.kotlincn.net/text/returns.html">返回与跳转</a><br>返回与跳转 英文版: <a href="https://kotlinlang.org/docs/returns.html">Returns and jumps</a></p><hr><p>已学习：</p><ul><li><p>扩展</p><ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li><li><p>函数类型</p><ul><li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li><li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li><li><input type='checkbox' disabled='true' checked>SAM 转换</input></li></ul></li></ul><p>未学习：</p><ul><li><p>关键字</p><ul><li>object</li><li>Unit</li><li>Nothing</li><li>with、let、run、apply、also</li><li>inline,noinline,crossinline</li></ul></li><li><p>泛型</p><ul><li>逆变</li><li>协变</li></ul></li><li><p>委托</p><ul><li>委托类</li><li>委托属性</li><li>自定义委托</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;继续上次在扩展函数中遗留下的问题：函数类型。总所周知，在Kotlin 中函数是一等公民。那么什么是高阶函数嘞？到处翻了翻，发现差不多是这么个意思：&lt;strong&gt;接受一个或多个函数作为参数，或者返回一个函数。&lt;/strong&gt;在 Kotlin 协程中的 launch、async函数以及各种各样的框架中到处都是高阶函数的影子，称高阶函数是 Kotlin函数式编程、各大框架的基石也不过分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin中的函数类型及扩展函数</title>
    <link href="https://blog.huangyuanlove.com/2024/04/22/Kotlin%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%8F%8A%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/"/>
    <id>https://blog.huangyuanlove.com/2024/04/22/Kotlin%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%8F%8A%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/</id>
    <published>2024-04-22T09:28:13.000Z</published>
    <updated>2024-04-28T03:12:44.861Z</updated>
    
    <content type="html"><![CDATA[<p>继续kotlin 的学习，之前只是学了点皮毛中的皮毛，会了一些简单语法而已。最后面列了一个大纲，认真的学习一下。<br>今天的内容是<strong>扩展</strong>。gradle：8.5，插件：id ‘org.jetbrains.kotlin.jvm’ version ‘1.9.23’</p><span id="more"></span><h3 id="简介和使用"><a href="#简介和使用" class="headerlink" title="简介和使用"></a>简介和使用</h3><p>kotlin 中扩展可以给已有的类添加额外的方法和属性，看起来就像是修改了类的源码一样，而不是像 java 一样需要继承该类然后添加自己的方法。扩展又分为扩展函数和扩展属性。<br>那么如何使用嘞？其实和声明普通函数几乎一致，只是多了一个叫做”接收者”的东西，也就是文档中的Receiver，说白了，其实就是限制这个接收者类型才能使用这个方法，也就是我们要对这个类型 <strong>“添加”</strong> 一个方法。<br>比如我们想要给字符串类型添加一个获取最后一个元素的方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">lastChar</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Char</span>?&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(length - <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的方法声明表示：对<code>String</code>类型定义一个无参的<code>lastChar</code>方法，返回值是<code>Char?</code>，使用的时候就像使用 String 类中的方法一样使用就好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;kotlin&quot;</span><br>    println(s.lastChar())<br>&#125;<br></code></pre></td></tr></table></figure><p>那么扩展属性怎么使用嘞？和扩展函数差不多：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> String.firstChar:<span class="hljs-built_in">Char</span>?<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.isEmpty()) <span class="hljs-literal">null</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>可以简单的认为上面的声明是这样:对<code>String</code>类型顶一个<code>firstChar</code>属性，类型是<code>Char?</code>,使用时和使用 String 类中的属性一样就好了:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;kotlin&quot;</span><br>    println(s.lastChar())<br>    println(s.firstChar)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思考：Java中如何使用？"><a href="#思考：Java中如何使用？" class="headerlink" title="思考：Java中如何使用？"></a>思考：Java中如何使用？</h3><p>接下来思考一下在 java 中如何调用嘞？得先看看 kotlin 是如何实现扩展的。最简单的方法，看反编译后的字节码文件：<br>顶部菜单中 tools–&gt;kotlin–&gt;Show Kotlin Bytecode，然后点Decompile就可以看到了<br><img src="/image/kotlin/show_kotlin_bytecode.png" alt="decompile kotlin bytecode"><br>代码大致如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainKt</span> &#123;<br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Character <span class="hljs-title function_">lastChar</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String $<span class="hljs-built_in">this</span>$lastChar)</span> &#123;<br>      Intrinsics.checkNotNullParameter($<span class="hljs-built_in">this</span>$lastChar, <span class="hljs-string">&quot;&lt;this&gt;&quot;</span>);<br>      <span class="hljs-keyword">return</span> ((CharSequence)$<span class="hljs-built_in">this</span>$lastChar).length() == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : $<span class="hljs-built_in">this</span>$lastChar.charAt($<span class="hljs-built_in">this</span>$lastChar.length() - <span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Character <span class="hljs-title function_">getFirstChar</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String $<span class="hljs-built_in">this</span>$firstChar)</span> &#123;<br>      Intrinsics.checkNotNullParameter($<span class="hljs-built_in">this</span>$firstChar, <span class="hljs-string">&quot;&lt;this&gt;&quot;</span>);<br>      <span class="hljs-keyword">return</span> ((CharSequence)$<span class="hljs-built_in">this</span>$firstChar).length() == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : $<span class="hljs-built_in">this</span>$firstChar.charAt(<span class="hljs-number">0</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;kotlin&quot;</span>;<br>      <span class="hljs-type">Character</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> lastChar(s);<br>      System.out.println(var1);<br>      var1 = getFirstChar(s);<br>      System.out.println(var1);<br>   &#125;<br><br>   <span class="hljs-comment">// $FF: synthetic method</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      main();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到反编译之后的代码只是添加了两个静态方法而已，这样的话，在 Java 中我们就可以这么使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        System.out.println( MainKt.lastChar(s));<br>        System.out.println( MainKt.getFirstChar(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="思考：作用域，继承与重载"><a href="#思考：作用域，继承与重载" class="headerlink" title="思考：作用域，继承与重载"></a>思考：作用域，继承与重载</h3><p>接下来思考另外一个问题：作用域，或者说我们可以在哪里声明、在哪里调用扩展函数？<br>上面的例子中都是声明为了顶级函数(top level),我们可以在任意地方使用对应的类型进行调用，如果声明在类里面会怎么样？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">isEmail</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.contains(<span class="hljs-string">&quot;@&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">val</span> email = <span class="hljs-string">&quot;a@a.com&quot;</span><br>        println(email.isEmail())<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> email = <span class="hljs-string">&quot;a@a.com&quot;</span><br>    println(email.isEmail())<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在类里面定义的扩展函数，只能在类里面调用，在类外是无法使用的。但是，我们可以在继承Example的类中使用，比如这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubExample</span> :<span class="hljs-type">Example</span></span>()&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subTest</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">val</span> email = <span class="hljs-string">&quot;a@a&quot;</span><br>        println(email.isEmail())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么问题来了，如果对<code>Example</code>定义一个扩展函数，那么在子类SubExample中能调用么？答案是可以的，但是不能覆写，因为kotlin中的函数默认是<code>final</code>不能被覆写的，同时定义扩展函数时又不能被<code>open</code>修饰，从语法上讲，这是扩展函数不能被覆写的原因。看反编译之后的代码，定义为顶级函数的扩展函数是 static 的，因此也不能被覆写。<br>那么在 Java 中能不能用嘞？遇事不决先看反编译后的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmail</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String $<span class="hljs-built_in">this</span>$isEmail)</span> &#123;<br>      Intrinsics.checkNotNullParameter($<span class="hljs-built_in">this</span>$isEmail, <span class="hljs-string">&quot;&lt;this&gt;&quot;</span>);<br>      <span class="hljs-keyword">return</span> StringsKt.contains$<span class="hljs-keyword">default</span>((CharSequence)$<span class="hljs-built_in">this</span>$isEmail, (CharSequence)<span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>, (Object)<span class="hljs-literal">null</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a@a.com&quot;</span>;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.isEmail(email);<br>      System.out.println(var2);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话就可以通过<code>Example</code>实例来调用了。同样注意到在<code>Example</code>类中定义的扩展函数<code>isEmail</code>被 final 修饰了，因此也无法通过继承来覆写该方法。</p><h3 id="思考：扩展函数如何引用？"><a href="#思考：扩展函数如何引用？" class="headerlink" title="思考：扩展函数如何引用？"></a>思考：扩展函数如何引用？</h3><p>嘿嘿嘿,我们知道函数是可以通过双冒号引用的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHi</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hi <span class="hljs-variable">$name</span>&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">referenceMethod</span><span class="hljs-params">(method: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    method(<span class="hljs-string">&quot;xuan&quot;</span>)<br>    method.invoke(<span class="hljs-string">&quot;yuan&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    referenceMethod(::sayHi)<br>    referenceMethod &#123; name -&gt; println(<span class="hljs-string">&quot;hello <span class="hljs-variable">$name</span>&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么扩展函数应该如何引用嘞？这里先学怎么用，后面再学函数类型吧<br>如果我们将扩展函数定义为顶级函数，那么在应用的时候和引用这个类本身的成员函数没啥区别,比如在一开始我们对 String 定义的扩展函数 lastChar,我们可以这么引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> lastCharFun1 = String::lastChar<br></code></pre></td></tr></table></figure><p>但是，如果我们将扩展函数定义在类里面又该如何应对？应对不了，没法引用。<br>为什么？思考一个问题，扩展函数属于哪个类？实际上可以认为扩展函数谁都不属于，只是加了一个限定，限定哪个类型的对象可以调用这个函数。<br>另外一个问题，语法上引用类的成员函数是类名双冒号函数名，那引用扩展函数也是这样，但是把扩展函数定义在其他类中，我们应该用哪个类名？干脆不能引用就好了。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解了扩展函数、扩展属性 及其作用域。了解了在 Java 层面如何实现的以及 Java 中如何使用。翻看 kotlin 源码，有很多都是基于扩展来实现的，比如 String、比如一些数字类型 Float、Double 等。</p><p>到此，扩展就差不多了，应该还会有一些小细节上的问题，但问题应该不大。接下来应该会学习一下遗留下来的问题：函数类型以及lambda 表达式</p><hr><p>已学习：</p><ul><li>扩展<ul><li><input type='checkbox' disabled='true' checked>扩展函数</input></li><li><input type='checkbox' disabled='true' checked>扩展属性</input></li><li><input type='checkbox' disabled='true' checked>作用域</input></li></ul></li></ul><p>未学习：</p><ul><li><p>Lambda表达式</p><ul><li>SAM 转换</li><li>函数类型</li></ul></li><li><p>函数类型</p><ul><li>带有接收者的函数类型</li></ul></li><li><p>关键字</p><ul><li>object</li><li>Unit</li><li>Nothing</li><li>with、let、run、apply、also</li></ul></li><li><p>泛型</p><ul><li>逆变</li><li>协变</li></ul></li><li><p>委托</p><ul><li>委托类</li><li>委托属性</li><li>自定义委托</li></ul></li><li><p>协程</p><ul><li>启动</li><li>挂起</li><li>Job</li><li>Context</li><li>Channel</li><li>Flow</li><li>select</li><li>并发、异常</li><li>launch</li><li>Dispatchers</li><li>CoroutineScope</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;继续kotlin 的学习，之前只是学了点皮毛中的皮毛，会了一些简单语法而已。最后面列了一个大纲，认真的学习一下。&lt;br&gt;今天的内容是&lt;strong&gt;扩展&lt;/strong&gt;。gradle：8.5，插件：id ‘org.jetbrains.kotlin.jvm’ version ‘1.9.23’&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="https://blog.huangyuanlove.com/tags/Android/"/>
    
    <category term="Kotlin" scheme="https://blog.huangyuanlove.com/tags/Kotlin/"/>
    
  </entry>
  
</feed>
