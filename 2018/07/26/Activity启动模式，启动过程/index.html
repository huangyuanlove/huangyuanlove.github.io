

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://avatars.githubusercontent.com/u/4216225?v=4">
  <link rel="icon" href="https://avatars.githubusercontent.com/u/4216225?v=4">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="HuangYuan_xuan">
  <meta name="keywords" content="启动模式,启动过程,Intent匹配规则,App启动流程">
  
    <meta name="description" content="面试总结，关于Activity启动模式、启动过程，Intent匹配规则、App启动流程等">
<meta property="og:type" content="article">
<meta property="og:title" content="Activity启动模式，启动过程">
<meta property="og:url" content="https://blog.huangyuanlove.com/2018/07/26/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/index.html">
<meta property="og:site_name" content="放码过来">
<meta property="og:description" content="面试总结，关于Activity启动模式、启动过程，Intent匹配规则、App启动流程等">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-07-26T06:20:07.000Z">
<meta property="article:modified_time" content="2023-05-19T12:51:02.208Z">
<meta property="article:author" content="HuangYuan_xuan">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Activity启动模式，启动过程 - 放码过来</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.huangyuanlove.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":"7a06626d17ff9ce19e18d0f08e94d8ba","google":"UA-123314537-1","tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"gtag":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="放码过来" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>放码过来</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Activity启动模式，启动过程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2018-07-26 14:20" pubdate>
          2018年7月26日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          25k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Activity启动模式，启动过程</h1>
            
            
              <div class="markdown-body">
                
                <p>面试总结，关于Activity启动模式、启动过程，Intent匹配规则、App启动流程等</p>
<span id="more"></span>
<h5 id="启动模式："><a href="#启动模式：" class="headerlink" title="启动模式："></a>启动模式：</h5><ul>
<li>standard：标准模式，这也是系统的默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。</li>
<li>singleTop：栈顶复用模式。在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数我们可以取出当前请求的信息。需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变。如果新Activity的实例已存在但不是位于栈顶，那么新Activity仍然会重新重建。</li>
<li>singleTask：栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent。</li>
<li>singleInstance：单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中，</li>
</ul>
<p>还有一个参数 <code>TaskAffinity</code>,这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。当然，我们可以为每个Activity都单独指定TaskAffinity属性，这个属性值必须不能和包名相同，否则就相当于没有指定。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。<br>还有Activity中能够影响启动模式、运行状态的标记位：</p>
<p>** FLAG_ACTIVITY_NEW_TASK **<br>这个标记位的作用是为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。<br>** FLAG_ACTIVITY_SINGLE_TOP **<br>这个标记位的作用是为Activity指定“singleTop”启动模式，其效果和在XML中指定该启动模式相同。<br>** FLAG_ACTIVITY_CLEAR_TOP **<br>具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用，在这种情况下，被启动Activity的实例如果已经存在，那么系统会调用它的onNewIntent。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。通过1.2.1节中的分析可以知道，singleTask启动模式默认就具有此标记位的效果。<br>** FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS **<br>具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性android:excludeFromRecents&#x3D;”true”。</p>
<h5 id="Intent匹配规则"><a href="#Intent匹配规则" class="headerlink" title="Intent匹配规则"></a>Intent匹配规则</h5><p>启动Activity分为两种，显式调用和隐式调用。显式调用需要明确地指定被启动对象的组件信息，包括包名和类名，而隐式调用则不需要明确指定组件信息。原则上一个Intent不应该既是显式调用又是隐式调用，如果二者<br>共存的话以显式调用为主。显式调用很简单，这里主要介绍一下隐式调用。隐式调用需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息，如果不匹配将无法启动目标Activity。<br>为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。一个过滤列表中的action、category和data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别、data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。另外一点，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应的Activity。</p>
<ul>
<li>action的匹配规则<br>action是一个字符串，系统预定义了一些action，同时我们也可以在应用中定义自己的action。action的匹配规则是Intent中的action必须能够和过滤规则中的action匹配，这里说的匹配是指action的字符串值完全一样。一个过滤规则中可以有多个action，那么只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功。需要注意的是，Intent中如果没有指定action，那么匹配失败。另外，action区分大小写，大小写不同字符串相同的action会匹配失败。</li>
<li>category的匹配规则<br>category是一个字符串，系统预定义了一些category，同时我们也可以在应用中定义自己的category。category的匹配规则和action不同，它要求Intent中如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同。换句话说，Intent中如果出现了category，不管有几个category，对于每个category来说，它必须是过滤规则中已经定义了的category。当然，Intent中可以没有category，如果没有category的话，按照上面的描述，这个Intent仍然可以匹配成功。这里要注意下它和action匹配过程的不同，action是要求Intent中必须有一个action且必须能够和过滤规则中的某个action相同，而category要求<br>Intent可以没有category，但是如果你一旦有category，不管有几个，每个都要能够和过滤规则中的任何一个category相同。</li>
<li>data的匹配规则<br>data的匹配规则和action类似，如果过滤规则中定义了data，那么Intent中必须也要定义可匹配的data。在介绍data的匹配规则之前，我们需要先了解一下data的结构，因为data稍微有些复杂<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>   <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:host</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:port</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:path</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:pathPattern</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:pathPrefix</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:mimeType</span>=<span class="hljs-string">&quot;string&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
data由两部分组成，mimeType和URI。mimeType指媒体类型，比如image&#x2F;jpeg、audio&#x2F;mpeg4-generic和video&#x2F;*等，可以表示图片、文本、视频等不同的媒体格式，而URI中包含的数据就比较多了，下面是URI的结构：<br><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code><br>有如下过滤规则</li>
</ul>
<p><code>&lt;data android:mimeType=&quot;image/*&quot; /&gt;</code><br>这种规则指定了媒体类型为所有类型的图片，那么Intent中的mimeType属性必须为“image&#x2F;*”才能匹配，这种情况下虽然过滤规则没有指定URI，但是却有默认值，URI的默认值为content和file。也就是说，虽然没有指定URI，但是Intent中的URI部分的schema必须为content或者file才能匹配，这点是需要尤其注意的。为了匹配上面中规则，我们可以写出如下示例<br><code>intent.setDataAndType(Uri.parse(&quot;file://abc&quot;),&quot;image/png&quot;)。</code><br>另外，如果要为Intent指定完整的data，必须要调用setDataAndType方法，不能先调用setData再调用setType，因为这两个方法彼此会清除对方的值。<br>最后，当我们通过隐式方式启动一个Activity的时候，可以做一下判断，看是否有Activity能够匹配我们的隐式Intent，如果不做判断就有可能出现上述的错误了。判断方法有两种：采用PackageManager的resolveActivity方法或者Intent的resolveActivity方法，如果它们找不到匹配的Activity就会返回null，我们通过判断返回值就可以规避上述错误了。另外，PackageManager还提供了queryIntentActivities方法，这个方法和resolveActivity方法不同的是：它不是返回最佳匹配的Activity信息而是返回所有成功匹配的Activity信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> List&lt;ResolveInfo&gt; <span class="hljs-title function_">queryIntentActivities</span><span class="hljs-params">(Intent intent,<span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ResolveInfo <span class="hljs-title function_">resolveActivity</span><span class="hljs-params">(Intent intent,<span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure>
<p>上述两个方法的第一个参数比较好理解，第二个参数需要注意，我们要使用MATCH_DEFAULT_ONLY这个标记位，这个标记位的含义是仅仅匹配那些在intent-filter中声明了<br><code>&lt;category  android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</code>这个category的Activity。使用这个标记位的意义在于，只要上述两个方法不返回null，那么startActivity一定可以成功。如果不用这个标记位，就可以把intent-filter中category不含DEFAULT的那些Activity给匹配出来，从而导致startActivity可能失败。因为不含有DEFAULT这个category的Activity是无法接收隐式Intent的。</p>
<h5 id="App启动过程"><a href="#App启动过程" class="headerlink" title="App启动过程"></a>App启动过程</h5><ol>
<li>点击桌面App图标，Launch进程采用Binder IPC向system_server进程发起startActivity请求</li>
<li>system_server收到请求后，向zygote进程发送创建进程请求。</li>
<li>Zygote进程fork出新的子进程，即App进程。</li>
<li>App进程通过Binder IPC向system_server进程发起attachApplication请求</li>
<li>system_server进程在收到请求后，进行一系列的准备工作，再通过Binder IPC向App进程发送scheduleLaunchActivity请求。</li>
<li>App进程的binder线程(ApplicationThread)在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；</li>
<li>主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法；</li>
<li>到此，App便正式启动，开始进入Activity生命周期。</li>
</ol>
<p>** 涉及到的类 **</p>
<ul>
<li><code>Activity</code> startActivity方法的真正实现在Activity中。</li>
<li><code>Instrumentation</code> 每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作,用来辅助Activity完成启动Activity的过程。</li>
<li><code>ActivityThread</code>（包含ApplicationThread + ApplicationThreadNative + IApplicationThread）：真正启动Activity的实现都在这里,应用的入口类，系统通过调用main函数，开启消息循环队列。ActivityThread所在线程被称为应用的主线程（UI线程）。与ActivityManagerServices配合，一起完成Activity的管理工作。</li>
<li><code>ActivityManagerService</code> 简称AMS，服务端对象。AMS是Android中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。</li>
<li><code>ActivityManagerProxy</code> AMS服务在当前进程的代理类，负责与AMS通信。</li>
<li><code>ApplicationThread</code> 用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。</li>
<li><code>ApplicationThreadProxy</code> 是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。</li>
<li><code>ActivityStack</code> Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</li>
<li><code>ActivityRecord</code> ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</li>
<li><code>TaskRecord</code> AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。</li>
</ul>
<p>** 基本概念 **</p>
<h6 id="zygote"><a href="#zygote" class="headerlink" title="zygote"></a>zygote</h6><p>Android是基于Linux系统的，而在Linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote进程也不例外。至于init进程怎么来的，可以搜一下Android系统启动过程。<br>在Android系统里面，zygote是一个进程的名字。Android是基于Linux System的，当你的手机开机的时候，Linux的内核加载完成之后就会启动一个叫“init“的进程。在Linux System里面，所有的进程都是由init进程fork出来的，我们的zygote进程也不例外。<br>我们都知道，每一个App其实都是</p>
<ul>
<li>一个单独的虚拟机</li>
<li>一个单独的进程<br>所以当系统里面的第一个zygote进程运行之后，在这之后再开启App，就相当于开启一个新的进程。而为了实现资源共用和更快的启动速度，Android系统开启新进程的方式，是通过fork第一个zygote进程实现的。所以说，除了第一个zygote进程，其他应用所在的进程都是zygote的子进程，</li>
</ul>
<h6 id="SystemServer"><a href="#SystemServer" class="headerlink" title="SystemServer"></a>SystemServer</h6><p>它也是个进程，而且是由zygote进程fork出来的。系统里面重要的服务都是在这个进程里面开启的，比如<code>ActivityManagerService</code>、<code>PackageManagerService</code>、<code>WindowManagerService</code> 等等。在zygote开启的时候，会调用ZygoteInit.main()进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Startup class for the zygote process.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Pre-initializes some classes, and then waits for commands on a UNIX domain</span><br><span class="hljs-comment"> * socket. Based on these commands, forks off child processes that inherit</span><br><span class="hljs-comment"> * the initial state of the VM.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Please see &#123;<span class="hljs-doctag">@link</span> ZygoteConnection.Arguments&#125; for documentation on the</span><br><span class="hljs-comment"> * client protocol.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p>从注释上也可以看出这个类主要是为了初始化某些参数。比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preload</span><span class="hljs-params">(TimingsTraceLog bootTimingsTraceLog)</span> &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;begin preload&quot;</span>);<br>        bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;BeginIcuCachePinning&quot;</span>);<br>        beginIcuCachePinning();<br>        bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// BeginIcuCachePinning</span><br>        bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;PreloadClasses&quot;</span>);<br>        preloadClasses();<br>        bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// PreloadClasses</span><br>        bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;PreloadResources&quot;</span>);<br>        preloadResources();<br>        bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// PreloadResources</span><br>        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, <span class="hljs-string">&quot;PreloadAppProcessHALs&quot;</span>);<br>        nativePreloadAppProcessHALs();<br>        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);<br>        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, <span class="hljs-string">&quot;PreloadOpenGL&quot;</span>);<br>        preloadOpenGL();<br>        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);<br>        preloadSharedLibraries();<br>        preloadTextResources();<br>        <span class="hljs-comment">// Ask the WebViewFactory to do any initialization that must run in the zygote process,</span><br>        <span class="hljs-comment">// for memory sharing purposes.</span><br>        WebViewFactory.prepareWebViewInZygote();<br>        endIcuCachePinning();<br>        warmUpJcaProviders();<br>        Log.d(TAG, <span class="hljs-string">&quot;end preload&quot;</span>);<br><br>        sPreloadComplete = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazyPreload</span><span class="hljs-params">()</span> &#123;<br>        Preconditions.checkState(!sPreloadComplete);<br>        Log.i(TAG, <span class="hljs-string">&quot;Lazily preloading resources.&quot;</span>);<br><br>        preload(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimingsTraceLog</span>(<span class="hljs-string">&quot;ZygoteInitTiming_lazy&quot;</span>, Trace.TRACE_TAG_DALVIK));<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>还有一些关键的方法<code>preloadSharedLibraries()</code>、<code>preloadOpenGL()</code>、<code>preloadTextResources()</code>、<code>preloadClasses()</code>、<code>preloadResources()</code>、<code>preloadDrawables()</code>、<code>preloadColorStateLists()</code> 等.还有一个<code>startSystemServer()</code>方法。</p>
<h6 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h6><p>简称AMS,服务端对象，负责系统中所有Activity生命周期。它的初始化时机很明确，就是在SystemServer进程开启的时候，就会初始化ActivityManagerService。具体情况可以看一下<code>SystemServer.java</code>类。<br>经过上面这些步骤，我们的ActivityManagerService对象已经创建好了，并且完成了成员变量初始化。而且在这之前，调用createSystemContext()创建系统上下文的时候，也已经完成了mSystemContext和ActivityThread的创建。注意，这是系统进程开启时的流程，在这之后，会开启系统的Launcher程序，完成系统界面的加载与显示。</p>
<h6 id="为什么说AMS是服务端对象"><a href="#为什么说AMS是服务端对象" class="headerlink" title="为什么说AMS是服务端对象"></a>为什么说AMS是服务端对象</h6><p>其实服务器客户端的概念不仅仅存在于Web开发中，在Android的框架设计中，使用的也是这一种模式。服务器端指的就是所有App共用的系统服务，比如我们这里提到的ActivityManagerService，和前面提到的PackageManagerService、WindowManagerService等等，这些基础的系统服务是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你想打开一个App，那么我们知道了包名和MainActivity类名之后就可以打开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_MAIN);  <br>intent.addCategory(Intent.CATEGORY_LAUNCHER);<br><span class="hljs-type">ComponentName</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentName</span>(packageName, className);<br>intent.setComponent(cn);  <br>startActivity(intent);<br></code></pre></td></tr></table></figure>

<p>但是，我们的App通过调用startActivity()并不能直接打开另外一个App，这个方法会通过一系列的调用，最后还是告诉AMS说：“我要打开这个App，我知道他的住址和名字，你帮我打开吧！”所以是AMS来通知zygote进程来fork一个新进程，来开启我们的目标App的。这就像是浏览器想要打开一个超链接一样，浏览器把网页地址发送给服务器，然后还是服务器把需要的资源文件发送给客户端的。</p>
<p>知道了Android Framework的客户端服务器架构之后，我们还需要了解一件事情，那就是我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？<br>App与AMS通过Binder进行IPC通信，AMS(SystemServer进程)与zygote通过Socket进行IPC通信。<br>那么AMS有什么用呢？在前面我们知道了，如果想打开一个App的话，需要AMS去通知zygote进程，除此之外，其实所有的Activity的开启、暂停、关闭都需要AMS来控制，所以我们说，AMS负责系统中所有Activity的生命周期。<br>在Android系统中，任何一个Activity的启动都是由AMS和应用程序进程（主要是ActivityThread）相互配合来完成的。AMS服务统一调度系统中所有进程的Activity启动，而每个Activity的启动过程则由其所属的进程具体来完成。</p>
<h6 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h6><p>当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。Launcher本质上也是一个应用程序，和我们的App一样，也是继承自Activity，系统源码可以在这里看 <a target="_blank" rel="noopener" href="http://androidxref.com/8.0.0_r4/xref/packages/apps/Launcher3/src/com/android/launcher3/Launcher.java">http://androidxref.com/8.0.0_r4/xref/packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">View <span class="hljs-title function_">createShortcut</span><span class="hljs-params">(<span class="hljs-type">int</span> layoutResId, ViewGroup parent, ShortcutInfo info)</span> &#123;<br>        <span class="hljs-type">BubbleTextView</span> <span class="hljs-variable">favorite</span> <span class="hljs-operator">=</span> (BubbleTextView) mInflater.inflate(layoutResId, parent, <span class="hljs-literal">false</span>);<br>        favorite.applyFromShortcutInfo(info, mIconCache);<br>        favorite.setOnClickListener(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> favorite;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建图标并设置点击监听</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Launches the intent referred by the clicked shortcut.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> v The view representing the clicked shortcut.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-comment">// Make sure that rogue clicks don&#x27;t get through while allapps is launching, or after the</span><br>        <span class="hljs-comment">// view has detached (it&#x27;s possible for this to happen if the view is removed mid touch).</span><br>        <span class="hljs-keyword">if</span> (v.getWindowToken() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!mWorkspace.isFinishedSwitchingState()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">tag</span> <span class="hljs-operator">=</span> v.getTag();<br>        <span class="hljs-keyword">if</span> (tag <span class="hljs-keyword">instanceof</span> ShortcutInfo) &#123;<br>            <span class="hljs-comment">// Open shortcut</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> ((ShortcutInfo) tag).intent;<br>            <span class="hljs-type">int</span>[] pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>            v.getLocationOnScreen(pos);<br>            intent.setSourceBounds(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rect</span>(pos[<span class="hljs-number">0</span>], pos[<span class="hljs-number">1</span>],<br>                    pos[<span class="hljs-number">0</span>] + v.getWidth(), pos[<span class="hljs-number">1</span>] + v.getHeight()));<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> startActivitySafely(v, intent, tag);<br><br>            <span class="hljs-keyword">if</span> (success &amp;&amp; v <span class="hljs-keyword">instanceof</span> BubbleTextView) &#123;<br>                mWaitingForResume = (BubbleTextView) v;<br>                mWaitingForResume.setStayPressed(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag <span class="hljs-keyword">instanceof</span> FolderInfo) &#123;<br>            <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> FolderIcon) &#123;<br>                <span class="hljs-type">FolderIcon</span> <span class="hljs-variable">fi</span> <span class="hljs-operator">=</span> (FolderIcon) v;<br>                handleFolderClick(fi);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v == mAllAppsButton) &#123;<br>            <span class="hljs-keyword">if</span> (isAllAppsVisible()) &#123;<br>                showWorkspace(<span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                onClickAllAppsButton(v);<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p>从上面可以看到，在桌面上点击快捷图标的时候，会调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">startActivitySafely(v, intent, tag);<br></code></pre></td></tr></table></figure>
<p>具体代码就不抄了，看一下上面的链接中的源码就好，在该方法中调用了<code>startActivity(v, intent, tag)</code>，这里会调用Activity.startActivity(intent, opts.toBundle())，这个方法熟悉吗？这就是我们经常用到的Activity.startActivity(Intent)的重载函数。而且由于设置了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br></code></pre></td></tr></table></figure>
<p>所以这个Activity会添加到一个新的Task栈中，而且，startActivity()调用的其实是startActivityForResult()这个方法。<br>所以现在明确了，Launcher中开启一个App，其实和我们在Activity中直接startActivity()基本一样，都是调用了Activity.startActivityForResult()。</p>
<h6 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h6><p>每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。当startActivityForResult()调用之后，实际上还是调用了mInstrumentation.execStartActivity().<br>下面是mInstrumetation.execStartActivity()的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title function_">execStartActivity</span><span class="hljs-params">(</span><br><span class="hljs-params">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="hljs-params">            Intent intent, <span class="hljs-type">int</span> requestCode, Bundle options)</span> &#123;<br>        <span class="hljs-type">IApplicationThread</span> <span class="hljs-variable">whoThread</span> <span class="hljs-operator">=</span> (IApplicationThread) contextThread;<br>        <span class="hljs-type">Uri</span> <span class="hljs-variable">referrer</span> <span class="hljs-operator">=</span> target != <span class="hljs-literal">null</span> ? target.onProvideReferrer() : <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (referrer != <span class="hljs-literal">null</span>) &#123;<br>            intent.putExtra(Intent.EXTRA_REFERRER, referrer);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mActivityMonitors != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (mSync) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> mActivityMonitors.size();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">ActivityMonitor</span> <span class="hljs-variable">am</span> <span class="hljs-operator">=</span> mActivityMonitors.get(i);<br>                    <span class="hljs-keyword">if</span> (am.match(who, <span class="hljs-literal">null</span>, intent)) &#123;<br>                        am.mHits++;<br>                        <span class="hljs-keyword">if</span> (am.isBlocking()) &#123;<br>                            <span class="hljs-keyword">return</span> requestCode &gt;= <span class="hljs-number">0</span> ? am.getResult() : <span class="hljs-literal">null</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            intent.migrateExtraStreamToClipData();<br>            intent.prepareToLeaveProcess();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ActivityManagerNative.getDefault()<br>                .startActivity(whoThread, who.getBasePackageName(), intent,<br>                        intent.resolveTypeIfNeeded(who.getContentResolver()),<br>                        token, target != <span class="hljs-literal">null</span> ? target.mEmbeddedID : <span class="hljs-literal">null</span>,<br>                        requestCode, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, options);<br>            checkStartActivityResult(result, intent);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Failure from system&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p>这里的 ActivityManagerNative.getDefault 返回ActivityManagerService的远程接口，即 ActivityManagerProxy 接口，有人可能会问了为什么会是ActivityManagerProxy，这就涉及到Binder通信了，这里不再展开。通过Binder驱动程序， ActivityManagerProxy 与AMS服务通信，则实现了跨进程到System进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Retrieve the system&#x27;s default/global activity manager.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IActivityManager <span class="hljs-title function_">getDefault</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> gDefault.get();<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>&lt;IActivityManager&gt;() &#123;<br>       <span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-type">IBinder</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ServiceManager.getService(<span class="hljs-string">&quot;activity&quot;</span>);<br>           <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>               Log.v(<span class="hljs-string">&quot;ActivityManager&quot;</span>, <span class="hljs-string">&quot;default service binder = &quot;</span> + b);<br>           &#125;<br>           <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">am</span> <span class="hljs-operator">=</span> asInterface(b);<br>           <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>               Log.v(<span class="hljs-string">&quot;ActivityManager&quot;</span>, <span class="hljs-string">&quot;default service = &quot;</span> + am);<br>           &#125;<br>           <span class="hljs-keyword">return</span> am;<br>       &#125;<br>   &#125;;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Cast a Binder object into an activity manager interface, generating</span><br><span class="hljs-comment">    * a proxy if needed.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IActivityManager <span class="hljs-title function_">asInterface</span><span class="hljs-params">(IBinder obj)</span> &#123;<br>       <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span><br>           (IActivityManager)obj.queryLocalInterface(descriptor);<br>       <span class="hljs-keyword">if</span> (in != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> in;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityManagerProxy</span>(obj);<br>   &#125;<br></code></pre></td></tr></table></figure>
<h6 id="AMS响应Launcher进程请求"><a href="#AMS响应Launcher进程请求" class="headerlink" title="AMS响应Launcher进程请求"></a>AMS响应Launcher进程请求</h6><p>至此，点击桌面图标调用startActivity()，终于把数据和要开启Activity的请求发送到了AMS了,AMS收到startActivity的请求之后，会按照如下的方法链进行调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">startActivity</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span><br><span class="hljs-params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-type">int</span> requestCode,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> &#123;<br>        <span class="hljs-keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,<br>            resultWho, requestCode, startFlags, profilerInfo, options,<br>            UserHandle.getCallingUserId());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">startActivityAsUser</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span><br><span class="hljs-params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-type">int</span> requestCode,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class="hljs-type">int</span> userId)</span> &#123;<br>        enforceNotIsolatedCaller(<span class="hljs-string">&quot;startActivity&quot;</span>);<br>        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,<br>                <span class="hljs-literal">false</span>, ALLOW_FULL_ONLY, <span class="hljs-string">&quot;startActivity&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Switch to user app stacks here.</span><br>        <span class="hljs-keyword">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class="hljs-number">1</span>, callingPackage, intent,<br>                resolvedType, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, resultTo, resultWho, requestCode, startFlags,<br>                profilerInfo, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, options, <span class="hljs-literal">false</span>, userId, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里又出现了一个<code>mStackSupervisor</code>，定义是这么说的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Run all ActivityStacks through this */</span><br>    ActivityStackSupervisor mStackSupervisor;<br><br></code></pre></td></tr></table></figure>
<p>在<code>mStackSupervisor.startActivityMayWait()</code>方法中又调用了<code>startActivityLocked()</code>方法，接着调用了<code>startActivityUncheckedLocked()</code>方法，在这个方法中一大堆眼花缭乱的判断，最终调用了<code>targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options)</code>方法，然后调用了<code>mStackSupervisor.resumeTopActivitiesLocked(this, r, options)</code>方法，然后调用<code>result = targetStack.resumeTopActivityLocked(target, targetOptions)</code>方法，调用<code>result = resumeTopActivityInnerLocked(prev, options)</code>方法，在这个方法里，prev.app为记录启动Lancher进程的ProcessRecord，prev.app.thread为Lancher进程的远程调用接口IApplicationThead，所以可以调用prev.app.thread.schedulePauseActivity，到Lancher进程暂停指定Activity。至此，AMS对Launcher的请求已经响应，这是我们发现又通过Binder通信回调至Launcher进程</p>
<h6 id="Launcher进程挂起Launcher，再次通知AMS"><a href="#Launcher进程挂起Launcher，再次通知AMS" class="headerlink" title="Launcher进程挂起Launcher，再次通知AMS"></a>Launcher进程挂起Launcher，再次通知AMS</h6><p>看一下怎么挂起Launcher的,在ActivityThread中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePauseActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-type">boolean</span> finished,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> userLeaving, <span class="hljs-type">int</span> configChanges, <span class="hljs-type">boolean</span> dontReport)</span> &#123;<br>        <span class="hljs-type">ActivityClientRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> mActivities.get(token);<br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br>            <span class="hljs-keyword">if</span> (userLeaving) &#123;<br>                performUserLeavingActivity(r);<br>            &#125;<br><br>            r.activity.mConfigChangeFlags |= configChanges;<br>            performPauseActivity(token, finished, r.isPreHoneycomb());<br><br>            <span class="hljs-comment">// Make sure any pending writes are now committed.</span><br>            <span class="hljs-keyword">if</span> (r.isPreHoneycomb()) &#123;<br>                QueuedWork.waitToFinish();<br>            &#125;<br><br>            <span class="hljs-comment">// Tell the activity manager we have paused.</span><br>            <span class="hljs-keyword">if</span> (!dontReport) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    ActivityManagerNative.getDefault().activityPaused(token);<br>                &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>                &#125;<br>            &#125;<br>            mSomeActivitiesChanged = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这部分Launcher的ActivityThread处理页面Paused并且再次通过ActivityManagerProxy通知AMS。</p>
<h6 id="AMS创建新的进程"><a href="#AMS创建新的进程" class="headerlink" title="AMS创建新的进程"></a>AMS创建新的进程</h6><p>创建新进程的时候，AMS会保存一个ProcessRecord信息，如果应用程序中的AndroidManifest.xml配置文件中，我们没有指定Application标签的process属性，系统就会默认使用package的名称。每一个应用程序都有自己的uid，因此，这里uid + process的组合就可以为每一个应用程序创建一个ProcessRecord。<br>在<code>ActivityManagerService</code>中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startProcessLocked</span><span class="hljs-params">(ProcessRecord app, String hostingType,</span><br><span class="hljs-params">            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();<br>        ......<br>        <span class="hljs-comment">// Start the process.  It will either succeed and return a result containing</span><br>            <span class="hljs-comment">// the PID of the new process, or else throw a RuntimeException.</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isActivityProcess</span> <span class="hljs-operator">=</span> (entryPoint == <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (entryPoint == <span class="hljs-literal">null</span>) entryPoint = <span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>;<br>            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;Start proc: &quot;</span> +<br>                    app.processName);<br>            checkTime(startTime, <span class="hljs-string">&quot;startProcess: asking zygote to start proc&quot;</span>);<br>            Process.<span class="hljs-type">ProcessStartResult</span> <span class="hljs-variable">startResult</span> <span class="hljs-operator">=</span> Process.start(entryPoint,<br>                    app.processName, uid, uid, gids, debugFlags, mountExternal,<br>                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,<br>                    app.info.dataDir, entryPointArgs);<br>            checkTime(startTime, <span class="hljs-string">&quot;startProcess: returned from zygote!&quot;</span>);<br>            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br><br>            <span class="hljs-keyword">if</span> (app.isolated) &#123;<br>                mBatteryStatsService.addIsolatedUid(app.uid, app.info.uid);<br>            &#125;<br>            mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);<br>            checkTime(startTime, <span class="hljs-string">&quot;startProcess: done updating battery stats&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>这里主要是调用Process.start接口来创建一个新的进程，新的进程会导入android.app.ActivityThread类，并且执行它的main函数，这就是每一个应用程序都有一个ActivityThread实例来对应的原因。</p>
<h6 id="应用进程初始化"><a href="#应用进程初始化" class="headerlink" title="应用进程初始化"></a>应用进程初始化</h6><p>来看Activity的main函数，这里绑定了主线程的Looper，并进入消息循环，大家应该知道，整个Android系统是消息驱动的，这也是为什么主线程默认绑定Looper的原因：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;ActivityThreadMain&quot;</span>);<br>        SamplingProfilerIntegration.start();<br><br>        <span class="hljs-comment">// CloseGuard defaults to true and can be quite spammy.  We</span><br>        <span class="hljs-comment">// disable it here, but selectively enable it later (via</span><br>        <span class="hljs-comment">// StrictMode) on debug builds, but using DropBox, not logs.</span><br>        CloseGuard.setEnabled(<span class="hljs-literal">false</span>);<br><br>        Environment.initForCurrentUser();<br><br>        <span class="hljs-comment">// Set the reporter for event logging in libcore</span><br>        EventLogger.setReporter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EventLoggingReporter</span>());<br><br>        AndroidKeyStoreProvider.install();<br><br>        <span class="hljs-comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">configDir</span> <span class="hljs-operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());<br>        TrustedCertificateStore.setDefaultUserDirectory(configDir);<br><br>        Process.setArgV0(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>);<br><br>        Looper.prepareMainLooper();<br><br>        <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>        thread.attach(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>            sMainThreadHandler = thread.getHandler();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>            Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span><br>                    <span class="hljs-title class_">LogPrinter</span>(Log.DEBUG, <span class="hljs-string">&quot;ActivityThread&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-comment">// End of event ActivityThreadMain.</span><br>        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>        Looper.loop();<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>attach函数最终调用了ActivityManagerService的远程接口ActivityManagerProxy的attachApplication函数，传入的参数是mAppThread，这是一个ApplicationThread类型的Binder对象，它的作用是AMS与应用进程进行进程间通信的。<br>将进程和指定的Application绑定起来。这个是通过上节的ActivityThread对象中调用bindApplication()方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中, 最终通过handleBindApplication()方法处理该消息. 然后调用makeApplication()方法来加载App的classes到内存中。</p>
<h6 id="在AMS中注册应用进程，启动栈顶页面"><a href="#在AMS中注册应用进程，启动栈顶页面" class="headerlink" title="在AMS中注册应用进程，启动栈顶页面"></a>在AMS中注册应用进程，启动栈顶页面</h6><p>mMainStack.topRunningActivityLocked(null)从堆栈顶端取出要启动的Activity，并在realStartActivityLockedhan函数中通过ApplicationThreadProxy调回App进程启动页面。<br>在<code>ActivityStackSupervisor</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">realStartActivityLocked</span><span class="hljs-params">(ActivityRecord r,</span><br><span class="hljs-params">            ProcessRecord app, <span class="hljs-type">boolean</span> andResume, <span class="hljs-type">boolean</span> checkConfig)</span><br>            <span class="hljs-keyword">throws</span> RemoteException &#123;<br>                    app.thread.scheduleLaunchActivity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(r.intent), r.appToken,<br>                    System.identityHashCode(r), r.info, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(mService.mConfiguration),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(stack.mOverrideConfig), r.compat, r.launchedFromPackage,<br>                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,<br>                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);<br>            &#125;<br></code></pre></td></tr></table></figure>
<p>它会调用application线程对象中的scheduleLaunchActivity()发送一个LAUNCH_ACTIVITY消息到消息队列中, 通过 handleLaunchActivity()来处理该消息。在 handleLaunchActivity()通过performLaunchActiivty()方法回调Activity的onCreate()方法和onStart()方法，然后通过handleResumeActivity()方法，回调Activity的onResume()方法，而后会通知AMS该MainActivity已经处于resume状态最终显示Activity界面。<br>至此，整个启动流程告一段落。</p>
<p>最后：</p>
<h6 id="一个App的程序入口到底是什么？"><a href="#一个App的程序入口到底是什么？" class="headerlink" title="一个App的程序入口到底是什么？"></a>一个App的程序入口到底是什么？</h6><p>是ActivityThread.main()。</p>
<h6 id="整个App的主线程的消息循环是在哪里创建的？"><a href="#整个App的主线程的消息循环是在哪里创建的？" class="headerlink" title="整个App的主线程的消息循环是在哪里创建的？"></a>整个App的主线程的消息循环是在哪里创建的？</h6><p>是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Handler不需要指定Looper，而如果在其他线程使用Handler，则需要单独使用Looper.prepare()和Looper.loop()创建消息循环。可以看ActivityThread的main方法</p>
<h6 id="Application是在什么时候创建的？onCreate-什么时候调用的？"><a href="#Application是在什么时候创建的？onCreate-什么时候调用的？" class="headerlink" title="Application是在什么时候创建的？onCreate()什么时候调用的？"></a>Application是在什么时候创建的？onCreate()什么时候调用的？</h6><p>也是在ActivityThread.main()的时候，就是在thread.attach(false)的时候。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!system) &#123;<br>            ViewRootImpl.addFirstDrawHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    ensureJitEnabled();<br>                &#125;<br>            &#125;);<br>            android.ddm.DdmHandleAppName.setAppName(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>,<br>                                                    UserHandle.myUserId());<br>            RuntimeInit.setApplicationObject(mAppThread.asBinder());<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">mgr</span> <span class="hljs-operator">=</span> ActivityManagerNative.getDefault();<br>            <span class="hljs-keyword">try</span> &#123;<br>                mgr.attachApplication(mAppThread);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>                <span class="hljs-comment">// Ignore</span><br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里需要关注的就是mgr.attachApplication(mAppThread)，这个就会通过Binder调用到AMS里面对应的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachApplication</span><span class="hljs-params">(IApplicationThread thread)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">origId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>        attachApplicationLocked(thread, callingPid);<br>        Binder.restoreCallingIdentity(origId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后调用的就是<code>private final boolean attachApplicationLocked(IApplicationThread thread,int pid)</code>方法，thread是IApplicationThread，实际上就是ApplicationThread在服务端的代理类ApplicationThreadProxy，然后又通过IPC就会调用到ApplicationThread的对应方法。这个方法里面又调用了<code>sendMessage()</code>，里面有函数的编号H.BIND_APPLICATION，然后这个Messge会被H这个Handler处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BIND_APPLICATION</span>        <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br>    <span class="hljs-keyword">case</span> BIND_APPLICATION:<br>                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;bindApplication&quot;</span>);<br>                    <span class="hljs-type">AppBindData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (AppBindData)msg.obj;<br>                    handleBindApplication(data);<br>                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后在<code>handleBindApplication(data)</code>方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">try</span> &#123;<br>      java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> instrContext.getClassLoader();<br>      mInstrumentation = (Instrumentation)cl.loadClass(data.instrumentationName.getClassName()).newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Unable to instantiate instrumentation &quot;</span>+ data.instrumentationName + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br><br>        ......<br>         <span class="hljs-comment">// Do this after providers, since instrumentation tests generally start their</span><br>            <span class="hljs-comment">// test thread at this point, and we don&#x27;t want that racing.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                mInstrumentation.onCreate(data.instrumentationArgs);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                    <span class="hljs-string">&quot;Exception thrown in onCreate() of &quot;</span><br>                    + data.instrumentationName + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                mInstrumentation.callApplicationOnCreate(app);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                        <span class="hljs-string">&quot;Unable to create application &quot;</span> + app.getClass().getName()<br>                        + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            StrictMode.setThreadPolicy(savedPolicy);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不同的版本代码不尽相同，但是基本逻辑不会变。<br>参考、抄袭的链接如下：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/bfboys/article/details/52564531">https://blog.csdn.net/bfboys/article/details/52564531</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a72c5ccbd150">https://www.jianshu.com/p/a72c5ccbd150</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6037f6fda285">https://www.jianshu.com/p/6037f6fda285</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a72c5ccbd150">https://www.jianshu.com/p/a72c5ccbd150</a></p>
<hr>
<p>以上</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Android/" class="print-no-link">#Android</a>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95/" class="print-no-link">#面试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Activity启动模式，启动过程</div>
      <div>https://blog.huangyuanlove.com/2018/07/26/Activity启动模式，启动过程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>HuangYuan_xuan</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2018年7月26日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              BY HUANG兄
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/07/29/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/" title="View事件分发">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">View事件分发</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/07/23/Android%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%89/" title="Android多进程三">
                        <span class="hidden-mobile">Android多进程三</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.7.2/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"76c9d0ecf028751aa0d2","clientSecret":"392bc0405dfbdf4928343edef0ef46007f02c7e4","repo":"huangyuanlove.github.io","owner":"huangyuanlove","admin":["huangyuanlove"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '534d101dd0e2d0efcaaf379922efdf39'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
