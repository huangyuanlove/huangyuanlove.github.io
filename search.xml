<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android N 应用内更新</title>
    <url>/2017/03/28/Android-N-%E5%BA%94%E7%94%A8%E5%86%85%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>继之前跪在Android M的动态权限之后，最近又跪在了Android N的<code>StrictMode</code>上了。所以啊，要对技术持有敬畏的态度。<br>场景如下：<br>我司内部员工使用的APP需要有应用内更新的功能，意思就是在应用内下载最新版本的应用并且调起安装界面。<br>方案：由于每次从新打开app都需要重新登录，那就在登录界面加上检查更新的接口请求，后台对比当前版本App的VersionCode 和 数据库存储的VersionCode对比，如果需要更新，则返回最新版本软件的下载地址，前端进行下载安装。<br>当前端解析出下载地址后，弹出提示框，下载或者取消。点击下载则开启线程下载，同时在界面上显示下载进度，下载完成后，调起安装界面进行安装。<br>代码很简单，这里放出不涉及我司业务的代码：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downLoadAPK</span><span class="hljs-params">()</span> &#123;<br>        downLoadThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(downLoadUrl);<br><br>                    <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (HttpURLConnection) url<br>                            .openConnection();<br>                    conn.connect();<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> conn.getContentLength();<br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> conn.getInputStream();<br><br>                    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;&quot;</span>);<br>                    <span class="hljs-keyword">if</span> (!file.exists()) &#123;<br>                        file.mkdir();<br>                    &#125;<br>                    <span class="hljs-type">File</span> <span class="hljs-variable">apkFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(saveFilePath);<br>                    <span class="hljs-keyword">if</span> (apkFile.exists()) &#123;<br>                        apkFile.delete();<br>                    &#125;<br>                    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(apkFile);<br><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                    <span class="hljs-type">byte</span> buf[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><br>                    <span class="hljs-comment">// 点击取消就停止下载.</span><br>                    <span class="hljs-keyword">while</span> (!interceptFlag) &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">numread</span> <span class="hljs-operator">=</span> is.read(buf);<br>                        count += numread;<br>                        progress = (<span class="hljs-type">int</span>) (((<span class="hljs-type">float</span>) count / length) * <span class="hljs-number">100</span>);<br>                        <span class="hljs-comment">// 更新进度</span><br>                        getHandler().sendEmptyMessage(DOWN_UPDATE);<br>                        <span class="hljs-keyword">if</span> (numread &lt;= <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-comment">// 下载完成通知安装</span><br>                            getHandler().sendEmptyMessage(DOWN_OVER);<br>                            interceptFlag = <span class="hljs-literal">false</span>;<br>                        &#125;<br>                        fos.write(buf, <span class="hljs-number">0</span>, numread);<br>                    &#125;<br>                    fos.close();<br>                    is.close();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>            &#125;<br>        &#125;);<br>        downLoadThread.start();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>以上为下载文件的代码，逻辑很简单，起一个新线程，使用HttpURLConnection进行文件下载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installAPK</span><span class="hljs-params">(String filePath)</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">apkFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>    <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_VIEW);<br>    <span class="hljs-keyword">if</span> (!apkFile.exists()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    intent.setDataAndType(Uri.fromFile(apkFile), <span class="hljs-string">&quot;application/vnd.android.package-archive&quot;</span>);<br>    context.startActivity(intent);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上代码是刚开始写的安装软件的代码，在Android N 以下运行正常，但是在Android N上却爆出了如下错误，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">android.os.FileUriExposedException: file: exposed beyond app through Intent.getData()<br>	at android.os.StrictMode.onFileUriExposed(StrictMode.java:<span class="hljs-number">1799</span>)<br>	at android.net.Uri.checkFileUriExposed(Uri.java:<span class="hljs-number">2346</span>)<br>	at android.content.Intent.prepareToLeaveProcess(Intent.java:<span class="hljs-number">8949</span>)<br>	at android.content.Intent.prepareToLeaveProcess(Intent.java:<span class="hljs-number">8908</span>)<br>	at android.app.Instrumentation.execStartActivity(Instrumentation.java:<span class="hljs-number">1519</span>)<br>	at android.app.ContextImpl.startActivity(ContextImpl.java:<span class="hljs-number">829</span>)<br>	at android.app.ContextImpl.startActivity(ContextImpl.java:<span class="hljs-number">806</span>)<br>	at android.content.ContextWrapper.startActivity(ContextWrapper.java:<span class="hljs-number">366</span>)<br>	at com.mmuu.travel.service.ui.LoginFrg.installAPK(LoginFrg.java:<span class="hljs-number">349</span>)<br>	at com.mmuu.travel.service.ui.LoginFrg.access$<span class="hljs-number">200</span>(LoginFrg.java:<span class="hljs-number">66</span>)<br>	at com.mmuu.travel.service.ui.LoginFrg$<span class="hljs-number">1.</span>onFinish(LoginFrg.java:<span class="hljs-number">134</span>)<br>	at android.os.CountDownTimer$<span class="hljs-number">1.</span>handleMessage(CountDownTimer.java:<span class="hljs-number">127</span>)<br>	at android.os.Handler.dispatchMessage(Handler.java:<span class="hljs-number">102</span>)<br>	at android.os.Looper.loop(Looper.java:<span class="hljs-number">154</span>)<br>	at android.app.ActivityThread.main(ActivityThread.java:<span class="hljs-number">6114</span>)<br>	at java.lang.reflect.Method.invoke(Native Method)<br>	at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:<span class="hljs-number">874</span>)<br>	at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="hljs-number">764</span>)<br></code></pre></td></tr></table></figure>
<p>网上搜了一下，是Android N在权限上做了一些修改：<a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html">参考链接</a> <a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html">https://developer.android.google.cn/about/versions/nougat/android-7.0-changes.html</a></p>
<blockquote>
<p>系统权限更改<br>为了提高私有文件的安全性，面向 Android 7.0 或更高版本的应用私有目录被限制访问　(0700)。此设置可防止私有文件的元数据泄漏，如它们的大小或存在性。此权限更改有多重副作用：<br>私有文件的文件权限不应再由所有者放宽，为使用 MODE_WORLD_READABLE 和&#x2F;或 MODE_WORLD_WRITEABLE 而进行的此类尝试将触发 SecurityException。</p>
<blockquote>
<p>注：迄今为止，这种限制尚不能完全执行。应用仍可能使用原生 API 或 File API 来修改它们的私有目录权限。但是，我们强烈反对放宽私有目录的权限。</p>
</blockquote>
</blockquote>
<blockquote>
<p>传递软件包网域外的 file:&#x2F;&#x2F; URI 可能给接收器留下无法访问的路径。因此，尝试传递 file:&#x2F;&#x2F; URI 会触发 FileUriExposedException。分享私有文件内容的推荐方法是使用 FileProvider。<br>DownloadManager 不再按文件名分享私人存储的文件。旧版应用在访问 COLUMN_LOCAL_FILENAME 时可能出现无法访问的路径。面向 Android 7.0 或更高版本的应用在尝试访问 COLUMN_LOCAL_FILENAME 时会触发 SecurityException。通过使用 DownloadManager.Request.setDestinationInExternalFilesDir() 或 DownloadManager.Request.setDestinationInExternalPublicDir() 将下载位置设置为公共位置的旧版应用仍可以访问 COLUMN_LOCAL_FILENAME 中的路径，但是我们强烈反对使用这种方法。对于由 DownloadManager 公开的文件，首选的访问方式是使用ContentResolver.openFileDescriptor()。</p>
</blockquote>
<p>解决方案：</p>
<ol>
<li>FileProvider<br>1.1 在mainfest中加入FileProvider注册<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;你的应用名.fileprovider&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.v4.content.FileProvider&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:grantUriPermissions</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">           <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/filepaths&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure>
1.2 在<code>res</code>文件夹下新建<code>xml</code>文件夹，在<code>xml</code>文件夹中新建<code>filepaths</code>文件，这个文件名字和上面的 Android:resource后面的名字要一致<br>编辑该文件：<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">paths</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">external-path</span></span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;external_storage_root&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">paths</span>&gt;</span><br></code></pre></td></tr></table></figure>
1.3 修改安装代码<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installAPK</span><span class="hljs-params">(String filePath)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">apkFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_VIEW);<br>        <span class="hljs-keyword">if</span> (!apkFile.exists()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;<br>            intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);<br>            <span class="hljs-type">Uri</span> <span class="hljs-variable">contentUri</span> <span class="hljs-operator">=</span> FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID + <span class="hljs-string">&quot;.fileProvider&quot;</span>, apkFile);<br>            intent.setDataAndType(contentUri, <span class="hljs-string">&quot;application/vnd.android.package-archive&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            intent.setDataAndType(Uri.fromFile(apkFile), <span class="hljs-string">&quot;application/vnd.android.package-archive&quot;</span>);<br>        &#125;<br>        getActivity().getApplicationContext().startActivity(intent);<br>        context.finish();<br>    &#125;<br></code></pre></td></tr></table></figure>
首先判断设备的Android版本，N或者N以上使用<code>FileProvider</code>进行安装，N一下还是原来的方式。注意调用startActivity要使用ApplicationContext，使用Activity.this会报错。</li>
<li>使用DownloadManager<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApkDownLoad</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DOWNLOAD_FOLDER_NAME</span> <span class="hljs-operator">=</span> getLocalForderPath();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DOWNLOAD_FILE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;XXX.apk&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">APK_DOWNLOAD_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apkDownloadId&quot;</span>;<br>    <span class="hljs-keyword">private</span> Context context;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String notificationTitle;<br>    <span class="hljs-keyword">private</span> String notificationDescription;<br><br>    <span class="hljs-keyword">private</span> DownloadManager downloadManager;<br>    <span class="hljs-keyword">private</span> CompleteReceiver completeReceiver;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> url                     下载apk的url</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> notificationTitle       通知栏标题</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> notificationDescription 通知栏描述</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ApkDownLoad</span><span class="hljs-params">(Context context, String url, String notificationTitle,</span><br><span class="hljs-params">                       String notificationDescription)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        <span class="hljs-built_in">this</span>.context = context;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.notificationTitle = notificationTitle;<br>        <span class="hljs-built_in">this</span>.notificationDescription = notificationDescription;<br>        downloadManager = (DownloadManager) context<br>                .getSystemService(Context.DOWNLOAD_SERVICE);<br>        completeReceiver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompleteReceiver</span>();<br><br>        <span class="hljs-comment">/** register download success broadcast **/</span><br>        context.registerReceiver(completeReceiver, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>(<br>                DownloadManager.ACTION_DOWNLOAD_COMPLETE));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">// 清除已下载的内容重新下载</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">downloadId</span> <span class="hljs-operator">=</span> UpdateUtils.getLong(context, APK_DOWNLOAD_ID);<br>        <span class="hljs-keyword">if</span> (downloadId != -<span class="hljs-number">1</span>) &#123;<br>            downloadManager.remove(downloadId);<br>            UpdateUtils.removeSharedPreferenceByKey(context, APK_DOWNLOAD_ID);<br>        &#125;<br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(Uri.parse(url));<br>        <span class="hljs-comment">// 设置Notification中显示的文字</span><br>        request.setTitle(notificationTitle);<br>        request.setDescription(notificationDescription);<br>        <span class="hljs-comment">// 设置可用的网络类型</span><br>        request.setAllowedNetworkTypes(Request.NETWORK_MOBILE<br>                | Request.NETWORK_WIFI);<br>        <span class="hljs-comment">// 设置状态栏中显示Notification</span><br>        request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);<br>        <span class="hljs-comment">// 不显示下载界面</span><br>        request.setVisibleInDownloadsUi(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 设置下载后文件存放的位置</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">folder</span> <span class="hljs-operator">=</span> Environment<br>                .getExternalStoragePublicDirectory(DOWNLOAD_FOLDER_NAME);<br>        <span class="hljs-keyword">if</span> (!folder.exists() || !folder.isDirectory()) &#123;<br>            folder.mkdirs();<br>        &#125;<br>        <span class="hljs-comment">// 设置下载文件的保存路径</span><br>        request.setDestinationInExternalPublicDir(DOWNLOAD_FOLDER_NAME,<br>                DOWNLOAD_FILE_NAME);<br>        <span class="hljs-comment">// 设置文件类型</span><br>        <span class="hljs-type">MimeTypeMap</span> <span class="hljs-variable">mimeTypeMap</span> <span class="hljs-operator">=</span> MimeTypeMap.getSingleton();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">mimeString</span> <span class="hljs-operator">=</span> mimeTypeMap.getMimeTypeFromExtension(MimeTypeMap<br>                .getFileExtensionFromUrl(url));<br>        request.setMimeType(mimeString);<br>        <span class="hljs-comment">// 保存返回唯一的downloadId</span><br>        UpdateUtils.putLong(context, APK_DOWNLOAD_ID,<br>                downloadManager.enqueue(request));<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompleteReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BroadcastReceiver</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * get the id of download which have download success, if the id is</span><br><span class="hljs-comment">             * my id and it&#x27;s status is successful, then install it</span><br><span class="hljs-comment">             **/</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">completeDownloadId</span> <span class="hljs-operator">=</span> intent.getLongExtra(<br>                    DownloadManager.EXTRA_DOWNLOAD_ID, <span class="hljs-number">0</span>);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">downloadId</span> <span class="hljs-operator">=</span> UpdateUtils.getLong(context, APK_DOWNLOAD_ID);<br><br>            <span class="hljs-keyword">if</span> (completeDownloadId == downloadId) &#123;<br><br>                <span class="hljs-comment">// if download successful</span><br>                <span class="hljs-keyword">if</span> (queryDownloadStatus(downloadManager, downloadId) == DownloadManager.STATUS_SUCCESSFUL) &#123;<br><br>                    <span class="hljs-comment">// clear downloadId</span><br>                    UpdateUtils.removeSharedPreferenceByKey(context,<br>                            APK_DOWNLOAD_ID);<br><br>                    <span class="hljs-comment">// unregisterReceiver</span><br>                    context.unregisterReceiver(completeReceiver);<br><br>                    <span class="hljs-comment">// install apk</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">apkFilePath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(Environment<br>                            .getExternalStorageDirectory().getAbsolutePath())<br>                            .append(File.separator)<br>                            .append(DOWNLOAD_FOLDER_NAME)<br>                            .append(File.separator).append(DOWNLOAD_FILE_NAME)<br>                            .toString();<br>                    install(context, apkFilePath);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询下载状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">queryDownloadStatus</span><span class="hljs-params">(DownloadManager downloadManager,</span><br><span class="hljs-params">                                          <span class="hljs-type">long</span> downloadId)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        DownloadManager.<span class="hljs-type">Query</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DownloadManager</span>.Query()<br>                .setFilterById(downloadId);<br>        <span class="hljs-type">Cursor</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            c = downloadManager.query(query);<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; c.moveToFirst()) &#123;<br>                result = c.getInt(c<br>                        .getColumnIndex(DownloadManager.COLUMN_STATUS));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;<br>                c.close();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * install app</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filePath</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> whether apk exist</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">install</span><span class="hljs-params">(Context context, String filePath)</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_VIEW);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filePath);<br>        <span class="hljs-keyword">if</span> (file != <span class="hljs-literal">null</span> &amp;&amp; file.length() &gt; <span class="hljs-number">0</span> &amp;&amp; file.exists() &amp;&amp; file.isFile()) &#123;<br>            i.setDataAndType(Uri.parse(<span class="hljs-string">&quot;file://&quot;</span> + filePath),<br>                    <span class="hljs-string">&quot;application/vnd.android.package-archive&quot;</span>);<br>            i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>            context.startActivity(i);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
检测到需要升级时  <code>new ApkDownLoad().execute()</code>就可以了，其中<code>UpdateUtils.getLong()</code>是一个<code>SharedPreferences</code>封装。</li>
</ol>
<hr>
<h2 id="以上两种方式在小米5Android-N-上实测有效"><a href="#以上两种方式在小米5Android-N-上实测有效" class="headerlink" title="以上两种方式在小米5Android N 上实测有效"></a>以上两种方式在小米5Android N 上实测有效</h2><p>以上</p>
]]></content>
      <tags>
        <tag>Android爬坑之旅</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>2016年国庆-在深圳</title>
    <url>/2016/10/08/2016%E5%9B%BD%E5%BA%86/</url>
    <content><![CDATA[<p>国庆之前,辞了工作,跑到深圳找妹子玩了几天.妹子在哈工大深圳校区读研究生,去了之后也没有出去逛,吃饭,图书馆,写作业,折腾hexo写博客.<br>也就在校园里逛了一下,拍了几张照片.<br>在深圳市南山区的大学城里面,好像是有清华北大哈工大三所研究生院校组成的,据说哈工大深研院开始招本科生了.<br><br/></p>
<span id="more"></span>
<p><strong>南门</strong> ,没去其他的门,就从这边进去的,别问为啥,近.<br> <img src="/image/South_Gate.jpg" alt="南门"><br><br/><br> **哈工大深研院的标志?**不知道是不是标志性建筑<br> <img src="/image/main_building.jpg" alt="标志"><br> <img src="/image/sign.jpg" alt="标志"><br><br/><br> <strong>图书馆</strong>,吐槽一下,图书馆的书好少.电梯的海报上面说是有电影放映,但是我们沉迷于学习无法自拔,理所当然的错过了.<br> <img src="/image/Library.jpg" alt="图书馆"><br><br/><br> <strong>图书馆门口的植物标本</strong>,我也不知道是啥,装作看懂的样子<br> <img src="/image/Library_Plant_specimen1.jpg" alt="植物标本"><br> <img src="/image/Library_Plant_specimen2.jpg" alt="植物标本"><br> <img src="/image/Library_Plant_specimen3.jpg" alt="植物标本"><br> <img src="/image/Library_Plant_specimen4.jpg" alt="植物标本"><br><br/><br> <strong>食堂</strong>,食堂的饭菜还是不错的,听说非学校人员也能在里面办卡,只是比学生买饭要贵40%.表示理解.<br><img src="/image/Restaurant.jpg" alt="荔园餐厅"><br><img src="/image/Meal1.jpg" alt="食堂饭"><br><img src="/image/Meal2.jpg" alt="食堂饭"><br><img src="/image/Meal3.jpg" alt="食堂饭"><br><br/><br>  <strong>北大汇丰商学院</strong>,就在图书馆旁边<br><img src="/image/PHBS.jpg" alt="北大汇丰商学院"><br><img src="/image/PHBS1.jpg" alt="北大汇丰商学院"><br><br/><br><strong>小树林里面有蛇</strong>,晚上去吃饭的时候路过的小树林,里面真的有蛇,亲眼所见,大概有食指粗细,一尺来长,黑灰色.可惜没拍到.<br>![小心有蛇](&#x2F;image&#x2F;Beware_of_ snakes.jpg)<br><br/><br><strong>清华大学深研院</strong>,不知道是不是这么叫的,吃完晚饭去瞻仰了一下<br><img src="/image/Tsinghua.jpg" alt="清华大学深研院"><br><br/><br> 本打算去蹭课来着,但是看着妹子的作业就不想去了,我觉得我应该听不大懂.</p>
<hr/>
 就这些,待了貌似有四五天的样子,然后就滚回北京找工作了.
 以上.
 
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>Android ContentProvider</title>
    <url>/2018/08/02/Android-ContentProvider/</url>
    <content><![CDATA[<p>《Android开发艺术探索》9.5章</p>
<p>系统预置了许多<code>ContentProvider</code>，比如通讯录信息、日程表信息等，要跨进程访问这些信息，只需要通过<code>ContentResolver</code>的query、update、insert和delete方法即可。虽然<code>ContentProvider</code>的底层<br>实现是<code>Binder</code>，但是它的使用过程要比<code>AIDL</code>简单许多，这是因为系统已经为我们做了封装，使得我们无须关心底层细节即可轻松实现IPC。系统预置了许多<code>ContentProvider</code>，比如通讯录信息、日程表信息等，要跨进程访问这些信息，只需要通过<code>ContentResolver</code>的query、update、insert和delete方法即可。</p>
<span id="more"></span>

<h4 id="使用ContentResolver读取联系人"><a href="#使用ContentResolver读取联系人" class="headerlink" title="使用ContentResolver读取联系人"></a>使用ContentResolver读取联系人</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ArrayList&lt;HashMap&lt;String, String&gt;&gt; <span class="hljs-title function_">readContact</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">NUM</span> <span class="hljs-operator">=</span> ContactsContract.CommonDataKinds.Phone.NUMBER;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">NAME</span> <span class="hljs-operator">=</span> ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME;<br>    <span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> ContactsContract.CommonDataKinds.Phone.CONTENT_URI;<br><br>    ArrayList&lt;HashMap&lt;String, String&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;HashMap&lt;String, String&gt;&gt;();<br>    <span class="hljs-type">ContentResolver</span> <span class="hljs-variable">cr</span> <span class="hljs-operator">=</span> getContentResolver();<br>    <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> cr.query(uri,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;NUM,NAME&#125;,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">while</span> (cursor.moveToNext())&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> cursor.getString(cursor.getColumnIndex(NAME));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> cursor.getString(cursor.getColumnIndex(NUM));<br>        HashMap&lt;String,String&gt; contact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        contact.put(<span class="hljs-string">&quot;name&quot;</span>,name);<br>        contact.put(<span class="hljs-string">&quot;phone&quot;</span>,phone);<br>        list.add(contact);<br>    &#125;<br>    <span class="hljs-keyword">return</span> list;<br></code></pre></td></tr></table></figure>

<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p><code>ContentProvider</code>是一种内容共享型组件，它通过<code>Binder</code>向其他组件乃至其他应用提供数据。当<code>ContentProvider</code>所在的进程启动时，<code>ContentProvider</code>会同时启动并被发布到AMS中。需要注意的是，这个时候<code>ContentProvider</code>的<code>onCreate</code>要先于<code>Application</code>的<code>onCreate</code>而执行。<br>当一个应用启动时，入口方法为<code>ActivityThread</code>的<code>main</code>方法，<code>main</code>方法是一个静态方法，在<code>main</code>方法中会创建<code>ActivityThread</code>的实例并创建主线程的消息队列，然后在<code>ActivityThread</code>的<code>attach</code>方法中会远程调用<code>AMS</code>的<code>attachApplication</code>方法并将<code>ApplicationThread</code>对象提供给<code>AMS</code>。<code>ApplicationThread</code>是一个<code>Binder</code>对象，它的<code>Binder</code>接口是<code>IApplicationThread</code>，它主要用于<code>ActivityThread</code>和<code>AMS</code>之间的通信，这一点在前面多次提到。在<code>AMS</code>的<code>attachApplication</code>方法中，会调用<code>ApplicationThread</code>的<code>bindApplication</code>方法，注意这个过程同样是跨进程完成的，<code>bindApplication</code>的逻辑会经过<code>ActivityThread</code>中的<code>mH  Handler</code>切换到<code>ActivityThread</code>中去执行，具体的方法是<code>handleBindApplication</code>。在<code>handleBindApplication</code>方法中，<code>ActivityThread</code>会创建<code>Application</code>对象并加载<code>ContentProvider</code>。需要注意的是，<code>ActivityThread</code>会先加载<code>ContentProvider</code>，然后再调用<code>Application</code>的<code>onCreate</code>方法。<br>这就是<code>ContentProvider</code>的启动过程，<code>ContentProvider</code>启动后，外界就可以通过它所提供的增删改查这四个接口来操作<code>ContentProvider</code>中的数据源，即insert、delete、update和query四个方法。这四个方法都是通过<code>Binder</code>来调用的，外界无法直接访问<code>ContentProvider</code>，它只能通过AMS根据Uri来获取对应的<code>ContentProvider</code>的<code>Binder</code>接口<code>IConentProvider</code>，然后再通过<code>IConentProvider</code>来访问<code>ContentProvider</code>中的数据源。<br>一般来说，<code>ContentProvide</code>r都应该是单实例的。<code>ContentProvider</code>到底是不是单实例，这是由它的<code>android:multiprocess</code>属性来决定的，当<code>android:multiprocess</code>为<code>false</code>时，<code>ContentProvider</code>是单实例，这也是默认值；当<code>android:multiprocess</code>为<code>true</code>时，<code>ContentProvider</code>为多实例，这个时候在每个调用者的进程中都存在一个<code>ContentProvider</code>对象。<br>访问<code>ContentProvide</code>r需要通过<code>ContentResolver</code>，<code>ContentResolver</code>是一个抽象类，通过<code>Context</code>的<code>getContentResolver</code>方法获取的实际上是<code>ApplicationContentResolver</code>对象，<code>ApplicationContentResolver</code>类继承了<code>ContentResolver</code>并实现了<code>ContentResolver</code>中的抽象方法。当<code>ContentProvider</code>所在的进程未启动时，第一次访问它时就会触发<code>ContentProvider</code>的创建，当然这也伴随着<code>ContentProvider</code>所在进程的启动。通过<code>ContentProvider</code>的四个方法的任何一个都可以触发<code>ContentProvider</code>的启动过程，这里选择<code>query</code>方法。<code>ContentProvider</code>的<code>query</code>方法中，首先会获取<code>IContentProvider</code>对象，不管是通过<code>acquireUnstableProvider</code>方法还是直接通过<code>acquireProvider</code>方法，它们的本质都是一样的，最终都是通过<code>acquireProvider</code>方法来获取<code>ContentProvider</code>。下面是<code>ApplicationContentResolver</code>的<code>acquireProvider</code>方法的具体实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> IContentProvider <span class="hljs-title function_">acquireProvider</span><span class="hljs-params">(Context context, String auth)</span> &#123;<br>       <span class="hljs-keyword">return</span> mMainThread.acquireProvider(context,<br>               ContentProvider.getAuthorityWithoutUserId(auth),<br>               resolveUserIdFromAuthority(auth), <span class="hljs-literal">true</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p><code>ApplicationContentResolver</code>的<code>acquireProvider</code>方法并没有处理任何逻辑，它直接调用了<code>ActivityThread</code>的<code>acquireProvider</code>方法，<code>ActivityThread</code>的<code>acquireProvider</code>方法的源码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> IContentProvider <span class="hljs-title function_">acquireProvider</span><span class="hljs-params">(</span><br><span class="hljs-params">            Context c, String auth, <span class="hljs-type">int</span> userId, <span class="hljs-type">boolean</span> stable)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">IContentProvider</span> <span class="hljs-variable">provider</span> <span class="hljs-operator">=</span> acquireExistingProvider(c, auth, userId, stable);<br>    <span class="hljs-keyword">if</span> (provider != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> provider;<br>    &#125;<br><br>    <span class="hljs-comment">// There is a possible race here.  Another thread may try to acquire</span><br>    <span class="hljs-comment">// the same provider at the same time.  When this happens, we want to ensure</span><br>    <span class="hljs-comment">// that the first one wins.</span><br>    <span class="hljs-comment">// Note that we cannot hold the lock while acquiring and installing the</span><br>    <span class="hljs-comment">// provider since it might take a long time to run and it could also potentially</span><br>    <span class="hljs-comment">// be re-entrant in the case where the provider is in the same process.</span><br>    <span class="hljs-type">ContentProviderHolder</span> <span class="hljs-variable">holder</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        holder = ActivityManager.getService().getContentProvider(<br>                getApplicationThread(), auth, userId, stable);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>        <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (holder == <span class="hljs-literal">null</span>) &#123;<br>        Slog.e(TAG, <span class="hljs-string">&quot;Failed to find provider info for &quot;</span> + auth);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Install provider will increment the reference count for us, and break</span><br>    <span class="hljs-comment">// any ties in the race.</span><br>    holder = installProvider(c, holder, holder.info,<br>            <span class="hljs-literal">true</span> <span class="hljs-comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);<br>    <span class="hljs-keyword">return</span> holder.provider;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的代码首先会从<code>ActivityThread</code>中查找是否已经存在目标<code>ContentProvider</code>了，如果存在就直接返回。<code>ActivityThread</code>中通过<code>mProviderMap</code>来存储已经启动的<code>ContentProvider</code>对象，<code>mProviderMap</code>的声明如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">inal ArrayMap&lt;providerKey,ProviderClientRecord&gt; mProviderMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;providerKey,ProviderClientRecord&gt;();<br></code></pre></td></tr></table></figure>
<p>如果目前<code>ContentProvider</code>没有启动，那么就发送一个进程间请求给AMS让其启动目标<code>ContentProvider</code>，最后再通过<code>installProvider</code>方法来修改引用计数。<code>ContentProvider</code>被启动时会伴随着进程的启动，在AMS中，首先会启动<code>ContentProvider</code>所在的进程，然后再启动<code>ContentProvider</code>。启动进程是由AMS的<code>startProcessLocked</code>方法来完成的，其内部主要是通过<code>Process</code>的<code>start</code>方法来完成一个新进程的启动，新进程启动后其入口方法为<code>ActivityThread</code>的main方法，如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;ActivityThreadMain&quot;</span>);<br><br>    <span class="hljs-comment">// CloseGuard defaults to true and can be quite spammy.  We</span><br>    <span class="hljs-comment">// disable it here, but selectively enable it later (via</span><br>    <span class="hljs-comment">// StrictMode) on debug builds, but using DropBox, not logs.</span><br>    CloseGuard.setEnabled(<span class="hljs-literal">false</span>);<br><br>    Environment.initForCurrentUser();<br><br>    <span class="hljs-comment">// Set the reporter for event logging in libcore</span><br>    EventLogger.setReporter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EventLoggingReporter</span>());<br><br>    <span class="hljs-comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">configDir</span> <span class="hljs-operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());<br>    TrustedCertificateStore.setDefaultUserDirectory(configDir);<br><br>    Process.setArgV0(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>);<br><br>    Looper.prepareMainLooper();<br><br>    <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>    thread.attach(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>        sMainThreadHandler = thread.getHandler();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>        Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span><br>                <span class="hljs-title class_">LogPrinter</span>(Log.DEBUG, <span class="hljs-string">&quot;ActivityThread&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// End of event ActivityThreadMain.</span><br>    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>    Looper.loop();<br><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，<code>ActivityThread</code>的<code>main</code>方法是一个静态方法，在它内部首先会创建<code>ActivityThread</code>的实例并调用<code>attach</code>方法来进行一系列初始化，接着就开始进行消息循环了。<code>ActivityThread</code>的<code>attach</code>方法会将<code>ApplicationThread</code>对象通过<code>AMS</code>的<code>attachApplication</code>方法跨进程传递给AMS，最终AMS会完成<code>ContentProvider</code>的创建过程，AMS的<code>attachApplication</code>方法调用了<code>attachApplicationLocked</code>方法，<code>attachApplicationLocked</code>中又调用了<code>ApplicationThread</code>的<code>bindApplication</code>，注意这个过程也是进程间调用，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    mgr.attachApplication(mAppThread);<br>&#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>    <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachApplication</span><span class="hljs-params">(IApplicationThread thread)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">origId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>            attachApplicationLocked(thread, callingPid);<br>            Binder.restoreCallingIdentity(origId);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">attachApplicationLocked</span><span class="hljs-params">(IApplicationThread thread,<span class="hljs-type">int</span> pid)</span> &#123;<br>    ......<br><span class="hljs-keyword">if</span> (app.instr != <span class="hljs-literal">null</span>) &#123;<br>                thread.bindApplication(processName, appInfo, providers,<br>                        app.instr.mClass,<br>                        profilerInfo, app.instr.mArguments,<br>                        app.instr.mWatcher,<br>                        app.instr.mUiAutomationConnection, testMode,<br>                        mBinderTransactionTrackingEnabled, enableTrackAllocation,<br>                        isRestrictedBackupMode || !normalMode, app.persistent,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(getGlobalConfiguration()), app.compat,<br>                        getCommonServicesLocked(app.isolated),<br>                        mCoreSettingsObserver.getCoreSettingsLocked(),<br>                        buildSerial);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                thread.bindApplication(processName, appInfo, providers, <span class="hljs-literal">null</span>, profilerInfo,<br>                        <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, testMode,<br>                        mBinderTransactionTrackingEnabled, enableTrackAllocation,<br>                        isRestrictedBackupMode || !normalMode, app.persistent,<br>                        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(getGlobalConfiguration()), app.compat,<br>                        getCommonServicesLocked(app.isolated),<br>                        mCoreSettingsObserver.getCoreSettingsLocked(),<br>                        buildSerial);<br>            &#125;<br>            ......<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ActivityThread</code>的<code>bindApplication</code>会发送一个<code>BIND_APPLICATION</code>类型的消息给<code>mH</code>，<code>mH</code>是一个<code>Handler</code>，它收到消息后会调用<code>ActivityThread</code>的<code>handleBindApplication</code>方法，<code>bindApplication</code>发送消息的过程如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">AppBindData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AppBindData</span>();<br>            data.processName = processName;<br>            data.appInfo = appInfo;<br>            data.providers = providers;<br>            data.instrumentationName = instrumentationName;<br>            data.instrumentationArgs = instrumentationArgs;<br>            data.instrumentationWatcher = instrumentationWatcher;<br>            data.instrumentationUiAutomationConnection = instrumentationUiConnection;<br>            data.debugMode = debugMode;<br>            data.enableBinderTracking = enableBinderTracking;<br>            data.trackAllocation = trackAllocation;<br>            data.restrictedBackupMode = isRestrictedBackupMode;<br>            data.persistent = persistent;<br>            data.config = config;<br>            data.compatInfo = compatInfo;<br>            data.initProfilerInfo = profilerInfo;<br>            data.buildSerial = buildSerial;<br>            sendMessage(H.BIND_APPLICATION, data);<br></code></pre></td></tr></table></figure>
<p><code>ActivityThread</code>的<code>handleBindApplication</code>则完成了<code>Application</code>的创建以及<code>ContentProvider</code>的创建，可以分为如下四个步骤:</p>
<p>** 创建ContextImpl和Instrumentation **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">appContext</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(<span class="hljs-built_in">this</span>, data.info);<br>updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales());<br> <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> instrContext.getClassLoader();<br>    mInstrumentation = (Instrumentation)<br>        cl.loadClass(data.instrumentationName.getClassName()).newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>        <span class="hljs-string">&quot;Unable to instantiate instrumentation &quot;</span><br>        + data.instrumentationName + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>&#125;<br><span class="hljs-keyword">final</span> <span class="hljs-type">ComponentName</span> <span class="hljs-variable">component</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentName</span>(ii.packageName, ii.name);<br>mInstrumentation.init(<span class="hljs-built_in">this</span>, instrContext, appContext, component, data.instrumentationWatcher, data.instrumentationUiAutomationConnection);<br></code></pre></td></tr></table></figure>

<p>** 创建Application对象 **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// If the app is being launched for full backup or restore, bring it up in</span><br><span class="hljs-comment">// a restricted environment with the base application class.</span><br>app = data.info.makeApplication(data.restrictedBackupMode, <span class="hljs-literal">null</span>);<br>mInitialApplication = app;<br></code></pre></td></tr></table></figure>

<p>** 启动当前进程的ContentProvider并调用其onCreate方法 **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// don&#x27;t bring up providers in restricted mode; they may depend on the</span><br><span class="hljs-comment">// app&#x27;s custom Application class</span><br><span class="hljs-keyword">if</span> (!data.restrictedBackupMode) &#123;<br>    <span class="hljs-keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;<br>        installContentProviders(app, data.providers);<br>        <span class="hljs-comment">// For process that contains content providers, we want to</span><br>        <span class="hljs-comment">// ensure that the JIT is enabled &quot;at some point&quot;.</span><br>        mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="hljs-number">10</span>*<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>installContentProviders</code>完成了<code>ContentProvider</code>的启动工作，它的实现如下所示。首先会遍历当前进程的<code>ProviderInfo</code>的列表并一一调用调用<code>installProvider</code>方法来启动它们，接着将已经启动的<code>ContentProvider</code>发布到AMS中，AMS会把它们存储在<code>ProviderMap</code>中，这样一来外部调用者就可以直接从AMS中获取<code>ContentProvider</code>了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">installContentProviders</span><span class="hljs-params">(</span><br><span class="hljs-params">           Context context, List&lt;ProviderInfo&gt; providers)</span> &#123;<br>       <span class="hljs-keyword">final</span> ArrayList&lt;ContentProviderHolder&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>       <span class="hljs-keyword">for</span> (ProviderInfo cpi : providers) &#123;<br>           <span class="hljs-keyword">if</span> (DEBUG_PROVIDER) &#123;<br>               <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">128</span>);<br>               buf.append(<span class="hljs-string">&quot;Pub &quot;</span>);<br>               buf.append(cpi.authority);<br>               buf.append(<span class="hljs-string">&quot;: &quot;</span>);<br>               buf.append(cpi.name);<br>               Log.i(TAG, buf.toString());<br>           &#125;<br>           <span class="hljs-type">ContentProviderHolder</span> <span class="hljs-variable">cph</span> <span class="hljs-operator">=</span> installProvider(context, <span class="hljs-literal">null</span>, cpi,<br>                   <span class="hljs-literal">false</span> <span class="hljs-comment">/*noisy*/</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*noReleaseNeeded*/</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/*stable*/</span>);<br>           <span class="hljs-keyword">if</span> (cph != <span class="hljs-literal">null</span>) &#123;<br>               cph.noReleaseNeeded = <span class="hljs-literal">true</span>;<br>               results.add(cph);<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">try</span> &#123;<br>           ActivityManager.getService().publishContentProviders(<br>               getApplicationThread(), results);<br>       &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>           <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>下面看一下<code>ContentProvider</code>对象的创建过程，在<code>installProvider</code>方法中有下面一段代码，其通过类加载器完成了<code>ContentProvider</code>对象的创建:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> c.getClassLoader();<br>localProvider = (ContentProvider)cl.loadClass(info.name).newInstance();<br>provider = localProvider.getIContentProvider();<br><span class="hljs-comment">// XXX Need to create the correct context for this provider.</span><br>localProvider.attachInfo(c, info);<br></code></pre></td></tr></table></figure>
<p>在上述代码中，除了完成<code>ContentProvider</code>对象的创建，还会通过<code>ContentProvider</code>的<code>attachInfo</code>方法来调用它的<code>onCreate</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachInfo</span><span class="hljs-params">(Context context, ProviderInfo info, <span class="hljs-type">boolean</span> testing)</span> &#123;<br>    mNoPerms = testing;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * Only allow it to be set once, so after the content service gives</span><br><span class="hljs-comment">        * this to us clients can&#x27;t change it.</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-keyword">if</span> (mContext == <span class="hljs-literal">null</span>) &#123;<br>        mContext = context;<br>        <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span>) &#123;<br>            mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(<br>                    Context.APP_OPS_SERVICE);<br>        &#125;<br>        mMyUid = Process.myUid();<br>        <span class="hljs-keyword">if</span> (info != <span class="hljs-literal">null</span>) &#123;<br>            setReadPermission(info.readPermission);<br>            setWritePermission(info.writePermission);<br>            setPathPermissions(info.pathPermissions);<br>            mExported = info.exported;<br>            mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != <span class="hljs-number">0</span>;<br>            setAuthorities(info.authority);<br>        &#125;<br>        ContentProvider.<span class="hljs-built_in">this</span>.onCreate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到此为止，<code>ContentProvider</code>已经被创建并且其<code>onCreate</code>方法也已经被调用，这意味着<code>ContentProvider</code>已经启动完成了。</p>
<p>** 调用Application的onCreate方法 **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Do this after providers, since instrumentation tests generally start their</span><br><span class="hljs-comment">// test thread at this point, and we don&#x27;t want that racing.</span><br><span class="hljs-keyword">try</span> &#123;<br>    mInstrumentation.onCreate(data.instrumentationArgs);<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>        <span class="hljs-string">&quot;Exception thrown in onCreate() of &quot;</span><br>        + data.instrumentationName + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    mInstrumentation.callApplicationOnCreate(app);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>            <span class="hljs-string">&quot;Unable to create application &quot;</span> + app.getClass().getName()<br>            + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>经过上面的四个步骤，<code>ContentProvider</code>已经成功启动，并且其所在进程的<code>Application</code>也已经启动，这意味着<code>ContentProvider</code>所在的进程已经完成了整个的启动过程，然后其他应用就可以通过AMS来访问这个<code>ContentProvider</code>了。拿到了<code>ContentProvider</code>以后，就可以通过它所提供的接口方法来访问它了。需要注意的是，这里的<code>ContentProvider</code>并不是原始的<code>ContentProvider</code>，而是<code>ContentProvider</code>的<code>Binder</code>类型的对象<code>IContentProvider</code>，<code>IContentProvider</code>的具体实现是<code>ContentProviderNative</code>和<code>ContentProvider.Transport</code>，其中<code>ContentProvider.Transport</code>继承了<code>ContentProviderNative</code>。这里仍然选择<code>query</code>方法，首先其他应用会通过AMS获取到<code>ContentProvider</code>的<code>Binder</code>对象即<code>IContentProvider</code>，而<code>IContentProvider</code>的实现者实际上是<code>ContentProvider.Transport</code>。因此其他应用调用<code>IContentProvider</code>的query方法时最终会以进程间通信的方式调用到<code>ContentProvider.Transport</code>的query方法，它的实现如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Cursor <span class="hljs-title function_">query</span><span class="hljs-params">(String callingPkg, Uri uri, <span class="hljs-meta">@Nullable</span> String[] projection,</span><br><span class="hljs-params">        <span class="hljs-meta">@Nullable</span> Bundle queryArgs, <span class="hljs-meta">@Nullable</span> ICancellationSignal cancellationSignal)</span> &#123;<br>    validateIncomingUri(uri);<br>    uri = maybeGetUriWithoutUserId(uri);<br>    <span class="hljs-keyword">if</span> (enforceReadPermission(callingPkg, uri, <span class="hljs-literal">null</span>) != AppOpsManager.MODE_ALLOWED) &#123;<br>        <span class="hljs-comment">// The caller has no access to the data, so return an empty cursor with</span><br>        <span class="hljs-comment">// the columns in the requested order. The caller may ask for an invalid</span><br>        <span class="hljs-comment">// column and we would not catch that but this is not a problem in practice.</span><br>        <span class="hljs-comment">// We do not call ContentProvider#query with a modified where clause since</span><br>        <span class="hljs-comment">// the implementation is not guaranteed to be backed by a SQL database, hence</span><br>        <span class="hljs-comment">// it may not handle properly the tautology where clause we would have created.</span><br>        <span class="hljs-keyword">if</span> (projection != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MatrixCursor</span>(projection, <span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Null projection means all columns but we have no idea which they are.</span><br>        <span class="hljs-comment">// However, the caller may be expecting to access them my index. Hence,</span><br>        <span class="hljs-comment">// we have to execute the query as if allowed to get a cursor with the</span><br>        <span class="hljs-comment">// columns. We then use the column names to return an empty cursor.</span><br>        <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> ContentProvider.<span class="hljs-built_in">this</span>.query(<br>                uri, projection, queryArgs,<br>                CancellationSignal.fromTransport(cancellationSignal));<br>        <span class="hljs-keyword">if</span> (cursor == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// Return an empty cursor for all columns.</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MatrixCursor</span>(cursor.getColumnNames(), <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">original</span> <span class="hljs-operator">=</span> setCallingPackage(callingPkg);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> ContentProvider.<span class="hljs-built_in">this</span>.query(<br>                uri, projection, queryArgs,<br>                CancellationSignal.fromTransport(cancellationSignal));<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        setCallingPackage(original);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很显然，<code>ContentProvider.Transport</code>的<code>query</code>方法调用了<code>ContentProvider</code>的<code>query</code>方法，<code>query</code>方法的执行结果再通过<code>Binder</code>返回给调用者，这样一来整个调用过程就完成了。除了query方法，insert、delete和update方法也是类似的。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android O---适配NotificationChannel</title>
    <url>/2018/12/27/Android-O-%E9%80%82%E9%85%8DNotificationChannel/</url>
    <content><![CDATA[<p>继之前跪在Android N的<code>StrictMode</code>上了。现在又跪在的Android O 的NotificationChannel上了</p>
<p>场景如下：</p>
<p>某些场景中需要上传图片，选择图片或者拍照时使用系统的图库会将自己的app置于后台，若选择图片的时间过长，则可能会导致自己的app会杀死。看了一下传承下来的代码，是在这种情况下发送一个前台通知<code>startForeground</code>,使此服务在前台运行。但是会在通知栏上显示一个应用正在运行的通知</p>
<p><img src="/image/Android/NotificationChanel/startForeground.png" alt="通知" title="startForeground通知"></p>
<span id="more"></span>

<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>查看Android 28的源码，发现调用链如下：</p>
<p>首先 <code>Service.java</code>中调用 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startForeground</span><span class="hljs-params">(<span class="hljs-type">int</span> id, Notification notification)</span> &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           mActivityManager.setServiceForeground(<br>                   <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentName</span>(<span class="hljs-built_in">this</span>, mClassName), mToken, id,<br>                   notification, <span class="hljs-number">0</span>);<br>       &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>这里的<code>mActivityManager</code>的声明是<code>private IActivityManager mActivityManager = null;</code>在这里，<code>IActivityManager</code>的实现类是<code>ActivityManagerService</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServiceForeground</span><span class="hljs-params">(ComponentName className, IBinder token,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> id, Notification notification, <span class="hljs-type">int</span> flags)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            mServices.setServiceForegroundLocked(className, token, id, notification, flags);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setServiceForegroundLocked</span><span class="hljs-params">(ComponentName className, IBinder token,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> id, Notification notification, <span class="hljs-type">int</span> flags)</span> &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHandle.getCallingUserId();<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">origId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-type">ServiceRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> findServiceLocked(className, token, userId);<br>           <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>               setServiceForegroundInnerLocked(r, id, notification, flags);<br>           &#125;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           Binder.restoreCallingIdentity(origId);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>finally中调用的Binder方法是一个native方法，主要看一下<code>setServiceForegroundInnerLocked</code>:</p>
<p>方法太长，关注一下我们需要的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Apps under strict background restrictions simply don&#x27;t get to have foreground</span><br><span class="hljs-comment">// services, so now that we&#x27;ve enforced the startForegroundService() contract</span><br><span class="hljs-comment">// we only do the machinery of making the service foreground when the app</span><br><span class="hljs-comment">// is not restricted.</span><br><span class="hljs-keyword">if</span> (!ignoreForeground) &#123;<br>    <span class="hljs-keyword">if</span> (r.foregroundId != id) &#123;<br>        cancelForegroundNotificationLocked(r);<br>        r.foregroundId = id;<br>    &#125;<br>    notification.flags |= Notification.FLAG_FOREGROUND_SERVICE;<br>    r.foregroundNoti = notification;<br>    <span class="hljs-keyword">if</span> (!r.isForeground) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ServiceMap</span> <span class="hljs-variable">smap</span> <span class="hljs-operator">=</span> getServiceMapLocked(r.userId);<br>        <span class="hljs-keyword">if</span> (smap != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ActiveForegroundApp</span> <span class="hljs-variable">active</span> <span class="hljs-operator">=</span> smap.mActiveForegroundApps.get(r.packageName);<br>            <span class="hljs-keyword">if</span> (active == <span class="hljs-literal">null</span>) &#123;<br>                active = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveForegroundApp</span>();<br>                active.mPackageName = r.packageName;<br>                active.mUid = r.appInfo.uid;<br>                active.mShownWhileScreenOn = mScreenOn;<br>                <span class="hljs-keyword">if</span> (r.app != <span class="hljs-literal">null</span>) &#123;<br>                    active.mAppOnTop = active.mShownWhileTop =<br>                            r.app.uidRecord.curProcState<br>                                    &lt;= ActivityManager.PROCESS_STATE_TOP;<br>                &#125;<br>                active.mStartTime = active.mStartVisibleTime<br>                        = SystemClock.elapsedRealtime();<br>                smap.mActiveForegroundApps.put(r.packageName, active);<br>                requestUpdateActiveForegroundAppsLocked(smap, <span class="hljs-number">0</span>);<br>            &#125;<br>            active.mNumActive++;<br>        &#125;<br>        r.isForeground = <span class="hljs-literal">true</span>;<br>        mAm.mAppOpsService.startOperation(<br>                AppOpsManager.getToken(mAm.mAppOpsService),<br>                AppOpsManager.OP_START_FOREGROUND, r.appInfo.uid, r.packageName,<br>                <span class="hljs-literal">true</span>);<br>        StatsLog.write(StatsLog.FOREGROUND_SERVICE_STATE_CHANGED,<br>                r.appInfo.uid, r.shortName,<br>                StatsLog.FOREGROUND_SERVICE_STATE_CHANGED__STATE__ENTER);<br>    &#125;<br>    r.postNotification();<br>    <span class="hljs-keyword">if</span> (r.app != <span class="hljs-literal">null</span>) &#123;<br>        updateServiceForegroundLocked(r.app, <span class="hljs-literal">true</span>);<br>    &#125;<br>    getServiceMapLocked(r.userId).ensureNotStartingBackgroundLocked(r);<br>    mAm.notifyPackageUse(r.serviceInfo.packageName,<br>            PackageManager.NOTIFY_PACKAGE_USE_FOREGROUND_SERVICE);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里面的<code> r.postNotification();</code>这里的<code>r</code>是<code>ServiceRecord</code>的一个实例对象，在该方法中调用了<code>ams.mHandler.post(new Runnable())</code>方法，ams是<code>ActivityManagerService</code>的一个实例，在这里创建了一个匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ams.mHandler.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-type">NotificationManagerInternal</span> <span class="hljs-variable">nm</span> <span class="hljs-operator">=</span> LocalServices.getService(<br>                            NotificationManagerInternal.class);<br>                    <span class="hljs-keyword">if</span> (nm == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    <span class="hljs-type">Notification</span> <span class="hljs-variable">localForegroundNoti</span> <span class="hljs-operator">=</span> _foregroundNoti;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (localForegroundNoti.getSmallIcon() == <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-comment">// It is not correct for the caller to not supply a notification</span><br>                            <span class="hljs-comment">// icon, but this used to be able to slip through, so for</span><br>                            <span class="hljs-comment">// those dirty apps we will create a notification clearly</span><br>                            <span class="hljs-comment">// blaming the app.</span><br>                            Slog.v(TAG, <span class="hljs-string">&quot;Attempted to start a foreground service (&quot;</span><br>                                    + name<br>                                    + <span class="hljs-string">&quot;) with a broken notification (no icon: &quot;</span><br>                                    + localForegroundNoti<br>                                    + <span class="hljs-string">&quot;)&quot;</span>);<br><br>                            <span class="hljs-type">CharSequence</span> <span class="hljs-variable">appName</span> <span class="hljs-operator">=</span> appInfo.loadLabel(<br>                                    ams.mContext.getPackageManager());<br>                            <span class="hljs-keyword">if</span> (appName == <span class="hljs-literal">null</span>) &#123;<br>                                appName = appInfo.packageName;<br>                            &#125;<br>                            <span class="hljs-type">Context</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                ctx = ams.mContext.createPackageContextAsUser(<br>                                        appInfo.packageName, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserHandle</span>(userId));<br><br>                                Notification.<span class="hljs-type">Builder</span> <span class="hljs-variable">notiBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notification</span>.Builder(ctx,<br>                                        localForegroundNoti.getChannelId());<br><br>                                <span class="hljs-comment">// it&#x27;s ugly, but it clearly identifies the app</span><br>                                notiBuilder.setSmallIcon(appInfo.icon);<br><br>                                <span class="hljs-comment">// mark as foreground</span><br>                                notiBuilder.setFlag(Notification.FLAG_FOREGROUND_SERVICE, <span class="hljs-literal">true</span>);<br><br>                                <span class="hljs-type">Intent</span> <span class="hljs-variable">runningIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<br>                                        Settings.ACTION_APPLICATION_DETAILS_SETTINGS);<br>                                runningIntent.setData(Uri.fromParts(<span class="hljs-string">&quot;package&quot;</span>,<br>                                        appInfo.packageName, <span class="hljs-literal">null</span>));<br>                                <span class="hljs-type">PendingIntent</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> PendingIntent.getActivityAsUser(ams.mContext, <span class="hljs-number">0</span>,<br>                                        runningIntent, PendingIntent.FLAG_UPDATE_CURRENT, <span class="hljs-literal">null</span>,<br>                                        UserHandle.of(userId));<br>                                notiBuilder.setColor(ams.mContext.getColor(<br>                                        com.android.internal<br>                                                .R.color.system_notification_accent_color));<br>                                notiBuilder.setContentTitle(<br>                                        ams.mContext.getString(<br>                                                com.android.internal.R.string<br>                                                        .app_running_notification_title,<br>                                                appName));<br>                                notiBuilder.setContentText(<br>                                        ams.mContext.getString(<br>                                                com.android.internal.R.string<br>                                                        .app_running_notification_text,<br>                                                appName));<br>                                notiBuilder.setContentIntent(pi);<br><br>                                localForegroundNoti = notiBuilder.build();<br>                            &#125; <span class="hljs-keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (nm.getNotificationChannel(localPackageName, appUid,<br>                                localForegroundNoti.getChannelId()) == <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">targetSdkVersion</span> <span class="hljs-operator">=</span> Build.VERSION_CODES.O_MR1;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-keyword">final</span> <span class="hljs-type">ApplicationInfo</span> <span class="hljs-variable">applicationInfo</span> <span class="hljs-operator">=</span><br>                                        ams.mContext.getPackageManager().getApplicationInfoAsUser(<br>                                                appInfo.packageName, <span class="hljs-number">0</span>, userId);<br>                                targetSdkVersion = applicationInfo.targetSdkVersion;<br>                            &#125; <span class="hljs-keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span> (targetSdkVersion &gt;= Build.VERSION_CODES.O_MR1) &#123;<br>                                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                                        <span class="hljs-string">&quot;invalid channel for service notification: &quot;</span><br>                                                + foregroundNoti);<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (localForegroundNoti.getSmallIcon() == <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-comment">// Notifications whose icon is 0 are defined to not show</span><br>                            <span class="hljs-comment">// a notification, silently ignoring it.  We don&#x27;t want to</span><br>                            <span class="hljs-comment">// just ignore it, we want to prevent the service from</span><br>                            <span class="hljs-comment">// being foreground.</span><br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;invalid service notification: &quot;</span><br>                                    + foregroundNoti);<br>                        &#125;<br>                        nm.enqueueNotification(localPackageName, localPackageName,<br>                                appUid, appPid, <span class="hljs-literal">null</span>, localForegroundId, 												localForegroundNoti,userId);<br><br>                        foregroundNoti = localForegroundNoti; <span class="hljs-comment">// save it for amending next time</span><br>                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>                        Slog.w(TAG, <span class="hljs-string">&quot;Error showing notification for service&quot;</span>, e);<br>                        <span class="hljs-comment">// If it gave us a garbage notification, it doesn&#x27;t</span><br>                        <span class="hljs-comment">// get to be foreground.</span><br>                        ams.setServiceForeground(name, ServiceRecord.<span class="hljs-built_in">this</span>,<br>                                <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);<br>                        ams.crashApplication(appUid, appPid, localPackageName, -<span class="hljs-number">1</span>,<br>                                <span class="hljs-string">&quot;Bad notification for startForeground: &quot;</span> + e);<br>                    &#125;<br>                &#125;<br>            &#125;);<br></code></pre></td></tr></table></figure>

<p>首先检查一下<code>getSmallIcon</code>是不是空，如果是空的，打印日志，然后创建一个新的Notification。然后走不为空的判断：检查有没有<code>NotificationChannel</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">nm.getNotificationChannel(localPackageName, appUid,localForegroundNoti.getChannelId()) == <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>

<p>这里面如果<code>targetSdkVersion &gt;= Build.VERSION_CODES.O_MR1</code>,则会抛出<code>invalid channel for service notification</code>异常。</p>
<p>如果一切正常，入队列发通知。</p>
<hr>
<p>至此，应用中发生崩溃的原因找到了，targetSdk是28，又没有NotificationChannel。</p>
<p>那么，NotificationChannel又是个卵？？？？</p>
<h4 id="NotificationChannel"><a href="#NotificationChannel" class="headerlink" title="NotificationChannel"></a>NotificationChannel</h4><p>从Android 8.0系统开始，Google引入了通知渠道这个概念。</p>
<p>什么是通知渠道呢？顾名思义，就是每条通知都要属于一个对应的渠道。每个App都可以自由地创建当前App拥有哪些通知渠道，但是这些通知渠道的控制权都是掌握在用户手上的。用户可以自由地选择这些通知渠道的重要程度，是否响铃、是否振动、或者是否要关闭这个渠道的通知。</p>
<p>Google这次对于8.0系统通知渠道的推广态度还是比较强硬的。</p>
<p>首先，如果你升级了appcompat库，那么所有使用appcompat库来构建通知的地方全部都会进行废弃方法提示，如下所示：</p>
<p><img src="/image/Android/NotificationChanel/Notification_build.png" alt="通知" title="startForeground通知"></p>
<h5 id="创建NotificationChannel"><a href="#创建NotificationChannel" class="headerlink" title="创建NotificationChannel"></a>创建NotificationChannel</h5><p>创建NotificationChannel对象(不必每次创建)，并且创建通知渠道的代码只在第一次执行的时候才会创建，以后每次执行创建代码系统会检测到该通知渠道已经存在了，因此不会重复创建，也并不会影响任何效率。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">channelId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;take_photo&quot;</span>;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">channelName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;拍照选择图片&quot;</span>;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">importance</span> <span class="hljs-operator">=</span> NotificationManager.IMPORTANCE_HIGH;<br>           <span class="hljs-type">NotificationManager</span><br>                   <span class="hljs-variable">notificationManager</span> <span class="hljs-operator">=</span> (NotificationManager) getSystemService(NOTIFICATION_SERVICE);<br>           <span class="hljs-type">NotificationChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> notificationManager.getNotificationChannel(channelId);<br>           <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;<br>               channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotificationChannel</span>(channelId, channelName, importance);<br>           &#125;<br>           notificationManager.createNotificationChannel(channel);<br>           <span class="hljs-keyword">if</span> (channel.getImportance() == NotificationManager.IMPORTANCE_NONE) &#123;<br>               <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);<br>               intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());<br>               intent.putExtra(Settings.EXTRA_CHANNEL_ID, channel.getId());<br>               startActivity(intent);<br>               Toast.makeText(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;请手动将通知打开&quot;</span>, Toast.LENGTH_SHORT).show();<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-type">Notification</span> <span class="hljs-variable">nf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notification</span>.Builder(<span class="hljs-built_in">this</span>, channelId)<br>                       .setContentText(<span class="hljs-string">&quot;setContentText&quot;</span>)<br>                       .setSettingsText(<span class="hljs-string">&quot;setSettingsText&quot;</span>)<br>                       .setContentTitle(<span class="hljs-string">&quot;setContentTitle&quot;</span>)<br>                       .setSmallIcon(R.drawable.ic_launcher_background)<br>                       .build();<br>               notificationManager.notify(<span class="hljs-number">1</span>, nf);<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>首先要确保的是当前手机的系统版本必须是Android 8.0系统或者更高，因为低版本的手机系统并没有通知渠道这个功能，不做系统版本检查的话会在低版本手机上造成崩溃。创建一个通知渠道至少需要渠道ID、渠道名称以及重要等级这三个参数，其中渠道ID可以随便定义，只要保证全局唯一性就可以。渠道名称是给用户看的，需要能够表达清楚这个渠道的用途。重要等级的不同则会决定通知的不同行为，当然这里只是初始状态下的重要等级，用户可以随时手动更改某个渠道的重要等级，App是无法干预的。</p>
<p>创建通知的代码就不再多做解释了，和传统创建通知的方法没什么两样，只是在NotificationCompat.Builder中需要多传入一个通知渠道ID，那么这里我们传入刚刚创建的渠道ID。</p>
<h5 id="管理通知渠道"><a href="#管理通知渠道" class="headerlink" title="管理通知渠道"></a>管理通知渠道</h5><p>通知渠道一旦创建之后就不能再通过代码修改了，如果用户不小心关闭了该渠道，我们可以通知用户手动去修改，就像动态权限申请一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;<br>	<span class="hljs-type">NotificationChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> manager.getNotificationChannel(<span class="hljs-string">&quot;chat&quot;</span>);<br>    <span class="hljs-keyword">if</span> (channel.getImportance() == NotificationManager.IMPORTANCE_NONE) &#123;<br>    	<span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);<br>        intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());<br>        intent.putExtra(Settings.EXTRA_CHANNEL_ID, channel.getId());<br>        startActivity(intent);<br>        Toast.makeText(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;请手动将通知打开&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过getNotificationChannel()方法获取到了NotificationChannel对象，然后就可以读取该通知渠道下的所有配置了。这里我们判断如果通知渠道的importance等于IMPORTANCE_NONE，就说明用户将该渠道的通知给关闭了，这时会跳转到通知的设置界面提醒用户手动打开。</p>
<p>Android 8.0还赋予了我们删除通知渠道的功能，只需使用如下代码即可删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">NotificationManager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> (NotificationManager)getSystemService(NOTIFICATION_SERVICE);<br>manager.deleteNotificationChannel(channelId);<br></code></pre></td></tr></table></figure>

<p>NotificationChannel章节参考 <a href="https://mp.weixin.qq.com/s/PG8XxHEHpijL4AMZ4AGP8g">https://mp.weixin.qq.com/s/PG8XxHEHpijL4AMZ4AGP8g</a></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android hook--示例</title>
    <url>/2018/08/06/Android-hook-%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>Hook过程：</p>
<ol>
<li>寻找 Hook 点，原则是静态变量或者单例对象，尽量 Hook public 的对象和方法。<br>Hook的选择点：静态变量和单例，因为一旦创建对象，它们不容易变化，非常容易定位。</li>
<li>选择合适的代理方式，如果是接口可以用动态代理。</li>
<li>偷梁换柱——用代理对象替换原始对象。<br>注意Android 的 API 版本比较多，方法和类可能不一样，所以要做好 API 的兼容工作。还有不要hook太底层的东西，各个厂商的rom代码不一样<span id="more"></span></li>
</ol>
<h4 id="hookView的点击事件"><a href="#hookView的点击事件" class="headerlink" title="hookView的点击事件"></a>hookView的点击事件</h4><p>先来个简单点的，View的点击事件。</p>
<h5 id="hookOnLongClick"><a href="#hookOnLongClick" class="headerlink" title="hookOnLongClick"></a>hookOnLongClick</h5><p>顺着View的<code>setOnClickListener</code>方法找到了<code>getListenerInfo</code>方法，进而找到了<code>ListenerInfo</code>类，而view的click，longClick，ScrollChange的监听事件都存放在这里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookOnLongCLickListener</span><span class="hljs-params">(View view)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//拿到mListenerInfo ，可以通过getListenerInfo方法</span><br>        Class&lt;?&gt; clazzView = Class.forName(<span class="hljs-string">&quot;android.view.View&quot;</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getListenerInfoMethod</span> <span class="hljs-operator">=</span> clazzView.getDeclaredMethod(<span class="hljs-string">&quot;getListenerInfo&quot;</span>);<br>        getListenerInfoMethod.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">listenerInfo</span> <span class="hljs-operator">=</span> getListenerInfoMethod.invoke(view);<br><br>        <span class="hljs-comment">//拿到 mOnLongClickListener字段，这里的ListenerInfo是View的内部类，需要用$符号链接。</span><br>        Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;android.view.View$ListenerInfo&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;mOnLongClickListener&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//拿到原来的mOnLongClickListener字段的值</span><br>        View.<span class="hljs-type">OnLongClickListener</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span>(View.OnLongClickListener) field.get(listenerInfo);<br>        <span class="hljs-comment">//替换成我们自己的</span><br>        field.set(listenerInfo, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HookOnLongClickListener</span>(raw));<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HookOnLongClickListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnLongClickListener&#123;<br>    <span class="hljs-keyword">private</span> View.OnLongClickListener raw;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HookOnLongClickListener</span><span class="hljs-params">(View.OnLongClickListener raw)</span>&#123;<br>        <span class="hljs-built_in">this</span>.raw = raw;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onLongClick</span><span class="hljs-params">(View v)</span> &#123;<br>        Log.e(<span class="hljs-string">&quot;HookUtil&quot;</span>,<span class="hljs-string">&quot;HookOnLongClickListener&quot;</span>);<br>        Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;替换之后&quot;</span>,Toast.LENGTH_SHORT).show();<br>        <span class="hljs-keyword">if</span>(raw!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//调用原来的onLongClick，保持原有逻辑不变</span><br>            raw.onLongClick(v);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样调用<code>hookOnLongCLickListerner(view)</code>方法即可在原有逻辑不变的情况下添加我们自己的逻辑。</p>
<h5 id="hookOnLongClick-1"><a href="#hookOnLongClick-1" class="headerlink" title="hookOnLongClick"></a>hookOnLongClick</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookOnClickListener</span><span class="hljs-params">(View view)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//拿到mListenerInfo ，可以通过getListenerInfo方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">getListenerInfoMethod</span> <span class="hljs-operator">=</span> view.getClass().getDeclaredMethod(<span class="hljs-string">&quot;getListenerInfo&quot;</span>);<br>        getListenerInfoMethod.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">listenerInfo</span> <span class="hljs-operator">=</span> getListenerInfoMethod.invoke(view);<br><br>        <span class="hljs-comment">// 得到 原始的 OnClickListener 对象</span><br>        Class&lt;?&gt; listenerInfoClz = Class.forName(<span class="hljs-string">&quot;android.view.View$ListenerInfo&quot;</span>);<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">mOnClickListener</span> <span class="hljs-operator">=</span> listenerInfoClz.getDeclaredField(<span class="hljs-string">&quot;mOnClickListener&quot;</span>);<br>        mOnClickListener.setAccessible(<span class="hljs-literal">true</span>);<br>        View.<span class="hljs-type">OnClickListener</span> <span class="hljs-variable">originOnClickListener</span> <span class="hljs-operator">=</span> (View.OnClickListener) mOnClickListener.get(listenerInfo);<br><br>        <span class="hljs-comment">// 用自定义的 OnClickListener 替换原始的 OnClickListener</span><br>        View.<span class="hljs-type">OnClickListener</span> <span class="hljs-variable">hookedOnClickListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HookedOnClickListener</span>(originOnClickListener);<br>        mOnClickListener.set(listenerInfo, hookedOnClickListener);<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HookedOnClickListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br>    <span class="hljs-keyword">private</span> View.OnClickListener origin;<br><br>    HookedOnClickListener(View.OnClickListener origin) &#123;<br>        <span class="hljs-built_in">this</span>.origin = origin;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;hook click&quot;</span>, Toast.LENGTH_SHORT).show();<br>        Log.i(<span class="hljs-string">&quot;hook&quot;</span>, <span class="hljs-string">&quot;Before click, do what you want to to.&quot;</span>);<br>        <span class="hljs-keyword">if</span> (origin != <span class="hljs-literal">null</span>) &#123;<br>            origin.onClick(v);<br>        &#125;<br>        Log.i(<span class="hljs-string">&quot;hook&quot;</span>, <span class="hljs-string">&quot;After click, do what you want to to.&quot;</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>这样调用<code>hookOnLongClickListerner(view)</code>方法即可在原有逻辑不变的情况下添加我们自己的逻辑。</p>
<h4 id="hookAlarmManager"><a href="#hookAlarmManager" class="headerlink" title="hookAlarmManager"></a>hookAlarmManager</h4><p>在设置Alarm的过程中，会调用AlarmManager.set方法，而AlarmManager对象又很方便得到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">AlarmManager</span> <span class="hljs-variable">alarm</span> <span class="hljs-operator">=</span> (AlarmManager) getSystemService(ALARM_SERVICE);<br>Class&lt;?&gt; alarmManagerClass = alarm.getClass();<br><span class="hljs-type">Field</span> <span class="hljs-variable">mService</span> <span class="hljs-operator">=</span> alarmManagerClass.getDeclaredField(<span class="hljs-string">&quot;mService&quot;</span>);<br>mService.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">mSerViceInstant</span> <span class="hljs-operator">=</span> mService.get(alarm);<br><br><span class="hljs-type">AlarmManagerInvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlarmManagerInvocationHandler</span>(mSerViceInstant);<br>Class&lt;?&gt; IActivityManagerIntercept = Class.forName(<span class="hljs-string">&quot;android.app.IAlarmManager&quot;</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]&#123;IActivityManagerIntercept&#125;, handler);<br>mService.set(alarm, proxy);<br><br><span class="hljs-comment">//动态代理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlarmManagerInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object iAlarmManagerObject;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">AlarmManagerInvocationHandler</span><span class="hljs-params">(Object iAlarmManagerObject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.iAlarmManagerObject = iAlarmManagerObject;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br><br>        Log.i(<span class="hljs-string">&quot;alarm_manager&quot;</span>, method.getName());<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;set&quot;</span>.equals(method.getName())) &#123;<br>            Log.e(<span class="hljs-string">&quot;alarm_manager&quot;</span>, <span class="hljs-string">&quot;调用了mService.set()&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">alarmManagerTimeType</span> <span class="hljs-operator">=</span> Integer.valueOf(args[<span class="hljs-number">1</span>].toString());<br>                <span class="hljs-type">long</span> <span class="hljs-variable">alarmManagerAtTime</span> <span class="hljs-operator">=</span> Long.valueOf(args[<span class="hljs-number">2</span>].toString());<br>                Log.e(<span class="hljs-string">&quot;alarm_manager_interval&quot;</span>, <span class="hljs-string">&quot;alarmManagerTimeType:&quot;</span> +alarmManagerTimeType);<br>                Log.e(<span class="hljs-string">&quot;alarm_manager_interval&quot;</span>, <span class="hljs-string">&quot;alarmManagerAtTime:&quot;</span> +alarmManagerAtTime);<br>                <span class="hljs-keyword">switch</span> (alarmManagerTimeType) &#123;<br>                    <span class="hljs-keyword">case</span> AlarmManager.RTC_WAKEUP:<br>                    <span class="hljs-keyword">case</span> AlarmManager.RTC:<br>                        Log.e(<span class="hljs-string">&quot;alarm_manager_interval&quot;</span>, <span class="hljs-string">&quot;currentTimeMillis--RTC:&quot;</span> +System.currentTimeMillis());<br>                         interval = alarmManagerAtTime - System.currentTimeMillis();<br><br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> AlarmManager.ELAPSED_REALTIME:<br>                    <span class="hljs-keyword">case</span> AlarmManager.ELAPSED_REALTIME_WAKEUP:<br>                        Log.e(<span class="hljs-string">&quot;alarm_manager_interval&quot;</span>, <span class="hljs-string">&quot;currentTimeMillis--ELAPSED_REALTIME:&quot;</span> +SystemClock.elapsedRealtime());<br>                        interval = alarmManagerAtTime - SystemClock.elapsedRealtime();<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                Log.e(<span class="hljs-string">&quot;alarm_manager_interval&quot;</span>,interval+<span class="hljs-string">&quot;--&gt;&quot;</span> + interval/<span class="hljs-number">1000</span>/<span class="hljs-number">60</span> );<br><br><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br><br>        &#125;<br>        <span class="hljs-keyword">return</span> method.invoke(iAlarmManagerObject, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="hookAMS"><a href="#hookAMS" class="headerlink" title="hookAMS"></a>hookAMS</h4><p>对于Activity的启动过程，我们可以hook它的startActivity方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookASM</span><span class="hljs-params">()</span>&#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>         Class&lt;?&gt; activityManagerNativeClass = Class.forName(<span class="hljs-string">&quot;android.app.ActivityManagerNative&quot;</span>);<br>         <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> activityManagerNativeClass.getDeclaredField(<span class="hljs-string">&quot;gDefault&quot;</span>);<br>         field.setAccessible(<span class="hljs-literal">true</span>);<br>         Object gDefault= field.get(<span class="hljs-literal">null</span>);<br><br>         Class&lt;?&gt; singletonClass = Class.forName(<span class="hljs-string">&quot;android.util.Singleton&quot;</span>);<br>         <span class="hljs-type">Field</span> <span class="hljs-variable">mInstance</span> <span class="hljs-operator">=</span> singletonClass.getDeclaredField(<span class="hljs-string">&quot;mInstance&quot;</span>);<br>         mInstance.setAccessible(<span class="hljs-literal">true</span>);<br>         <span class="hljs-type">Object</span> <span class="hljs-variable">iActivityManagerObject</span> <span class="hljs-operator">=</span> mInstance.get(gDefault);<br><br><br>         <span class="hljs-comment">//开始动态代理，用代理对象替换掉真实的ActivityManager，</span><br>         <span class="hljs-type">AmsInvocationHandler</span> <span class="hljs-variable">amsInvocationHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AmsInvocationHandler</span>(iActivityManagerObject);<br>         <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), iActivityManagerObject.getClass().getInterfaces(), amsInvocationHandler);<br><br>         <span class="hljs-comment">//现在替换掉这个对象</span><br>         mInstance.set(gDefault, proxy);<br><br>     &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>         e.printStackTrace();<br>     &#125;<br>&#125;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AmsInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>     <span class="hljs-keyword">private</span> Object iActivityManagerObject;<br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">AmsInvocationHandler</span><span class="hljs-params">(Object iActivityManagerObject)</span> &#123;<br>         <span class="hljs-built_in">this</span>.iActivityManagerObject = iActivityManagerObject;<br>     &#125;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>         Log.i(<span class="hljs-string">&quot;hookASM&quot;</span>, method.getName());<br>         <span class="hljs-comment">//我要在这里搞点事情</span><br>         <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;startActivity&quot;</span>.contains(method.getName())) &#123;<br>             Log.e(<span class="hljs-string">&quot;hookASM&quot;</span>,<span class="hljs-string">&quot;Activity已经开始启动&quot;</span>);<br>         &#125;<br>         <span class="hljs-keyword">return</span> method.invoke(iActivityManagerObject, args);<br>     &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="既然我们能够接管startActivity方法，我们就可以伪造一个Intent去启动一个没有在清单文件中注册的Activity。"><a href="#既然我们能够接管startActivity方法，我们就可以伪造一个Intent去启动一个没有在清单文件中注册的Activity。" class="headerlink" title="既然我们能够接管startActivity方法，我们就可以伪造一个Intent去启动一个没有在清单文件中注册的Activity。"></a>既然我们能够接管startActivity方法，我们就可以伪造一个Intent去启动一个没有在清单文件中注册的Activity。</h2><p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android7.0 MultiWindow</title>
    <url>/2018/06/11/Android7-0%E5%88%86%E5%B1%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Android7.0推出了多窗口(分屏)模式，允许一个屏幕下显示两个应用，可以一边追剧一边看电子书，不过在小一点的手机屏幕上看起来可能有点鸡肋。但是在TV端(这个屏幕就比较大了，一般都是40寸起步)中，画中画模式可以让我们同时进行多个任务了。</p>
<span id="more"></span>
<h4 id="开启分屏"><a href="#开启分屏" class="headerlink" title="开启分屏"></a>开启分屏</h4><p>只要你编译使用sdk版本大于等于7.0就可以支持分屏了：<code>compileSdkVersion 25</code>，如果想要禁用分屏，只需要在<code>AndroidManifest.xml</code>添加属性：android:resizeableActivity&#x3D;”false”，这个属性使用于application和Activity标签。<br>7.0中默认是true。<br>除了分屏模式之外，还有自由模式(Freeform,常见于桌面设备，类似于windows的应用窗口，可以拖拽边缘改变大小)。</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>开启多窗口模式不会更改Activity的生命周期，<br>在多窗口模式中，在指定时间只有最近与用户交互过的 Activity 为活动状态。 该 Activity 将被视为顶级 Activity。 所有其他 Activity 虽然可见，但均处于暂停状态。 但是，这些已暂停但可见的 Activity 在系统中享有比不可见 Activity 更高的优先级。 如果用户与其中一个暂停的 Activity 交互，该 Activity 将恢复，而之前的顶级 Activity 将暂停。</p>
<p>例如：<br><img src="/image/Android/MultiWindow/1.png" alt="MultiWindow"><br>在上图中，我先打开了上面的Activity，然后又打开了下面Gmail的Activity，这时下面的Activity处于可交互(顶级Activity)状态，上面的Activity虽然课件，但是处于暂停状态，这时按下back键是对下面Activity进行操作。当点击上面的Activity时，上面的Activity处于可交互状态，下面的Activity处于暂停状态。<br>PS：在多窗口模式中，用户仍可以看到处于暂停状态的应用。 应用在暂停状态下可能仍需要继续其操作。 例如，处于暂停模式但可见的视频播放应用应继续显示视频。 因此，我们建议播放视频的 Activity 不要暂停其 onPause() 处理程序中的视频。 应暂停 onStop() 中的视频，并恢复 onStart() 中的视频播放。</p>
<p>用户使用多窗口模式显示应用时，系统将通知 Activity 发生配置变更。 该变更与系统通知应用设备从纵向模式切换到横向模式时的 Activity 生命周期影响基本相同，但设备不仅仅是交换尺寸，而是会变更尺寸。您的 Activity 可以自行处理配置变更，或允许系统销毁 Activity，并以新的尺寸重新创建该 Activity。<br>给Activity加上如下配置可以保证切换成多屏模式或者画中画模式时Activity不会销毁重建。<br>android:configChanges&#x3D;”screenSize|smallestScreenSize|screenLayout|orientation”</p>
<h4 id="针对多窗口模式配置应用"><a href="#针对多窗口模式配置应用" class="headerlink" title="针对多窗口模式配置应用"></a>针对多窗口模式配置应用</h4><p>如果应用支持 Android N，您可以对应用的 Activity 是否支持多窗口显示以及显示方式进行配置。 您可以在清单文件中设置属性，以控制大小和布局。 根 Activity 的属性设置适用于其任务栈中的所有 Activity。 例如，如果根 Activity 中 <code>android:resizeableActivity</code> 设定为 true，则任务栈中的所有 Activity 都将可以调整大小。<br>如果使用低于 Android N 版本的 SDK 构建多向应用，则用户在多窗口模式中使用应用时，系统将强制调整应用大小。 系统将显示对话框，提醒用户应用可能会发生异常。 系统不会调整定向应用的大小；如果用户尝试在多窗口模式下打开定向应用，应用将全屏显示。</p>
<p>** android:resizeableActivity **<br>在清单的 <code>&lt;activity&gt;</code> 或 <code>&lt;application&gt;</code> 节点中设置该属性，启用或禁用多窗口显示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">android:resizeableActivity=[&quot;true&quot; | &quot;false&quot;] <br></code></pre></td></tr></table></figure>
<p>如果该属性设置为 true，Activity 将能以分屏和自由形状模式启动。 如果此属性设置为 false，Activity 将不支持多窗口模式。 如果该值为 false，且用户尝试在多窗口模式下启动 Activity，该 Activity 将全屏显示。<br>如果应用面向 Android N，但未对该属性指定值，则该属性的值默认设为 true。</p>
<p>** android:supportsPictureInPicture **<br>在清单文件的 <code>&lt;activity&gt;</code> 节点中设置该属性，指明 Activity 是否支持画中画显示。 如果 <code>android:resizeableActivity</code> 为 false，将忽略该属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">android:supportsPictureInPicture=[&quot;true&quot; | &quot;false&quot;]<br></code></pre></td></tr></table></figure>

<h4 id="布局属性"><a href="#布局属性" class="headerlink" title="布局属性"></a>布局属性</h4><p>对于 Android N，<code>&lt;layout&gt;</code> 清单元素支持以下几种属性，这些属性影响 Activity 在多窗口模式中的行为：</p>
<p><code>android:defaultWidth</code><br>以自由形状模式启动时 Activity 的默认宽度。<br><code>android:defaultHeight</code><br>以自由形状模式启动时 Activity 的默认高度。<br><code>android:gravity</code><br>以自由形状模式启动时 Activity 的初始位置。请参阅 Gravity 参考资料，了解合适的值设置。<br><code>android:minimalHeight、android:minimalWidth</code><br>分屏和自由形状模式中 Activity 的最小高度和最小宽度。 如果用户在分屏模式中移动分界线，使 Activity 尺寸低于指定的最小值，系统会将 Activity 裁剪为用户请求的尺寸。<br>例如，以下节点显示了如何指定 Activity 在自由形状模式中显示时 Activity 的默认大小、位置和最小尺寸：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyActivity&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">android:defaultHeight</span>=<span class="hljs-string">&quot;500dp&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:defaultWidth</span>=<span class="hljs-string">&quot;600dp&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;top|end&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:minimalHeight</span>=<span class="hljs-string">&quot;450dp&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:minimalWidth</span>=<span class="hljs-string">&quot;300dp&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="在多窗口模式中运行应用"><a href="#在多窗口模式中运行应用" class="headerlink" title="在多窗口模式中运行应用"></a>在多窗口模式中运行应用</h4><p>** 多窗口模式中被禁用的功能 **<br>在设备处于多窗口模式中时，某些功能会被禁用或忽略，因为这些功能对与其他 Activity 或应用共享设备屏幕的 Activity 而言没有意义。 此类功能包括：</p>
<ol>
<li>某些系统 UI 自定义选项将被禁用；例如，在非全屏模式中，应用无法隐藏状态栏。</li>
<li>系统将忽略对 android:screenOrientation 属性所作的更改。</li>
</ol>
<p>** 多窗口变更通知和查询 **</p>
<ol>
<li>Activity.isInMultiWindowMode()<br>调用该方法以确认 Activity 是否处于多窗口模式。</li>
<li>Activity.isInPictureInPictureMode()<br>调用该方法以确认 Activity 是否处于画中画模式。<blockquote>
<p>画中画模式是多窗口模式的特例。 如果 myActivity.isInPictureInPictureMode() 返回 true，<br>myActivity.isInMultiWindowMode() 也返回 true。</p>
</blockquote>
</li>
<li>Activity.onMultiWindowModeChanged()<br>Activity 进入或退出多窗口模式时系统将调用此方法。 在 Activity 进入多窗口模式时，系统向该方法传递 true 值，在退出多窗口模式时，则传递 false 值。</li>
<li>Activity.onPictureInPictureModeChanged()<br>Activity 进入或退出画中画模式时系统将调用此方法。 在 Activity 进入画中画模式时，系统向该方法传递 true 值，在退出画中画模式时，则传递 false 值。</li>
</ol>
<p>每个方法还有 Fragment 版本，例如 Fragment.isInMultiWindowMode()。</p>
<h4 id="进入画中画模式"><a href="#进入画中画模式" class="headerlink" title="进入画中画模式"></a>进入画中画模式</h4><p>如需在画中画模式中启动 Activity，请调用新方法 Activity.enterPictureInPictureMode()。 如果设备不支持画中画模式，则此方法无效。 如需了解详细信息，请参阅<a href="https://developer.android.com/guide/topics/ui/picture-in-picture">画中画</a>文档。<br><a href="https://developer.android.com/guide/topics/ui/picture-in-picture">https://developer.android.com/guide/topics/ui/picture-in-picture</a></p>
<h4 id="在多窗口模式中启动新-Activity"><a href="#在多窗口模式中启动新-Activity" class="headerlink" title="在多窗口模式中启动新 Activity"></a>在多窗口模式中启动新 Activity</h4><p>如果只是简单的开启Activity，和在非多窗口模式下是一致的。如果想要在当前Activity的旁边启动Activity，可以添加<code>FLAG_ACTIVITY_LAUNCH_ADJACENT</code>标志位(官方文档说是<code>Intent.FLAG_ACTIVITY_LAUNCH_TO_ADJACENT</code>,但在实际操作中这个标志位不存在)，传递此标志将请求以下行为：</p>
<ol>
<li>如果设备处于分屏模式，系统会尝试在启动系统的 Activity 旁创建新 Activity，这样两个 Activity 将共享屏幕。 系统并不一定能实现此操作，但如果可以，系统将使两个 Activity 处于相邻的位置。</li>
<li>如果设备不处于分屏模式，则该标志无效。<br>如果设备处于自由形状模式，则在启动新 Activity 时，用户可通过调用 ActivityOptions.setLaunchBounds() 指定新 Activity 的尺寸和屏幕位置。 如果设备不处于多窗口模式，则该方法无效。<br>PS:如果在任务栈中启动 Activity，该 Activity 将替换屏幕上的 Activity，并继承其所有的多窗口属性。 如果要在多窗口模式中以单独的窗口启动新 Activity，则必须在新的任务栈中启动此 Activity。</li>
</ol>
<h4 id="支持拖放"><a href="#支持拖放" class="headerlink" title="支持拖放"></a>支持拖放</h4><p>用户可以在两个 Activity 共享屏幕的同时在这两个 Activity 之间拖放数据 （在此之前，用户只能在一个 Activity 内部拖放数据）。 </p>
<ol>
<li>android.view.DropPermissions<br>令牌对象，负责指定对接收拖放数据的应用授予的权限。</li>
<li>View.startDragAndDrop()<br>View.startDrag() 的新别名。要启用跨 Activity 拖放，请传递新标志 View.DRAG_FLAG_GLOBAL。 如需对接收拖放数据的 Activity 授予 URI 权限，可根据情况传递新标志 View.DRAG_FLAG_GLOBAL_URI_READ 或 View.DRAG_FLAG_GLOBAL_URI_WRITE。</li>
<li>View.cancelDragAndDrop()<br>取消当前正在进行的拖动操作。只能由发起拖动操作的应用调用。</li>
<li>View.updateDragShadow()<br>替换当前正在进行的拖动操作的拖动阴影。只能由发起拖动操作的应用调用。</li>
<li>Activity.requestDropPermissions()<br>请求使用 DragEvent 中包含的 ClipData 传递的内容 URI 的权限。</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>** 在当前Activity旁边开启新界面 **<br>如下图所示，上面的界面是MainActivity，下面的Activity是在MainActivity中点击<code>获取实时天气</code>开启的界面<br><img src="/image/Android/MultiWindow/2.png" alt="MultiWindow"><br>在MainActivity中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">findViewById(R.id.get_weather).setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(MainActivity.<span class="hljs-built_in">this</span>,Main2Activity.class);<br>        intent.addFlags(Intent.FLAG_ACTIVITY_LAUNCH_ADJACENT | Intent.FLAG_ACTIVITY_NEW_TASK);<br>        startActivity(intent);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>为什么需要 <code>FLAG_ACTIVITY_NEW_TASK</code>:<br>官方解释</p>
<blockquote>
<p>在同一个Activity返回栈中，打开一个新的Activity时，这个Activity将会继承上一个Activity所有和分屏模式有关的属性。如果你想要在一个独立的窗口以分屏模式打开一个新的Activity，那么必须新建一个Activity返回栈。</p>
</blockquote>
<p>** 拖拽 **<br>首先在多窗口模式下打开新界面，如上面的代码所示。<br>在MainActivity中发起拖拽</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Button</span> <span class="hljs-variable">dragedButton</span> <span class="hljs-operator">=</span> findViewById(R.id.drag_to_another);<span class="hljs-comment">//拖拽按钮</span><br>        dragedButton.setTag(<span class="hljs-string">&quot;this is a test&quot;</span>);<br><br>        dragedButton.setOnTouchListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnTouchListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouch</span><span class="hljs-params">(View v, MotionEvent event)</span> &#123;<br><br>                <span class="hljs-keyword">if</span>(event.getAction() == MotionEvent.ACTION_DOWN)&#123;<br><br>                    ClipData.<span class="hljs-type">Item</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClipData</span>.Item((CharSequence) dragedButton.getTag());<br>                    String[] mimeTypes = &#123;ClipDescription.MIMETYPE_TEXT_PLAIN&#125;;<br>                    <span class="hljs-type">ClipData</span> <span class="hljs-variable">dragData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClipData</span>(v.getTag().toString(), mimeTypes, item);<br>                    View.<span class="hljs-type">DragShadowBuilder</span> <span class="hljs-variable">shadow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.DragShadowBuilder(dragedButton);<br>                    <span class="hljs-comment">/** startDragAndDrop是Android N SDK中的新方法，替代了以前的startDrag，flag需要设置为DRAG_FLAG_GLOBAL */</span><br>                    v.startDragAndDrop(dragData, shadow, <span class="hljs-literal">null</span>, View.DRAG_FLAG_GLOBAL);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure>
<p>在第二个界面中接收拖拽结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">TextView</span> <span class="hljs-variable">textView</span> <span class="hljs-operator">=</span> findViewById(R.id.show_drag_view_tag);<br>        textView.setText(<span class="hljs-string">&quot;拖拽到这里&quot;</span>);<br>        textView.setOnDragListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnDragListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onDrag</span><span class="hljs-params">(View view, DragEvent dragEvent)</span> &#123;<br>                <span class="hljs-keyword">switch</span> (dragEvent.getAction()) &#123;<br>                    <span class="hljs-keyword">case</span> DragEvent.ACTION_DRAG_STARTED:<br>                        Log.d(TAG, <span class="hljs-string">&quot;Action is DragEvent.ACTION_DRAG_STARTED&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br><br>                    <span class="hljs-keyword">case</span> DragEvent.ACTION_DRAG_ENTERED:<br>                        Log.d(TAG, <span class="hljs-string">&quot;Action is DragEvent.ACTION_DRAG_ENTERED&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br><br>                    <span class="hljs-keyword">case</span> DragEvent.ACTION_DRAG_EXITED:<br>                        Log.d(TAG, <span class="hljs-string">&quot;Action is DragEvent.ACTION_DRAG_EXITED&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br><br>                    <span class="hljs-keyword">case</span> DragEvent.ACTION_DRAG_LOCATION:<br>                        <span class="hljs-keyword">break</span>;<br><br>                    <span class="hljs-keyword">case</span> DragEvent.ACTION_DRAG_ENDED:<br>                        Log.d(TAG, <span class="hljs-string">&quot;Action is DragEvent.ACTION_DRAG_ENDED&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br><br>                    <span class="hljs-keyword">case</span> DragEvent.ACTION_DROP:<br>                        Log.d(TAG, <span class="hljs-string">&quot;ACTION_DROP event&quot;</span>);<br>                        <span class="hljs-comment">/** 3.在这里显示接收到的结果 */</span><br>                        textView.setText(dragEvent.getClipData().getItemAt(<span class="hljs-number">0</span>).getText());<br>                        <span class="hljs-keyword">break</span>;<br><br>                    <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>将MainActivity中的拖拽按钮拖放的第二个界面中<code>拖拽到这里</code>view上之后<br><img src="/image/Android/MultiWindow/3.png" alt="MultiWindow"><br>关于startDragAndDrop，官方参考文档在这里<br><a href="https://developer.android.com/reference/android/view/View?hl=zh-cn#startDrag">startDragAndDrop</a><br><a href="https://developer.android.com/reference/android/view/View?hl=zh-cn#startDrag">https://developer.android.com/reference/android/view/View?hl=zh-cn#startDrag</a></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动模式，启动过程</title>
    <url>/2018/07/26/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>面试总结，关于Activity启动模式、启动过程，Intent匹配规则、App启动流程等</p>
<span id="more"></span>
<h5 id="启动模式："><a href="#启动模式：" class="headerlink" title="启动模式："></a>启动模式：</h5><ul>
<li>standard：标准模式，这也是系统的默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。</li>
<li>singleTop：栈顶复用模式。在这种模式下，如果新Activity已经位于任务栈的栈顶，那么此Activity不会被重新创建，同时它的onNewIntent方法会被回调，通过此方法的参数我们可以取出当前请求的信息。需要注意的是，这个Activity的onCreate、onStart不会被系统调用，因为它并没有发生改变。如果新Activity的实例已存在但不是位于栈顶，那么新Activity仍然会重新重建。</li>
<li>singleTask：栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewIntent。</li>
<li>singleInstance：单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中，</li>
</ul>
<p>还有一个参数 <code>TaskAffinity</code>,这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。当然，我们可以为每个Activity都单独指定TaskAffinity属性，这个属性值必须不能和包名相同，否则就相当于没有指定。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。<br>还有Activity中能够影响启动模式、运行状态的标记位：</p>
<p>** FLAG_ACTIVITY_NEW_TASK **<br>这个标记位的作用是为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。<br>** FLAG_ACTIVITY_SINGLE_TOP **<br>这个标记位的作用是为Activity指定“singleTop”启动模式，其效果和在XML中指定该启动模式相同。<br>** FLAG_ACTIVITY_CLEAR_TOP **<br>具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用，在这种情况下，被启动Activity的实例如果已经存在，那么系统会调用它的onNewIntent。如果被启动的Activity采用standard模式启动，那么它连同它之上的Activity都要出栈，系统会创建新的Activity实例并放入栈顶。通过1.2.1节中的分析可以知道，singleTask启动模式默认就具有此标记位的效果。<br>** FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS **<br>具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性android:excludeFromRecents&#x3D;”true”。</p>
<h5 id="Intent匹配规则"><a href="#Intent匹配规则" class="headerlink" title="Intent匹配规则"></a>Intent匹配规则</h5><p>启动Activity分为两种，显式调用和隐式调用。显式调用需要明确地指定被启动对象的组件信息，包括包名和类名，而隐式调用则不需要明确指定组件信息。原则上一个Intent不应该既是显式调用又是隐式调用，如果二者<br>共存的话以显式调用为主。显式调用很简单，这里主要介绍一下隐式调用。隐式调用需要Intent能够匹配目标组件的IntentFilter中所设置的过滤信息，如果不匹配将无法启动目标Activity。<br>为了匹配过滤列表，需要同时匹配过滤列表中的action、category、data信息，否则匹配失败。一个过滤列表中的action、category和data可以有多个，所有的action、category、data分别构成不同类别，同一类别的信息共同约束当前类别的匹配过程。只有一个Intent同时匹配action类别、category类别、data类别才算完全匹配，只有完全匹配才能成功启动目标Activity。另外一点，一个Activity中可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应的Activity。</p>
<ul>
<li>action的匹配规则<br>action是一个字符串，系统预定义了一些action，同时我们也可以在应用中定义自己的action。action的匹配规则是Intent中的action必须能够和过滤规则中的action匹配，这里说的匹配是指action的字符串值完全一样。一个过滤规则中可以有多个action，那么只要Intent中的action能够和过滤规则中的任何一个action相同即可匹配成功。需要注意的是，Intent中如果没有指定action，那么匹配失败。另外，action区分大小写，大小写不同字符串相同的action会匹配失败。</li>
<li>category的匹配规则<br>category是一个字符串，系统预定义了一些category，同时我们也可以在应用中定义自己的category。category的匹配规则和action不同，它要求Intent中如果含有category，那么所有的category都必须和过滤规则中的其中一个category相同。换句话说，Intent中如果出现了category，不管有几个category，对于每个category来说，它必须是过滤规则中已经定义了的category。当然，Intent中可以没有category，如果没有category的话，按照上面的描述，这个Intent仍然可以匹配成功。这里要注意下它和action匹配过程的不同，action是要求Intent中必须有一个action且必须能够和过滤规则中的某个action相同，而category要求<br>Intent可以没有category，但是如果你一旦有category，不管有几个，每个都要能够和过滤规则中的任何一个category相同。</li>
<li>data的匹配规则<br>data的匹配规则和action类似，如果过滤规则中定义了data，那么Intent中必须也要定义可匹配的data。在介绍data的匹配规则之前，我们需要先了解一下data的结构，因为data稍微有些复杂<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">data</span>   <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:host</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:port</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:path</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:pathPattern</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:pathPrefix</span>=<span class="hljs-string">&quot;string&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:mimeType</span>=<span class="hljs-string">&quot;string&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
data由两部分组成，mimeType和URI。mimeType指媒体类型，比如image&#x2F;jpeg、audio&#x2F;mpeg4-generic和video&#x2F;*等，可以表示图片、文本、视频等不同的媒体格式，而URI中包含的数据就比较多了，下面是URI的结构：<br><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</code><br>有如下过滤规则</li>
</ul>
<p><code>&lt;data android:mimeType=&quot;image/*&quot; /&gt;</code><br>这种规则指定了媒体类型为所有类型的图片，那么Intent中的mimeType属性必须为“image&#x2F;*”才能匹配，这种情况下虽然过滤规则没有指定URI，但是却有默认值，URI的默认值为content和file。也就是说，虽然没有指定URI，但是Intent中的URI部分的schema必须为content或者file才能匹配，这点是需要尤其注意的。为了匹配上面中规则，我们可以写出如下示例<br><code>intent.setDataAndType(Uri.parse(&quot;file://abc&quot;),&quot;image/png&quot;)。</code><br>另外，如果要为Intent指定完整的data，必须要调用setDataAndType方法，不能先调用setData再调用setType，因为这两个方法彼此会清除对方的值。<br>最后，当我们通过隐式方式启动一个Activity的时候，可以做一下判断，看是否有Activity能够匹配我们的隐式Intent，如果不做判断就有可能出现上述的错误了。判断方法有两种：采用PackageManager的resolveActivity方法或者Intent的resolveActivity方法，如果它们找不到匹配的Activity就会返回null，我们通过判断返回值就可以规避上述错误了。另外，PackageManager还提供了queryIntentActivities方法，这个方法和resolveActivity方法不同的是：它不是返回最佳匹配的Activity信息而是返回所有成功匹配的Activity信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> List&lt;ResolveInfo&gt; <span class="hljs-title function_">queryIntentActivities</span><span class="hljs-params">(Intent intent,<span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ResolveInfo <span class="hljs-title function_">resolveActivity</span><span class="hljs-params">(Intent intent,<span class="hljs-type">int</span> flags)</span>;<br></code></pre></td></tr></table></figure>
<p>上述两个方法的第一个参数比较好理解，第二个参数需要注意，我们要使用MATCH_DEFAULT_ONLY这个标记位，这个标记位的含义是仅仅匹配那些在intent-filter中声明了<br><code>&lt;category  android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</code>这个category的Activity。使用这个标记位的意义在于，只要上述两个方法不返回null，那么startActivity一定可以成功。如果不用这个标记位，就可以把intent-filter中category不含DEFAULT的那些Activity给匹配出来，从而导致startActivity可能失败。因为不含有DEFAULT这个category的Activity是无法接收隐式Intent的。</p>
<h5 id="App启动过程"><a href="#App启动过程" class="headerlink" title="App启动过程"></a>App启动过程</h5><ol>
<li>点击桌面App图标，Launch进程采用Binder IPC向system_server进程发起startActivity请求</li>
<li>system_server收到请求后，向zygote进程发送创建进程请求。</li>
<li>Zygote进程fork出新的子进程，即App进程。</li>
<li>App进程通过Binder IPC向system_server进程发起attachApplication请求</li>
<li>system_server进程在收到请求后，进行一系列的准备工作，再通过Binder IPC向App进程发送scheduleLaunchActivity请求。</li>
<li>App进程的binder线程(ApplicationThread)在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；</li>
<li>主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法；</li>
<li>到此，App便正式启动，开始进入Activity生命周期。</li>
</ol>
<p>** 涉及到的类 **</p>
<ul>
<li><code>Activity</code> startActivity方法的真正实现在Activity中。</li>
<li><code>Instrumentation</code> 每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作,用来辅助Activity完成启动Activity的过程。</li>
<li><code>ActivityThread</code>（包含ApplicationThread + ApplicationThreadNative + IApplicationThread）：真正启动Activity的实现都在这里,应用的入口类，系统通过调用main函数，开启消息循环队列。ActivityThread所在线程被称为应用的主线程（UI线程）。与ActivityManagerServices配合，一起完成Activity的管理工作。</li>
<li><code>ActivityManagerService</code> 简称AMS，服务端对象。AMS是Android中最核心的服务之一，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要，它本身也是一个Binder的实现类。</li>
<li><code>ActivityManagerProxy</code> AMS服务在当前进程的代理类，负责与AMS通信。</li>
<li><code>ApplicationThread</code> 用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。</li>
<li><code>ApplicationThreadProxy</code> 是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。</li>
<li><code>ActivityStack</code> Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</li>
<li><code>ActivityRecord</code> ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</li>
<li><code>TaskRecord</code> AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。</li>
</ul>
<p>** 基本概念 **</p>
<h6 id="zygote"><a href="#zygote" class="headerlink" title="zygote"></a>zygote</h6><p>Android是基于Linux系统的，而在Linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote进程也不例外。至于init进程怎么来的，可以搜一下Android系统启动过程。<br>在Android系统里面，zygote是一个进程的名字。Android是基于Linux System的，当你的手机开机的时候，Linux的内核加载完成之后就会启动一个叫“init“的进程。在Linux System里面，所有的进程都是由init进程fork出来的，我们的zygote进程也不例外。<br>我们都知道，每一个App其实都是</p>
<ul>
<li>一个单独的虚拟机</li>
<li>一个单独的进程<br>所以当系统里面的第一个zygote进程运行之后，在这之后再开启App，就相当于开启一个新的进程。而为了实现资源共用和更快的启动速度，Android系统开启新进程的方式，是通过fork第一个zygote进程实现的。所以说，除了第一个zygote进程，其他应用所在的进程都是zygote的子进程，</li>
</ul>
<h6 id="SystemServer"><a href="#SystemServer" class="headerlink" title="SystemServer"></a>SystemServer</h6><p>它也是个进程，而且是由zygote进程fork出来的。系统里面重要的服务都是在这个进程里面开启的，比如<code>ActivityManagerService</code>、<code>PackageManagerService</code>、<code>WindowManagerService</code> 等等。在zygote开启的时候，会调用ZygoteInit.main()进行初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Startup class for the zygote process.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Pre-initializes some classes, and then waits for commands on a UNIX domain</span><br><span class="hljs-comment"> * socket. Based on these commands, forks off child processes that inherit</span><br><span class="hljs-comment"> * the initial state of the VM.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Please see &#123;<span class="hljs-doctag">@link</span> ZygoteConnection.Arguments&#125; for documentation on the</span><br><span class="hljs-comment"> * client protocol.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p>从注释上也可以看出这个类主要是为了初始化某些参数。比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preload</span><span class="hljs-params">(TimingsTraceLog bootTimingsTraceLog)</span> &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;begin preload&quot;</span>);<br>        bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;BeginIcuCachePinning&quot;</span>);<br>        beginIcuCachePinning();<br>        bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// BeginIcuCachePinning</span><br>        bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;PreloadClasses&quot;</span>);<br>        preloadClasses();<br>        bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// PreloadClasses</span><br>        bootTimingsTraceLog.traceBegin(<span class="hljs-string">&quot;PreloadResources&quot;</span>);<br>        preloadResources();<br>        bootTimingsTraceLog.traceEnd(); <span class="hljs-comment">// PreloadResources</span><br>        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, <span class="hljs-string">&quot;PreloadAppProcessHALs&quot;</span>);<br>        nativePreloadAppProcessHALs();<br>        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);<br>        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, <span class="hljs-string">&quot;PreloadOpenGL&quot;</span>);<br>        preloadOpenGL();<br>        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);<br>        preloadSharedLibraries();<br>        preloadTextResources();<br>        <span class="hljs-comment">// Ask the WebViewFactory to do any initialization that must run in the zygote process,</span><br>        <span class="hljs-comment">// for memory sharing purposes.</span><br>        WebViewFactory.prepareWebViewInZygote();<br>        endIcuCachePinning();<br>        warmUpJcaProviders();<br>        Log.d(TAG, <span class="hljs-string">&quot;end preload&quot;</span>);<br><br>        sPreloadComplete = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lazyPreload</span><span class="hljs-params">()</span> &#123;<br>        Preconditions.checkState(!sPreloadComplete);<br>        Log.i(TAG, <span class="hljs-string">&quot;Lazily preloading resources.&quot;</span>);<br><br>        preload(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimingsTraceLog</span>(<span class="hljs-string">&quot;ZygoteInitTiming_lazy&quot;</span>, Trace.TRACE_TAG_DALVIK));<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>还有一些关键的方法<code>preloadSharedLibraries()</code>、<code>preloadOpenGL()</code>、<code>preloadTextResources()</code>、<code>preloadClasses()</code>、<code>preloadResources()</code>、<code>preloadDrawables()</code>、<code>preloadColorStateLists()</code> 等.还有一个<code>startSystemServer()</code>方法。</p>
<h6 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h6><p>简称AMS,服务端对象，负责系统中所有Activity生命周期。它的初始化时机很明确，就是在SystemServer进程开启的时候，就会初始化ActivityManagerService。具体情况可以看一下<code>SystemServer.java</code>类。<br>经过上面这些步骤，我们的ActivityManagerService对象已经创建好了，并且完成了成员变量初始化。而且在这之前，调用createSystemContext()创建系统上下文的时候，也已经完成了mSystemContext和ActivityThread的创建。注意，这是系统进程开启时的流程，在这之后，会开启系统的Launcher程序，完成系统界面的加载与显示。</p>
<h6 id="为什么说AMS是服务端对象"><a href="#为什么说AMS是服务端对象" class="headerlink" title="为什么说AMS是服务端对象"></a>为什么说AMS是服务端对象</h6><p>其实服务器客户端的概念不仅仅存在于Web开发中，在Android的框架设计中，使用的也是这一种模式。服务器端指的就是所有App共用的系统服务，比如我们这里提到的ActivityManagerService，和前面提到的PackageManagerService、WindowManagerService等等，这些基础的系统服务是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你想打开一个App，那么我们知道了包名和MainActivity类名之后就可以打开</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_MAIN);  <br>intent.addCategory(Intent.CATEGORY_LAUNCHER);<br><span class="hljs-type">ComponentName</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentName</span>(packageName, className);<br>intent.setComponent(cn);  <br>startActivity(intent);<br></code></pre></td></tr></table></figure>

<p>但是，我们的App通过调用startActivity()并不能直接打开另外一个App，这个方法会通过一系列的调用，最后还是告诉AMS说：“我要打开这个App，我知道他的住址和名字，你帮我打开吧！”所以是AMS来通知zygote进程来fork一个新进程，来开启我们的目标App的。这就像是浏览器想要打开一个超链接一样，浏览器把网页地址发送给服务器，然后还是服务器把需要的资源文件发送给客户端的。</p>
<p>知道了Android Framework的客户端服务器架构之后，我们还需要了解一件事情，那就是我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？<br>App与AMS通过Binder进行IPC通信，AMS(SystemServer进程)与zygote通过Socket进行IPC通信。<br>那么AMS有什么用呢？在前面我们知道了，如果想打开一个App的话，需要AMS去通知zygote进程，除此之外，其实所有的Activity的开启、暂停、关闭都需要AMS来控制，所以我们说，AMS负责系统中所有Activity的生命周期。<br>在Android系统中，任何一个Activity的启动都是由AMS和应用程序进程（主要是ActivityThread）相互配合来完成的。AMS服务统一调度系统中所有进程的Activity启动，而每个Activity的启动过程则由其所属的进程具体来完成。</p>
<h6 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h6><p>当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。Launcher本质上也是一个应用程序，和我们的App一样，也是继承自Activity，系统源码可以在这里看 <a href="http://androidxref.com/8.0.0_r4/xref/packages/apps/Launcher3/src/com/android/launcher3/Launcher.java">http://androidxref.com/8.0.0_r4/xref/packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">View <span class="hljs-title function_">createShortcut</span><span class="hljs-params">(<span class="hljs-type">int</span> layoutResId, ViewGroup parent, ShortcutInfo info)</span> &#123;<br>        <span class="hljs-type">BubbleTextView</span> <span class="hljs-variable">favorite</span> <span class="hljs-operator">=</span> (BubbleTextView) mInflater.inflate(layoutResId, parent, <span class="hljs-literal">false</span>);<br>        favorite.applyFromShortcutInfo(info, mIconCache);<br>        favorite.setOnClickListener(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> favorite;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建图标并设置点击监听</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Launches the intent referred by the clicked shortcut.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> v The view representing the clicked shortcut.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-comment">// Make sure that rogue clicks don&#x27;t get through while allapps is launching, or after the</span><br>        <span class="hljs-comment">// view has detached (it&#x27;s possible for this to happen if the view is removed mid touch).</span><br>        <span class="hljs-keyword">if</span> (v.getWindowToken() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!mWorkspace.isFinishedSwitchingState()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">tag</span> <span class="hljs-operator">=</span> v.getTag();<br>        <span class="hljs-keyword">if</span> (tag <span class="hljs-keyword">instanceof</span> ShortcutInfo) &#123;<br>            <span class="hljs-comment">// Open shortcut</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> ((ShortcutInfo) tag).intent;<br>            <span class="hljs-type">int</span>[] pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>            v.getLocationOnScreen(pos);<br>            intent.setSourceBounds(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Rect</span>(pos[<span class="hljs-number">0</span>], pos[<span class="hljs-number">1</span>],<br>                    pos[<span class="hljs-number">0</span>] + v.getWidth(), pos[<span class="hljs-number">1</span>] + v.getHeight()));<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> startActivitySafely(v, intent, tag);<br><br>            <span class="hljs-keyword">if</span> (success &amp;&amp; v <span class="hljs-keyword">instanceof</span> BubbleTextView) &#123;<br>                mWaitingForResume = (BubbleTextView) v;<br>                mWaitingForResume.setStayPressed(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag <span class="hljs-keyword">instanceof</span> FolderInfo) &#123;<br>            <span class="hljs-keyword">if</span> (v <span class="hljs-keyword">instanceof</span> FolderIcon) &#123;<br>                <span class="hljs-type">FolderIcon</span> <span class="hljs-variable">fi</span> <span class="hljs-operator">=</span> (FolderIcon) v;<br>                handleFolderClick(fi);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v == mAllAppsButton) &#123;<br>            <span class="hljs-keyword">if</span> (isAllAppsVisible()) &#123;<br>                showWorkspace(<span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                onClickAllAppsButton(v);<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p>从上面可以看到，在桌面上点击快捷图标的时候，会调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">startActivitySafely(v, intent, tag);<br></code></pre></td></tr></table></figure>
<p>具体代码就不抄了，看一下上面的链接中的源码就好，在该方法中调用了<code>startActivity(v, intent, tag)</code>，这里会调用Activity.startActivity(intent, opts.toBundle())，这个方法熟悉吗？这就是我们经常用到的Activity.startActivity(Intent)的重载函数。而且由于设置了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br></code></pre></td></tr></table></figure>
<p>所以这个Activity会添加到一个新的Task栈中，而且，startActivity()调用的其实是startActivityForResult()这个方法。<br>所以现在明确了，Launcher中开启一个App，其实和我们在Activity中直接startActivity()基本一样，都是调用了Activity.startActivityForResult()。</p>
<h6 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h6><p>每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。当startActivityForResult()调用之后，实际上还是调用了mInstrumentation.execStartActivity().<br>下面是mInstrumetation.execStartActivity()的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title function_">execStartActivity</span><span class="hljs-params">(</span><br><span class="hljs-params">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="hljs-params">            Intent intent, <span class="hljs-type">int</span> requestCode, Bundle options)</span> &#123;<br>        <span class="hljs-type">IApplicationThread</span> <span class="hljs-variable">whoThread</span> <span class="hljs-operator">=</span> (IApplicationThread) contextThread;<br>        <span class="hljs-type">Uri</span> <span class="hljs-variable">referrer</span> <span class="hljs-operator">=</span> target != <span class="hljs-literal">null</span> ? target.onProvideReferrer() : <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (referrer != <span class="hljs-literal">null</span>) &#123;<br>            intent.putExtra(Intent.EXTRA_REFERRER, referrer);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mActivityMonitors != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (mSync) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> mActivityMonitors.size();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">ActivityMonitor</span> <span class="hljs-variable">am</span> <span class="hljs-operator">=</span> mActivityMonitors.get(i);<br>                    <span class="hljs-keyword">if</span> (am.match(who, <span class="hljs-literal">null</span>, intent)) &#123;<br>                        am.mHits++;<br>                        <span class="hljs-keyword">if</span> (am.isBlocking()) &#123;<br>                            <span class="hljs-keyword">return</span> requestCode &gt;= <span class="hljs-number">0</span> ? am.getResult() : <span class="hljs-literal">null</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            intent.migrateExtraStreamToClipData();<br>            intent.prepareToLeaveProcess();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> ActivityManagerNative.getDefault()<br>                .startActivity(whoThread, who.getBasePackageName(), intent,<br>                        intent.resolveTypeIfNeeded(who.getContentResolver()),<br>                        token, target != <span class="hljs-literal">null</span> ? target.mEmbeddedID : <span class="hljs-literal">null</span>,<br>                        requestCode, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, options);<br>            checkStartActivityResult(result, intent);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Failure from system&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p>这里的 ActivityManagerNative.getDefault 返回ActivityManagerService的远程接口，即 ActivityManagerProxy 接口，有人可能会问了为什么会是ActivityManagerProxy，这就涉及到Binder通信了，这里不再展开。通过Binder驱动程序， ActivityManagerProxy 与AMS服务通信，则实现了跨进程到System进程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Retrieve the system&#x27;s default/global activity manager.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IActivityManager <span class="hljs-title function_">getDefault</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> gDefault.get();<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>&lt;IActivityManager&gt;() &#123;<br>       <span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title function_">create</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-type">IBinder</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ServiceManager.getService(<span class="hljs-string">&quot;activity&quot;</span>);<br>           <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>               Log.v(<span class="hljs-string">&quot;ActivityManager&quot;</span>, <span class="hljs-string">&quot;default service binder = &quot;</span> + b);<br>           &#125;<br>           <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">am</span> <span class="hljs-operator">=</span> asInterface(b);<br>           <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>               Log.v(<span class="hljs-string">&quot;ActivityManager&quot;</span>, <span class="hljs-string">&quot;default service = &quot;</span> + am);<br>           &#125;<br>           <span class="hljs-keyword">return</span> am;<br>       &#125;<br>   &#125;;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Cast a Binder object into an activity manager interface, generating</span><br><span class="hljs-comment">    * a proxy if needed.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IActivityManager <span class="hljs-title function_">asInterface</span><span class="hljs-params">(IBinder obj)</span> &#123;<br>       <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>       &#125;<br>       <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span><br>           (IActivityManager)obj.queryLocalInterface(descriptor);<br>       <span class="hljs-keyword">if</span> (in != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> in;<br>       &#125;<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityManagerProxy</span>(obj);<br>   &#125;<br></code></pre></td></tr></table></figure>
<h6 id="AMS响应Launcher进程请求"><a href="#AMS响应Launcher进程请求" class="headerlink" title="AMS响应Launcher进程请求"></a>AMS响应Launcher进程请求</h6><p>至此，点击桌面图标调用startActivity()，终于把数据和要开启Activity的请求发送到了AMS了,AMS收到startActivity的请求之后，会按照如下的方法链进行调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">startActivity</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span><br><span class="hljs-params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-type">int</span> requestCode,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> &#123;<br>        <span class="hljs-keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,<br>            resultWho, requestCode, startFlags, profilerInfo, options,<br>            UserHandle.getCallingUserId());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">startActivityAsUser</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span><br><span class="hljs-params">            Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="hljs-type">int</span> requestCode,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options, <span class="hljs-type">int</span> userId)</span> &#123;<br>        enforceNotIsolatedCaller(<span class="hljs-string">&quot;startActivity&quot;</span>);<br>        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,<br>                <span class="hljs-literal">false</span>, ALLOW_FULL_ONLY, <span class="hljs-string">&quot;startActivity&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Switch to user app stacks here.</span><br>        <span class="hljs-keyword">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class="hljs-number">1</span>, callingPackage, intent,<br>                resolvedType, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, resultTo, resultWho, requestCode, startFlags,<br>                profilerInfo, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, options, <span class="hljs-literal">false</span>, userId, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里又出现了一个<code>mStackSupervisor</code>，定义是这么说的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Run all ActivityStacks through this */</span><br>    ActivityStackSupervisor mStackSupervisor;<br><br></code></pre></td></tr></table></figure>
<p>在<code>mStackSupervisor.startActivityMayWait()</code>方法中又调用了<code>startActivityLocked()</code>方法，接着调用了<code>startActivityUncheckedLocked()</code>方法，在这个方法中一大堆眼花缭乱的判断，最终调用了<code>targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options)</code>方法，然后调用了<code>mStackSupervisor.resumeTopActivitiesLocked(this, r, options)</code>方法，然后调用<code>result = targetStack.resumeTopActivityLocked(target, targetOptions)</code>方法，调用<code>result = resumeTopActivityInnerLocked(prev, options)</code>方法，在这个方法里，prev.app为记录启动Lancher进程的ProcessRecord，prev.app.thread为Lancher进程的远程调用接口IApplicationThead，所以可以调用prev.app.thread.schedulePauseActivity，到Lancher进程暂停指定Activity。至此，AMS对Launcher的请求已经响应，这是我们发现又通过Binder通信回调至Launcher进程</p>
<h6 id="Launcher进程挂起Launcher，再次通知AMS"><a href="#Launcher进程挂起Launcher，再次通知AMS" class="headerlink" title="Launcher进程挂起Launcher，再次通知AMS"></a>Launcher进程挂起Launcher，再次通知AMS</h6><p>看一下怎么挂起Launcher的,在ActivityThread中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePauseActivity</span><span class="hljs-params">(IBinder token, <span class="hljs-type">boolean</span> finished,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> userLeaving, <span class="hljs-type">int</span> configChanges, <span class="hljs-type">boolean</span> dontReport)</span> &#123;<br>        <span class="hljs-type">ActivityClientRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> mActivities.get(token);<br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r);</span><br>            <span class="hljs-keyword">if</span> (userLeaving) &#123;<br>                performUserLeavingActivity(r);<br>            &#125;<br><br>            r.activity.mConfigChangeFlags |= configChanges;<br>            performPauseActivity(token, finished, r.isPreHoneycomb());<br><br>            <span class="hljs-comment">// Make sure any pending writes are now committed.</span><br>            <span class="hljs-keyword">if</span> (r.isPreHoneycomb()) &#123;<br>                QueuedWork.waitToFinish();<br>            &#125;<br><br>            <span class="hljs-comment">// Tell the activity manager we have paused.</span><br>            <span class="hljs-keyword">if</span> (!dontReport) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    ActivityManagerNative.getDefault().activityPaused(token);<br>                &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>                &#125;<br>            &#125;<br>            mSomeActivitiesChanged = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这部分Launcher的ActivityThread处理页面Paused并且再次通过ActivityManagerProxy通知AMS。</p>
<h6 id="AMS创建新的进程"><a href="#AMS创建新的进程" class="headerlink" title="AMS创建新的进程"></a>AMS创建新的进程</h6><p>创建新进程的时候，AMS会保存一个ProcessRecord信息，如果应用程序中的AndroidManifest.xml配置文件中，我们没有指定Application标签的process属性，系统就会默认使用package的名称。每一个应用程序都有自己的uid，因此，这里uid + process的组合就可以为每一个应用程序创建一个ProcessRecord。<br>在<code>ActivityManagerService</code>中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startProcessLocked</span><span class="hljs-params">(ProcessRecord app, String hostingType,</span><br><span class="hljs-params">            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> SystemClock.elapsedRealtime();<br>        ......<br>        <span class="hljs-comment">// Start the process.  It will either succeed and return a result containing</span><br>            <span class="hljs-comment">// the PID of the new process, or else throw a RuntimeException.</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isActivityProcess</span> <span class="hljs-operator">=</span> (entryPoint == <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (entryPoint == <span class="hljs-literal">null</span>) entryPoint = <span class="hljs-string">&quot;android.app.ActivityThread&quot;</span>;<br>            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;Start proc: &quot;</span> +<br>                    app.processName);<br>            checkTime(startTime, <span class="hljs-string">&quot;startProcess: asking zygote to start proc&quot;</span>);<br>            Process.<span class="hljs-type">ProcessStartResult</span> <span class="hljs-variable">startResult</span> <span class="hljs-operator">=</span> Process.start(entryPoint,<br>                    app.processName, uid, uid, gids, debugFlags, mountExternal,<br>                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,<br>                    app.info.dataDir, entryPointArgs);<br>            checkTime(startTime, <span class="hljs-string">&quot;startProcess: returned from zygote!&quot;</span>);<br>            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br><br>            <span class="hljs-keyword">if</span> (app.isolated) &#123;<br>                mBatteryStatsService.addIsolatedUid(app.uid, app.info.uid);<br>            &#125;<br>            mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);<br>            checkTime(startTime, <span class="hljs-string">&quot;startProcess: done updating battery stats&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>这里主要是调用Process.start接口来创建一个新的进程，新的进程会导入android.app.ActivityThread类，并且执行它的main函数，这就是每一个应用程序都有一个ActivityThread实例来对应的原因。</p>
<h6 id="应用进程初始化"><a href="#应用进程初始化" class="headerlink" title="应用进程初始化"></a>应用进程初始化</h6><p>来看Activity的main函数，这里绑定了主线程的Looper，并进入消息循环，大家应该知道，整个Android系统是消息驱动的，这也是为什么主线程默认绑定Looper的原因：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;ActivityThreadMain&quot;</span>);<br>        SamplingProfilerIntegration.start();<br><br>        <span class="hljs-comment">// CloseGuard defaults to true and can be quite spammy.  We</span><br>        <span class="hljs-comment">// disable it here, but selectively enable it later (via</span><br>        <span class="hljs-comment">// StrictMode) on debug builds, but using DropBox, not logs.</span><br>        CloseGuard.setEnabled(<span class="hljs-literal">false</span>);<br><br>        Environment.initForCurrentUser();<br><br>        <span class="hljs-comment">// Set the reporter for event logging in libcore</span><br>        EventLogger.setReporter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EventLoggingReporter</span>());<br><br>        AndroidKeyStoreProvider.install();<br><br>        <span class="hljs-comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">configDir</span> <span class="hljs-operator">=</span> Environment.getUserConfigDirectory(UserHandle.myUserId());<br>        TrustedCertificateStore.setDefaultUserDirectory(configDir);<br><br>        Process.setArgV0(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>);<br><br>        Looper.prepareMainLooper();<br><br>        <span class="hljs-type">ActivityThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityThread</span>();<br>        thread.attach(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-keyword">if</span> (sMainThreadHandler == <span class="hljs-literal">null</span>) &#123;<br>            sMainThreadHandler = thread.getHandler();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>            Looper.myLooper().setMessageLogging(<span class="hljs-keyword">new</span><br>                    <span class="hljs-title class_">LogPrinter</span>(Log.DEBUG, <span class="hljs-string">&quot;ActivityThread&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-comment">// End of event ActivityThreadMain.</span><br>        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>        Looper.loop();<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>attach函数最终调用了ActivityManagerService的远程接口ActivityManagerProxy的attachApplication函数，传入的参数是mAppThread，这是一个ApplicationThread类型的Binder对象，它的作用是AMS与应用进程进行进程间通信的。<br>将进程和指定的Application绑定起来。这个是通过上节的ActivityThread对象中调用bindApplication()方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中, 最终通过handleBindApplication()方法处理该消息. 然后调用makeApplication()方法来加载App的classes到内存中。</p>
<h6 id="在AMS中注册应用进程，启动栈顶页面"><a href="#在AMS中注册应用进程，启动栈顶页面" class="headerlink" title="在AMS中注册应用进程，启动栈顶页面"></a>在AMS中注册应用进程，启动栈顶页面</h6><p>mMainStack.topRunningActivityLocked(null)从堆栈顶端取出要启动的Activity，并在realStartActivityLockedhan函数中通过ApplicationThreadProxy调回App进程启动页面。<br>在<code>ActivityStackSupervisor</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">realStartActivityLocked</span><span class="hljs-params">(ActivityRecord r,</span><br><span class="hljs-params">            ProcessRecord app, <span class="hljs-type">boolean</span> andResume, <span class="hljs-type">boolean</span> checkConfig)</span><br>            <span class="hljs-keyword">throws</span> RemoteException &#123;<br>                    app.thread.scheduleLaunchActivity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(r.intent), r.appToken,<br>                    System.identityHashCode(r), r.info, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(mService.mConfiguration),<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>(stack.mOverrideConfig), r.compat, r.launchedFromPackage,<br>                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,<br>                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);<br>            &#125;<br></code></pre></td></tr></table></figure>
<p>它会调用application线程对象中的scheduleLaunchActivity()发送一个LAUNCH_ACTIVITY消息到消息队列中, 通过 handleLaunchActivity()来处理该消息。在 handleLaunchActivity()通过performLaunchActiivty()方法回调Activity的onCreate()方法和onStart()方法，然后通过handleResumeActivity()方法，回调Activity的onResume()方法，而后会通知AMS该MainActivity已经处于resume状态最终显示Activity界面。<br>至此，整个启动流程告一段落。</p>
<p>最后：</p>
<h6 id="一个App的程序入口到底是什么？"><a href="#一个App的程序入口到底是什么？" class="headerlink" title="一个App的程序入口到底是什么？"></a>一个App的程序入口到底是什么？</h6><p>是ActivityThread.main()。</p>
<h6 id="整个App的主线程的消息循环是在哪里创建的？"><a href="#整个App的主线程的消息循环是在哪里创建的？" class="headerlink" title="整个App的主线程的消息循环是在哪里创建的？"></a>整个App的主线程的消息循环是在哪里创建的？</h6><p>是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Handler不需要指定Looper，而如果在其他线程使用Handler，则需要单独使用Looper.prepare()和Looper.loop()创建消息循环。可以看ActivityThread的main方法</p>
<h6 id="Application是在什么时候创建的？onCreate-什么时候调用的？"><a href="#Application是在什么时候创建的？onCreate-什么时候调用的？" class="headerlink" title="Application是在什么时候创建的？onCreate()什么时候调用的？"></a>Application是在什么时候创建的？onCreate()什么时候调用的？</h6><p>也是在ActivityThread.main()的时候，就是在thread.attach(false)的时候。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!system) &#123;<br>            ViewRootImpl.addFirstDrawHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    ensureJitEnabled();<br>                &#125;<br>            &#125;);<br>            android.ddm.DdmHandleAppName.setAppName(<span class="hljs-string">&quot;&lt;pre-initialized&gt;&quot;</span>,<br>                                                    UserHandle.myUserId());<br>            RuntimeInit.setApplicationObject(mAppThread.asBinder());<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">mgr</span> <span class="hljs-operator">=</span> ActivityManagerNative.getDefault();<br>            <span class="hljs-keyword">try</span> &#123;<br>                mgr.attachApplication(mAppThread);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>                <span class="hljs-comment">// Ignore</span><br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里需要关注的就是mgr.attachApplication(mAppThread)，这个就会通过Binder调用到AMS里面对应的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachApplication</span><span class="hljs-params">(IApplicationThread thread)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">origId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>        attachApplicationLocked(thread, callingPid);<br>        Binder.restoreCallingIdentity(origId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后调用的就是<code>private final boolean attachApplicationLocked(IApplicationThread thread,int pid)</code>方法，thread是IApplicationThread，实际上就是ApplicationThread在服务端的代理类ApplicationThreadProxy，然后又通过IPC就会调用到ApplicationThread的对应方法。这个方法里面又调用了<code>sendMessage()</code>，里面有函数的编号H.BIND_APPLICATION，然后这个Messge会被H这个Handler处理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BIND_APPLICATION</span>        <span class="hljs-operator">=</span> <span class="hljs-number">110</span>;<br>    <span class="hljs-keyword">case</span> BIND_APPLICATION:<br>                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="hljs-string">&quot;bindApplication&quot;</span>);<br>                    <span class="hljs-type">AppBindData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (AppBindData)msg.obj;<br>                    handleBindApplication(data);<br>                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);<br>                    <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后在<code>handleBindApplication(data)</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">try</span> &#123;<br>      java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> instrContext.getClassLoader();<br>      mInstrumentation = (Instrumentation)cl.loadClass(data.instrumentationName.getClassName()).newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Unable to instantiate instrumentation &quot;</span>+ data.instrumentationName + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br><br>        ......<br>         <span class="hljs-comment">// Do this after providers, since instrumentation tests generally start their</span><br>            <span class="hljs-comment">// test thread at this point, and we don&#x27;t want that racing.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                mInstrumentation.onCreate(data.instrumentationArgs);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                    <span class="hljs-string">&quot;Exception thrown in onCreate() of &quot;</span><br>                    + data.instrumentationName + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                mInstrumentation.callApplicationOnCreate(app);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                        <span class="hljs-string">&quot;Unable to create application &quot;</span> + app.getClass().getName()<br>                        + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            StrictMode.setThreadPolicy(savedPolicy);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不同的版本代码不尽相同，但是基本逻辑不会变。<br>参考、抄袭的链接如下：<br><a href="https://blog.csdn.net/bfboys/article/details/52564531">https://blog.csdn.net/bfboys/article/details/52564531</a><br><a href="https://www.jianshu.com/p/a72c5ccbd150">https://www.jianshu.com/p/a72c5ccbd150</a><br><a href="https://www.jianshu.com/p/6037f6fda285">https://www.jianshu.com/p/6037f6fda285</a><br><a href="https://www.jianshu.com/p/a72c5ccbd150">https://www.jianshu.com/p/a72c5ccbd150</a></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidService</title>
    <url>/2018/08/01/AndroidService/</url>
    <content><![CDATA[<p>《Android开发艺术探索》9.3章<br><code>Service</code>分为两种工作状态,一种是启动状态，主要用于执行后台计算;另一种是绑定态,主要用于其他组件和<code>Service</code>的交互。需要注意的是，<code>Service</code>的这两种状态是可以共存的，即<code>Service</code>既可以处于启动状态也可以同时处于绑定状态。<br>通过<code>Context</code>的<code>startService</code>方法即可启动一个<code>Service</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(content,Service.class);<br>startService(intent);<br></code></pre></td></tr></table></figure>
<p>通过<code>Context</code>的<code>bindService</code>方法可以绑定一个<code>Service</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(content,Service.class);<br>bindService(intent,connection,BIND_AUTO_CREATE);<br></code></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="Service启动过程"><a href="#Service启动过程" class="headerlink" title="Service启动过程"></a>Service启动过程</h4><p><code>Service</code>的启动时从<code>ContextWrapper</code>的<code>startService</code>开始的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ComponentName <span class="hljs-title function_">startService</span><span class="hljs-params">(Intent service)</span> &#123;<br>        <span class="hljs-keyword">return</span> mBase.startService(service);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><code>mBase</code>是<code>Context</code>的实现类<code>ContextImpl</code>，<code>在Activity</code>启动的时候会通过<code>attach</code>方法关联一个<code>ContextImpl</code>，这个<code>ContextImpl</code>就是上面的<code>mBase</code>，从<code>ContextWrapper</code>的实现来看，大部分的实现都是通过<code>mBase</code>来实现的，这是一种典型的桥接模式。在<code>ContextImpl</code>的<code>startService</code>方法中又调用了<code>startServiceCommon</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ComponentName <span class="hljs-title function_">startService</span><span class="hljs-params">(Intent service)</span> &#123;<br>        warnIfCallingFromSystemProcess();<br>        <span class="hljs-keyword">return</span> startServiceCommon(service, <span class="hljs-literal">false</span>, mUser);<br>    &#125;<br><span class="hljs-keyword">private</span> ComponentName <span class="hljs-title function_">startServiceCommon</span><span class="hljs-params">(Intent service, <span class="hljs-type">boolean</span> requireForeground,UserHandle user)</span> &#123;<br><br>    validateServiceIntent(service);<br>    service.prepareToLeaveProcess(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">//api 27</span><br>    <span class="hljs-type">ComponentName</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> ActivityManager.getService().startService(<br>        mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(<br>                    getContentResolver()), requireForeground,<br>                    getOpPackageName(), user.getIdentifier());<br>    <span class="hljs-comment">//api 25</span><br>    <span class="hljs-comment">//ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br>     <span class="hljs-comment">//   mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br>      <span class="hljs-comment">//  getContentResolver()), getOpPackageName(), user.getIdentifier());</span><br><br>    <span class="hljs-keyword">return</span> cn;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>startServiceCommon</code>中通过<code>getService</code>这个对象来启动一个服务，这个对象就是AMS，需要注意的是，在上述代码中通过AMS来启动服务的过程是一个跨进程调用。AMS的<code>startService</code>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ComponentName <span class="hljs-title function_">startService</span><span class="hljs-params">(IApplicationThread caller, Intent service,</span><br><span class="hljs-params">            String resolvedType, String callingPackage, <span class="hljs-type">int</span> userId)</span><br>            <span class="hljs-keyword">throws</span> TransactionTooLargeException &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">callingUid</span> <span class="hljs-operator">=</span> Binder.getCallingUid();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">origId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>            <span class="hljs-type">ComponentName</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> mServices.startServiceLocked(caller, service,<br>                    resolvedType, callingPid, callingUid, callingPackage, userId);<br>            Binder.restoreCallingIdentity(origId);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>AMS会通过<code>mServices</code>来完成<code>service</code>的启动过程，<code>mServices</code>的对象类型是<code>ActiveServices</code>，<code>ActiveServices</code>是一个辅助AMS进行<code>Service</code>管理的类，包括<code>Service</code>的启动、绑定和停止。在<code>startService</code>方法的尾部会调用<code>startServiceInnerLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ComponentName <span class="hljs-title function_">startServiceInnerLocked</span><span class="hljs-params">(ServiceMap smap, Intent service, ServiceRecord r,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> callerFg, <span class="hljs-type">boolean</span> addToStarting)</span> <span class="hljs-keyword">throws</span> TransactionTooLargeException &#123;<br>        <span class="hljs-type">ServiceState</span> <span class="hljs-variable">stracker</span> <span class="hljs-operator">=</span> r.getTracker();<br>        <span class="hljs-keyword">if</span> (stracker != <span class="hljs-literal">null</span>) &#123;<br>            stracker.setStarted(<span class="hljs-literal">true</span>, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);<br>        &#125;<br>        r.callStart = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;<br>            r.stats.startRunningLocked();<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">error</span> <span class="hljs-operator">=</span> bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span> r.name;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>上述代码中<code>ServiceRecord</code>是描述一个Service记录，<code>ServiceRecord</code>一直贯穿整个Service流程，<code>startServiceInnerLocked</code>并没有完成启动Service的完整流程，而是将后续的过程交给了<code>bringUpServiceLocked</code>，在该方法中又调用了<code>realStartServiceLocked</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">realStartServiceLocked</span><span class="hljs-params">(ServiceRecord r,</span><br><span class="hljs-params">            ProcessRecord app, <span class="hljs-type">boolean</span> execInFg)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>       <br>        r.app = app;<br>        r.restartTime = r.lastActivity = SystemClock.uptimeMillis();<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">newService</span> <span class="hljs-operator">=</span> app.services.add(r);<br>        bumpServiceExecutingLocked(r, execInFg, <span class="hljs-string">&quot;create&quot;</span>);<br>        mAm.updateLruProcessLocked(app, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        mAm.updateOomAdjLocked();<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <br>            <span class="hljs-keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;<br>                r.stats.startLaunchedLocked();<br>            &#125;<br>            mAm.notifyPackageUse(r.serviceInfo.packageName,<br>                                 PackageManager.NOTIFY_PACKAGE_USE_SERVICE);<br>            app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);<br>            app.thread.scheduleCreateService(r, r.serviceInfo,<br>                    mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),<br>                    app.repProcState);<br>            r.postNotification();<br>            created = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (DeadObjectException e) &#123;<br>            Slog.w(TAG, <span class="hljs-string">&quot;Application dead when creating service &quot;</span> + r);<br>            mAm.appDiedLocked(app);<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (!created) &#123;<br>                <span class="hljs-comment">// Keep the executeNesting count accurate.</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">inDestroying</span> <span class="hljs-operator">=</span> mDestroyingServices.contains(r);<br>                serviceDoneExecutingLocked(r, inDestroying, inDestroying);<br><br>                <span class="hljs-comment">// Cleanup.</span><br>                <span class="hljs-keyword">if</span> (newService) &#123;<br>                    app.services.remove(r);<br>                    r.app = <span class="hljs-literal">null</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// Retry.</span><br>                <span class="hljs-keyword">if</span> (!inDestroying) &#123;<br>                    scheduleServiceRestartLocked(r, <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (r.whitelistManager) &#123;<br>            app.whitelistManager = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        requestServiceBindingsLocked(r, execInFg);<br><br>        updateServiceClientActivitiesLocked(app, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// If the service is in the started state, and there are no</span><br>        <span class="hljs-comment">// pending arguments, then fake up one so its onStartCommand() will</span><br>        <span class="hljs-comment">// be called.</span><br>        <span class="hljs-keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="hljs-number">0</span>) &#123;<br>            r.pendingStarts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceRecord</span>.StartItem(r, <span class="hljs-literal">false</span>, r.makeNextStartId(),<br>                    <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>));<br>        &#125;<br><br>        sendServiceArgsLocked(r, execInFg, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-keyword">if</span> (r.delayed) &#123;<br>            <span class="hljs-keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="hljs-string">&quot;REM FR DELAY LIST (new proc): &quot;</span> + r);<br>            getServiceMap(r.userId).mDelayedStartList.remove(r);<br>            r.delayed = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (r.delayedStop) &#123;<br>            <span class="hljs-comment">// Oh and hey we&#x27;ve already been asked to stop!</span><br>            r.delayedStop = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (r.startRequested) &#123;<br>                <span class="hljs-keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,<br>                        <span class="hljs-string">&quot;Applying delayed stop (from start): &quot;</span> + r);<br>                stopServiceLocked(r);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在<code>realStartServiceLocked</code>方法中，首先通过<code>app.thread</code>的<code>scheduleCreateService</code>方法来创建<code>Service</code>对象并调用其<code>onCreate</code>,接着再通过<code>sendServiceArgsLocked</code>方法来调用<code>Service</code>的其他方法，比如<code>onStartCommand</code>,这两个过程均是进程间通信。<code>app.thread</code>对象是<code>IApplicationThread</code>类型，它实际上是一个<code>Binder</code>,它的具体实现是<code>ApplicationThread</code>和<code>ApplicationThreadNative</code>。由于<code>ApplicationThread</code>继承了<code>ApplicationThreadNative</code>,因此只需要看<code>ApplicationThread</code>对<code>Service</code>启动过程的处理即可，这对应着它的<code>scheduleCreateService</code>方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleCreateService</span><span class="hljs-params">(IBinder token,</span><br><span class="hljs-params">               ServiceInfo info, CompatibilityInfo compatInfo, <span class="hljs-type">int</span> processState)</span> &#123;<br>           updateProcessState(processState, <span class="hljs-literal">false</span>);<br>           <span class="hljs-type">CreateServiceData</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CreateServiceData</span>();<br>           s.token = token;<br>           s.info = info;<br>           s.compatInfo = compatInfo;<br><br>           sendMessage(H.CREATE_SERVICE, s);<br>       &#125;<br></code></pre></td></tr></table></figure>
<p>通过发送消息给<code>Handler H</code>来完成的。H会接收这个<code>CREATE_ SERVICE</code>消息并通过<code>ActivityThread</code>的<code>handleCreateService</code>方法来完成Service的最终启动，<code>handleCreateService</code>的源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleCreateService</span><span class="hljs-params">(CreateServiceData data)</span> &#123;<br>        <span class="hljs-comment">// If we are getting ready to gc after going to the background, well</span><br>        <span class="hljs-comment">// we are back active so skip it.</span><br>        unscheduleGcIdler();<br>        <span class="hljs-type">LoadedApk</span> <span class="hljs-variable">packageInfo</span> <span class="hljs-operator">=</span> getPackageInfoNoCheck(<br>                data.info.applicationInfo, data.compatInfo);<br>        <span class="hljs-type">Service</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>            java.lang.<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> packageInfo.getClassLoader();<br>            service = (Service) cl.loadClass(data.info.name).newInstance();<br><br>            <span class="hljs-type">ContextImpl</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> ContextImpl.createAppContext(<span class="hljs-built_in">this</span>, packageInfo);<br>            context.setOuterContext(service);<br><br>            <span class="hljs-type">Application</span> <span class="hljs-variable">app</span> <span class="hljs-operator">=</span> packageInfo.makeApplication(<span class="hljs-literal">false</span>, mInstrumentation);<br>            service.attach(context, <span class="hljs-built_in">this</span>, data.info.name, data.token, app,<br>                    ActivityManagerNative.getDefault());<br>            service.onCreate();<br>            mServices.put(data.token, service);<br>            ActivityManagerNative.getDefault().serviceDoneExecuting(<br>                        data.token, SERVICE_DONE_EXECUTING_ANON, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p><code>handleCreateService</code>主要完成了以下几件事：<br>首先通过类加载器创建了Service实例，接着创建<code>ContextImpl</code>对象和<code>Application</code>对象  并通过service.attach方法建立联系，最后调用<code>service.onCreate</code>方法，并将<code>service</code>存储在<code>ActivityThread</code>中的一个列表<code>mServices</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ArrayMap&lt;IBinder, Service&gt; mServices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>
<p>由于<code>service</code>的<code>onCreate</code>方法执行了，也就意味着<code>Service</code>已经启动了。除此之外，<code>ActivityThead</code>中还会通过<code>handleServiceArgs</code>方法调用<code>Service</code>的<code>onStartCommand</code>方法。</p>
<h4 id="Service绑定过程"><a href="#Service绑定过程" class="headerlink" title="Service绑定过程"></a>Service绑定过程</h4><p>和启动过程一样，也是从<code>ContextWrapper</code>开始的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">bindService</span><span class="hljs-params">(Intent service, ServiceConnection conn,</span><br><span class="hljs-params">        <span class="hljs-type">int</span> flags)</span> &#123;<br>    <span class="hljs-keyword">return</span> mBase.bindService(service, conn, flags);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后是<code>ContextImpl</code>的<code>bindService</code>方法调用<code>bindServiceCommon</code>方法，然后远程调用AMS的<code>bindService</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">bindServiceCommon</span><span class="hljs-params">(Intent service, ServiceConnection conn, <span class="hljs-type">int</span> flags, Handler handler, UserHandle user)</span> &#123;<br>    <span class="hljs-comment">// Keep this in sync with DevicePolicyManager.bindDeviceAdminServiceAsUser.</span><br>    IServiceConnection sd;<br>    <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;connection is null&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mPackageInfo != <span class="hljs-literal">null</span>) &#123;<br>        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Not supported in system context&quot;</span>);<br>    &#125;<br>    validateServiceIntent(service);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">IBinder</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> getActivityToken();<br>        <span class="hljs-keyword">if</span> (token == <span class="hljs-literal">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="hljs-number">0</span> &amp;&amp; mPackageInfo != <span class="hljs-literal">null</span><br>                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion<br>                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;<br>            flags |= BIND_WAIVE_PRIORITY;<br>        &#125;<br>        service.prepareToLeaveProcess(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> ActivityManager.getService().bindService(<br>            mMainThread.getApplicationThread(), getActivityToken(), service,<br>            service.resolveTypeIfNeeded(getContentResolver()),<br>            sd, flags, getOpPackageName(), user.getIdentifier());<br>        <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityException</span>(<br>                    <span class="hljs-string">&quot;Not allowed to bind to service &quot;</span> + service);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res != <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在该方法中，首先将客户端的<code>ServiceConnection</code>转化为<code>ServiceDispatcher.InnerConnection</code>对象，因为服务绑定是跨进程的，所以<code>ServiceConnection</code>对象必须借助<code>Binder</code>对象才能让远程服务端调用自己的方法。<code>ServiceDispatcher</code>起着连接<code>ServiceConnection</code>和<code>InnerConnection</code>的作用。这个过程由<code>LoadedApk.getServiceDispatcher</code>方法完成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> IServiceConnection <span class="hljs-title function_">getServiceDispatcher</span><span class="hljs-params">(ServiceConnection c,</span><br><span class="hljs-params">            Context context, Handler handler, <span class="hljs-type">int</span> flags)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (mServices) &#123;<br>            LoadedApk.<span class="hljs-type">ServiceDispatcher</span> <span class="hljs-variable">sd</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);<br>            <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (DEBUG) Slog.d(TAG, <span class="hljs-string">&quot;Returning existing dispatcher &quot;</span> + sd + <span class="hljs-string">&quot; for conn &quot;</span> + c);<br>                sd = map.get(c);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (sd == <span class="hljs-literal">null</span>) &#123;<br>                sd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceDispatcher</span>(c, context, handler, flags);<br>                <span class="hljs-keyword">if</span> (DEBUG) Slog.d(TAG, <span class="hljs-string">&quot;Creating new dispatcher &quot;</span> + sd + <span class="hljs-string">&quot; for conn &quot;</span> + c);<br>                <span class="hljs-keyword">if</span> (map == <span class="hljs-literal">null</span>) &#123;<br>                    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;&gt;();<br>                    mServices.put(context, map);<br>                &#125;<br>                map.put(c, sd);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sd.validate(context, handler);<br>            &#125;<br>            <span class="hljs-keyword">return</span> sd.getIServiceConnection();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，<code>mServices</code>是一个<code>ArrayMap</code>，它存储了一个应用当前活动的<code>ServiceConnection</code>和<code>ServiceDispatcher</code>的映射关系，其声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices<br>        = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>
<p>系统首先会查找是否存在相同的<code>ServiceConnection</code>,如果不存在就重新创建一个<code>ServiceDispatcher</code>对象，并将其存储在<code>mServices</code>中，其中映射关系的key是<code>ServiceConnection</code>,value是<code>ServiceDispatcher</code>,在<code>ServiceDispatcher</code>的内部又保存了<code>ServiceConnection</code>和<code>InnerConnection</code>对象。当<code>Service</code>和客户端建立连接后，系统会通过<code>InnerConnection</code>来调用<code>ServiceConnection</code>中的<code>onServiceConnected</code>方法，这个过程有可能是跨进程的。当<code>ServiceDispatcher</code>创建好了以后，<code>getServiceDispatcher</code>会 返回其保存的<code>InnerConnection</code>对象。<br>接着调用AMS的<code>bindService</code>  方法，该方法又调用了<code>bindServiceLocked</code>–&gt;<code>bringUpServiceLocked</code>–&gt;<code>realStartServiceLocked</code>，这个过程和上面的<code>StartService</code>过程逻辑类似，最终都是通过<code>ApplicationThread</code>来完成<code>Service</code>的实例创建并调用<code>onCreate</code>方法。和启动<code>Service</code>过程不同的是，绑定过程会调用<code>app.thread</code>的<code>scheduleBindService</code>方法，这个过程的实现在<code>ActivityService</code>的<code>requestServiceBindingsLocked</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestServiceBindingsLocked</span><span class="hljs-params">(ServiceRecord r, <span class="hljs-type">boolean</span> execInFg)</span><br>           <span class="hljs-keyword">throws</span> TransactionTooLargeException &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=r.bindings.size()-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>           <span class="hljs-type">IntentBindRecord</span> <span class="hljs-variable">ibr</span> <span class="hljs-operator">=</span> r.bindings.valueAt(i);<br>           <span class="hljs-keyword">if</span> (!requestServiceBindingLocked(r, ibr, execInFg, <span class="hljs-literal">false</span>)) &#123;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure>
<p>该方法用到了<code>r.bindings</code>。它是一个<code>ArrayMap</code>，保存了客户端的<code>bind</code>消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt; bindings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;Intent.FilterComparison, IntentBindRecord&gt;();<br></code></pre></td></tr></table></figure>
<p>具体保存方法在AMS一开始的方法<code>bindServiceLocked</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">AppBindRecord</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> s.retrieveAppBindingLocked(service, callerApp);<br></code></pre></td></tr></table></figure>
<p>在<code>requestServiceBindingsLocked</code>方法中调用了了<code>requestServiceBindingLocked</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">requestServiceBindingLocked</span><span class="hljs-params">(ServiceRecord r, IntentBindRecord i,</span><br><span class="hljs-params">            <span class="hljs-type">boolean</span> execInFg, <span class="hljs-type">boolean</span> rebind)</span> <span class="hljs-keyword">throws</span> TransactionTooLargeException &#123;<br>        <span class="hljs-keyword">if</span> (r.app == <span class="hljs-literal">null</span> || r.app.thread == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// If service is not currently running, can&#x27;t yet bind.</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.d(TAG_SERVICE, <span class="hljs-string">&quot;requestBind &quot;</span> + i + <span class="hljs-string">&quot;: requested=&quot;</span> + i.requested<br>                + <span class="hljs-string">&quot; rebind=&quot;</span> + rebind);<br>        <span class="hljs-keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                bumpServiceExecutingLocked(r, execInFg, <span class="hljs-string">&quot;bind&quot;</span>);<br>                r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);<br>                r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,<br>                        r.app.repProcState);<br>                <span class="hljs-keyword">if</span> (!rebind) &#123;<br>                    i.requested = <span class="hljs-literal">true</span>;<br>                &#125;<br>                i.hasBound = <span class="hljs-literal">true</span>;<br>                i.doRebind = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (TransactionTooLargeException e) &#123;<br>                <span class="hljs-comment">// Keep the executeNesting count accurate.</span><br>                <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="hljs-string">&quot;Crashed while binding &quot;</span> + r, e);<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">inDestroying</span> <span class="hljs-operator">=</span> mDestroyingServices.contains(r);<br>                serviceDoneExecutingLocked(r, inDestroying, inDestroying);<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                <span class="hljs-keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="hljs-string">&quot;Crashed while binding &quot;</span> + r);<br>                <span class="hljs-comment">// Keep the executeNesting count accurate.</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">inDestroying</span> <span class="hljs-operator">=</span> mDestroyingServices.contains(r);<br>                serviceDoneExecutingLocked(r, inDestroying, inDestroying);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在上述代码中，<code>app.thread</code>这个对象多次出现过，它实际上就是<code>ApplicationThread</code>。<code>ApplicationThread</code>的一系列以<code>schedule</code>开头的方法，其内部都是通过<code>Handler H</code>来中转的，对于<code>scheduleBindService</code>方法来说也是如此，它的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleBindService</span><span class="hljs-params">(IBinder token, Intent intent,</span><br><span class="hljs-params">                <span class="hljs-type">boolean</span> rebind, <span class="hljs-type">int</span> processState)</span> &#123;<br>            updateProcessState(processState, <span class="hljs-literal">false</span>);<br>            <span class="hljs-type">BindServiceData</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindServiceData</span>();<br>            s.token = token;<br>            s.intent = intent;<br>            s.rebind = rebind;<br>            sendMessage(H.BIND_SERVICE, s);<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>在H内部，接收到<code>BIND_SERVICE</code>这类消息时，会交给<code>ActivityThread</code>的<code>handleBindService</code>方法来处理。在<code>handleBindService</code>中，首先根据<code>Service</code>的<code>token</code>取出<code>Service</code>对象，然后调用<code>Service</code>的<code>onBind</code>方法，<code>Service</code>的<code>onBind</code>方法会返回一个<code>Binder</code>对象给客户端使用，原则上来说，<code>Service</code>的<code>onBind</code>方法被调用以后，<code>Service</code>就处于绑定状态了，但是<code>onBind</code>方法是<code>Service</code>的方法，这个时候客户端并不知道已经成功连接<code>Service</code>了，所以还必须调用客户端的<code>ServiceConnection</code>中的<code>onServiceConnected</code>,这个过程是由<code>ActivityManager.getService()</code>的<code>publishService</code>方法来完成的，而前面多次提到，<code>ActivityManager.getService()</code>就是AMS。<code>handleBindService</code>的实现过程如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleBindService</span><span class="hljs-params">(BindServiceData data)</span> &#123;<br>        <span class="hljs-type">Service</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> mServices.get(data.token);<br>        <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                data.intent.setExtrasClassLoader(s.getClassLoader());<br>                data.intent.prepareToEnterProcess();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (!data.rebind) &#123;<br>                        <span class="hljs-type">IBinder</span> <span class="hljs-variable">binder</span> <span class="hljs-operator">=</span> s.onBind(data.intent);<br>                        ActivityManager.getService().publishService(<br>                                data.token, data.intent, binder);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        s.onRebind(data.intent);<br>                        ActivityManager.getService().serviceDoneExecuting(<br>                                data.token, SERVICE_DONE_EXECUTING_ANON, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>                    &#125;<br>                    ensureJitEnabled();<br>                &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>                    <span class="hljs-keyword">throw</span> ex.rethrowFromSystemServer();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                            <span class="hljs-string">&quot;Unable to bind to service &quot;</span> + s<br>                            + <span class="hljs-string">&quot; with &quot;</span> + data.intent + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>Service有一个特性，当多次绑定同一个Service时，Service的<code>onBind</code>方法<strong>只会执行一次</strong>，除非Service被终止了。当Service的onBind执行以后，系统还需要告知客户端已经成功连接Service了。根据上面的分析，这个过程由AMS的<code>publishService</code>方法来实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publishService</span><span class="hljs-params">(IBinder token, Intent intent, IBinder service)</span> &#123;<br>        <span class="hljs-comment">// Refuse possible leaked file descriptors</span><br>        <span class="hljs-keyword">if</span> (intent != <span class="hljs-literal">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;File descriptors passed in Intent&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!(token <span class="hljs-keyword">instanceof</span> ServiceRecord)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid service token&quot;</span>);<br>            &#125;<br>            mServices.publishServiceLocked((ServiceRecord)token, intent, service);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>从_上面代码可以看出，AMS的<code>publishService</code>方法将具体的工作交给了<code>ActiveServices</code>类型的<code>mServices</code>对象来处理。<code>ActiveServices</code>的<code>publishServiceLocked</code>方法看起来很复杂，但其实核心代码就只有一- 句话: <code>c.conn.connected(r.name,service)</code>， 其中c的类型是<code>ConnectionRecord</code>，<code>c.comn</code>的类型是<code>ServiceDispatcher.InnerConnection</code>, service就是Service的onBind方法返回的Binder对象。为了分析具体的逻辑，下面看一下<code>ServiceDispatcher.InnerConnection</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerConnection</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IServiceConnection</span>.Stub &#123;<br>            <span class="hljs-keyword">final</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;<br><br>            InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;<br>                mDispatcher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;LoadedApk.ServiceDispatcher&gt;(sd);<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connected</span><span class="hljs-params">(ComponentName name, IBinder service, <span class="hljs-type">boolean</span> dead)</span><br>                    <span class="hljs-keyword">throws</span> RemoteException &#123;<br>                LoadedApk.<span class="hljs-type">ServiceDispatcher</span> <span class="hljs-variable">sd</span> <span class="hljs-operator">=</span> mDispatcher.get();<br>                <span class="hljs-keyword">if</span> (sd != <span class="hljs-literal">null</span>) &#123;<br>                    sd.connected(name, service, dead);<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>从<code>InnerConnection</code>的定义可以看出来，它的<code>connected</code>方法又调用了<code>ServiceDispatcher</code>的<code>connected</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connected</span><span class="hljs-params">(ComponentName name, IBinder service, <span class="hljs-type">boolean</span> dead)</span> &#123;<br>            <span class="hljs-keyword">if</span> (mActivityThread != <span class="hljs-literal">null</span>) &#123;<br>                mActivityThread.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RunConnection</span>(name, service, <span class="hljs-number">0</span>, dead));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                doConnected(name, service, dead);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>对于Service的绑定过程来讲，<code>ServiceDispatcher</code>中的<code>mActivityThread</code>就是一个<code>handler</code>，它就是<code>ActivityThread</code>中的<code>H</code>，从<code>Service</code>的创建过程来讲，<code>mActivityTHread</code>不会为<code>null</code>，这样一来，<code>RunConnection</code>就可以经由<code>H</code>的<code>post</code>方法从而运行在主线程中，因此，客户端的<code>ServiceConnection</code>中的方法回调是在主线程中执行的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>            RunConnection(ComponentName name, IBinder service, <span class="hljs-type">int</span> command, <span class="hljs-type">boolean</span> dead) &#123;<br>                mName = name;<br>                mService = service;<br>                mCommand = command;<br>                mDead = dead;<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">if</span> (mCommand == <span class="hljs-number">0</span>) &#123;<br>                    doConnected(mName, mService, mDead);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCommand == <span class="hljs-number">1</span>) &#123;<br>                    doDeath(mName, mService);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">final</span> ComponentName mName;<br>            <span class="hljs-keyword">final</span> IBinder mService;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> mCommand;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> mDead;<br>        &#125;<br><br></code></pre></td></tr></table></figure>
<p>很显然，<code>RunConnection</code>的<code>run</code>方法也是简单调用了<code>ServiceDispatcher</code>的<code>doConnected</code>方法，由于<code>ServiceDispatcher</code>内部保存了客户端的<code>ServiceConnection</code>对象，因此它可以很方便地调用<code>ServiceConnection</code>对象的<code>onServiceConnected</code>方法，如下所示。<br>至此，bindService的过程完成。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android hook--反射基础</title>
    <url>/2018/08/06/Android-hook--%E5%8F%8D%E5%B0%84%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>假如你已经非常熟悉java中反射(reflect)和代理(Proxy)，那你还在这里看我这篇文章纯粹就是浪费时间了。</p>
<span id="more"></span>
<h4 id="反射是什么"><a href="#反射是什么" class="headerlink" title="反射是什么"></a>反射是什么</h4><p>官方介绍</p>
<blockquote>
<p>Reflection is commonly used by programs which require the ability to examine or modify the runtime behavior of applications running in the Java virtual machine. This is a relatively advanced feature and should be used only by developers who have a strong grasp of the fundamentals of the language. With that caveat in mind, reflection is a powerful technique and can enable applications to perform operations which would otherwise be impossible.</p>
</blockquote>
<p>概括来讲就是：** 反射这个功能很XX **<br>大家常见的对反射机制的概念:<br>在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p>
<h4 id="涉及到的类"><a href="#涉及到的类" class="headerlink" title="涉及到的类"></a>涉及到的类</h4><ul>
<li><code>Class</code>：反射的核心类，可以获取类的属性，方法等信息。 </li>
<li><code>Field</code>：Java.lang.reflec包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。 </li>
<li><code>Method</code>： Java.lang.reflec包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。 </li>
<li><code>Constructor</code>： Java.lang.reflec包中的类，表示类的构造方法。</li>
</ul>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>先写一个简单的Person类当做目标类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>	<span class="hljs-keyword">public</span> String name;<br>	<span class="hljs-keyword">private</span> String nickName;<br>	<span class="hljs-type">int</span> age;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;&#125;<br>	<span class="hljs-keyword">protected</span>  <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>		<span class="hljs-built_in">this</span>. age = age;<br>	&#125;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>		<span class="hljs-built_in">this</span>.name = name;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name,String nickName)</span> &#123;<br>		<span class="hljs-built_in">this</span>.name = name;<br>		<span class="hljs-built_in">this</span>.nickName = nickName;<br>	&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, String nickName, <span class="hljs-type">int</span> age)</span> &#123;<br>		<span class="hljs-built_in">super</span>();<br>		<span class="hljs-built_in">this</span>.name = name;<br>		<span class="hljs-built_in">this</span>.nickName = nickName;<br>		<span class="hljs-built_in">this</span>.age = age;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person [name=&quot;</span> + name + <span class="hljs-string">&quot;, nickName=&quot;</span> + nickName + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;]&quot;</span>;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="获取想要操作的类的Class对象"><a href="#获取想要操作的类的Class对象" class="headerlink" title="获取想要操作的类的Class对象"></a>获取想要操作的类的Class对象</h5><ol>
<li>Object.getClass();  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">personClass</span> <span class="hljs-operator">=</span> person.getClass();<br></code></pre></td></tr></table></figure></li>
<li>任何数据类型（包括基本数据类型）都有一个“静态”的class属性  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">personClass2</span> <span class="hljs-operator">=</span> Person.class;<br></code></pre></td></tr></table></figure></li>
<li>通过Class类的静态方法：forName（String  className）(常用)     <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">personClass3</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.huangyuanlove.Person&quot;</span>);<br></code></pre></td></tr></table></figure>
  需要注意的是，在运行期间，一个只有一个Class对象：  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">System.out.println(personClass);<br>System.out.println(personClass == personClass2);<br>System.out.println(personClass == personClass3);<br></code></pre></td></tr></table></figure>
  输出：<blockquote>
<p>class com.huangyuanlove.Person<br> true<br> true</p>
</blockquote>
</li>
</ol>
<h5 id="调用Class类中的方法"><a href="#调用Class类中的方法" class="headerlink" title="调用Class类中的方法"></a>调用Class类中的方法</h5><h6 id="获取构造方法并创造对象："><a href="#获取构造方法并创造对象：" class="headerlink" title="获取构造方法并创造对象："></a>获取构造方法并创造对象：</h6>   <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> 	<span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">personClass</span> <span class="hljs-operator">=</span> person.getClass();<br><br><span class="hljs-comment">// 获取所有的公有构造方法</span><br>Constructor[] publicConstructors = personClass.getConstructors();<br>System.out.println(<span class="hljs-string">&quot;获取所有的公有构造方法&quot;</span>);<br><span class="hljs-keyword">for</span> (Constructor c : publicConstructors) &#123;<br>	System.out.println(c);<br>&#125;<br><br><span class="hljs-comment">// 获取所有的构造方法</span><br>Constructor[] allConstructors = personClass.getDeclaredConstructors();<br>System.out.println(<span class="hljs-string">&quot;获取所有的构造方法&quot;</span>);<br><span class="hljs-keyword">for</span> (Constructor c : allConstructors) &#123;<br>	System.out.println(c);<br>&#125;<br><br><span class="hljs-comment">// 获取公有，无参构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">publicConstructorWithoutArgs</span> <span class="hljs-operator">=</span> personClass.getConstructor();<br>System.out.println(<span class="hljs-string">&quot;获取公有，无参构造方法&quot;</span>);<br>System.out.println(publicConstructorWithoutArgs);<br>System.out.println(publicConstructorWithoutArgs.newInstance());<br><br><span class="hljs-comment">// 获取私有，有一个String类型参数的构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">publicConstructorWithOneStringArgs</span> <span class="hljs-operator">=</span> personClass.getDeclaredConstructor(String.class);<br>System.out.println(<span class="hljs-string">&quot;获取私有，有一个String类型参数的构造方法&quot;</span>);<br>System.out.println(publicConstructorWithOneStringArgs);<br>personClass.getDeclaredField(<span class="hljs-string">&quot;nickName&quot;</span>).setAccessible(<span class="hljs-literal">true</span>);<br>System.out.println(publicConstructorWithOneStringArgs.newInstance(<span class="hljs-string">&quot;xuan&quot;</span>));<br><br><span class="hljs-comment">// 获取公有，有两个个String类型参数的构造方法</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">publicConstructorWithTwoStringArgs</span> <span class="hljs-operator">=</span> personClass.getConstructor(String.class, String.class);<br>System.out.println(<span class="hljs-string">&quot;获取公有，有两个个String类型参数的构造方法&quot;</span>);<br>System.out.println(publicConstructorWithTwoStringArgs);<br>publicConstructorWithTwoStringArgs.setAccessible(<span class="hljs-literal">true</span>);<br>System.out.println(publicConstructorWithTwoStringArgs.newInstance(<span class="hljs-string">&quot;xuan&quot;</span>, <span class="hljs-string">&quot;huangyuan&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>  这里需要注意的是，在获取私有，有一个String类型参数的构造方法，并调用<code>newInstance</code>方法的时候会抛出异常，这是因为该构造方法中的<code>nickName</code>字段是私有的,将其注释掉可获得如下输出<br>  输出：</p>
<blockquote>
<p>获取所有的公有构造方法<br>    public com.huangyuanlove.Person(java.lang.String,java.lang.String,int)<br>    public com.huangyuanlove.Person(java.lang.String,java.lang.String)<br>    public com.huangyuanlove.Person()<br>    获取所有的构造方法<br>    public com.huangyuanlove.Person(java.lang.String,java.lang.String,int)<br>    public com.huangyuanlove.Person(java.lang.String,java.lang.String)<br>    private com.huangyuanlove.Person(java.lang.String)<br>    protected com.huangyuanlove.Person(int)<br>    public com.huangyuanlove.Person()<br>    获取公有，无参构造方法<br>    public com.huangyuanlove.Person()<br>    Person [name&#x3D;null, nickName&#x3D;null, age&#x3D;0]<br>    获取私有，有一个String类型参数的构造方法<br>    private com.huangyuanlove.Person(java.lang.String)<br>    获取公有，有两个个String类型参数的构造方法<br>    public com.huangyuanlove.Person(java.lang.String,java.lang.String)<br>    Person [name&#x3D;xuan, nickName&#x3D;huangyuan, age&#x3D;0]</p>
</blockquote>
<h6 id="获取成员变量并进行操作"><a href="#获取成员变量并进行操作" class="headerlink" title="获取成员变量并进行操作"></a>获取成员变量并进行操作</h6>  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">personClass</span> <span class="hljs-operator">=</span> person.getClass();<br><br><span class="hljs-comment">// 获取所有的公共成员变量</span><br>Field publicFields[] = personClass.getFields();<br>System.out.println(<span class="hljs-string">&quot;获取所有的公共成员变量&quot;</span>);<br><span class="hljs-keyword">for</span> (Field f : publicFields) &#123;<br>	System.out.println(f);<br>&#125;<br><span class="hljs-comment">// 获取所有的成员变量</span><br>Field allFields[] = personClass.getDeclaredFields();<br>System.out.println(<span class="hljs-string">&quot;获取所有的成员变量&quot;</span>);<br><span class="hljs-keyword">for</span> (Field f : allFields) &#123;<br>	System.out.println(f);<br>&#125;<br><br><span class="hljs-comment">// 获取某个公有成员变量并赋值</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> personClass.getField(<span class="hljs-string">&quot;name&quot;</span>);<br>nameField.set(person, <span class="hljs-string">&quot;huangyuan&quot;</span>);<br>System.out.println(person);<br><br><span class="hljs-comment">// 获取某个私有成员变量并赋值</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">nickNameField</span> <span class="hljs-operator">=</span> personClass.getDeclaredField(<span class="hljs-string">&quot;nickName&quot;</span>);<br>  <span class="hljs-comment">//因为nickName是私有的，所有需要先设置可访问</span><br>nickNameField.setAccessible(<span class="hljs-literal">true</span>);<br>nickNameField.set(person, <span class="hljs-string">&quot;xuan&quot;</span>);<br>System.out.println(person);<br></code></pre></td></tr></table></figure>
<p>  可以得到如下输出：</p>
<blockquote>
<p>获取所有的公共成员变量<br>    public java.lang.String com.huangyuanlove.Person.name<br>    获取所有的成员变量<br>    public java.lang.String com.huangyuanlove.Person.name<br>    private java.lang.String com.huangyuanlove.Person.nickName<br>    int com.huangyuanlove.Person.age<br>    Person [name&#x3D;huangyuan, nickName&#x3D;null, age&#x3D;0]<br>    Person [name&#x3D;huangyuan, nickName&#x3D;xuan, age&#x3D;0]</p>
</blockquote>
<p>  重要的事情来了，一定要记住，谁要是想上面那样反射获取类的公有成员变量然后进行赋值操作，肯定被骂的祸国殃民、民不聊生、生灵涂炭，都public了你还反射。<br>  获取私有变量的时候需要使用<code>getDeclaredField</code>方法，否则会抛出<code>noSuchFieldException</code></p>
<h6 id="获取方法并进行调用"><a href="#获取方法并进行调用" class="headerlink" title="获取方法并进行调用"></a>获取方法并进行调用</h6><p>   在类中添加两个方法<br>   <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;hi&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saySomeThing</span><span class="hljs-params">(String someThing)</span> &#123;<br>    System.out.println(someThing);<br>&#125;<br></code></pre></td></tr></table></figure><br>  反射获取类方法并进行调用<br>  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">personClass</span> <span class="hljs-operator">=</span> person.getClass();<br><br><span class="hljs-comment">// 获取所有公共方法</span><br>System.out.println(<span class="hljs-string">&quot;获取所有公共方法&quot;</span>);<br>Method publicMethods[] = personClass.getMethods();<br><span class="hljs-keyword">for</span> (Method m : publicMethods) &#123;<br>	System.out.println(m.getName());<br>&#125;<br><br><span class="hljs-comment">// 获取所有方法</span><br>System.out.println(<span class="hljs-string">&quot;获取所有方法&quot;</span>);<br>Method allMethods[] = personClass.getDeclaredMethods();<br><span class="hljs-keyword">for</span> (Method m : allMethods) &#123;<br>	System.out.println(m.getName());<br>&#125;<br><br><span class="hljs-comment">// 获取指定的公有方法</span><br>System.out.println(<span class="hljs-string">&quot;获取指定的公有方法&quot;</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">publicMethodWithoutArgs</span> <span class="hljs-operator">=</span> personClass.getMethod(<span class="hljs-string">&quot;sayHi&quot;</span>);<br>publicMethodWithoutArgs.invoke(person);<br><br><span class="hljs-comment">// 获取指定的私有方法</span><br>System.out.println(<span class="hljs-string">&quot;获取指定的私有方法&quot;</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">privateMethodWithStringArgs</span> <span class="hljs-operator">=</span> personClass.getDeclaredMethod(<span class="hljs-string">&quot;saySomeThing&quot;</span>, String.class);<br>privateMethodWithStringArgs.setAccessible(<span class="hljs-literal">true</span>);<br>privateMethodWithStringArgs.invoke(person, <span class="hljs-string">&quot;someThing&quot;</span>);<br></code></pre></td></tr></table></figure><br>  得到输出：</p>
<blockquote>
<p>获取所有公共方法<br>    toString<br>    sayHi<br>    wait<br>    wait<br>    wait<br>    equals<br>    hashCode<br>    getClass<br>    notify<br>    notifyAll<br>    获取所有方法<br>    toString<br>    sayHi<br>    saySomeThing<br>    获取指定的公有方法<br>    hi<br>    获取指定的私有方法<br>    someThing</p>
</blockquote>
<p>  获取到的方法中并不包含构造方法，但是包含从父类继承下来的公共方法。和上面的获取成员变量赋值一样，谁要是反射去获取公共方法再去调用，基本上就凉了。</p>
<h4 id="静态代理和动态代理"><a href="#静态代理和动态代理" class="headerlink" title="静态代理和动态代理"></a>静态代理和动态代理</h4><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>简单来说，代理就是用一个代理类来封装一个委托类，这样做有两个好处：可以隐藏委托类的具体实现；可以在不改变委托类的情况下增加额外的操作。而静态代理，就是在程序运行之前，代理类就已经存在了。静态代理一般的实现方式为：委托类和代理类都实现同一个接口或者是继承自同一个父类，然后在代理类中保存一个委托类的对象引用（父类或者父类接口的对象引用），通过给构造器传入委托类的对象进行初始化，在同名方法中通过调用委托类的方法实现静态代理。除此之外，在代理类同名方法中还可以实现一些额外的功能。代码如下：<br>RealObject类为委托类，SimpleProxy类为代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">somethingElse</span><span class="hljs-params">(String arg)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interface</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;doSomething&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">somethingElse</span><span class="hljs-params">(String arg)</span> &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;somethingElse &quot;</span> + arg);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interface</span> &#123;<br>    <span class="hljs-comment">// 保存委托类（父接口的引用）</span><br>    <span class="hljs-keyword">private</span> Interface proxied;<br><br>    <span class="hljs-comment">// 传入委托类的对象用于初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleProxy</span><span class="hljs-params">(Interface proxied)</span> &#123;<br>        <span class="hljs-built_in">this</span>.proxied = proxied;<br>    &#125;<br><br>    <span class="hljs-comment">// 两个同名方法中还实现了其他的功能</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;SimpleProxy doSomething&quot;</span>);<br>        proxied.doSomething();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">somethingElse</span><span class="hljs-params">(String arg)</span> &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;SimpleProxy somethingElse &quot;</span> + arg);<br>        proxied.somethingElse(arg);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        consumer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RealObject</span>());<br>        consumer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RealObject</span>()));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(Interface iface)</span> &#123;<br>        iface.doSomething();<br>        iface.somethingElse(<span class="hljs-string">&quot;bonobo&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>静态代理的局限性在于，代理类需要在程序运行之前就编写好，而动态代理则可以在程序运行的过程中动态创建并处理对所代理方法的调用。在动态代理中，需要定义一个中介类，这个类实现InvocationHandle接口（主要是里面的invoke方法）。这个中介类位于委托类和代理类之间，作为一个调用处理器而存在。它保存一个委托类的引用，通过传入委托类对象进行初始化；然后在invoke方法中，实现对委托类方法的调用，并增加需要的额外操作。在需要使用动态代理时，首先通过Proxy类中的newProxyInstance方法得到代理类对象（方法的三个参数分别是：（通常是委托类实现接口的）类加载器，希望代理类实现的接口列表（通常也是委托类实现的接口），以及一个调用处理器的对象），然后通过这个代理类对象直接调用代理类的方法。这种调用实际上会通过调用处理器调用invoke方法，进而实现对委托类相应方法的调用。</p>
<p>注意在动态代理中，只实现了一个调用处理器，而没有真正实现代理类。代理类对象是通过Proxy类中的newProxyInstance方法得到的。这样，不管你在调用委托类任何方法时需要加入的额外操作都可以仅仅在调用处理器中的invoke方法中实现就可以了。代码示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleDynamiProxyDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(Interface iface)</span> &#123;<br>        iface.doSomething();<br>        iface.somethingElse(<span class="hljs-string">&quot;bonobo&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RealObject</span> <span class="hljs-variable">real</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealObject</span>();<br>        consumer(real);<br>        <span class="hljs-comment">// 通过Proxy.newProxyInstance方法得到代理类对象</span><br>        <span class="hljs-type">Interface</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Interface) Proxy.newProxyInstance(Interface.class.getClassLoader(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Interface.class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicProxyHandler</span>(real));<br>        <span class="hljs-comment">// 通过代理类对象直接调用方法，会被重定向到调用处理器上的invoke方法</span><br>        consumer(proxy);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 中介类（调用处理器）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxyHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">// 保存一个委托类的对象</span><br>    <span class="hljs-keyword">private</span> Object proxied;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicProxyHandler</span><span class="hljs-params">(Object proxied)</span> &#123;<br>        <span class="hljs-built_in">this</span>.proxied = proxied;<br>    &#125;<br><br>    <span class="hljs-comment">// 三个参数：代理类的引用，方法名和方法的参数列表</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        System.out.println(<span class="hljs-string">&quot;**** proxy: &quot;</span> + proxy.getClass() + <span class="hljs-string">&quot;, method: &quot;</span> + method + <span class="hljs-string">&quot;, args: &quot;</span> + args);<br>        <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Object arg : args) &#123;<br>                System.out.println(<span class="hljs-string">&quot; &quot;</span> + arg);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 实现对委托类方法的调用，参数表示委托类对象和参数</span><br>        <span class="hljs-keyword">return</span> method.invoke(proxied, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p>以上<br>以上静态代理和动态代理相关的文字代码出自于 <a href="https://www.cnblogs.com/hrcnblogs/p/8711418.html">https://www.cnblogs.com/hrcnblogs/p/8711418.html</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidStudio插件开发</title>
    <url>/2020/12/13/AndroidStudio%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>写了个类似<code>Butter Knife</code>的<a href="https://github.com/huangyuanlove/AndroidAnnotation">开发库</a>，但是并没有与其配套的AndroidStudio插件，抽时间研究了以下IDEA的api文档，撸了一个对应的插件，<a href="https://github.com/huangyuanlove/AndroidAnnotation-Plugin">源码在这里</a></p>
<p>代码参考<a href="https://github.com/avast/android-butterknife-zelezny">https://github.com/avast/android-butterknife-zelezny</a></p>
<p>所用到的知识点：</p>
<ol>
<li>查找文件</li>
<li>解析xml</li>
<li>写文件<br>IDEA插件开发文档：<a href="https://jetbrains.org/intellij/sdk/docs/intro/welcome.html">https://jetbrains.org/intellij/sdk/docs/intro/welcome.html</a><span id="more"></span></li>
</ol>
<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>官方推荐创建gradle项目，这里贴个图，创建过程按照官网叙述的创建就好</p>
<p><a href="https://jetbrains.org/intellij/sdk/docs/tutorials/build_system/prerequisites.html">https://jetbrains.org/intellij/sdk/docs/tutorials/build_system/prerequisites.html</a></p>
<p>这里说明一下，如果想要在AndroidStudio中进行debug，阅读一下这个</p>
<p><a href="https://jetbrains.org/intellij/sdk/docs/products/android_studio.html">https://jetbrains.org/intellij/sdk/docs/products/android_studio.html</a></p>
<p>也就是在项目根目录的的<code>build.gradle</code>中配置 <code>intellij</code>和<code>runIde</code>，具体含义可在网页中找到，这里不再赘述</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// See https://github.com/JetBrains/gradle-intellij-plugin/</span><br>intellij &#123;<br>    version <span class="hljs-string">&#x27;201.8743.12&#x27;</span><br>    type <span class="hljs-string">&#x27;IC&#x27;</span><br>    plugins = [<span class="hljs-string">&#x27;android&#x27;</span>, <span class="hljs-string">&#x27;java&#x27;</span>]<br>&#125;<br>runIde &#123;<br>    <span class="hljs-comment">// Absolute path to installed target 3.5 Android Studio to use as IDE Development Instance</span><br>    <span class="hljs-comment">// The &quot;Contents&quot; directory is macOS specific.</span><br><span class="hljs-comment">//    ideDirectory &#x27;/Applications/Android Studio.app/Contents&#x27; //for mac</span><br><span class="hljs-comment">//    ideDirectory &#x27;/home/huangyuan/androidStudio&#x27; //for linux</span><br>    ideDirectory <span class="hljs-string">&#x27;G:\\AndroidStudio&#x27;</span> <span class="hljs-comment">//for window</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/image/Android/AndroidStudioPlugin/create_plugin_gradle.png" alt="create_plugin_gradle"></p>
<h4 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h4><p>创建一个继承AnAction 的类，这里创建的方式有两种，一个是直接创建java类，然后再去注册；另外一个就是通过想到直接创建(就像我们创建Activity一样)；</p>
<p>具体可以看这里 <a href="https://jetbrains.org/intellij/sdk/docs/tutorials/action_system/working_with_custom_actions.html">https://jetbrains.org/intellij/sdk/docs/tutorials/action_system/working_with_custom_actions.html</a></p>
<p>这里我们需要解析layout文件(xml文件)并且还要写入文件，所以就直接继承<code>BaseGenerateAction</code>，重写其中的两个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> AnActionEvent e)</span> &#123;<br>   <span class="hljs-comment">// Using the event, evaluate the context, and enable or disable the action.</span><br>    e.getPresentation().setEnabledAndVisible(e.getProject() != <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> AnActionEvent event)</span> &#123;<br>    <span class="hljs-comment">// Using the event, implement an action. For example, create and show a dialog.</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>当工程处于indexing的时候，我们不想让插件生效，可以实现<code>DumbAware</code>接口，继续向<code>actionPerformed</code>方法中添加逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actionPerformed</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> AnActionEvent event)</span> &#123;<br>    <span class="hljs-comment">//获取工程对象，具体信息可以看这里 https://jetbrains.org/intellij/sdk/docs/basics/project_structure.html</span><br>    <span class="hljs-type">Project</span> <span class="hljs-variable">project</span> <span class="hljs-operator">=</span> event.getData(PlatformDataKeys.PROJECT);<br>    <span class="hljs-keyword">if</span>(project ==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-type">Editor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> event.getData(PlatformDataKeys.EDITOR);<br>    <span class="hljs-keyword">if</span>(editor ==<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">DumbService</span> <span class="hljs-variable">dumbService</span> <span class="hljs-operator">=</span> DumbService.getInstance(project);<br>    <span class="hljs-keyword">if</span> (dumbService.isDumb()) &#123;<br>        dumbService.showDumbModeNotification(<span class="hljs-string">&quot;ViewInject plugin is not available during indexing&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//这里是我们自己的逻辑</span><br>    analyze(project, editor);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="获取文件"><a href="#获取文件" class="headerlink" title="获取文件"></a>获取文件</h4><p>我们可以获取到当前光标所指向的位置，也可以获取当前选中的字符，我们从官方文档中找到我们自己需要的东西：需要看一下PSI(Program Structure Interface),具体信息在这里<a href="https://jetbrains.org/intellij/sdk/docs/basics/architectural_overview/psi.html">https://jetbrains.org/intellij/sdk/docs/basics/architectural_overview/psi.html</a></p>
<p>关键信息在<a href="https://jetbrains.org/intellij/sdk/docs/basics/architectural_overview/psi_elements.html">PSI element</a> 和 <a href="https://jetbrains.org/intellij/sdk/docs/basics/architectural_overview/psi_files.html">PSI Files</a>，项目的中的具体逻辑在<code>GetLayoutFileUtil.java</code>，这里比较麻烦一些，用到了<code>Module</code>和<code>GlobalSearchScope</code>这两个类，<a href="https://jetbrains.org/intellij/sdk/docs/reference_guide/project_model/module.html">具体可以看这里https://jetbrains.org/intellij/sdk/docs/reference_guide&#x2F;project_model&#x2F;module.html</a>，就不再抄一遍+翻译了</p>
<h4 id="解析文件"><a href="#解析文件" class="headerlink" title="解析文件"></a>解析文件</h4><p>这里我们拿到了对应的<code>layout.xml</code>文件对象，一个<code>PsiFile</code>对象，调用文件的遍历方法<code>layoutFile.accept(PsiElementVisitor visitor)</code>，这里我们传入<code>XmlRecursiveElementVisitor</code>实例对象，在解析xml的过程中，我们可能会遇到<code>&lt;include&gt;</code>标签，需要继续解析该标签下的xml文件，这里搞个递归。</p>
<h4 id="展示解析内容"><a href="#展示解析内容" class="headerlink" title="展示解析内容"></a>展示解析内容</h4><p>解析出来的数据存入ArrayList中，在解析过程中，保存了对应id、判断是否引用了android name space中id、将id的值转化为对应的字段名字、保存了是是否为自定义的view等信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String id;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isAndroidNS</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">public</span> String nameFull; <span class="hljs-comment">// element name with package</span><br><span class="hljs-keyword">public</span> String name; <span class="hljs-comment">// element name</span><br><span class="hljs-keyword">public</span> String fieldName; <span class="hljs-comment">// name of variable</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isValid</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">used</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isClick</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>

<p>展示解析内容使用<code>javax.swing</code>组件，这个也没什么好说的。</p>
<p><img src="/image/Android/AndroidStudioPlugin/AndroidAnnotation.png" alt="show_android_annotation_info"></p>
<p>在展示面板上提供的全选功能；提供了生成代码的两种格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindView(idStr = &quot;xxxx&quot;)</span> <span class="hljs-comment">//可在library、application中使用</span><br><span class="hljs-meta">@BindView(id = R.id.xxx)</span> <span class="hljs-comment">//仅在application中使用</span><br></code></pre></td></tr></table></figure>

<p>因为在library中生成的R文件中的变量不是final类型，并且application中的R文件变量，在gradle plugin  5.0之后也不再是final的，所以建议使用idStr的方式，也是默认生成的代码</p>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>为了方便，写入文件的时候使用的是<code>PsiClass</code>对象进行操作的，<a href="https://upsource.jetbrains.com/idea-ce/file/idea-ce-4b94ba01122752d7576eb9d69638b6e89d1671b7/java/java-psi-api/src/com/intellij/psi/PsiClass.java">源码在这里</a>，至于如何操作PsiFile，<a href="https://jetbrains.org/intellij/sdk/docs/basics/architectural_overview/psi.html">可以看这里</a>。写入文件的过程，看起来个使用<code>javapoet</code>差不多，<a href="https://github.com/square/javapoet">javapoet可以看这里，github上直接搜索即可</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateClick</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (ElementBean element : mElements) &#123;<br>    <span class="hljs-keyword">if</span> (element.isClick) &#123;<br>      <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>      method.append(<span class="hljs-string">&quot;@ClickResponder(&quot;</span> + element.getGenerateValue(generateId) + <span class="hljs-string">&quot;)&quot;</span>);<br>      method.append(<span class="hljs-string">&quot;public void onClick&quot;</span> + Utils.capitalize(element.fieldName) + <span class="hljs-string">&quot; (View v) &#123;&#125;&quot;</span>);<br>      mClass.add(mFactory.createMethodFromText(method.toString(), mClass));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在写入类字段的时候，需要判断是否需要添加前缀，在<code>Constant</code>中列举了一些需要特殊处理的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateFields</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (ElementBean element : mElements) &#123;<br>        <span class="hljs-keyword">if</span> (!element.used) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">injection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        injection.append(<span class="hljs-string">&quot;@BindView&quot;</span>);<br>        injection.append(<span class="hljs-string">&#x27;(&#x27;</span>);<br>        injection.append(element.getGenerateValue(generateId));<br>        injection.append(<span class="hljs-string">&quot;)&quot;</span>);<br>        <span class="hljs-keyword">if</span> (element.nameFull != <span class="hljs-literal">null</span> &amp;&amp; element.nameFull.length() &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// custom package+class</span><br>            injection.append(element.nameFull);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Constant.paths.containsKey(element.name)) &#123; <span class="hljs-comment">// listed class</span><br>            injection.append(Constant.paths.get(element.name));<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// android.widget</span><br>            injection.append(<span class="hljs-string">&quot;android.widget.&quot;</span>);<br>            injection.append(element.name);<br>        &#125;<br>        injection.append(<span class="hljs-string">&quot; &quot;</span>);<br>        injection.append(element.fieldName);<br>        injection.append(<span class="hljs-string">&quot;;&quot;</span>);<br>        mClass.add(mFactory.createFieldFromText(injection.toString(), mClass));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>写入完成后格式化一下代买，要不然写入的字段会是这样：<code>android.widget.TextView userNameTextView</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">JavaCodeStyleManager</span> <span class="hljs-variable">styleManager</span> <span class="hljs-operator">=</span> JavaCodeStyleManager.getInstance(mProject);<br>styleManager.optimizeImports(mFile);<br>styleManager.shortenClassReferences(mClass);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ReformatCodeProcessor</span>(mProject, mClass.getContainingFile(), <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>).runWithoutProgress();<br></code></pre></td></tr></table></figure>

<p>到此为止，就已经完成了我们的工作。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中使用WebSocket-2</title>
    <url>/2017/12/26/Android%E4%B8%AD%E4%BD%BF%E7%94%A8WebSocket-2/</url>
    <content><![CDATA[<p>上一篇提到在Android中使用WebSocket和服务端进行通信。是直接在Activity里面进行操作的这样会保持一个长连接，一个应用里面没必要也不应该保持多个长连接，所以我们可以把WebSocket客户端挪到Service里面，使用广播和Activity进行通信。</p>
<span id="more"></span>
<ol>
<li>APP端：<br>继承<code>BroadcastReceiver</code>，重写<code>public void onReceive(Context context, Intent intent)</code>方法，在该方法中进行业务处理。<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br><br>    <span class="hljs-keyword">private</span> TextView showMessage;<br>    <span class="hljs-keyword">private</span> EditText editText;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">private</span> WebSocketBroadcastReceiver webSocketBroadcastReceiver;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, WebSocketService.class);<br>        startService(intent);<br>        showMessage = findViewById(R.id.show_message);<br>        editText = findViewById(R.id.edit_text);<br>        findViewById(R.id.send).setOnClickListener(<span class="hljs-built_in">this</span>);<br>        webSocketBroadcastReceiver = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketBroadcastReceiver</span>();<br>        <span class="hljs-type">IntentFilter</span> <span class="hljs-variable">intentFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>(<span class="hljs-string">&quot;web_socket&quot;</span>);<br>        registerReceiver(webSocketBroadcastReceiver, intentFilter);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (v.getId()) &#123;<br>            <span class="hljs-keyword">case</span> R.id.send:<br><br>                sb.append(<span class="hljs-string">&quot;客户端发送消息：&quot;</span>);<br>                sb.append(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toLocaleString());<br>                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>                sb.append(editText.getText().toString().trim());<br>                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>                showMessage.setText(sb.toString());<br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, WebSocketService.class);<br>                intent.putExtra(<span class="hljs-string">&quot;message&quot;</span>, editText.getText().toString().trim());<br>                startService(intent);<br>                editText.setText(<span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketBroadcastReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BroadcastReceiver</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> intent.getStringExtra(<span class="hljs-string">&quot;message&quot;</span>);<br>            sb.append(<span class="hljs-string">&quot;服务端返回消息：&quot;</span>);<br>            sb.append(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().toLocaleString());<br>            sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>            sb.append(message);<br>            sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>            showMessage.setText(sb.toString());<br><br>    &#125;<br>&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, WebSocketService.class);<br>        stopService(intent);<br>        unregisterReceiver(webSocketBroadcastReceiver);<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>Service<br>继承<code>Service</code>,在<code>onCreate()</code>方法里面创建<code>WebSocketClient</code>并和服务端进行连接。在<code>AndroidManifest.xml</code>中注册服务。<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSocketService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">private</span> IoTWebSocketClient ioTWebSocketClient;<br>    <span class="hljs-keyword">private</span> Intent broadcastIntent;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br>        broadcastIntent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        broadcastIntent.setAction(<span class="hljs-string">&quot;web_socket&quot;</span>);<br>        ioTWebSocketClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IoTWebSocketClient</span>(URI.create(<span class="hljs-string">&quot;ws://192.168.1.64:8887&quot;</span>));<br>        ioTWebSocketClient.connect();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">onStartCommand</span><span class="hljs-params">(Intent intent, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> startId)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> intent.getStringExtra(<span class="hljs-string">&quot;message&quot;</span>);<br>        <span class="hljs-keyword">if</span>(ioTWebSocketClient.isClosing() || ioTWebSocketClient.isClosed())&#123;<br>            stopSelf();<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onStartCommand(intent, flags, startId);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ioTWebSocketClient.send(message);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onStartCommand(intent, flags, startId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        ioTWebSocketClient.close();<br>        ioTWebSocketClient = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">IoTWebSocketClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSocketClient</span> &#123;<br><br>        IoTWebSocketClient(URI serverUri) &#123;<br>            <span class="hljs-built_in">super</span>(serverUri);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(ServerHandshake handshakedata)</span> &#123;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message)</span> &#123;<br>            broadcastIntent.putExtra(<span class="hljs-string">&quot;message&quot;</span>, message);<br>            WebSocketService.<span class="hljs-built_in">this</span>.sendBroadcast(broadcastIntent);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(<span class="hljs-type">int</span> code, String reason, <span class="hljs-type">boolean</span> remote)</span> &#123;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Exception ex)</span> &#123;<br>            stopSelf();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
在<code>onStartCommand()</code>方法里面，对发送消息方法的调用进行异常捕获，是因为这时候可能服务端重启或者服务端还没有准备好，这是发送消息会抛出异常，可以根据自己的业务需求进行改进。</li>
</ol>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中的单元测试</title>
    <url>/2021/04/25/Android%E4%B8%AD%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h4 id="纯java代码的单元测试"><a href="#纯java代码的单元测试" class="headerlink" title="纯java代码的单元测试"></a>纯java代码的单元测试</h4><p>这里的纯java代码指的是不包含Android包中的代码，我们使用Junit写单元测试即可。</p>
<p>比如我们有一个方法是用来格式化数字，返回保留两位小数后的字符串，方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">numberFormat</span><span class="hljs-params">(<span class="hljs-type">double</span> number)</span>&#123;<br>  <span class="hljs-keyword">return</span> String.format(Locale.getDefault(),<span class="hljs-string">&quot;%.2f&quot;</span>,number);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么我们的单元测试可以这么写，依赖一下junit测试框架<code>testImplementation &#39;junit:junit:4.+&#39;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> org.junit.Assert.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleUnitTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNumberFormat</span><span class="hljs-params">()</span>&#123;<br>        assertEquals(<span class="hljs-string">&quot;0.23&quot;</span>,Util.numberFormat(<span class="hljs-number">0.232323</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<span id="more"></span>

<p>这里说明一下，我们在写单元测试的时候，经常会需要初始化一些数据，但我们又不想在每个测试方法中都调用一遍初始化的方法，这里测试框架给出了四个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BeforeClass</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><span class="hljs-meta">@Before</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>&#123;<br><br>&#125;<br><span class="hljs-meta">@After</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span>&#123;<br><br>&#125;<br><span class="hljs-meta">@AfterClass</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>@BeforeClass:只会执行一次，修饰的方法必须是静态的</li>
<li>@AfterClass：只会执行一次，修饰的方法必须是静态的</li>
<li>@Before：每次调用测试方法时都会执行一次</li>
<li>@After：每次测试方法执行完成后都会执行一次</li>
</ul>
<h4 id="代码中包含Android代码"><a href="#代码中包含Android代码" class="headerlink" title="代码中包含Android代码"></a>代码中包含Android代码</h4><p>但是，假如我们的代码中不小心”混入”了一些调用Android包的功能，比如验证邮箱的有效性，代码可能是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.util.Patterns;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmailAddress</span><span class="hljs-params">(String address)</span>&#123;<br>  <span class="hljs-keyword">return</span> Patterns.EMAIL_ADDRESS.matcher(address).matches();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里导入了 android.util包，如果使用junit的话，在单元测试代码中会报一个空指针异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testEmailAddress</span><span class="hljs-params">()</span>&#123;<br>  Assert.assertTrue(Util.isEmailAddress(<span class="hljs-string">&quot;gg@gg.com&quot;</span>));<br>  Assert.assertTrue(Util.isEmailAddress(<span class="hljs-string">&quot;huangyuan@chunyu.me&quot;</span>));<br>  Assert.assertFalse(Util.isEmailAddress(<span class="hljs-string">&quot;wwww&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">java<span class="hljs-variable">.lang</span><span class="hljs-variable">.NullPointerException</span><br>	at com<span class="hljs-variable">.huangyuanlove</span><span class="hljs-variable">.tdd_demo</span><span class="hljs-variable">.Util</span><span class="hljs-variable">.isEmailAddress</span>(Util<span class="hljs-variable">.java</span>:<span class="hljs-number">15</span>)<br>	at com<span class="hljs-variable">.huangyuanlove</span><span class="hljs-variable">.tdd_demo</span><span class="hljs-variable">.ExampleUnitTest</span><span class="hljs-variable">.testEmailAddress</span>(ExampleUnitTest<span class="hljs-variable">.java</span>:<span class="hljs-number">27</span>)<br>	at sun<span class="hljs-variable">.reflect</span><span class="hljs-variable">.NativeMethodAccessorImpl</span><span class="hljs-variable">.invoke0</span>(Native Method)<br>	at sun<span class="hljs-variable">.reflect</span><span class="hljs-variable">.NativeMethodAccessorImpl</span><span class="hljs-variable">.invoke</span>(NativeMethodAccessorImpl<span class="hljs-variable">.java</span>:<span class="hljs-number">62</span>)<br>	at sun<span class="hljs-variable">.reflect</span><span class="hljs-variable">.DelegatingMethodAccessorImpl</span><span class="hljs-variable">.invoke</span>(DelegatingMethodAccessorImpl<span class="hljs-variable">.java</span>:<span class="hljs-number">43</span>)<br>	at java<span class="hljs-variable">.lang</span><span class="hljs-variable">.reflect</span><span class="hljs-variable">.Method</span><span class="hljs-variable">.invoke</span>(Method<span class="hljs-variable">.java</span>:<span class="hljs-number">498</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.model</span><span class="hljs-variable">.FrameworkMethod</span>$<span class="hljs-number">1</span><span class="hljs-variable">.runReflectiveCall</span>(FrameworkMethod<span class="hljs-variable">.java</span>:<span class="hljs-number">59</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.internal</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.model</span><span class="hljs-variable">.ReflectiveCallable</span><span class="hljs-variable">.run</span>(ReflectiveCallable<span class="hljs-variable">.java</span>:<span class="hljs-number">12</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.model</span><span class="hljs-variable">.FrameworkMethod</span><span class="hljs-variable">.invokeExplosively</span>(FrameworkMethod<span class="hljs-variable">.java</span>:<span class="hljs-number">56</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.internal</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.statements</span><span class="hljs-variable">.InvokeMethod</span><span class="hljs-variable">.evaluate</span>(InvokeMethod<span class="hljs-variable">.java</span>:<span class="hljs-number">17</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.ParentRunner</span>$<span class="hljs-number">3</span><span class="hljs-variable">.evaluate</span>(ParentRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">306</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.BlockJUnit4ClassRunner</span>$<span class="hljs-number">1</span><span class="hljs-variable">.evaluate</span>(BlockJUnit4ClassRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">100</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.ParentRunner</span><span class="hljs-variable">.runLeaf</span>(ParentRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">366</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.BlockJUnit4ClassRunner</span><span class="hljs-variable">.runChild</span>(BlockJUnit4ClassRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">103</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.BlockJUnit4ClassRunner</span><span class="hljs-variable">.runChild</span>(BlockJUnit4ClassRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">63</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.ParentRunner</span>$<span class="hljs-number">4</span><span class="hljs-variable">.run</span>(ParentRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">331</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.ParentRunner</span>$<span class="hljs-number">1</span><span class="hljs-variable">.schedule</span>(ParentRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">79</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.ParentRunner</span><span class="hljs-variable">.runChildren</span>(ParentRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">329</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.ParentRunner</span><span class="hljs-variable">.access</span>$<span class="hljs-number">100</span>(ParentRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">66</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.ParentRunner</span>$<span class="hljs-number">2</span><span class="hljs-variable">.evaluate</span>(ParentRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">293</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.ParentRunner</span>$<span class="hljs-number">3</span><span class="hljs-variable">.evaluate</span>(ParentRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">306</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runners</span><span class="hljs-variable">.ParentRunner</span><span class="hljs-variable">.run</span>(ParentRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">413</span>)<br>	at org<span class="hljs-variable">.junit</span><span class="hljs-variable">.runner</span><span class="hljs-variable">.JUnitCore</span><span class="hljs-variable">.run</span>(JUnitCore<span class="hljs-variable">.java</span>:<span class="hljs-number">137</span>)<br>	at com<span class="hljs-variable">.intellij</span><span class="hljs-variable">.junit4</span><span class="hljs-variable">.JUnit4IdeaTestRunner</span><span class="hljs-variable">.startRunnerWithArgs</span>(JUnit4IdeaTestRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">68</span>)<br>	at com<span class="hljs-variable">.intellij</span><span class="hljs-variable">.rt</span><span class="hljs-variable">.junit</span><span class="hljs-variable">.IdeaTestRunner</span>$Repeater<span class="hljs-variable">.startRunnerWithArgs</span>(IdeaTestRunner<span class="hljs-variable">.java</span>:<span class="hljs-number">33</span>)<br>	at com<span class="hljs-variable">.intellij</span><span class="hljs-variable">.rt</span><span class="hljs-variable">.junit</span><span class="hljs-variable">.JUnitStarter</span><span class="hljs-variable">.prepareStreamsAndStart</span>(JUnitStarter<span class="hljs-variable">.java</span>:<span class="hljs-number">230</span>)<br>	at com<span class="hljs-variable">.intellij</span><span class="hljs-variable">.rt</span><span class="hljs-variable">.junit</span><span class="hljs-variable">.JUnitStarter</span><span class="hljs-variable">.main</span>(JUnitStarter<span class="hljs-variable">.java</span>:<span class="hljs-number">58</span>)<br></code></pre></td></tr></table></figure>

<p>因为我们的junit是跑在jvm上的，默认并没有加载android的包，这时候我们可以使用<a href="http://robolectric.org/">Robolectric</a>这个三方包来做测试。在gradle中添加一下依赖<code>testImplementation &#39;org.robolectric:robolectric:4.2&#39;</code>,<strong>别问为啥不用4.4,因为我还没整明白，Shadows方法不能用</strong></p>
<p>在我们的单元测试类上加下注解，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(RobolectricTestRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UtilTestWithRobolectric</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testEmailAddress</span><span class="hljs-params">()</span>&#123;<br>        Assert.assertTrue(Util.isEmailAddress(<span class="hljs-string">&quot;gg@gg.com&quot;</span>));<br>        Assert.assertTrue(Util.isEmailAddress(<span class="hljs-string">&quot;huangyuan@chunyu.me&quot;</span>));<br>        Assert.assertFalse(Util.isEmailAddress(<span class="hljs-string">&quot;wwww&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了这个，我们还可以使用Robolectric来测试一些页面行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> androidx.test.core.app.ActivityScenario;<br><span class="hljs-keyword">import</span> androidx.test.core.app.ApplicationProvider;<br><span class="hljs-keyword">import</span> org.junit.Assert;<br><span class="hljs-keyword">import</span> org.junit.Before;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.robolectric.RobolectricTestRunner;<br><span class="hljs-keyword">import</span> org.robolectric.Shadows;<br><span class="hljs-keyword">import</span> org.robolectric.shadows.ShadowAlertDialog;<br><span class="hljs-keyword">import</span> org.robolectric.shadows.ShadowToast;<br><span class="hljs-meta">@RunWith(RobolectricTestRunner.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UtilTestWithRobolectric</span> &#123;<br>    <span class="hljs-keyword">private</span> ActivityScenario&lt;MainActivity&gt; scenario;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initScenario</span><span class="hljs-params">()</span>&#123;<br>         scenario = ActivityScenario.launch(MainActivity.class);<br>    &#125;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testScenario</span><span class="hljs-params">()</span>&#123;<br>        Assert.assertNotNull(scenario);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testEmailAddress</span><span class="hljs-params">()</span>&#123;<br>        Assert.assertTrue(Util.isEmailAddress(<span class="hljs-string">&quot;gg@gg.com&quot;</span>));<br>        Assert.assertTrue(Util.isEmailAddress(<span class="hljs-string">&quot;huangyuan@chunyu.me&quot;</span>));<br>        Assert.assertFalse(Util.isEmailAddress(<span class="hljs-string">&quot;wwww&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-comment">//是否弹出toast</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testShowToast</span><span class="hljs-params">()</span>&#123;<br>        scenario.onActivity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityScenario</span>.ActivityAction&lt;MainActivity&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">perform</span><span class="hljs-params">(MainActivity activity)</span> &#123;<br>                <span class="hljs-type">Toast</span> <span class="hljs-variable">toast</span> <span class="hljs-operator">=</span> ShadowToast.getLatestToast();<br>                Assert.assertNull(toast);<br><br>                activity.findViewById(R.id.show_toast).performClick();<br>                toast = ShadowToast.getLatestToast();<br>                Assert.assertNotNull(toast);<br><br>                <span class="hljs-type">ShadowToast</span> <span class="hljs-variable">shadowToast</span> <span class="hljs-operator">=</span> Shadows.shadowOf(toast);<br>                Assert.assertEquals(<span class="hljs-string">&quot;show_toast&quot;</span>,ShadowToast.getTextOfLatestToast());<br>                Assert.assertEquals(Toast.LENGTH_SHORT,toast.getDuration());<br><br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>  	<span class="hljs-comment">//是否展示Dialog</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testShowDialog</span><span class="hljs-params">()</span>&#123;<br>        scenario.onActivity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityScenario</span>.ActivityAction&lt;MainActivity&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">perform</span><span class="hljs-params">(MainActivity activity)</span> &#123;<br>                <span class="hljs-type">AlertDialog</span> <span class="hljs-variable">dialog</span> <span class="hljs-operator">=</span> ShadowAlertDialog.getLatestAlertDialog();<br>                Assert.assertNull(dialog);<br>                activity.findViewById(R.id.show_toast).performClick();<br><br>                dialog = ShadowAlertDialog.getLatestAlertDialog();<br>                Assert.assertNotNull(dialog);<br><br>                <span class="hljs-type">ShadowAlertDialog</span> <span class="hljs-variable">shadowDialog</span> <span class="hljs-operator">=</span> Shadows.shadowOf(dialog);<br>                Assert.assertEquals(<span class="hljs-string">&quot;Hello！&quot;</span>, shadowDialog.getMessage());<br><br>            &#125;<br>        &#125;);<br><br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>  	<span class="hljs-comment">//是否跳转到了指定页面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGoToLogin</span><span class="hljs-params">()</span>&#123;<br><br>        scenario.onActivity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivityScenario</span>.ActivityAction&lt;MainActivity&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">perform</span><span class="hljs-params">(MainActivity activity)</span> &#123;<br>                activity.findViewById(R.id.login).performClick();<br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">expectedIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(activity, LoginActivity.class);<br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">actual</span> <span class="hljs-operator">=</span> Shadows.shadowOf(activity).getNextStartedActivity();<br>                Assert.assertEquals(expectedIntent.getComponent(),actual.getComponent());<br>            &#125;<br>        &#125;);<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这里的<code>ActivityScenario</code>是使用的 androidx.test.core.app包下的类，需要依赖<code>testImplementation &#39;androidx.test:core:1.1.0&#39;</code></p>
<p>当然在<code>Robolectric</code>中也有对应的创建Activity的方法，不过在4.4版本中被废弃了，也推荐使用androidx.test包中创建Activity的方法。</p>
<h4 id="Mock和Mockito"><a href="#Mock和Mockito" class="headerlink" title="Mock和Mockito"></a>Mock和Mockito</h4><p>如何测试一个没有返回值的方法，一般是来看这个方法有没有得到调用。<br>假如我们有如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginPresenter</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserManager</span><span class="hljs-params">(UserManager userManager)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userManager = userManager;<br>    &#125;<br>	  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String userName,String password)</span>&#123;<br>        userManager.performLogin(userName,password);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们要验证<code>mUserManager</code>的一些行为，首先要 mock UserManager 这个类，mock 这个类的方式是：<br><code>Mockito.mock(UserManager.class);</code><br>mock 了<code>UserManager</code>类之后，我们就可以开始测试了,验证一个对象的方法调用情况的方法是：<br><code>Mockito.verify(objectToVerify).methodToVerify(arguments);</code><br>其中，<code>objectToVerify</code>和<code>methodToVerify</code>分别是你想要验证的对象和方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLogin</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">UserManager</span> <span class="hljs-variable">userManager</span> <span class="hljs-operator">=</span> Mockito.mock(UserManager.class);<br>  <span class="hljs-type">LoginPresenter</span> <span class="hljs-variable">loginPresenter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginPresenter</span>();<br>  loginPresenter.setUserManager(userManager);<br>  loginPresenter.login(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>  Mockito.verify(userManager).performLogin(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再假如我们在登录的时候需要先验证密码强度，但是我们测试的时候不关心这个验证逻辑，希望不管传入的密码是啥，都可以通过验证。我们就需要干预某些mock对象的方法行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loginWithVerifyPassword</span><span class="hljs-params">(PasswordValidator passwordValidator, String userName,String password)</span>&#123;<br>  <span class="hljs-keyword">if</span>(passwordValidator.verifyPassword(password))&#123;<br>    userManager.performLogin(userName,password);<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;密码不正确&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PasswordValidator</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPassword</span><span class="hljs-params">(String password)</span>&#123;<br>    <span class="hljs-keyword">return</span> password != <span class="hljs-literal">null</span> &amp;&amp; password.length() &gt;<span class="hljs-number">5</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们需要mock一下PasswordValidator这个类中verifyPassword的行为,这种指定 mock 对象的某个方法，让它返回特定值的写法如下：<br><code>Mockito.when(mockObject.targetMethod(args)).thenReturn(desiredReturnValue);</code>代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLoginWithPasswordValidator</span><span class="hljs-params">()</span> &#123;<br>  LoginPresenter.<span class="hljs-type">PasswordValidator</span> <span class="hljs-variable">passwordValidator</span> <span class="hljs-operator">=</span> Mockito.mock(LoginPresenter.PasswordValidator.class);<br>  <span class="hljs-comment">//验证方法行为是否被改变</span><br>  Mockito.when(passwordValidator.verifyPassword(ArgumentMatchers.any())).thenReturn(<span class="hljs-literal">true</span>);<br>  Assert.assertTrue(passwordValidator.verifyPassword(<span class="hljs-string">&quot;&quot;</span>));<br>  Assert.assertTrue(passwordValidator.verifyPassword(<span class="hljs-literal">null</span>));<br>  Assert.assertTrue(passwordValidator.verifyPassword(<span class="hljs-string">&quot;123&quot;</span>));<br>  Assert.assertTrue(passwordValidator.verifyPassword(<span class="hljs-string">&quot;321321321&quot;</span>));<br><br>  <span class="hljs-comment">//验证登录方法是否被调用</span><br>  <span class="hljs-type">UserManager</span> <span class="hljs-variable">userManager</span> <span class="hljs-operator">=</span> Mockito.mock(UserManager.class);<br>  <span class="hljs-type">LoginPresenter</span> <span class="hljs-variable">loginPresenter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginPresenter</span>();<br>  loginPresenter.setUserManager(userManager);<br>  loginPresenter.loginWithVerifyPassword(passwordValidator, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>  Mockito.verify(userManager).performLogin(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Androidx-test"><a href="#Androidx-test" class="headerlink" title="Androidx.test"></a>Androidx.test</h4><p>最近在看Androidx包下的测试框架，对于我们来讲，单元测试不是很多，测试代码跑在模拟器或者真机上带来的时间消耗还是可以接受的。有时间撸一下对应的代码</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android启动过程</title>
    <url>/2021/03/04/Android%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Android启动过程"><a href="#Android启动过程" class="headerlink" title="Android启动过程"></a>Android启动过程</h2><p>从Zygote启动过程开始，省略掉了前面的解析.rc文件等步骤</p>
<span id="more"></span>

<h4 id="Zygote-启动过程"><a href="#Zygote-启动过程" class="headerlink" title="Zygote 启动过程"></a>Zygote 启动过程</h4><div id="sequence-0"></div>

<p><img src="/image/Android/aosp/zygote_start.png" alt="zygote_startr"></p>
<p>解释一下：</p>
<ol>
<li>解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法</li>
<li>调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数</li>
<li>通过JNI方式调用ZygoteInit.main()，第一次进入java世界</li>
<li>registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求</li>
<li>preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率</li>
<li>zygote完成大部分工作，接下来再通过startSystemServer(),fork得力助手system-server进行，也是上层framework的运行载体</li>
<li>zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进行请求时立即唤醒并执行相应工作。</li>
</ol>
<h4 id="SystemService-启动流程"><a href="#SystemService-启动流程" class="headerlink" title="SystemService 启动流程"></a>SystemService 启动流程</h4><p><img src="/image/Android/aosp/start_system_server.png" alt="start_system_server"></p>
<p>上图前4个步骤运行在Zygote进行，从第五步开始是运行在新创建的system_server,这是fork机制实现的。</p>
<p>RuntimeInit.java 中 invokeStaticMain 方法通过创建并抛出异常 ZygoteInit.MethodAndArgsCaller，在 ZygoteInit.java 中的 main()方法会捕捉该异常，并调用 caller.run()，再通过反射便会调用到 SystemServer.main()方法，在该方法中创建SystemServer对象并执行run方法。<br>在该方法中执行了如下操作</p>
<ul>
<li><p>设置系统时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;<br>              Slog.w(TAG, <span class="hljs-string">&quot;System clock is before 1970; setting to 1970.&quot;</span>);<br>              SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);<br>          &#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>变更虚拟机库文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SystemProperties.set(<span class="hljs-string">&quot;persist.sys.dalvik.vm.lib.2&quot;</span>, VMRuntime.getRuntime().vmLibrary());<br></code></pre></td></tr></table></figure>


</li>
<li><p>Mmmmmm… more memory!（清除vm内存增长限制）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">VMRuntime.getRuntime().clearGrowthLimit();<br></code></pre></td></tr></table></figure>


</li>
<li><p>Prepare the main looper thread (this thread)</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">android.os.Process.setThreadPriority(<br>             android.os.Process.THREAD_PRIORITY_FOREGROUND);<br>         android.os.Process.setCanSelfBackground(<span class="hljs-literal">false</span>);<br>         Looper.prepareMainLooper();<br>         Looper.getMainLooper().setSlowLogThresholdMs(<br>                 SLOW_DISPATCH_THRESHOLD_MS, SLOW_DELIVERY_THRESHOLD_MS);<br></code></pre></td></tr></table></figure>
</li>
<li><p>Initialize native services</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">System.loadLibrary(<span class="hljs-string">&quot;android_servers&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>检测上次关机过程是否失败，该方法可能不会返回</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">performPendingShutdown();<br></code></pre></td></tr></table></figure>
</li>
<li><p>Initialize the system context</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">createSystemContext();<span class="hljs-comment">//这里需要区分system_server进程和app进程：http://gityuan.com/2017/04/02/android-application/</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>Create the system service manager</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">mSystemServiceManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServiceManager</span>(mSystemContext);<br><span class="hljs-comment">//将 mSystemServiceManager 添加到本地服务的成员 sLocalServiceObjects</span><br>LocalServices.addService(SystemServiceManager.class, mSystemServiceManage<br>r);<br></code></pre></td></tr></table></figure>
<ul>
<li>Start services  startBootstrapServices();<blockquote>
<p>该方法所创建的服务:DeviceIdentifiersPolicyService、ActivityManagerService、PowerManagerService、RecoverySystemService、LightsService、DisplayManagerService、PackageManagerService、 UserManagerService、 SensorService.</p>
</blockquote>
<p>  startCoreServices();</p>
<blockquote>
<p>启动服务 BatteryService，UsageStatsService，WebViewUpdateService。</p>
</blockquote>
<p>  startOtherServices();</p>
<blockquote>
<p>这里启动的服务挺多的，捡主要的写一下：VibratorService、NetworkManagementService、IpSecService、NetworkStatsService、WindowManagerService、InputManagerService、AlarmManagerService</p>
</blockquote>
</li>
</ul>
<p>SystemServer 启动各种服务中最后的一个环节便是 AMS.systemReady()，到此, System_server 主线程的启动工作总算完成, 进入 Looper.loop()状态,等待 其他线程通过 handler 发送消息到主线再处理。<script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">title:Zygote启动过程
participant App_main.cpp
participant AndroidRuntime.cpp
participant ZygoteInit.java
participant ZygoteConnection.java
participant Zygote.java

App_main.cpp -> App_main.cpp : 1:main
App_main.cpp -> AndroidRuntime.cpp: 2:start
AndroidRuntime.cpp -> AndroidRuntime.cpp:3:startVM
AndroidRuntime.cpp -> AndroidRuntime.cpp: 4:startReg
AndroidRuntime.cpp -> ZygoteInit.java: 5:main
ZygoteInit.java -> ZygoteInit.java : 6:registerZygoteSocket
ZygoteInit.java -> ZygoteInit.java : 7:preload
ZygoteInit.java -> ZygoteInit.java : 8:startSystemServer
ZygoteInit.java -> Zygote.java : 9:forkSystemServer
ZygoteInit.java -> ZygoteInit.java : 10:runSelectLoop
ZygoteInit.java -> ZygoteConnection.java: 11:runOnce
ZygoteConnection.java -> Zygote.java: 12:forkAndSpecialize</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多进程(一)</title>
    <url>/2018/06/21/Android%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/</url>
    <content><![CDATA[<p>Reference：《Android开发艺术探索》，作者：任玉刚<br>多进程基础以及一些名词</p>
<span id="more"></span>
<h6 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h6><p>进程间通信或者跨进程通信，全称：Inter-Process Communication。<br>在操作系统中，线程是CPU调度的最小单元，同时线程是一种有限的系统资源。而进程一般指一个执行单元。一个进程可以包含做个线程。最简单的情况下，一个进程中可以只有一个线程，即主线程，在Android中，主线程也叫UI线程。<br>IPC不是Android中所独有的，任何一个操作系统都需要有相应的IPC机制，比如windows上可以通过剪贴板、管道和邮槽等来进行进程间通信；linux上可以通过命名管道、共享内容、信号量等来进行进程间通信。Android是基于Linux内核的移动操作系统，它的进程间通信方式没有完全继承自linux，在Android中可以通过Binder轻松实现进程间通信。除了Binder，Android还支持Socket。</p>
<h6 id="开启多进程"><a href="#开启多进程" class="headerlink" title="开启多进程"></a>开启多进程</h6><p>** 指定process属性 **</p>
<p>正常情况下，在Android中多进程是指一个应用中存在多个进程的情况，因此先忽略多个应用多进程的情况。首先在Android中使用多进程只有一种方式：在AndroidMenifest文件中指定<code>android:process</code>属性，除此之外还有一种非常规的方式，通过JNI在native层fork一个新的进程。也就是说我们无法给一个线程或者一个实体类指定其运行时所在的进程。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">	<span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ui.ActivityOne&quot;</span></span><br><span class="hljs-tag">	<span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;:remote&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">	<span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ui.ActivityTwo&quot;</span></span><br><span class="hljs-tag">	<span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;com.huangyuanlove.xuan&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">	<span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ui.ActivityThree&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>假如当前应用包名为<code>com.huangyuanlove.ipc</code>，当<code>ActivityOne</code>启动时，系统会为它创建一个单独的进程，进程名为<code>com.huangyuanlove.ipc:remote</code>，当<code>ActivityTwo</code>启动时，系统也会为它创建一个进程，进程名为：<code>com.huangyuanlove.xuan</code>，当然<code>ActivityThree</code>是运行在默认进程中，默认进程是包名。</p>
<p>** :name 和 全限定名的区别 **</p>
<ul>
<li>“:”的含义是在当前进程名的前面附加上包名(ActivityOne)，全限定名并不会附加包名。</li>
<li>以”:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，其他不以”:”开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。</li>
</ul>
<p>​     Android会为每一个应用分配一个UID，具有相同UID的应用才能共享数据，需要注意的是，两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。这种情况下，他们可以互相访问对方的私有数据，还可以共享内存数据，或者说它们看起来就像是一个应用的两个部分。</p>
<h6 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h6><ul>
<li>静态成员和单例模式凉凉</li>
<li>线程同步锁机制凉凉</li>
<li>SharedPreferences可靠性凉凉</li>
<li>Application会创建多次</li>
</ul>
<p>因为开启多进程之后，就不再是同一个内存区域，所以带来第一个问题，第二个问题也是同样，不在同一个内存区域，无论是对象锁还是全局锁可靠性基本就凉了。第三个问题和多进程写sp一样，第四个问题也是显而易见的，系统在创建新进程的时候会同时分配独立的虚拟机，所以这个过程就是启动一个应用的过程。</p>
<h6 id="Parcelable-和-Serializable"><a href="#Parcelable-和-Serializable" class="headerlink" title="Parcelable 和 Serializable"></a>Parcelable 和 Serializable</h6><p>这个自己玩</p>
<h6 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h6><p>直观的讲，Binder是Android中的一个类，它继承了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，从Android Framework角度来说，Binder是ServiceManager连接各种Manager(ActivityManager、WindowManager，等等)和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介。</p>
<p>** 创建AIDL示例 **<br>创建一个Book类，实现Parcelable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Parcelable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> bookId;<br>    <span class="hljs-keyword">private</span> String bookName;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(<span class="hljs-type">int</span> bookId, String bookName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookId = bookId;<br>        <span class="hljs-built_in">this</span>.bookName = bookName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">describeContents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToParcel</span><span class="hljs-params">(Parcel dest, <span class="hljs-type">int</span> flags)</span> &#123;<br>        dest.writeInt(<span class="hljs-built_in">this</span>.bookId);<br>        dest.writeString(<span class="hljs-built_in">this</span>.bookName);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(Parcel in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookId = in.readInt();<br>        <span class="hljs-built_in">this</span>.bookName = in.readString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Creator&lt;Book&gt; CREATOR = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Creator</span>&lt;Book&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">createFromParcel</span><span class="hljs-params">(Parcel source)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(source);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Book[] newArray(<span class="hljs-type">int</span> size) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>[size];<br>        &#125;<br>    &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>创建<code>IBookManager.aidl</code>文件，需要注意的是，在AndroidStudio中，右键创建aidl文件时候，IDE会自动创建一个和java平级的aidl文件夹，我们创建的aidl文件就在这里面。<br><img src="/image/Android/IPC/create_aidl.png" alt="create_aidl_file"><br>** Book.aidl **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.huangyuan.testandroid;<br>parcelable Book;<br></code></pre></td></tr></table></figure>
<p><code>Book.aidl</code>是<code>Book.java</code>类在AIDL中的声明。</p>
<p>** IBookManager.aidl **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// IBookManager.aidl</span><br><span class="hljs-keyword">package</span> com.example.huangyuan.testandroid;<br><span class="hljs-keyword">import</span> com.example.huangyuan.testandroid.Book;<br><span class="hljs-comment">// Declare any non-default types here with import statements</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBookManager</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Demonstrates some basic types that you can use as parameters</span><br><span class="hljs-comment">     * and return values in AIDL.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicTypes</span><span class="hljs-params">(<span class="hljs-type">int</span> anInt, <span class="hljs-type">long</span> aLong, <span class="hljs-type">boolean</span> aBoolean, <span class="hljs-type">float</span> aFloat,</span><br><span class="hljs-params">            <span class="hljs-type">double</span> aDouble, String aString)</span>;<br><br>     List&lt;Book&gt; <span class="hljs-title function_">getBookList</span><span class="hljs-params">()</span>;<br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(in Book book)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中 <code>basicTypes</code>是IDE自动生成的，我们自己添加 <code>getBookList()</code> 和 <code>addBook</code> 两个方法<br>尽管Book类和IBookManager的包名相同，但是在IBookManager中仍要导入Book类。下面看一下IDE生成的<code>IBookManager.java</code>类，该类在<code>app/build/generated/source/aidl/debug/packageName</code>包下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="hljs-comment"> * Original file: /Users/huangyuan/AndroidStudioProjects/TestAndroid/app/src/main/aidl/com/example/huangyuan/testandroid/IBookManager.aidl</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> com.example.huangyuan.testandroid;<br><span class="hljs-comment">// Declare any non-default types here with import statements</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBookManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.IInterface &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Local-side IPC implementation stub class.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.Binder <span class="hljs-keyword">implements</span> <span class="hljs-title class_">com</span>.example.huangyuan.testandroid.IBookManager &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">DESCRIPTOR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.example.huangyuan.testandroid.IBookManager&quot;</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Construct the stub at attach it to the interface.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stub</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">this</span>.attachInterface(<span class="hljs-built_in">this</span>, DESCRIPTOR);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Cast an IBinder object into an com.example.huangyuan.testandroid.IBookManager interface,</span><br><span class="hljs-comment">         * generating a proxy if needed.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.example.huangyuan.testandroid.IBookManager <span class="hljs-title function_">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span> &#123;<br>            <span class="hljs-keyword">if</span> ((obj == <span class="hljs-literal">null</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>            android.os.<span class="hljs-type">IInterface</span> <span class="hljs-variable">iin</span> <span class="hljs-operator">=</span> obj.queryLocalInterface(DESCRIPTOR);<br>            <span class="hljs-keyword">if</span> (((iin != <span class="hljs-literal">null</span>) &amp;&amp; (iin <span class="hljs-keyword">instanceof</span> com.example.huangyuan.testandroid.IBookManager))) &#123;<br>                <span class="hljs-keyword">return</span> ((com.example.huangyuan.testandroid.IBookManager) iin);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.example.huangyuan.testandroid.IBookManager.Stub.Proxy(obj);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> android.os.IBinder <span class="hljs-title function_">asBinder</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTransact</span><span class="hljs-params">(<span class="hljs-type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="hljs-type">int</span> flags)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;<br>            <span class="hljs-keyword">switch</span> (code) &#123;<br>                <span class="hljs-keyword">case</span> INTERFACE_TRANSACTION: &#123;<br>                    reply.writeString(DESCRIPTOR);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> TRANSACTION_basicTypes: &#123;<br>                    data.enforceInterface(DESCRIPTOR);<br>                    <span class="hljs-type">int</span> _arg0;<br>                    _arg0 = data.readInt();<br>                    <span class="hljs-type">long</span> _arg1;<br>                    _arg1 = data.readLong();<br>                    <span class="hljs-type">boolean</span> _arg2;<br>                    _arg2 = (<span class="hljs-number">0</span> != data.readInt());<br>                    <span class="hljs-type">float</span> _arg3;<br>                    _arg3 = data.readFloat();<br>                    <span class="hljs-type">double</span> _arg4;<br>                    _arg4 = data.readDouble();<br>                    java.lang.String _arg5;<br>                    _arg5 = data.readString();<br>                    <span class="hljs-built_in">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);<br>                    reply.writeNoException();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> TRANSACTION_getBookList: &#123;<br>                    data.enforceInterface(DESCRIPTOR);<br>                    java.util.List&lt;com.example.huangyuan.testandroid.Book&gt; _result = <span class="hljs-built_in">this</span>.getBookList();<br>                    reply.writeNoException();<br>                    reply.writeTypedList(_result);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> TRANSACTION_addBook: &#123;<br>                    data.enforceInterface(DESCRIPTOR);<br>                    com.example.huangyuan.testandroid.Book _arg0;<br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-number">0</span> != data.readInt())) &#123;<br>                        _arg0 = com.example.huangyuan.testandroid.Book.CREATOR.createFromParcel(data);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        _arg0 = <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">this</span>.addBook(_arg0);<br>                    reply.writeNoException();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onTransact(code, data, reply, flags);<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">com</span>.example.huangyuan.testandroid.IBookManager &#123;<br>            <span class="hljs-keyword">private</span> android.os.IBinder mRemote;<br><br>            Proxy(android.os.IBinder remote) &#123;<br>                mRemote = remote;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> android.os.IBinder <span class="hljs-title function_">asBinder</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> mRemote;<br>            &#125;<br><br>            <span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">getInterfaceDescriptor</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> DESCRIPTOR;<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * Demonstrates some basic types that you can use as parameters</span><br><span class="hljs-comment">             * and return values in AIDL.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicTypes</span><span class="hljs-params">(<span class="hljs-type">int</span> anInt, <span class="hljs-type">long</span> aLong, <span class="hljs-type">boolean</span> aBoolean, <span class="hljs-type">float</span> aFloat, <span class="hljs-type">double</span> aDouble, java.lang.String aString)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;<br>                android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_data</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>                android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_reply</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    _data.writeInterfaceToken(DESCRIPTOR);<br>                    _data.writeInt(anInt);<br>                    _data.writeLong(aLong);<br>                    _data.writeInt(((aBoolean) ? (<span class="hljs-number">1</span>) : (<span class="hljs-number">0</span>)));<br>                    _data.writeFloat(aFloat);<br>                    _data.writeDouble(aDouble);<br>                    _data.writeString(aString);<br>                    mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, <span class="hljs-number">0</span>);<br>                    _reply.readException();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    _reply.recycle();<br>                    _data.recycle();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> java.util.List&lt;com.example.huangyuan.testandroid.Book&gt; getBookList() <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;<br>                android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_data</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>                android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_reply</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>                java.util.List&lt;com.example.huangyuan.testandroid.Book&gt; _result;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    _data.writeInterfaceToken(DESCRIPTOR);<br>                    mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="hljs-number">0</span>);<br>                    _reply.readException();<br>                    _result = _reply.createTypedArrayList(com.example.huangyuan.testandroid.Book.CREATOR);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    _reply.recycle();<br>                    _data.recycle();<br>                &#125;<br>                <span class="hljs-keyword">return</span> _result;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(com.example.huangyuan.testandroid.Book book)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException &#123;<br>                android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_data</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>                android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_reply</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    _data.writeInterfaceToken(DESCRIPTOR);<br>                    <span class="hljs-keyword">if</span> ((book != <span class="hljs-literal">null</span>)) &#123;<br>                        _data.writeInt(<span class="hljs-number">1</span>);<br>                        book.writeToParcel(_data, <span class="hljs-number">0</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        _data.writeInt(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="hljs-number">0</span>);<br>                    _reply.readException();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    _reply.recycle();<br>                    _data.recycle();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRANSACTION_basicTypes</span> <span class="hljs-operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRANSACTION_getBookList</span> <span class="hljs-operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRANSACTION_addBook</span> <span class="hljs-operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Demonstrates some basic types that you can use as parameters</span><br><span class="hljs-comment">     * and return values in AIDL.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicTypes</span><span class="hljs-params">(<span class="hljs-type">int</span> anInt, <span class="hljs-type">long</span> aLong, <span class="hljs-type">boolean</span> aBoolean, <span class="hljs-type">float</span> aFloat, <span class="hljs-type">double</span> aDouble, java.lang.String aString)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException;<br><br>    <span class="hljs-keyword">public</span> java.util.List&lt;com.example.huangyuan.testandroid.Book&gt; getBookList() <span class="hljs-keyword">throws</span> android.os.RemoteException;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(com.example.huangyuan.testandroid.Book book)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>结构比较简单，最外面是IBookManager接口，<br>其中声明了一个抽象内部类Stub，在该类中，声明了一个Proxy代理类。还声明了三个静态变量来标志aidl文件中的三个方法。这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由内部Proxy类来完成。<br>最后，声明了aidl文件中的三个方法。<br>下面详细介绍：<br>** DESCRIPTOR **<br>Binder的唯一标示，一般用当前Binder的类名标示</p>
<p>** asInterface(android.os.IBinder obj) **<br>用于将服务端的BInder对象转换成客户端所需的AIDL借口类型的对象，这种转换过程是区分进程的，如果客户端和服务端位于同一进程，那么此方法返回的就是服务端的Stub对象本身，否则返回的是系统封装后的Stub.proxy对象。</p>
<p>** asBinder **<br>用于返回当前Binder对象</p>
<p>** onTransact **<br>这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为public Boolean onTransact(int code,android.os. Parcel data,android.os.Parcel reply,int flags)。服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数(如果目标方法有参数的话)，然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值(如果目标方法有返回值的话)，onTransact方 法的执行过程就是这样的。需要注意的是，如果此方法返回false,那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便-一个进程都能远程调用我们的服务。</p>
<p>** Proxy#getBookList **<br>这个方法运行在客户端，当客户端远程调用此方法时，它的内部实现是这样的:首先创建该方法所需要的输入型Parcel对象_data、 输出型Parcel对象_ reply和返回值对象List;然后把该方法的参数信息写入_data中(如果有参数的话);接着调用transact方法来发起RPC (远程过程调用)请求，同时当前线程挂起;然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中 取出RPC过程的返回结果;最后返回_reply中的数据。</p>
<p>** Proxy#addBook **<br>这个方法运行在客户端，它的执行过程和getBookList是一样的，addBook没有返回值，所以它不需要从_replay中取出返回值。</p>
<p>接下来，我们介绍Binder的两个很重要的方法linkToDeath和unlinkToDeath。我们知道，Binder运行在服务端进程，如果服务端进程由于某种原因异常终止，这个时候我们到服务端的Binder连接断裂(称之为Binder死亡)，会导致我们的远程调用失败。更为关键的是，如果我们不知道Binder连接已经断裂，那么客户端的功能就会受到影响。为了解决这个问题，Binder中提供 了两个配对的方法linkToDeath和unlinkToDeath,通过linkToDeath我们可以给Binder设置- - 个死亡代理，当Binder死亡时， 我们就会收到通知，这个时候我们就可以重新发起连接请求从而恢复连接。那么到底如何给Binder设置死亡代理呢?也很简单。<br>首先，声明一个DeathRecipient对象。DeathRecipient是一个接口，其内部只有一个方法binderDied,我们需要实现这个方法，当Binder死亡的时 候，系统就会回调binderDied方法，然后我们就可以移出之前绑定的binder代理并重新绑定远程服务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> IBinder .<span class="hljs-type">DeathRecipient</span> <span class="hljs-variable">mDeathRecipient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IBinder</span>.DeathRecipient() &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">binderDied</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">if</span> ( mBookManager ==<span class="hljs-literal">null</span>)<br>				<span class="hljs-keyword">return</span>;<br><br>		mBookManager.asBinder().unlinkToDeath(mDeathRecipient <span class="hljs-number">0</span>);<br>		mBookManager = <span class="hljs-literal">null</span>;<br>	&#125;<br>);<br></code></pre></td></tr></table></figure>
<p>其次，在客户端绑定远程服务成功后，给binder设置死亡代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">mService = IMessageBoxManager.Stub.asInterface(binder);<br>binder.linkToDeath(mDeathRecipient,<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<p>其中linkToDeath的第二个参数是个标记位，我们直接设为0即可。经过上面两个步骤，就给我们的Binder设置了死亡代理，当Binder死 亡的时候我们就可以收到通知了。另外，通过Binder的 方法isBinderAlive也可以判断Binder是否死亡。</p>
<h2 id="这一篇全部都是抄的《Android开发艺术探索》第2-3-3Binder-章节上的内容，毕竟一直带着书也不现实"><a href="#这一篇全部都是抄的《Android开发艺术探索》第2-3-3Binder-章节上的内容，毕竟一直带着书也不现实" class="headerlink" title="** 这一篇全部都是抄的《Android开发艺术探索》第2.3.3Binder 章节上的内容，毕竟一直带着书也不现实 **"></a>** 这一篇全部都是抄的《Android开发艺术探索》第2.3.3Binder 章节上的内容，毕竟一直带着书也不现实 **</h2><p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中使用WebSocket</title>
    <url>/2017/12/25/Android%E4%B8%AD%E4%BD%BF%E7%94%A8WebSocket/</url>
    <content><![CDATA[<p>背景：后端逻辑框架调整，将原来的推送和轮询方式改成了使用<code>WebSocket</code>通信。原来的请求方式是由app发起请求，appServer对请求进行分发，中转中继服务器将具体请求下发到对应的物联网服务器，物联网服务器将指令下发到指定的设备。整个流程涉及到很多层http请求，并且每个服务的回调接口还不一致，只能在app发情请求之后，接着去轮询服务器，服务器端去查询设备状态、是否对指令有响应。<br>改版后涉及到对物联网的请求全部改成<code>WebSocket</code>,不在轮询，而是被动等待。<br>后端使用的是<code>Spring</code>实现的<code>WebSocket</code>,app端使用的是<a href="https://github.com/TooTallNate/Java-WebSocket">https://github.com/TooTallNate/Java-WebSocket</a>这个开源项目。</p>
<span id="more"></span>
<h4 id="APP端实现"><a href="#APP端实现" class="headerlink" title="APP端实现"></a>APP端实现</h4><ol>
<li>添加依赖<code>compile &quot;org.java-websocket:Java-WebSocket:1.3.7&quot;</code></li>
<li>我们只需要关心三方库中<code>WebSocketClient</code>类就可以了，其他细节底层已经封装好了。</li>
<li>类中有四个方法需要重写：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**打开连接*/</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(ServerHandshake handshakedata)</span><br> <span class="hljs-comment">/**服务端返回消息*/</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message)</span> <br> <span class="hljs-comment">/**关闭连接*/</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(<span class="hljs-type">int</span> code, String reason, <span class="hljs-type">boolean</span> remote)</span><br> <span class="hljs-comment">/**出现异常*/</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Exception ex)</span><br></code></pre></td></tr></table></figure></li>
<li>一个简单的小测试，app端定义了一个发送按钮，和一个展示消息的文本<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;com.huangyuanlove.testwebsocket.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ScrollView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/show_message&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ScrollView</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">EditText</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/edit_text&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/send&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/colorAccent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;发送&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@android:color/black&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>在代码里面处理具体逻辑：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.os.Handler;<br><span class="hljs-keyword">import</span> android.os.Message;<br><span class="hljs-keyword">import</span> android.support.design.widget.Snackbar;<br><span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity;<br><span class="hljs-keyword">import</span> android.view.View;<br><span class="hljs-keyword">import</span> android.widget.EditText;<br><span class="hljs-keyword">import</span> android.widget.TextView;<br><br><span class="hljs-keyword">import</span> org.java_websocket.client.WebSocketClient;<br><span class="hljs-keyword">import</span> org.java_websocket.handshake.ServerHandshake;<br><br><span class="hljs-keyword">import</span> java.net.URI;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br><br><br>    <span class="hljs-keyword">private</span> TextView showMessage;<br>    <span class="hljs-keyword">private</span> EditText editText;<br>    <span class="hljs-keyword">private</span> WebSocketClient webSocketClient;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>.Callback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            sb.append(<span class="hljs-string">&quot;服务器返回数据：&quot;</span>);<br>            sb.append(msg.obj.toString());<br>            sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>            showMessage.setText(sb.toString());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        showMessage = findViewById(R.id.show_message);<br>        editText = findViewById(R.id.edit_text);<br>        findViewById(R.id.send).setOnClickListener(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-type">URI</span> <span class="hljs-variable">serverURI</span> <span class="hljs-operator">=</span> URI.create(<span class="hljs-string">&quot;ws://192.168.1.199:8887&quot;</span>);<br>        webSocketClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocketClient</span>(serverURI) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(ServerHandshake handshakedata)</span> &#123;<br>                sb.append(<span class="hljs-string">&quot;onOpen at time：&quot;</span>);<br>                sb.append(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                sb.append(<span class="hljs-string">&quot;服务器状态：&quot;</span>);<br>                sb.append(handshakedata.getHttpStatusMessage());<br>                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>                showMessage.setText(sb.toString());<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(String message)</span> &#123;<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">handlerMessage</span> <span class="hljs-operator">=</span> Message.obtain();<br>                handlerMessage.obj = message;<br>                handler.sendMessage(handlerMessage);<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(<span class="hljs-type">int</span> code, String reason, <span class="hljs-type">boolean</span> remote)</span> &#123;<br>                sb.append(<span class="hljs-string">&quot;onClose at time：&quot;</span>);<br>                sb.append(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>                sb.append(<span class="hljs-string">&quot;onClose info:&quot;</span>);<br>                sb.append(code);<br>                sb.append(reason);<br>                sb.append(remote);<br>                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>                showMessage.setText(sb.toString());<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Exception ex)</span> &#123;<br>                sb.append(<span class="hljs-string">&quot;onError at time：&quot;</span>);<br>                sb.append(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>                sb.append(ex);<br>                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>                showMessage.setText(sb.toString());<br>            &#125;<br>        &#125;;<br>        webSocketClient.connect();<br><br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (v.getId()) &#123;<br>            <span class="hljs-keyword">case</span> R.id.send:<br>                <span class="hljs-keyword">if</span>(webSocketClient.isClosed() || webSocketClient.isClosing())&#123;<br>                    Snackbar.make(v,<span class="hljs-string">&quot;Client正在关闭&quot;</span>,Snackbar.LENGTH_SHORT).show();<br>                    webSocketClient.connect();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                webSocketClient.send(editText.getText().toString().trim());<br>                sb.append(<span class="hljs-string">&quot;客户端发送消息：&quot;</span>);<br>                sb.append(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>                sb.append(editText.getText().toString().trim());<br>                sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>                showMessage.setText(sb.toString());<br>                editText.setText(<span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h4>上面提到我们后端使用的Spring中的WebSocket实现，其实用什么实现服务端无所谓，只要遵循协议就可以。个人在本地做测试的时候用的还是这个开源项目。</li>
<li>服务端只需要关心<code>WebSocketServer</code>这个类就好，这个类里面有五个方法需要重写：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**服务开启*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> <br><span class="hljs-comment">/**有客户端连接*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(WebSocket webSocket, ClientHandshake clientHandshake)</span><br><span class="hljs-comment">/**服务端关闭*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(WebSocket webSocket, <span class="hljs-type">int</span> i, String s, <span class="hljs-type">boolean</span> b)</span><br><span class="hljs-comment">/**收到客户端的消息*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(WebSocket webSocket, String s)</span><br><span class="hljs-comment">/**出现异常*/</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(WebSocket webSocket, Exception e)</span> <br></code></pre></td></tr></table></figure></li>
<li>具体代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huangyuanlove;<br><br><span class="hljs-keyword">import</span> org.java_websocket.WebSocket;<br><span class="hljs-keyword">import</span> org.java_websocket.WebSocketImpl;<br><span class="hljs-keyword">import</span> org.java_websocket.handshake.ClientHandshake;<br><span class="hljs-keyword">import</span> org.java_websocket.server.WebSocketServer;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.net.InetSocketAddress;<br><span class="hljs-keyword">import</span> java.net.UnknownHostException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestWebSocket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSocketServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestWebSocket</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> UnknownHostException &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestWebSocket</span><span class="hljs-params">(InetSocketAddress address)</span> &#123;<br>        <span class="hljs-built_in">super</span>(address);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        WebSocketImpl.DEBUG = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8887</span>; <span class="hljs-comment">// 843 flash policy port</span><br>            <span class="hljs-type">TestWebSocket</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestWebSocket</span>(port);<br>            s.start();<br>            System.out.println(<span class="hljs-string">&quot;ChatServer started on port: &quot;</span> + s.getPort());<br><br>            <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">sysin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> sysin.readLine();<br>                s.broadcast(in);<br>                <span class="hljs-keyword">if</span> (in.equals(<span class="hljs-string">&quot;exit&quot;</span>)) &#123;<br>                    s.stop(<span class="hljs-number">1000</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onOpen</span><span class="hljs-params">(WebSocket webSocket, ClientHandshake clientHandshake)</span> &#123;<br><br>        broadcast(<span class="hljs-string">&quot;new connection: &quot;</span> + clientHandshake.getResourceDescriptor());<br>        System.out.println(webSocket.getRemoteSocketAddress().getAddress().getHostAddress() + <span class="hljs-string">&quot; entered the room!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClose</span><span class="hljs-params">(WebSocket webSocket, <span class="hljs-type">int</span> i, String s, <span class="hljs-type">boolean</span> b)</span> &#123;<br>        broadcast(webSocket + <span class="hljs-string">&quot; onClose&quot;</span>);<br>        System.out.println(webSocket + <span class="hljs-string">&quot; onClose&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(WebSocket webSocket, String s)</span> &#123;<br><br>        broadcast(s);<br>        System.out.println(webSocket + <span class="hljs-string">&quot;: &quot;</span> + s);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(WebSocket webSocket, Exception e)</span> &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">if</span> (webSocket != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// some errors like port binding failed may not be assignable to a specific websocket</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Server started!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
上面代码中<code>onMessage</code>方法中的<code>broadcast</code>方法是向所有连接到服务器的客户端发送消息(广播发送，其实就是一个小型的局域网聊天室)，如果只是谁发来的消息就回复给谁，可以调用<code>webSocket.send()</code>方法。<br>是用的时候先开启服务端，然后开启客户端(app)，需要注意是的，在客户端中重写的方法都不是在主线程中，如果需要更新UI，请切换到UI线程。<br>或者在客户端中使用<code>Service</code>,在<code>Service</code>中收到消息之后，广播给UI界面。</li>
</ol>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多进程-二</title>
    <url>/2018/06/22/Android%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%BA%8C/</url>
    <content><![CDATA[<p>Android中中IPC方式有很多，比如使用Bundle，使用文件共享，使用Messenger，使用AIDL，使用ContentProvider，使用Socket等。前两种方式比较简单，自己玩。<br>下面主要是抄的《Android开发艺术探索》2.4.3章节，看过书的就不用看了。</p>
<span id="more"></span>
<p>Messenger可以翻译为信使，顾名思义，通过它可以在不同进程中传递Message对象,在Message中放入我们需要传递的数据，就可以轻松地实现数据的进程间传递了。Messenger是一种轻量级的IPC方案，它的底层实现是AIDL，为什么这么说呢，我们大致看一下Messenger这个类的构造方法就明白了。下面是Messenger的两个构造方法，从构造方法的实现上我们可以明显看出AIDL的痕迹，不管是IMessenger还是Stub.asInterface,这种使用方法都表明它的底层是AIDL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Messenger</span> <span class="hljs-params">(Handler target)</span> &#123;<br>    mTarget = target.getIMessenger();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Messenger</span> <span class="hljs-params">( IBinder target)</span> &#123;<br>    mTarget = IMessenger.Stub.asInterface(target);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Messenger的使用方法很简单，它对AIDL做了封装，使得我们可以更简便地进行进程间通信。同时，由于它一次处理一个请求，因此在服务端我们不用考虑线程同步的问题，这是因为服务端中不存在并发执行的情形。实现一个Messenger有如下几个步骤，分为服务端和客户端。</p>
<ol>
<li>服务端进程<br>首先，我们需要在服务端创建–个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建一个Messenger对 象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。</li>
<li>客户端进程<br>客户端进程中，首先要绑定服务端的Service,绑定成功后用服务端返回的IBinder对象创建一个Messenger,通过这个Messenger就可以向服务端发送消息了，发消息类型为Message对象。如果需要服务端能够回应客户端，就和服务端一-样，我们还需要创建一个Handler并创建一个 新的Messenger,并把这个Messenger对象通过Message的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。</li>
</ol>
<p>首先看服务端的代码，这是服务端的典型代码，可以看到MessengerHandler用来处理客户端发送的消息，并从消息中取出客户端发来的文本信息。而mMessenger是一个Messenger对象，它和MessengerHandler相关联，并在onBind方法中返回它里面的Binder对象，可以看出，这里Messenger的作用是将客户端发送的消息传递给MessengerHandler处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessengerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessengerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-keyword">switch</span> (msg.what)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">10001</span>:<br>                    Log.e(<span class="hljs-string">&quot;xuan&quot;</span>,<span class="hljs-string">&quot;收到客户端&quot;</span>+msg.getData().getString(<span class="hljs-string">&quot;msg&quot;</span>));<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-built_in">super</span>.handleMessage(msg);<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Messenger</span> <span class="hljs-variable">messenger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Messenger</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessengerHandler</span>());<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-keyword">return</span> messenger.getBinder();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>然后注册<code>service</code>,让其在单独的进程中运行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;.messenger.MessengerService&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:</span> <span class="hljs-attr">process</span>=<span class="hljs-string">&quot;:remote&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>在客户端,首先需要绑定远程进程的MessengerService,绑定成功后，根据服务端返回的binder对象创建Messenger对象并使用此对象向服务端发送消息。下面的代码在Bundle中向服务端发送了一句话，在，上面的服务端代码中会打印出这句话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessengerActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> Messenger mService;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ServiceConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> &#123;<br>            mService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Messenger</span>(service);<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain(<span class="hljs-literal">null</span>,<span class="hljs-number">10001</span>);<br>            <span class="hljs-type">Bundle</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>            data.putString(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hi 来自客户端的问候&quot;</span>);<br>            msg.setData(data);<br>            <span class="hljs-keyword">try</span> &#123;<br>                mService.send(msg);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> &#123;<br><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_messenger2);<br><br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, MessengerService.class);<br>        bindService(intent,connection, Context.BIND_AUTO_CREATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        unbindService(connection);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>通过上面的例子可以看出，在Messenger中进行数据传递必须将数据放入Message中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。简单来说,Message中所支持的数据类型就是Messenger所支持的传输类型。实际上，通过Messenger来传输Message, Message中 能使用的载体只有what、arg1、 arg2、 Bundle 以及replyTo。Message中的另一个字段object在同一-个进程中是很实用的，但是在进程间通信的时候，在Android2.2以前object字段不支持跨进程传输，即便是2.2以后，也仅仅是系统提供的实现了Parcelable接口的对象才能通过它来传输。这就意味着我们自定义的Parcelable对象是无法通过object字段来传输的，读者可以试一下。非系统的Parcelable对象的确无法通过object字段来传输，这也导致了object字段的实用性大大降低，所幸我们还有Bundle,Bundle中可以支持大量的数据类型。<br>上面的例子演示了如何在服务端接收客户端中发送的消息，但是有时候我们还需要能回应客户端，下面就介绍如何实现这种效果。还是采用上面的例子，但是稍微做一下修改，每当客户端发来一条消息，服务端就会自动回复一条“嗯，你的消息我已经收到，稍后会回复你。”，这很类似邮箱的自动回复功能。</p>
<p>首先看服务端的修改，服务端只需要修改MessengerHandler,当收到消息后，会立即回复一条消息给客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessengerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessengerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-keyword">switch</span> (msg.what)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">10001</span>:<br>                    Log.e(<span class="hljs-string">&quot;huangyuan&quot;</span>,<span class="hljs-string">&quot;收到客户端&quot;</span>+msg.getData().getString(<span class="hljs-string">&quot;msg&quot;</span>));<br>                    <span class="hljs-type">Messenger</span> <span class="hljs-variable">clientMessenger</span> <span class="hljs-operator">=</span> msg.replyTo;<br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> Message.obtain(<span class="hljs-literal">null</span>,<span class="hljs-number">10001</span>);<br>                    <span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>                    bundle.putString(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;服务端回应&quot;</span>);<br>                    message.setData(bundle);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        clientMessenger.send(message);<br>                    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br><br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-built_in">super</span>.handleMessage(msg);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Messenger</span> <span class="hljs-variable">messenger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Messenger</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessengerHandler</span>());<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-keyword">return</span> messenger.getBinder();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>为了接收服务端的消息，客户端也需要准备一个接收消息的Messenger和Handler:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessengerActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Messenger mService;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Messenger</span> <span class="hljs-variable">getReplyMessenger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Messenger</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessengerHandler</span>());<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ServiceConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> &#123;<br>            mService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Messenger</span>(service);<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> Message.obtain(<span class="hljs-literal">null</span>,<span class="hljs-number">10001</span>);<br>            <span class="hljs-type">Bundle</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>            data.putString(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hi 来自客户端的问候&quot;</span>);<br>            msg.setData(data);<br>            msg.replyTo = getReplyMessenger;<br>            <span class="hljs-keyword">try</span> &#123;<br>                mService.send(msg);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> &#123;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessengerHandler</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-keyword">switch</span> (msg.what)&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">10001</span>:<br>                    Log.e(<span class="hljs-string">&quot;huangyuan&quot;</span>,<span class="hljs-string">&quot;收到服务端的回复--&gt;&quot;</span>+ msg.getData().get(<span class="hljs-string">&quot;msg&quot;</span>));<br>                    <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-built_in">super</span>.handleMessage(msg);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_messenger2);<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>, MessengerService.class);<br>        bindService(intent,connection, Context.BIND_AUTO_CREATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        unbindService(connection);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>关键的一点在于当客户端发送消息的时候，需要把接收服务端回复的Messenger通过Message的replyTo参数传递给服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">msg.replyTo = getReplyMessenger;<br></code></pre></td></tr></table></figure>

<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android布局文件中的xmlns:tools</title>
    <url>/2018/01/04/Android%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84xmlns-tools/</url>
    <content><![CDATA[<p>在使用AndroidStudio创建布局文件的时候，跟布局下总是有如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RootTag</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;***.***Activity&quot;</span> &gt;</span><br></code></pre></td></tr></table></figure>
<p>于是在官网查了一下这俩货是干嘛用的，下面是自己的翻译+实践</p>
<span id="more"></span>
<p><code>xmlns</code>的全称是<code>xmlnamespace</code>,和c++中<code>namespace</code>差不多，都是为了解决命名上的冲突问题。<br>在Android布局文件中，常见的<code>xmlns</code>大概有三个（你可以随意命名，把tools改成bug也可以，只要对应使用tools的地方都改成bug，说白了，它只是个变量而已）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;<br>xmlns:tools=&quot;http://schemas.android.com/tools&quot;<br>xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;<br></code></pre></td></tr></table></figure>
<h6 id="android"><a href="#android" class="headerlink" title="android"></a>android</h6><p>用于Android系统定义的一些属性</p>
<h6 id="app"><a href="#app" class="headerlink" title="app"></a>app</h6><p>用于我们自定义的一些属性</p>
<h6 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h6><p>给IDE或者预览界面用的，当打包编译时并不会包含在apk中。</p>
<h4 id="tools可以干什么"><a href="#tools可以干什么" class="headerlink" title="tools可以干什么"></a>tools可以干什么</h4><p>先看官网介绍 <a href="https://developer.android.com/studio/write/tool-attributes.html">https://developer.android.com/studio/write/tool-attributes.html</a></p>
<blockquote>
<p>Android Studio supports a variety of XML attributes in the tools namespace that enable design-time features (such as which layout to show in a fragment) or compile-time behaviors (such as which shrinking mode to apply to your XML resources). When you build your app, the build tools remove these attributes so there is no effect on your APK size or runtime behavior.</p>
</blockquote>
<p>大致意思就是说使用<code>tools</code>后面的属性不会再编译时存在，只存在于设计时的预览，不会影响apk的体积，</p>
<h5 id="Error-handling-attributes"><a href="#Error-handling-attributes" class="headerlink" title="Error handling attributes"></a>Error handling attributes</h5><p>影响Lint提示的属性主要有下面三种：</p>
<blockquote>
<p><strong>tools:ignore</strong><br>Intended for: Any element<br>Used by: Lint</p>
</blockquote>
<blockquote>
<p><strong>tools:targetApi</strong><br>Intended for: Any element<br>Used by: Lint</p>
</blockquote>
<blockquote>
<p><strong>tools:locale</strong><br>Intended for: resources<br>Used by: Lint, Android Studio editor</p>
</blockquote>
<p><code>ignore</code>属性是告诉Lint忽略xml中的某些警告，比如我们在<code>ImageView</code>或者<code>ImageButton</code>中没有写<code>contentDescription</code>属性，Lint会有警告：<code>Missing contentDescription attribute on image</code>,原因是这个属性是提供无障碍阅读的，没有这个属性的话<code>Screen Reader</code>无法正常工作，但是有些特定分类的软件是不考虑这些东西的。虽然这种警告无所谓，但是对于要求代码中不能有warning的公司来说，这是不可取的，我们可以用<code>ignore</code>属性来忽略这个警告(如果你说你改了Lint的警告级别，当我没说)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;@dimen/margin_main&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;@dimen/margin_main&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/divider&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">tools:ignore</span>=<span class="hljs-string">&quot;contentDescription&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>targetApi</code>和代码中的注解<code>@RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)</code>差不多。假设配置文件中的最小sdkLevel为11，而布局文件中使用了21的控件比如<code>GridLayout</code>,Lint会有警告，为了消除这个警告，可以这么写：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">GridLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:targetApi</span>=<span class="hljs-string">&quot;14&quot;</span> &gt;</span><br></code></pre></td></tr></table></figure>
<p><code>locale</code>是告诉Lint和AndroidStudio editor默认的是什么语言，如果不指定的话，默认是英语。可以把这个属性添加到<code>values/strings.xml</code>中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span> <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:locale</span>=<span class="hljs-string">&quot;es&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<h5 id="Design-time-view-attributes-设计时试图属性"><a href="#Design-time-view-attributes-设计时试图属性" class="headerlink" title="Design-time view attributes(设计时试图属性)"></a>Design-time view attributes(设计时试图属性)</h5><h6 id="tools-instead-of-android"><a href="#tools-instead-of-android" class="headerlink" title="tools: instead of android"></a>tools: instead of android</h6><p><strong>Intended for:</strong> <em><code>View</code></em><br><strong>Used by:</strong>  <em>Android Studio layout editor</em></p>
<p>我们有一个<code>TextView</code>，需要显示从网络获取到的文件，控件大小是<code>wrap_content</code>,但是<code>TextView</code>中没有文字的话在预览界面中是看不到的，大部分同学可能会使用<code>android:text=XXXX</code>这个属性，调整好布局之后再把文字删除。一两个控件还好说，控件多了指不定哪个控件就忘记删除文本了，我们可以使用<code>tools</code>这个东西：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/unlock_bike&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#12345678&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:paddingBottom</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:paddingTop</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:text</span>=<span class="hljs-string">&quot;测试用例&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>这时我们在IDE预览界面是可以看到文字的，打包成apk运行在手机上时是看不到的。<br>总之，<code>tools</code>可以告诉<code>Android Studio</code>哪些属性在运行的时候是被忽略的，只在设计布局的时候有效。基本上原生控件的属性都可以这么使用。</p>
<h6 id="tools-context"><a href="#tools-context" class="headerlink" title="tools:context"></a>tools:context</h6><p><strong>Intended for:</strong> <em>Any root View</em><br><strong>Used by:</strong>  <em>Lint, Android Studio layout editor</em><br>这个属性告诉IDE当前布局和哪个activity相关联，在预览界面使用关联Activity的主题展示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.ConstraintLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span> &gt;</span><br></code></pre></td></tr></table></figure>
<h6 id="tools-itemCount"><a href="#tools-itemCount" class="headerlink" title="tools:itemCount"></a>tools:itemCount</h6><p><strong>Intended for:</strong> <em>RecyclerView</em><br><strong>Used by:</strong> <em>Android Studio layout editor</em><br>这个属性告诉编辑器在预览窗口展示多少个列表项</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.RecyclerView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/recyclerView&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:itemCount</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<h6 id="tools-layout"><a href="#tools-layout" class="headerlink" title="tools:layout"></a>tools:layout</h6><p><strong>Intended for:</strong> <em><code>fragment</code></em><br><strong>Used by:</strong> <em>Android Studio layout editor</em><br>这个属性告诉编辑器fragment中显示哪个布局文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">fragment</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.master.ItemListFragment&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/list_content&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<h6 id="tools-listitem-x2F-tools-listheader-x2F-tools-listfooter"><a href="#tools-listitem-x2F-tools-listheader-x2F-tools-listfooter" class="headerlink" title="tools:listitem &#x2F; tools:listheader &#x2F; tools:listfooter"></a>tools:listitem &#x2F; tools:listheader &#x2F; tools:listfooter</h6><p><strong>Intended for:</strong> <em><code>AdapterView</code> (and subclasses like <code>ListView</code>)</em><br><strong>Used by:</strong> <em>Android Studio layout editor</em><br>看属性名字就能猜出来了，预览界面显示列表的头部，底部和列表项布局</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ListView</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@android:id/list&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:listitem</span>=<span class="hljs-string">&quot;@layout/sample_list_item&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:listheader</span>=<span class="hljs-string">&quot;@layout/sample_list_header&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:listfooter</span>=<span class="hljs-string">&quot;@layout/sample_list_footer&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<h6 id="tools-showIn"><a href="#tools-showIn" class="headerlink" title="tools:showIn"></a>tools:showIn</h6><p><strong>Intended for:</strong> <em>Any root <code>View</code> in a layout that’s referred to by an <code>include</code></em><br><strong>Used by:</strong> <em>Android Studio layout editor</em><br>此属性可以通过指向使用此布局包含的布局，因此您可以预览(和编辑)这个文件，因为它嵌入在其父布局时出现</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;@string/hello_world&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:showIn</span>=<span class="hljs-string">&quot;@layout/activity_main&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<h6 id="tools-menu"><a href="#tools-menu" class="headerlink" title="tools:menu"></a>tools:menu</h6><p><strong>Intended for:</strong>  <em>Any root <code>View</code></em><br><strong>Used by:</strong> <em>Android Studio layout editor</em><br>此属性指定菜单应该显示在应用程序栏的布局预览。该值可以是一个或多个菜单id，由逗号分隔</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:menu</span>=<span class="hljs-string">&quot;menu1,menu2&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<h6 id="tools-minValue-x2F-tools-maxValue"><a href="#tools-minValue-x2F-tools-maxValue" class="headerlink" title="tools:minValue &#x2F; tools:maxValue"></a>tools:minValue &#x2F; tools:maxValue</h6><p><strong>Intended for:</strong> <em><code>NumberPicker</code></em><br><strong>Used by:</strong> <em>Android Studio layout editor</em><br>设置NumberPicker的最大值和最小值</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberPicker</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/numberPicker&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:minValue</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:maxValue</span>=<span class="hljs-string">&quot;10&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<h6 id="tools-openDrawer"><a href="#tools-openDrawer" class="headerlink" title="tools:openDrawer"></a>tools:openDrawer</h6><p><strong>Intended for:</strong> <em><code>DrawerLayout</code></em><br><strong>Used by:</strong> <em>Android Studio layout editor</em><br>设置<code>DrawerLayout</code>在预览窗口的打开位置</p>
<table>
<thead>
<tr>
<th align="center">Constant</th>
<th align="center">Value</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">end</td>
<td align="center">800005</td>
<td align="center">Push object to the end of its container, not changing its size.</td>
</tr>
<tr>
<td align="center">left</td>
<td align="center">3</td>
<td align="center">Push object to the left of its container, not changing its size.</td>
</tr>
<tr>
<td align="center">right</td>
<td align="center">5</td>
<td align="center">Push object to the right of its container, not changing its size.</td>
</tr>
<tr>
<td align="center">start</td>
<td align="center">800003</td>
<td align="center">Push object to the beginning of its container, not changing its size.</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.v4.widget.DrawerLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/drawer_layout&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:openDrawer</span>=<span class="hljs-string">&quot;start&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>下面的不想翻译了，链接在下面<br><a href="https://developer.android.com/studio/write/tool-attributes.html#resource_shrinking_attributes">https://developer.android.com/studio/write/tool-attributes.html#resource_shrinking_attributes</a><br>自己撸吧</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android多进程三</title>
    <url>/2018/07/23/Android%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%89/</url>
    <content><![CDATA[<p>Android中中IPC方式有很多，比如使用Bundle，使用文件共享，使用Messenger，使用AIDL，使用ContentProvider，使用Socket等。前两种方式比较简单，自己玩。<br>下面主要是抄的《Android开发艺术探索》2.4.4章节，看过书的就不用看了。</p>
<span id="more"></span>
<p>上一篇主要抄了Messenger来进行进程间通信的方法，可以发现Messenger是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务端，服务端仍然只能一个个处理，如果有大量的并发请求，那么用Messenger就不太合适了。同时，Messenger的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了，但是我们可以使用AIDL来实现跨进程的方法调用。AIDL也是Messenger的底层实现，因此Messenger本质上也是AIDL，只不过系统为我们做了封装从而方便上层的调用而已。在上一节中，我们介绍了Binder的概念，大家对Binder也有了一定的了解，在Binder的基础上我们可以更加容易地理解AIDL。这里先介绍使用AIDL来进行进程间通信的流程，分为服务端和客户端两个方面。</p>
<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。</p>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>客户端所要做事情就稍微简单一些，首先需要绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。</p>
<h5 id="具体实现方式"><a href="#具体实现方式" class="headerlink" title="具体实现方式"></a>具体实现方式</h5><h6 id="AIDL接口的创建"><a href="#AIDL接口的创建" class="headerlink" title="AIDL接口的创建"></a>AIDL接口的创建</h6><p>收看看AIDL接口的创建，如下所示创建了一个后缀为AIDL的文件，在里面声明了一个接口和两个方法。创建AIDL文件的方式可以看这个<a href="http://blog.huangyuanlove.com/2018/06/21/Android%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/#more">Android多进程(一)</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// IBookManager.aidl</span><br><span class="hljs-keyword">package</span> com.huangyuanlove.testandroid;<br><br><span class="hljs-comment">// Declare any non-default types here with import statements</span><br><span class="hljs-keyword">import</span> com.huangyuanlove.testandroid.Book;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBookManager</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Demonstrates some basic types that you can use as parameters</span><br><span class="hljs-comment">     * and return values in AIDL.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicTypes</span><span class="hljs-params">(<span class="hljs-type">int</span> anInt, <span class="hljs-type">long</span> aLong, <span class="hljs-type">boolean</span> aBoolean, <span class="hljs-type">float</span> aFloat,</span><br><span class="hljs-params">            <span class="hljs-type">double</span> aDouble, String aString)</span>;<br>            List&lt;Book&gt; <span class="hljs-title function_">getBookList</span><span class="hljs-params">()</span>;<br>            <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(in Book book)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在AIDL文件中，并不是所有的数据类型都是可以使用的，只支持如下几种类型：</p>
<ul>
<li>基本数据类型（int、long、char、boolean、double等）；</li>
<li>String和CharSequence；</li>
<li>List：只支持ArrayList，里面每个元素都必须能够被AIDL支持；</li>
<li>Map：只支持HashMap，里面的每个元素都必须被AIDL支持，包括key和value；</li>
<li>Parcelable：所有实现了Parcelable接口的对象；</li>
<li>AIDL：所有的AIDL接口本身也可以在AIDL文件中使用。</li>
</ul>
<p>以上6种数据类型就是AIDL所支持的所有类型，其中自定义的Parcelable对象和AIDL对象必须要显式import进来，不管它们是否和当前的AIDL文件位于同一个包内。比如IBookManager.aidl这个文件，里面用到了Book这个类，这个类实现了Parcelable接口并且和IBookManager.aidl位于同一个包中，但是遵守AIDL的规范，我们仍然需要显式地import进来：com.huangyuanlove.testandroid.Book。<br>另外一个需要注意的地方是，如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelable类型。在上面的IBookManager.aidl中，我们用到了Book这个类，所以，我们必须要创建Book.aidl，然后在里面添加如下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huangyuanlove.testandroid;<br>parcelable Book;<br></code></pre></td></tr></table></figure>

<h6 id="远程服务端Service的实现"><a href="#远程服务端Service的实现" class="headerlink" title="远程服务端Service的实现"></a>远程服务端Service的实现</h6><p>上面讲述了如何定义AIDL接口，接下来实现这个接口。先创建一个service，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huangyuanlove.testandroid;<br><br><span class="hljs-keyword">import</span> android.app.Service;<br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.os.Binder;<br><span class="hljs-keyword">import</span> android.os.IBinder;<br><span class="hljs-keyword">import</span> android.os.RemoteException;<br><span class="hljs-keyword">import</span> android.support.annotation.Nullable;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br><br>    <span class="hljs-keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Binder</span> <span class="hljs-variable">mBinder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IBookManager</span>.Stub() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicTypes</span><span class="hljs-params">(<span class="hljs-type">int</span> anInt, <span class="hljs-type">long</span> aLong, <span class="hljs-type">boolean</span> aBoolean, <span class="hljs-type">float</span> aFloat, <span class="hljs-type">double</span> aDouble, String aString)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title function_">getBookList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            <span class="hljs-keyword">return</span> mBookList;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(Book book)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            mBookList.add(book);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br>        mBookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;Android&quot;</span>));<br>        mBookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;IOS&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-keyword">return</span> mBinder;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面是一个服务端Service的典型实现，首先在onCreate中初始化添加了两本图书的信息，然后创建了一个Binder对象并在onBind中返回它，这个对象继承<code>IBookManager.Stub</code>并实现了它内部的AIDL方法，注意这里采用了CopyOnWriteArrayList，这个CopyOnWriteArrayList支持并发读&#x2F;写。在前面<br>我们提到，AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在AIDL方法中处理线程同步，而我们这里直接使用CopyOnWriteArrayList来进行自动的线程同步。AIDL中所支持的是抽象的List，而List只是一个接口，因此虽然服务端返回的是CopyOnWriteArrayList，但是在Binder中会按照List的规范去访问数据并最终形成一个新的ArrayList传递给客户端。所以，我们在服务端采用CopyOnWriteArrayList是完全可以的。和此类似的还有ConcurrentHashMap，然后我们需要在XML中注册这个Service:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.BookManagerService&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;:remote&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>
<h6 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h6><p>客户端的实现就比较简单了，首先要绑定远程服务，绑定成功后将服务端返回的Binder对象转换成AIDL接口，然后就可以通过这个接口去调用服务端的远程方法了，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ServiceConnection</span> <span class="hljs-variable">mConnection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> &#123;<br>            IBookManager bookManager= IBookManager.Stub.asInterface(service);<br>            <span class="hljs-keyword">try</span> &#123;<br>                List&lt;Book&gt; list = bookManager.getBookList();<br>                Log.d(<span class="hljs-string">&quot;xuan&quot;</span>,<span class="hljs-string">&quot;bookManager.getBookList()--&gt;&quot;</span> + list.size());<br>                bookManager.addBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;java&quot;</span>));<br>                List&lt;Book&gt; newList = bookManager.getBookList();<br>                Log.d(<span class="hljs-string">&quot;xuan&quot;</span>,<span class="hljs-string">&quot;bookManager.getBookList()--&gt;&quot;</span> + newList.size());<br>            &#125;<span class="hljs-keyword">catch</span> (RemoteException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> &#123;<br><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>,BookManagerService.class);<br>        bindService(intent,mConnection, Context.BIND_AUTO_CREATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        unbindService(mConnection);<br>        <span class="hljs-built_in">super</span>.onDestroy();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>绑定成功以后，会通过bookManager去调用getBookList方法，然后打印出所获取的图书信息。需要注意的是，服务端的方法有可能需要很久才能执行完毕，这个时候下面的代码就会导致ANR，这一点是需要注意的，后面会再介绍这种情况，接着再调用一下另外一个接口addBook，我们在客户端给服务端添加一本书，然后再获取一次。<br>现在我们考虑一种情况，假设有一种需求：用户不想时不时地去查询图书列表了，太累了，于是，他去问图书馆，“当有新书时能不能把书的信息告诉我呢？”。这就是一种典型的观察者模式。<br>首先，我们需要提供一个AIDL接口，每个用户都需要实现这个接口并且向图书馆申请新书的提醒功能，当然用户也可以随时取消这种提醒。之所以选择AIDL<br>接口而不是普通接口，是因为AIDL中无法使用普通接口。这里我们创建一个IOnNewBookArrivedListener.aidl文件，我们所期望的情况是：当服务端有新书到来时，就会通知每一个已经申请提醒功能的用户。从程序上来说就是调用所有IOnNewBookArrivedListener对象中的onNewBookArrived方法，并把新书的对象通过参数传递给客户端，内容如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// IOnNewBookArrivedListener.aidl</span><br><span class="hljs-keyword">package</span> com.huangyuanlove.testandroid;<br><br><span class="hljs-comment">// Declare any non-default types here with import statements</span><br><span class="hljs-keyword">import</span> com.huangyuanlove.testandroid.Book;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IOnNewBookArrivedListener</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Demonstrates some basic types that you can use as parameters</span><br><span class="hljs-comment">     * and return values in AIDL.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicTypes</span><span class="hljs-params">(<span class="hljs-type">int</span> anInt, <span class="hljs-type">long</span> aLong, <span class="hljs-type">boolean</span> aBoolean, <span class="hljs-type">float</span> aFloat,</span><br><span class="hljs-params">            <span class="hljs-type">double</span> aDouble, String aString)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewBookArrived</span><span class="hljs-params">(in Book newBook)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>AIDL中除了基本数据类型，其他类型的参数必须标上方向：in、out或者inout，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数，至于它们具体的区别，官网是这么说的：</p>
<blockquote>
<p>All non-primitive parameters require a directional tag indicating which way the data goes . Either in , out , or inout . Primitives are in by default , and connot be otherwise .</p>
</blockquote>
<blockquote>
<p>所有的非基本参数都需要一个定向tag来指出数据的流向，不管是 in , out , 还是 inout 。基本参数的定向tag默认是并且只能是 in 。</p>
</blockquote>
<p>我们要根据实际需要去指定参数类型，不能一概使用out或者inout，因为这在底层实现是有开销的。最后，AIDL接口中只支持方法，不支持声明静态常量，这一点区别于传统的接口。<br>除了要新增加一个AIDL接口，还需要在原有的接口中添加两个新方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huangyuanlove.testandroid;<br><br><span class="hljs-keyword">import</span> com.huangyuanlove.testandroid.Book;<br><span class="hljs-keyword">import</span> com.huangyuanlove.testandroid.IOnNewBookArrivedListener;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IBookManager</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicTypes</span><span class="hljs-params">(<span class="hljs-type">int</span> anInt, <span class="hljs-type">long</span> aLong, <span class="hljs-type">boolean</span> aBoolean, <span class="hljs-type">float</span> aFloat,</span><br><span class="hljs-params">            <span class="hljs-type">double</span> aDouble, String aString)</span>;<br>    List&lt;Book&gt; <span class="hljs-title function_">getBookList</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(in Book book)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerListener</span><span class="hljs-params">(IOnNewBookArrivedListener listener)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unRegisterListener</span><span class="hljs-params">(IOnNewBookArrivedListener listener)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>接着，服务端中的Service的实现也需要修改一下，主要是Service中的IBookManager.Stub的实现，需要实现新增加的两个方法(IDE没有提示的话可以make一下)。同时，在BookManagerService中还开启了一个线程，每隔5s就向书库中增加一本新书并通知所有感兴趣的用户，整个代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">mIsServiceDestroyed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt; mListenerList<br>            = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Binder</span> <span class="hljs-variable">mBinder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IBookManager</span>.Stub() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicTypes</span><span class="hljs-params">(<span class="hljs-type">int</span> anInt, <span class="hljs-type">long</span> aLong, <span class="hljs-type">boolean</span> aBoolean, <span class="hljs-type">float</span> aFloat, <span class="hljs-type">double</span> aDouble, String aString)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title function_">getBookList</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            <span class="hljs-keyword">return</span> mBookList;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(Book book)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            mBookList.add(book);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerListener</span><span class="hljs-params">(IOnNewBookArrivedListener listener)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            <span class="hljs-keyword">if</span> (!mListenerList.contains(listener)) &#123;<br>                mListenerList.add(listener);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Log.d(<span class="hljs-string">&quot;xuan&quot;</span>, <span class="hljs-string">&quot;already exists.&quot;</span>);<br>            &#125;<br>            Log.d(<span class="hljs-string">&quot;xuan&quot;</span>, <span class="hljs-string">&quot;registerListener,size:&quot;</span> + mListenerList.size());<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unRegisterListener</span><span class="hljs-params">(IOnNewBookArrivedListener listener)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            <span class="hljs-keyword">if</span> (mListenerList.contains(listener)) &#123;<br>                mListenerList.remove(listener);<br>                Log.d(<span class="hljs-string">&quot;xuan&quot;</span>, <span class="hljs-string">&quot;unregister listener succeed.&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Log.d(<span class="hljs-string">&quot;xuan&quot;</span>, <span class="hljs-string">&quot;not found,can not unregister.&quot;</span>);<br>            &#125;<br>            Log.d(<span class="hljs-string">&quot;xuan&quot;</span>, <span class="hljs-string">&quot;unregisterListener,current size:&quot;</span> + mListenerList.size());<br>        &#125;<br>    &#125;;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br><br>        mBookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Android&quot;</span>));<br>        mBookList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;IOS&quot;</span>));<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceWorker</span>()).start();<br>    &#125;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-keyword">return</span> mBinder;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        mIsServiceDestroyed.set(<span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewBookArrived</span><span class="hljs-params">(Book book)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        mBookList.add(book);<br>        Log.d(<span class="hljs-string">&quot;xuan&quot;</span>, <span class="hljs-string">&quot;onNewBookArrived,notify listeners:&quot;</span> + mListenerList.<br>                size());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mListenerList.size(); i++) &#123;<br>            <span class="hljs-type">IOnNewBookArrivedListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> mListenerList.get(i);<br>            Log.d(<span class="hljs-string">&quot;xuan&quot;</span>, <span class="hljs-string">&quot;onNewBookArrived,notify listener:&quot;</span> + listener);<br>            listener.onNewBookArrived(book);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceWorker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (!mIsServiceDestroyed.get()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">bookId</span> <span class="hljs-operator">=</span> mBookList.size() + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">Book</span> <span class="hljs-variable">newBook</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(bookId, <span class="hljs-string">&quot;new book#&quot;</span> + bookId);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    onNewBookArrived(newBook);<br>                &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>最后还需要修改一下客户端的代码，主要有两方面：首先客户端要注册IOnNewBookArrivedListener到远程服务端，这样当有新书时服务端才能通知当前客户端，同时我们要在Activity退出时解除这个注册；另一方面，当有新书时，服务端会回调客户端的IOnNewBookArrivedListener对象中的onNewBookArrived方法，但是这个方法是在客户端的Binder线程池中执行的，因此，为了便于进行UI操作，我们需要有一个Handler可以将其切换到客户端的主线程中去执行，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MESSAGE_NEW_BOOK_ARRIVED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> IBookManager mRemoteBookManager;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                <span class="hljs-keyword">case</span> MESSAGE_NEW_BOOK_ARRIVED:<br>                    Log.d(<span class="hljs-string">&quot;MainActivity&quot;</span>,<span class="hljs-string">&quot;receive new book :&quot;</span> + msg.obj);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-built_in">super</span>.handleMessage(msg);<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ServiceConnection</span> <span class="hljs-variable">mConnection</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> &#123;<br>            IBookManager bookManager= IBookManager.Stub.asInterface(service);<br>            <span class="hljs-keyword">try</span> &#123;<br>                mRemoteBookManager = bookManager;<br>                List&lt;Book&gt; list = bookManager.getBookList();<br>                Log.d(<span class="hljs-string">&quot;MainActivity&quot;</span>,<span class="hljs-string">&quot;bookManager.getBookList()--&gt;&quot;</span> + list.size() +<span class="hljs-string">&quot;&gt;&gt; &quot;</span> + list.toString());<br>                bookManager.addBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;java&quot;</span>));<br>                List&lt;Book&gt; newList = bookManager.getBookList();<br>                Log.d(<span class="hljs-string">&quot;MainActivity&quot;</span>,<span class="hljs-string">&quot;bookManager.getBookList()--&gt;&quot;</span> + newList.size()+<span class="hljs-string">&quot;&gt;&gt; &quot;</span> + newList.toString());<br>                bookManager.registerListener(mOnNewBookArrivedListener);<br>            &#125;<span class="hljs-keyword">catch</span> (RemoteException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> &#123;<br>            mRemoteBookManager = <span class="hljs-literal">null</span>;<br>            Log.e(<span class="hljs-string">&quot;MainActivity&quot;</span>,<span class="hljs-string">&quot;binder died.&quot;</span>);<br>        &#125;<br>    &#125;;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">IOnNewBookArrivedListener</span> <span class="hljs-variable">mOnNewBookArrivedListener</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOnNewBookArrivedListener</span>.Stub() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">basicTypes</span><span class="hljs-params">(<span class="hljs-type">int</span> anInt, <span class="hljs-type">long</span> aLong, <span class="hljs-type">boolean</span> aBoolean, <span class="hljs-type">float</span> aFloat, <span class="hljs-type">double</span> aDouble, String aString)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewBookArrived</span><span class="hljs-params">(Book newBook)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            mHandler.obtainMessage(MESSAGE_NEW_BOOK_ARRIVED,newBook)<br>                    .sendToTarget();<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>,BookManagerService.class);<br>        bindService(intent,mConnection, Context.BIND_AUTO_CREATE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (mRemoteBookManager != <span class="hljs-literal">null</span><br>                &amp;&amp; mRemoteBookManager.asBinder().isBinderAlive()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Log.d(<span class="hljs-string">&quot;MainActivity&quot;</span>,<span class="hljs-string">&quot;unregister listener:&quot;</span> + mOnNewBookArrivedListener);<br>                mRemoteBookManager.unRegisterListener(mOnNewBookArrivedListener);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        unbindService(mConnection);<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上面的代码可以看出，当BookManagerActivity关闭时，我们会在onDestroy中去解除已经注册到服务端的listener，这就相当于我们不想再接收图书馆的新书提醒了，所以我<br>们可以随时取消这个提醒服务。按back键退出BookManagerActivity,下面是打印出的log</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs log">07-23 14:56:55.493 16905-16918/com.huangyuanlove.testandroid:remote D/BookManagerService: not found,can not unregister.<br>07-23 14:56:57.185 16905-16918/com.huangyuanlove.testandroid:remote D/BookManagerService: unregisterListener,current size:1<br></code></pre></td></tr></table></figure>
<p>从上面的log可以看出，程序没有像我们所预期的那样执行。在解注册的过程中，服务端竟然无法找到我们之前注册的那个listener，其实，这是必然的，这种解注册的处理方式在日常开发过程中时常使用到，但是放到多进程中却无法奏效，因为Binder会把客户端传递过来的对象重新转化并生成一个新的对象。虽然我们在注册和解注册过程中使用的是同一个客户端对象，但是通过Binder传递到服务端后，却会产生两个全新的对象。别忘了对象是不能跨进程直接传输的，对象的跨进程传输本质上都是反序列化的过程，这就是为什么AIDL中的自定义对象都必须要实现Parcelable接口的原因。可以使用<code>RemoteCallbackList</code>。<br>RemoteCallbackList是系统专门提供的用于删除跨进程listener的接口。 RemoteCallbackList是一个泛型， 支持管理任意的AIDL接口， 这点从它的声明就可以看出，因为所有的AIDL接口都继承自IInterface接口</p>
<blockquote>
<p>public class RemoteCallbackList<E extends IInterface></p>
</blockquote>
<p>它的工作原理很简单， 在它的内部有一个Map结构专门用来保存所有的AIDL回调，这个Map的key是IBinder类型， value是Callback类型， 如下所示:</p>
<blockquote>
<p>ArrayMap&lt;IBinder,Callback&gt; mCallbacks &#x3D; new ArrayMap&lt;IBinder,Callback&gt;();</p>
</blockquote>
<p>其中Callback中封装了真正的远程listener。 当客户端注册listener的时候，它会把这个listener的信息存入mCallbacks中， 其中key和value分别通过下面的方式获得：</p>
<blockquote>
<p>IBinder key&#x3D; listener.asBinder()<br>Callback value &#x3D; new Callback(listener,cookie)</p>
</blockquote>
<p>虽然说多次跨进程传输客户端的同一个对象会在服务端生成不同的对象，但是这些新生成的对象有一个共同点，那就是它们底层的Binder对象是同一个， 利用这个特性，就可以实现上面我们无法实现的功能。当客户端解注册的时候，我们只要遍历服务端所有的listener， 找出那个和解注册listener具有相同Binder对象的服务端listener并把它删掉即可，这就是RemoteCallbackList为我们做的事情。同时RemoteCallbackList还有一个很有用的功能， 那就是当客户端进程终止后，它能够自动移除客户端所注册的listener。另外，RemoteCallbackList内部自动实现了线程同步的功能，所以我们使用它来注册和解注册时，不需要做额外的线程同步工作。<br>RemoteCallbackList使用起来很简单，我们要对BookManagerService做一些修改，首先要创建一个RemoteCallbackList对象来替代之前的CopyOnWriteArrayList，如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> RemoteCallbackList&lt;IOnNewBookArrivedListener&gt; mListenerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteCallbackList</span>&lt;IOnNewBookArrivedListener&gt;();<br></code></pre></td></tr></table></figure>
<p>然后修改registerListener和unregisterListener这两个接口的实现， 如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerListener</span><span class="hljs-params">(IOnNewBookArrivedIistener listener)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    mListenerList.register(listener);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unRegisterListener</span><span class="hljs-params">(IOnNewBookArrivedIistener listener)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    mListenerList.unregister(listener);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着要修改onNewBookArrived方法，当有新书时，我们就要通知所有已注册的listener，如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNewBookArrived</span><span class="hljs-params">(Book book)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        books.add(book);<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span>  <span class="hljs-operator">=</span>mListenerList.beginBroadcast();<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; N;i++)&#123;<br>           <span class="hljs-type">IOnNewBookArrivedIistener</span> <span class="hljs-variable">iOnNewBookArrivedIistener</span> <span class="hljs-operator">=</span> mListenerList.getBroadcastItem(i);<br>           <span class="hljs-keyword">if</span>(iOnNewBookArrivedIistener!=<span class="hljs-literal">null</span>)&#123;<br>               iOnNewBookArrivedIistener.onNewBookArrived(book);<br>           &#125;<br>       &#125;<br>       mListenerList.finishBroadcast();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>使用RemoteCallbackList，有一点需要注意，我们无法像操作List一样去操作它，尽管它的名字中也带个List，但是它并不是一个List。遍历RemoteCallbackList，必须要按照下面的方式进行，其中beginBroadcast和beginBroadcast必须要配对使用，哪怕我们仅仅是想要获取RemoteCallbackList中的元素个数，这是必须要注意的地方。<br>另外还有几点需要说明一下：</p>
<ul>
<li>客户端调用远程服务的方法，被调用的方法运行在服务端的Binder线程池中，同时客户端线程会被挂起，这个时候如果服务端方法执行比较耗时，就会导致客户端线程长时间地阻塞在这里，而如果这个客户端线程是UI线程的话，就会导致客户端ANR。因此，如果我们明确知道某个远程方法是耗时的，那么就要避免在客户端的UI线程中去访问远程方法。由于客户端的<code>onServiceConnected</code>和<code>onServiceDisconnected</code>方法都运行在UI线程中，所以也不可以在它们里面直接调用服务端的耗时方法，这点要尤其注意。</li>
<li>由于服务端的方法本身就运行在服务端的Binder线程池中，所以服务端方法本身就可以执行大量耗时操作，这个时候切记不要在服务端方法中开线程去进行异步任务，除非你明确知道自己在干什么，否则不建议这么做。</li>
<li>同理，当远程服务端需要调用客户端的listener中的方法时，被调用的方法也运行在Binder线程池中，只不过是客户端的线程池。所以，我们同样不可以在服务端中调用客户端的耗时方法。比如针对BookManagerService的onNewBookArrived方法。在它内部调用了客户端的IOnNewBookArrivedListener中的onNewBookArrived方法，如果客户端的这个onNewBookArrived方法比较耗时的话，那么请确保BookManagerService中的onNewBookArrived运行在非UI线程中，否则将导致服务端无法响应。</li>
<li>权限验证，第一种方法，我们可以在onBind中进行验证，验证不通过就直接返回null，这样验证失败的客户端直接无法绑定服务，至于验证方式可以有多种， 比如使用permission验证。第二种方法，我们可以在服务端的onTransact方法中进行权限验证，如果验证失败就直接返回false，这样服务端就不会终止执行AIDL中的方法从而达到保护服务端的效果。</li>
</ul>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android广播</title>
    <url>/2018/07/31/Android%E5%B9%BF%E6%92%AD/</url>
    <content><![CDATA[<p>面试APUS的时候被问到广播：<br>面试官：聊一下广播吧。<br>我：广播啊，四大组件之一，自己创建个类继承自<code>BroadcastReceiver</code>，重写<code>onReceive()</code>方法，需要注意的是不要在这个方法中做耗时操作。注册的话可以在<code>AndroidManifest</code>文件中静态注册，也可以在代码中动态注册。都做完了之后就可以调用sendBroadCast()方法发送广播了。<br>面试官：了解广播注册过程么？<br>我：哈~！这个没怎么看过。<br>面试官：了解怎么接收到的广播么？<br>我：没有。。。。</p>
<span id="more"></span>

<h4 id="广播的注册过程"><a href="#广播的注册过程" class="headerlink" title="广播的注册过程"></a>广播的注册过程</h4><p>《Android开发艺术探索》9.4章<br>广播的注册分为静态注册和动态注册，其中静态注册的广播在应用安装时由系统自动完成注册，具体来说是由PMS ( PackageManagerService)来完成整个注册过程的，除了广播以外，其他三大组件也都是在应用安装时由PMS解析并注册的。这里只分析广播的动态注册的过程，动态注册的过程是从ContextWrapper的registerReceiver方法开始的，和Activity以及Service一样 。ContextWrapper并 没有做实际的工作，而是将注册过程直接交给了ContextImpl来完成，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Intent <span class="hljs-title function_">registerReceiver</span><span class="hljs-params">(BroadcastReceiver receiver, IntentFilter filter)</span> &#123;<br>    <span class="hljs-keyword">return</span> mBase.registerReceiver(receiver, filter);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Intent <span class="hljs-title function_">registerReceiver</span><span class="hljs-params">(BroadcastReceiver receiver, IntentFilter filter,String broadcastPermission, Handler scheduler)</span> &#123;<br>    <span class="hljs-keyword">return</span> registerReceiverInternal(receiver, getUserId(),<br>            filter, broadcastPermission, scheduler, getOuterContext(), <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的<code>registerReceiver</code>方法是重载方法，最终调用了<code>registerReceiverInternal</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Intent <span class="hljs-title function_">registerReceiverInternal</span><span class="hljs-params">(BroadcastReceiver receiver, <span class="hljs-type">int</span> userId,</span><br><span class="hljs-params">            IntentFilter filter, String broadcastPermission,</span><br><span class="hljs-params">            Handler scheduler, Context context, <span class="hljs-type">int</span> flags)</span> &#123;<br>        <span class="hljs-type">IIntentReceiver</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (receiver != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mPackageInfo != <span class="hljs-literal">null</span> &amp;&amp; context != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (scheduler == <span class="hljs-literal">null</span>) &#123;<br>                    scheduler = mMainThread.getHandler();<br>                &#125;<br>                rd = mPackageInfo.getReceiverDispatcher(<br>                    receiver, context, scheduler,<br>                    mMainThread.getInstrumentation(), <span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (scheduler == <span class="hljs-literal">null</span>) &#123;<br>                    scheduler = mMainThread.getHandler();<br>                &#125;<br>                rd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadedApk</span>.ReceiverDispatcher(<br>                        receiver, context, scheduler, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>).getIIntentReceiver();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> ActivityManager.getService().registerReceiver(<br>                    mMainThread.getApplicationThread(), mBasePackageName, rd, filter,<br>                    broadcastPermission, userId, flags);<br>            <span class="hljs-keyword">if</span> (intent != <span class="hljs-literal">null</span>) &#123;<br>                intent.setExtrasClassLoader(getClassLoader());<br>                intent.prepareToEnterProcess();<br>            &#125;<br>            <span class="hljs-keyword">return</span> intent;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，系统首先从<code>mPackageInfo</code>获取<code>IIntentReceiver</code>对象，然后再采用跨进程的方式向AMS发送广播注册的请求。之所以采用<code>IIntentReceiver</code>而不是直接采用<code>BroadcastReceiver</code> ,这是因为上述注册过程是一个进程间通信的过程，而<code>BroadcastReceiver</code>作为Android的一个组件是不能直接跨进程传递的，所以需要通过<code>IIntentReceiver</code>来中转一下。毫无疑问，<code>IIntentReceiver</code>必须是一个Binder接口，它的具体实现是<code>LoadedApk.ReceiverDispatcher.InnerReceiver</code>, <code>ReceiverDispatcher</code>的内部同时保存了<code>BroadcastReceiver</code>和<code>InnerReceiver</code>,这样当接收到广播时，<code>ReceiverDispatcher</code>可以很方便地调用<code>BroadcastReceiver</code>的<code>onReceive</code>方法。<br>看一下<code>LoadedApk.getReceiverDispatcher</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> IIntentReceiver <span class="hljs-title function_">getReceiverDispatcher</span><span class="hljs-params">(BroadcastReceiver r,</span><br><span class="hljs-params">            Context context, Handler handler,</span><br><span class="hljs-params">            Instrumentation instrumentation, <span class="hljs-type">boolean</span> registered)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (mReceivers) &#123;<br>            LoadedApk.<span class="hljs-type">ReceiverDispatcher</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (registered) &#123;<br>                map = mReceivers.get(context);<br>                <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>                    rd = map.get(r);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (rd == <span class="hljs-literal">null</span>) &#123;<br>                rd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReceiverDispatcher</span>(r, context, handler,<br>                        instrumentation, registered);<br>                <span class="hljs-keyword">if</span> (registered) &#123;<br>                    <span class="hljs-keyword">if</span> (map == <span class="hljs-literal">null</span>) &#123;<br>                        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayMap</span>&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();<br>                        mReceivers.put(context, map);<br>                    &#125;<br>                    map.put(r, rd);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                rd.validate(context, handler);<br>            &#125;<br>            rd.mForgotten = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> rd.getIIntentReceiver();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>很显然，<code>getReceiverDispatcher</code>方法重新创建了一个<code>ReceiverDispatcher</code>对象并将其保存的<code>InnerReceiver</code>对象作为返回值返回，其中<code>InnerReceiver</code>对象和<code>BroadcastReceiver</code>都是在<code>ReceiverDispatcher</code>的构造方法中被保存起来的。<br>由于注册广播的真正实现过程是在AMS中，因此我们需要看一下AMS的具体实现。AMS的<code>registerReceiver</code>方法看起来很长，其实关键点就只有下面一部分，最终会把远程的<code>InnerReceiver</code>对象以及<code>IntentFilter</code>对象存储起来，这样整个广播的注册过程就完成了，代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Intent <span class="hljs-title function_">registerReceiver</span><span class="hljs-params">(IApplicationThread caller, String callerPackage,IIntentReceiver receiver, IntentFilter filter, String permission, <span class="hljs-type">int</span> userId)</span> &#123;<br>    <span class="hljs-comment">// The first sticky in the list is returned directly back to the client.</span><br>    <span class="hljs-type">Intent</span> <span class="hljs-variable">sticky</span> <span class="hljs-operator">=</span> allSticky != <span class="hljs-literal">null</span> ? allSticky.get(<span class="hljs-number">0</span>) : <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ReceiverList</span> <span class="hljs-variable">rl</span> <span class="hljs-operator">=</span> mRegisteredReceivers.get(receiver.asBinder());<br>    <span class="hljs-type">BroadcastFilter</span> <span class="hljs-variable">bf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastFilter</span>(filter, rl, callerPackage,permission, callingUid, userId);<br>    rl.add(bf);<br>    mReceiverResolver.addFilter(bf);<br>    <span class="hljs-keyword">return</span> sticky;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="广播的发送过程"><a href="#广播的发送过程" class="headerlink" title="广播的发送过程"></a>广播的发送过程</h4><p>当通过send方法来发送广播时，AMS会查找出匹配的广播接收者并将广播发送给它们处理。广播的发送有几种类型:普通广播、有序广播和粘性广播，有序广播和粘性广播与普通广播相比具有不同的特性，但是它们的发送&#x2F;接收过程的流程是类似的，因此这里只分析普通厂播的实现。广播的发送和接收，其本质是一个过程的两个阶段。这里从广播的发送可以说起，广播的发送仍然开始于<code>ContextWrapper</code>的<code>sendBroadcast</code>方法，之所以不是<code>Context</code>,那是因为<code>Context</code>的<code>sendBroadcast</code>是-一个抽象方法。和广播的注册过程一样，<code>ContextWrapper</code>的<code>sendBroadcast</code>方法仍然什么都不做，只是把事情交给<code>ContextImpl</code>去处理，<code>ContextImpl的sendBroadcast</code>方法的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendBroadcast</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        warnIfCallingFromSystemProcess();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">resolvedType</span> <span class="hljs-operator">=</span> intent.resolveTypeIfNeeded(getContentResolver());<br>        <span class="hljs-keyword">try</span> &#123;<br>            intent.prepareToLeaveProcess(<span class="hljs-built_in">this</span>);<br>            ActivityManager.getService().broadcastIntent(<br>                    mMainThread.getApplicationThread(), intent, resolvedType, <span class="hljs-literal">null</span>,<br>                    Activity.RESULT_OK, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, AppOpsManager.OP_NONE, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>,<br>                    getUserId());<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-keyword">throw</span> e.rethrowFromSystemServer();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>从_上面的代码来看，<code>ContextImpl</code>也是几乎什么事都没干，它直接向AMS发起了一个异步请求用于发送广播。因此，下面直接看AMS对广播发送过程的处理，AMS的<code>broadcastIntent</code>方法又调用了<code>broadcastIntentLocked</code>,在这个方法的开始有这么一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// By default broadcasts do not go to stopped apps.</span><br>intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);<br></code></pre></td></tr></table></figure>
<p>从Android3.1开始广播默认情况下广播不会发送给已经停止的应用。这是因为系统在Android3.1中为Intent添加了两个标记位，分别是<code>FLAG_INCLUDE_STOPPED_PACKAGES</code>和<code>FLAG_EXCLUDE_STOPPED_PACKAGES</code>，用来控制广播是否要对处于停止状态的应用起作用，它们的含义如下所示。<br>** FLAG_INCLUDE_STOPPED_PACKAGES **<br>表示包含已经停止的应用，这个时候广播会发送给已经停止的应用。<br>** FLAG_EXCLUDE_STOPPED_PACKAGES **<br>表示不包含已经停止的应用，这个时候广播不会发送给已经停止的应用。</p>
<p>从Android3.1开始，系统为所有广播默认添加了<code>FLAG_EXCLUDE_STOPPED_PACKAGES</code>标志，这样做是为了防止广播无意间或者在不必要的时候调起已经停止运行的应用。如果的确需要调起未启动的应用，那么只需要为广播的Intent添加<code>FLAG_INCLUDE_STOPPED_PACKAGES</code>标记即可。当<code>FLAG_EXCLUDE_STOPPED_PACKAGES</code>和<code>FLAG_INCLUDE_STOPPED_PACKAGES</code>两种标记位共存时,以<code>FLAG_INCLUDE_STOPPED_PACKAGES</code>为准。这里需要补充一下，一个应用处于停止状态分为两种情形:<br>第一种是应用安装后未运行，<br>第二种是应用被手动或者其他应用强停了。<br>Android3.1中广播的这个特性同样会影响开机广播，从Android3.1开始，处于停止状态的应用同样无法接收到开机广播，而在Android 3.1之前，处于停止状态的应用是可以收到开机广播的。<br>在<code>broadcastIntentLocked</code>的内部，会根据<code>intent-filter</code>查找出匹配的广播接收者并经过一系列的条件过滤，最终会将满足条件的广播接收者添加到<code>BroadcastQueue</code>中，接着<code>BroadcastQueue</code>就会将广播发送给相应的广播接收者，这个过程的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((receivers != <span class="hljs-literal">null</span> &amp;&amp; receivers.size() &gt; <span class="hljs-number">0</span>)<br>                || resultTo != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">BroadcastQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> broadcastQueueForIntent(intent);<br>            <span class="hljs-type">BroadcastRecord</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadcastRecord</span>(queue, intent, callerApp,<br>                    callerPackage, callingPid, callingUid, resolvedType,<br>                    requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,<br>                    resultData, resultExtras, ordered, sticky, <span class="hljs-literal">false</span>, userId);<br><br>            <span class="hljs-keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="hljs-string">&quot;Enqueueing ordered broadcast &quot;</span> + r<br>                    + <span class="hljs-string">&quot;: prev had &quot;</span> + queue.mOrderedBroadcasts.size());<br>            <span class="hljs-keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,<br>                    <span class="hljs-string">&quot;Enqueueing broadcast &quot;</span> + r.intent.getAction());<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">replaced</span> <span class="hljs-operator">=</span> replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);<br>            <span class="hljs-keyword">if</span> (!replaced) &#123;<br>                queue.enqueueOrderedBroadcastLocked(r);<br>                queue.scheduleBroadcastsLocked();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// There was nobody interested in the broadcast, but we still want to record</span><br>            <span class="hljs-comment">// that it happened.</span><br>            <span class="hljs-keyword">if</span> (intent.getComponent() == <span class="hljs-literal">null</span> &amp;&amp; intent.getPackage() == <span class="hljs-literal">null</span><br>                    &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// This was an implicit broadcast... let&#x27;s record it for posterity.</span><br>                addBroadcastStatLocked(intent.getAction(), callerPackage, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>将广播添加到<code>BroadCastQueue</code>之后，接着调用了<code>scheduleBroadcastsLocked</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleBroadcastsLocked</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="hljs-string">&quot;Schedule broadcasts [&quot;</span><br>               + mQueueName + <span class="hljs-string">&quot;]: current=&quot;</span><br>               + mBroadcastsScheduled);<br><br>       <span class="hljs-keyword">if</span> (mBroadcastsScheduled) &#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="hljs-built_in">this</span>));<br>       mBroadcastsScheduled = <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>方法内发送了一个<code>BROADCAST_INTENT_MSG</code>消息，handler接到消息后，调用了<code>processNextBroadcast</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BroadcastHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>       <span class="hljs-keyword">public</span> <span class="hljs-title function_">BroadcastHandler</span><span class="hljs-params">(Looper looper)</span> &#123;<br>           <span class="hljs-built_in">super</span>(looper, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>           <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>               <span class="hljs-keyword">case</span> BROADCAST_INTENT_MSG: &#123;<br>                   <span class="hljs-keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="hljs-string">&quot;Received BROADCAST_INTENT_MSG&quot;</span>);<br>                   processNextBroadcast(<span class="hljs-literal">true</span>);<br>               &#125; <span class="hljs-keyword">break</span>;<br>               <span class="hljs-keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;<br>                   <span class="hljs-keyword">synchronized</span> (mService) &#123;<br>                       broadcastTimeoutLocked(<span class="hljs-literal">true</span>);<br>                   &#125;<br>               &#125; <span class="hljs-keyword">break</span>;<br>               <span class="hljs-keyword">case</span> SCHEDULE_TEMP_WHITELIST_MSG: &#123;<br>                   DeviceIdleController.<span class="hljs-type">LocalService</span> <span class="hljs-variable">dic</span> <span class="hljs-operator">=</span> mService.mLocalDeviceIdleController;<br>                   <span class="hljs-keyword">if</span> (dic != <span class="hljs-literal">null</span>) &#123;<br>                       dic.addPowerSaveTempWhitelistAppDirect(UserHandle.getAppId(msg.arg1),msg.arg2, <span class="hljs-literal">true</span>, (String)msg.obj);<br>                   &#125;<br>               &#125; <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>收到消息后会调用<code>processNextBroadcast</code>方法，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// First, deliver any non-serialized broadcasts right away.</span><br>    <span class="hljs-keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        r = mParallelBroadcasts.remove(<span class="hljs-number">0</span>);<br>        r.dispatchTime = SystemClock.uptimeMillis();<br>        r.dispatchClockTime = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;<br>            Trace.asyncTraceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER,<br>                createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_PENDING),<br>                System.identityHashCode(r));<br>            Trace.asyncTraceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,<br>                createBroadcastTraceTitle(r, BroadcastRecord.DELIVERY_DELIVERED),<br>                System.identityHashCode(r));<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> r.receivers.size();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> r.receivers.get(i);<br>            <span class="hljs-keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,<br>                    <span class="hljs-string">&quot;Delivering non-ordered on [&quot;</span> + mQueueName + <span class="hljs-string">&quot;] to registered &quot;</span><br>                    + target + <span class="hljs-string">&quot;: &quot;</span> + r);<br>            deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="hljs-literal">false</span>, i);<br>        &#125;<br>        addBroadcastToHistoryLocked(r);<br>       <br>    &#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，无序广播存储在<code>mParallelBroadcasts</code>中，系统会遍历<code>mParallelBroadcasts</code>并将其中的广播发送给它们所有的接收者，具体的发送过程是通过<code>deliverToRegisteredReceiverLocked</code>方法来实现的。<code>deliverToRegisteredReceiverLocked</code>方法负责将一个广播发送给一个特定的接收者，它内部调用了<code>performReceiveLocked</code>方法来完成具体的发送过程:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">performReceiveLocked(r.callerApp, r.resultTo,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(r.intent), r.resultCode,r.resultData, r.resultExtras, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, r.userId);<br></code></pre></td></tr></table></figure>
<p><code>performReceiveLocked</code>方法的实现如下所示。由于接收广播会调起应用程序，因此app.thread不为null，根据前面的分析我们知道这里的<code>app.thread</code>仍然指<code>ApplicationThread</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">performReceiveLocked</span><span class="hljs-params">(ProcessRecord app, IIntentReceiver receiver,Intent intent, <span class="hljs-type">int</span> resultCode, String data, Bundle extras,<span class="hljs-type">boolean</span> ordered, <span class="hljs-type">boolean</span> sticky, <span class="hljs-type">int</span> sendingUser)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            <br>            <span class="hljs-comment">// Send the intent to the receiver asynchronously using one-way binder calls.</span><br>    <span class="hljs-keyword">if</span> (app != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (app.thread != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// If we have an app thread, do the call through that so it is</span><br>            <span class="hljs-comment">// correctly ordered with other one-way calls.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,<br>                        data, extras, ordered, sticky, sendingUser, app.repProcState);<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Uncomment this when (b/28322359) is fixed and we aren&#x27;t getting</span><br>            <span class="hljs-comment">// DeadObjectException when the process isn&#x27;t actually dead.</span><br>            <span class="hljs-comment">//&#125; catch (DeadObjectException ex) &#123;</span><br>            <span class="hljs-comment">// Failed to call into the process.  It&#x27;s dying so just let it die and move on.</span><br>            <span class="hljs-comment">//    throw ex;</span><br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException ex) &#123;<br>                <span class="hljs-comment">// Failed to call into the process. It&#x27;s either dying or wedged. Kill it gently.</span><br>                <span class="hljs-keyword">synchronized</span> (mService) &#123;<br>                    Slog.w(TAG, <span class="hljs-string">&quot;Can&#x27;t deliver broadcast to &quot;</span> + app.processName<br>                            + <span class="hljs-string">&quot; (pid &quot;</span> + app.pid + <span class="hljs-string">&quot;). Crashing it.&quot;</span>);<br>                    app.scheduleCrash(<span class="hljs-string">&quot;can&#x27;t deliver broadcast&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">throw</span> ex;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Application has died. Receiver doesn&#x27;t exist.</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteException</span>(<span class="hljs-string">&quot;app.thread must not be null&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        receiver.performReceive(intent, resultCode, data, extras, ordered,<br>                sticky, sendingUser);<br>    &#125;<br>            <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>ApplicationThread</code>的<code>scheduleRegisteredReceiver</code>的实现比较简单，它通过<code>InnerReceiver</code>来实现广播的接收:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// This function exists to make sure all receiver dispatching is</span><br><span class="hljs-comment">// correctly ordered, since these are one-way calls and the binder driver</span><br><span class="hljs-comment">// applies transaction ordering per object for such calls.</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleRegisteredReceiver</span><span class="hljs-params">(IIntentReceiver receiver, Intent intent,</span><br><span class="hljs-params">        <span class="hljs-type">int</span> resultCode, String dataStr, Bundle extras, <span class="hljs-type">boolean</span> ordered,</span><br><span class="hljs-params">        <span class="hljs-type">boolean</span> sticky, <span class="hljs-type">int</span> sendingUser, <span class="hljs-type">int</span> processState)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>    updateProcessState(processState, <span class="hljs-literal">false</span>);<br>    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,<br>            sticky, sendingUser);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>InnerReceiver</code>的<code>performReceive</code>方法会调用<code>LoadedApk.ReceiverDispatcher</code>的<code>performReceive</code>方法，<code>LoadedApk.ReceiverDispatcher</code>的<code>performReceive</code>方法的实现如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performReceive</span><span class="hljs-params">(Intent intent, <span class="hljs-type">int</span> resultCode, String data,Bundle extras, <span class="hljs-type">boolean</span> ordered, <span class="hljs-type">boolean</span> sticky, <span class="hljs-type">int</span> sendingUser)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Args</span> <span class="hljs-variable">args</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Args</span>(intent, resultCode, data, extras, ordered,<br>            sticky, sendingUser);<br>    <span class="hljs-keyword">if</span> (intent == <span class="hljs-literal">null</span>) &#123;<br>        Log.wtf(TAG, <span class="hljs-string">&quot;Null intent received&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">seq</span> <span class="hljs-operator">=</span> intent.getIntExtra(<span class="hljs-string">&quot;seq&quot;</span>, -<span class="hljs-number">1</span>);<br>            Slog.i(ActivityThread.TAG, <span class="hljs-string">&quot;Enqueueing broadcast &quot;</span> + intent.getAction()<br>                    + <span class="hljs-string">&quot; seq=&quot;</span> + seq + <span class="hljs-string">&quot; to &quot;</span> + mReceiver);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (intent == <span class="hljs-literal">null</span> || !mActivityThread.post(args.getRunnable())) &#123;<br>        <span class="hljs-keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;<br>            <span class="hljs-type">IActivityManager</span> <span class="hljs-variable">mgr</span> <span class="hljs-operator">=</span> ActivityManager.getService();<br>            <span class="hljs-keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,<br>                    <span class="hljs-string">&quot;Finishing sync broadcast to &quot;</span> + mReceiver);<br>            args.sendFinished(mgr);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，会创建一个Args对象并通过mActivityThread的post方法来执行Args中的逻辑，而Args实现了Runnable接口。mActivityThread是一个Handler，它其实就是ActivityThread中的mH，mH的类型是ActivityThread的内部类H。在Args的run方法中有如下几行代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">BroadcastReceiver</span> <span class="hljs-variable">receiver</span> <span class="hljs-operator">=</span> mReceiver;<br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ordered</span> <span class="hljs-operator">=</span> mOrdered;<br>receiver.setPendingResult(<span class="hljs-built_in">this</span>);<br>receiver.onReceive(mContext, intent);<br></code></pre></td></tr></table></figure>
<p>这个时候BroadcastReceiver的onReceive方法被执行了，也就是说应用已经接收到广播了，同时onReceive方法是在广播接收者的主线程中被调用的。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android慢网络及页面监控</title>
    <url>/2021/06/19/Android%E6%85%A2%E7%BD%91%E7%BB%9C%E5%8F%8A%E9%A1%B5%E9%9D%A2%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p>最近在搞Android应用大盘监控，目前需要监控的是慢网络请求及页面的打开和关闭。由于应用中使用的OkHttp进行网络请求，着重看了一下OkHttp源码，还有别人写的一些总结。对于页面的打开关闭行为，我们可以搞个BaseActivity或者在Application中注册生命周期回调就好了。问题在于慢网络监控需要实时上报，而用户行为监控则需要本地落盘保存，在需要的时候再上报，所以如何落盘保存则是一个问题，为此了解了java IO和mmap。</p>
<span id="more"></span>

<h2 id="慢网络监控"><a href="#慢网络监控" class="headerlink" title="慢网络监控"></a>慢网络监控</h2><p><strong>嫌长不看直接看结论，代码在这一段的最后。</strong></p>
<p>在构建<code>OkHttpClient</code>对象时加入<code>eventListener</code>即可，如果会有多个异步网络同时请求，就添加<code>eventListenerFactory</code>。不论是不是同时会有多个异步网络请求，使用<code>eventListenerFactory</code>差距不大。</p>
<p><strong>比较啰嗦的详解篇</strong></p>
<p>我们先来看下网络基础内容：</p>
<ul>
<li>OSI七层模型和实际应用中的五层模型</li>
<li>什么是Http</li>
<li>请求方式、报文结构</li>
<li>TCP的三次握手、四次挥手</li>
<li>一次完整的http请求过程</li>
<li>Http不同版本的差异、优缺点</li>
<li>http和https的区别</li>
</ul>
<p>相关的知识点放在这里了，别人已经写得比较全面了，再抄一遍也没啥意思 :smiley:</p>
<p><a href="https://juejin.cn/post/6877362691350986766">面试官的这份HTTP灵魂追问你Hold住吗？</a></p>
<p><a href="https://www.jianshu.com/p/b0aa797608c0">关于HTTP请求你需要知道的一切</a></p>
<p>当我们使用OkHttp进行网络请求的时候，过程一般是这样的：</p>
<ol>
<li>构建<code>OkHttpClient</code></li>
<li>构建<code>Request</code></li>
<li>构建<code>Call</code></li>
<li>使用<code>Call</code>对象进行网络请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">okHttpClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>.Builder()<br>        .eventListenerFactory(NetworkListener.get())<br>		.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Interceptor</span>() &#123;<br>		    <span class="hljs-meta">@NotNull</span><br>		    <span class="hljs-meta">@Override</span><br>		    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>		        Log.e(TAG,<span class="hljs-string">&quot;addInterceptor before proceed&quot;</span>);<br>		        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(chain.request());<br>		        Log.e(TAG,<span class="hljs-string">&quot;addInterceptor after proceed &quot;</span>);<br>		        <span class="hljs-keyword">return</span> response;<br>		    &#125;<br>		&#125;)<br>		.addNetworkInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Interceptor</span>() &#123;<br>		    <span class="hljs-meta">@NotNull</span><br>		    <span class="hljs-meta">@Override</span><br>		    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>		        Log.e(TAG,<span class="hljs-string">&quot;addNetworkInterceptor before proceed&quot;</span>);<br>		        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(chain.request());<br>		        Log.e(TAG,<span class="hljs-string">&quot;addNetworkInterceptor after proceed &quot;</span>);<br>		        <span class="hljs-keyword">return</span> response;<br>		    &#125;<br>		&#125;)<br>        .build();<br><br><span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>        .url(<span class="hljs-string">&quot;.....&quot;</span>)<br>        .build();<br><span class="hljs-type">Call</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> okHttpClient.newCall(request);<br>call.enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callback</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Call call, <span class="hljs-meta">@NotNull</span> IOException e)</span> &#123;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResponse</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Call call, <span class="hljs-meta">@NotNull</span> Response response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>流程图如下：</p>
<p><img src="/image/Android/okhttp/OkHttp%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="OkHttp流程图"></p>
<p>最经典的应该是拦截器部分了，网络对拦截器的分析也挺多了，可以自己翻一下源码总结一下，我也写不出花来 :hushed:</p>
<p><img src="/image/Android/okhttp/OkHttp%E6%8B%A6%E6%88%AA%E5%99%A8.png" alt="OkHttp流程图"></p>
<p>图片我是用drawio画的，源文件放在了github上，路径 <a href="https://github.com/huangyuanlove/huangyuanlove.github.io/tree/master/image/Android/okhttp">https://github.com/huangyuanlove/huangyuanlove.github.io/tree/master/image/Android/okhttp</a></p>
<p>下面的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventListener</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NetworkListener&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Factory <span class="hljs-title function_">get</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Factory</span>() &#123;<br>            <span class="hljs-meta">@NotNull</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> EventListener <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Call call)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NetworkListener</span>();<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callStart</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Call call)</span> &#123;<br>        <span class="hljs-built_in">super</span>.callStart(call);<br>        Log.e(TAG,<span class="hljs-string">&quot;-------callStart---requestId-----&quot;</span>+mRequestId);<br>    &#125;<br><br><span class="hljs-comment">//重写的N个回调方法</span><br>  .<br>  .<br>  .<br>  .<br>  .<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callFailed</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Call call, <span class="hljs-meta">@NotNull</span> IOException ioe)</span> &#123;<br>        <span class="hljs-built_in">super</span>.callFailed(call, ioe);<br>        ioe.printStackTrace();<br>        Log.e(TAG, <span class="hljs-string">&quot;callFailed&quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们可以在这些回调方法中做时间统计，超过指定时长则认为是慢网络请求。</p>
<h2 id="页面打开关闭监控"><a href="#页面打开关闭监控" class="headerlink" title="页面打开关闭监控"></a>页面打开关闭监控</h2><p>结论：在自定义的application中调用一下<code>registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks callback);</code>就好。在每个Activity的生命周期执行的时候都会回调<code>callback</code>.</p>
<h4 id="收集信息"><a href="#收集信息" class="headerlink" title="收集信息"></a>收集信息</h4><p>在Application中注册一下生命周期回调接口:<code>registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks callback);</code>并重写各种回调方法，记录对应的时间戳+类名。由于生命周期都是在主线程回调，我们不必担心多线程竞争问题。搞个list直接存。</p>
<h4 id="落盘保存"><a href="#落盘保存" class="headerlink" title="落盘保存"></a>落盘保存</h4><ol>
<li>在什么时机保存</li>
<li>如何保存</li>
</ol>
<p>对于问题1，我们在了解Handler机制的时候，提到过在<code>MessageQueue</code>里面有个开发过程中不常用的对象:<code>IdleHandle</code>r，查看源码和注释我们得知，是在线程的MessageQueue中没有消息的时候，会去调用这个类的”queueIdle()”方法，并且该方法返回true时，不会被移除队列。</p>
<p>我们在Application中向MainLooper的MessageQueue中添加一个IdleHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Looper.myQueue().addIdleHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>.IdleHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">queueIdle</span><span class="hljs-params">()</span> &#123;<br>                Log.e(TAG,<span class="hljs-string">&quot;queueIdle,当前线程名称&quot;</span> + Thread.currentThread().getName()+<span class="hljs-string">&quot;,线程id:&quot;</span> +Thread.currentThread().getId());<br>                BehaviorRepository.getInstance(MyApplication.<span class="hljs-built_in">this</span>).storeLifeEvent();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure>



<p>对于如何保存，一开始考虑的是写到数据库，因为有事务。后来结合业务发现并不需要这么搞，直接写文件就好，需要的时候直接上传文件到服务器，那么我们如何去写文件？想到了mmap这货。当使用mmap方式写文件失败再考虑使用普通java io。于是有了下面：下面代码来源于：<a href="https://www.cnblogs.com/rustfisher/p/11551372.html">https://www.cnblogs.com/rustfisher/p/11551372.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogWriter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;activityLifeRecorder&quot;</span>;<br><br><br>    <span class="hljs-comment">// 注意申请SD卡读写权限</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String logFileDir;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String fileName;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HandlerThread handlerThread;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Handler writerHandler;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LOG_FILE_GROW_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>; <span class="hljs-comment">// log文件每次增长的大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">gCurrentLogPos</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                  <span class="hljs-comment">// log文件当前写到的位置 - 注意要单线程处理</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用前必须调用此方法进行准备</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Context context)</span>&#123;<br>        gCurrentLogPos = <span class="hljs-number">0</span>;<br>        logFileDir = context.getCacheDir() + File.separator + <span class="hljs-string">&quot;logs&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == handlerThread) &#123;<br>            handlerThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerThread</span>(<span class="hljs-string">&quot;LL&quot;</span>);<br>            handlerThread.start();<br>        &#125;<br>        writerHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(handlerThread.getLooper());<br><br><br>        <span class="hljs-comment">//可以保存本次打开的日志，只保存三五次打开的日志</span><br>        fileName = <span class="hljs-string">&quot;_&quot;</span> +  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>,Locale.CHINA).format(System.currentTimeMillis()) + <span class="hljs-string">&quot;.txt&quot;</span>;<br>        Log.d(TAG, <span class="hljs-string">&quot;[prepare] file: &quot;</span> + fileName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getFileName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> fileName;<br>    &#125;<br><br>    <span class="hljs-comment">// 退出</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quit</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (writerHandler != <span class="hljs-literal">null</span>) &#123;<br>            writerHandler.removeCallbacksAndMessages(<span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (handlerThread != <span class="hljs-literal">null</span>) &#123;<br>            handlerThread.quit();<br>        &#125;<br>    &#125;<br><br><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToFile</span><span class="hljs-params">(String content)</span>&#123;<br>        <span class="hljs-keyword">if</span> (writerHandler != <span class="hljs-literal">null</span>) &#123;<br>            writerHandler.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteRunnable</span>(content));<br>        &#125;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        String  content;<br><br>        WriteRunnable( String content) &#123;<br>            <span class="hljs-built_in">this</span>.content = content;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(logFileDir);<br>                <span class="hljs-keyword">if</span> (!dir.exists()) &#123;<br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">mk</span> <span class="hljs-operator">=</span> dir.mkdirs();<br>                    Log.d(TAG, <span class="hljs-string">&quot;make dir &quot;</span> + mk);<br>                &#125;<br>                <span class="hljs-type">File</span> <span class="hljs-variable">eFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(logFileDir + File.separator + fileName);<br>                <span class="hljs-type">byte</span>[] strBytes = content.getBytes();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">randomAccessFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(eFile, <span class="hljs-string">&quot;rw&quot;</span>);<br>                    MappedByteBuffer mappedByteBuffer;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">inputLen</span> <span class="hljs-operator">=</span> strBytes.length;<br>                    <span class="hljs-keyword">if</span> (!eFile.exists()) &#123;<br>                        <span class="hljs-type">boolean</span> <span class="hljs-variable">nf</span> <span class="hljs-operator">=</span> eFile.createNewFile();<br>                        Log.d(TAG, <span class="hljs-string">&quot;new log file &quot;</span> + nf);<br>                        mappedByteBuffer = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_WRITE, gCurrentLogPos, LOG_FILE_GROW_SIZE);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mappedByteBuffer = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_WRITE, gCurrentLogPos, inputLen);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (mappedByteBuffer.remaining() &lt; inputLen) &#123;<br>                        mappedByteBuffer = randomAccessFile.getChannel().map(FileChannel.MapMode.READ_WRITE, gCurrentLogPos, LOG_FILE_GROW_SIZE + inputLen);<br>                    &#125;<br>                    mappedByteBuffer.put(strBytes);<br>                    gCurrentLogPos += inputLen;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    Log.e(TAG, <span class="hljs-string">&quot;WriteRunnable run: &quot;</span>, e);<br>                    <span class="hljs-keyword">if</span> (!eFile.exists()) &#123;<br>                        <span class="hljs-type">boolean</span> <span class="hljs-variable">nf</span> <span class="hljs-operator">=</span> eFile.createNewFile();<br>                        Log.d(TAG, <span class="hljs-string">&quot;new log file &quot;</span> + nf);<br>                    &#125;<br>                    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(eFile, <span class="hljs-literal">true</span>);<br>                    os.write(content.getBytes());<br>                    os.flush();<br>                    os.close();<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                Log.e(TAG, <span class="hljs-string">&quot;写log文件出错: &quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>



<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android打包流程</title>
    <url>/2020/11/11/Android%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>现在的Android开发大部分是在AndroidStudio中进行的，当我们想要得到APK文件的时候，点一下RUN，或者执行一下<code>gradlew assembleDebug</code> 就可以了，那么在这个过程中到底发生了什么，我们来详细看一下。<br>构建的过程大致可以划分为两个过程：编译和打包<br>编译：编译器(compileer)通过编译source code、AIDL files、source filse、dependednce files，最终生成Dex(s)文件和编译后的资源文件<br>打包：打包器(APK packager)利用签名文件(KeyStore)和上一步编译过程中生成的Dex(s)文件、编译后的资源文件打包成最终的APK文件</p>
<span id="more"></span>
<h4 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h4><p>一个几乎是最简化的构建流程<br><img src="/image/gradle/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B--%E6%9C%80%E7%AE%80.png" alt="最简化的构建流程" title="最简化的构建流程"><br>上图中的菱形表示一些构建操作，矩形表示输入或者输出文件</p>
<h4 id="初见细节"><a href="#初见细节" class="headerlink" title="初见细节"></a>初见细节</h4><p><img src="/image/gradle/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B.png" alt="稍微有点细节的构建流程" title="稍微有点细节的构建流程"></p>
<p>编译打包流程</p>
<ol>
<li><p>使用aapt&#x2F;aapt2编译资源文件生成resource.arsc和R.java</p>
</li>
<li><p>使用AIDL处理aidl文件，生成java文件</p>
</li>
<li><p>使用javac编译java文件，生成class文件</p>
</li>
<li><p>(proguard混淆如果有)使用DX&#x2F;D8&#x2F;R8处理class文件，生成最终需要的dex文件</p>
</li>
<li><p>使用Android NDK处理native代码生成.so文件</p>
</li>
<li><p>使用apkbuilder生成未签名的apk文件</p>
</li>
<li><p>使用apksigner对apk进行签名，生成签名后的apk文件</p>
</li>
<li><p>使用zipalign工具，对已签名的apk文件进行优化(只有v1签名才有这一步，v2签名的apk会在zipalign后签名被破坏）。</p>
</li>
</ol>
<h4 id="终章"><a href="#终章" class="headerlink" title="终章"></a>终章</h4><p>这是一张流传已久的网图，找到的图已经有包浆了，又重新画了一遍<br>在图的最下方有示例说明：</p>
<ol>
<li>矩形表示文件</li>
<li>椭圆表示工具</li>
<li>箭头表示输出</li>
<li>空心圆表示输入</li>
</ol>
<p><img src="/image/gradle/apk%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8Bfinal.png" alt="最终构建流程" title="最终构建流程"></p>
<p>既然都是调用的工具，我们同样可以自己写脚本运行这些工具进行打包，调用的工具详细信息可以在这里找到 <a href="https://developer.android.com/studio/command-line?hl=zh_cn">https://developer.android.com/studio/command-line?hl=zh_cn</a></p>
<p>文中图片的源文件在 &#x2F;image&#x2F;apk打包流程.drawio ,使用drawio绘制;</p>
<hr>
<p>以上</p>
<p>参考：</p>
<ol>
<li><a href="https://www.zhihu.com/search?type=content&amp;q=Android%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B">https://www.zhihu.com/search?type=content&amp;q=Android%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B</a></li>
<li><a href="https://juejin.im/post/6882328361294069773">https://juejin.im/post/6882328361294069773</a></li>
</ol>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Android接入flutter多渠道引起的问题</title>
    <url>/2019/06/19/Android%E6%8E%A5%E5%85%A5flutter%E5%A4%9A%E6%B8%A0%E9%81%93%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>公司已经开始在项目中使用Flutter进行跨平台开发了，并且已经在其中一款应用上线了，过程并没有多曲折，按照官网教程一步步进行，继承、打包、测试、发版。</p>
<p>最近另外一个项目有新的需求，也开始使用Flutter，在集成打包的时候出现了问题：</p>
<p><code>A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.</code></p>
<p>收集到的错误日志如下：</p>
<span id="more"></span>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs crash">E/CrashReport: #++++++++++Record By Bugly++++++++++#<br>E/CrashReport: # You can use Bugly(http:\\bugly.qq.com) to get more Crash Detail!<br>E/CrashReport: # PKG NAME: me.chunyu.ChunyuDoctor<br>E/CrashReport: # APP VER: 8.6.0<br>E/CrashReport: # LAUNCH TIME: 2019-06-19 18:00:12<br>E/CrashReport: # CRASH TYPE: NATIVE_CRASH<br>E/CrashReport: # CRASH TIME: 2019-06-19 18:00:22<br>E/CrashReport: # CRASH PROCESS: me.chunyu.ChunyuDoctor<br>E/CrashReport: # CRASH THREAD: main(2)<br>E/CrashReport: # REPORT ID: d88b5d1a-cbb0-4920-b41c-d8ea8eb804bd<br>E/CrashReport: # CRASH DEVICE: MI 5 UNROOT<br>E/CrashReport: # RUNTIME AVAIL RAM:1411100672 ROM:11107233792 SD:11107233792<br>E/CrashReport: # RUNTIME TOTAL RAM:2824822784 ROM:26300211200 SD:26300211200<br>E/CrashReport: # EXCEPTION FIRED BY UNKNOWN_USER me.chunyu.ChunyuDoctor(27335)<br>E/CrashReport: # CRASH STACK: <br>E/CrashReport: SIGABRT<br>    0x6ac7<br>    #00    pc 0004b10c    /system/lib/libc.so (tgkill+12) [armeabi-v7a::d7f479b7abcbff3bc09ca6d100c44333]<br>    #01    pc 0001a9a3    /system/lib/libc.so (abort+54) [armeabi-v7a::d7f479b7abcbff3bc09ca6d100c44333]<br>    #02    pc 00af85ab    /data/app/me.chunyu.ChunyuDoctor-n6cyA4a8iSyIl6wZ_2ghlw==/lib/arm/libflutter.so [armeabi-v7a::a12434e0b53806a35730000001000000]<br>    #03    pc 00b197cf    /data/app/me.chunyu.ChunyuDoctor-n6cyA4a8iSyIl6wZ_2ghlw==/lib/arm/libflutter.so [armeabi-v7a::a12434e0b53806a35730000001000000]<br>    #04    pc 00aeaf45    /data/app/me.chunyu.ChunyuDoctor-n6cyA4a8iSyIl6wZ_2ghlw==/lib/arm/libflutter.so [armeabi-v7a::a12434e0b53806a35730000001000000]<br>    #05    pc 00af0507    /data/app/me.chunyu.ChunyuDoctor-n6cyA4a8iSyIl6wZ_2ghlw==/lib/arm/libflutter.so [armeabi-v7a::a12434e0b53806a35730000001000000]<br>    #06    pc 00aef79b    /data/app/me.chunyu.ChunyuDoctor-n6cyA4a8iSyIl6wZ_2ghlw==/lib/arm/libflutter.so [armeabi-v7a::a12434e0b53806a35730000001000000]<br>    #07    pc 003d9d29    /system/lib/libart.so (ExecuteMterpImpl+37417) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #08    pc 003d5fe1    /system/lib/libart.so (ExecuteMterpImpl+21729) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #09    pc 003da555    /system/lib/libart.so (art_quick_invoke_stub+228) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #10    pc 000a0e1d    /system/lib/libart.so (_ZN3art9ArtMethod6InvokeEPNS_6ThreadEPjjPNS_6JValueEPKc+140) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #11    pc 001e6e53    /system/lib/libart.so (_ZN3art11interpreter34ArtInterpreterToCompiledCodeBridgeEPNS_6ThreadEPNS_9ArtMethodEPKNS_7DexFile8CodeItemEPNS_11ShadowFrameEPNS_6JValueE+238) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #12    pc 001e2403    /system/lib/libart.so (_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE+574) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #13    pc 003c0d75    /system/lib/libart.so (MterpInvokeDirect+360) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #14    pc 003c8394    /system/lib/libart.so (artInvokeSuperTrampolineWithAccessCheck+3599) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #15    pc 001c9985    /system/lib/libart.so (_ZN3art22IndirectReferenceTable10VisitRootsEPNS_11RootVisitorERKNS_8RootInfoE+16) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #16    pc 001ced07    /system/lib/libart.so (_ZN3art11interpreter33ArtInterpreterToInterpreterBridgeEPNS_6ThreadEPKNS_7DexFile8CodeItemEPNS_11ShadowFrameEPNS_6JValueE+142) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #17    pc 001e23ed    /system/lib/libart.so (_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE+552) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #18    pc 003bfebf    /system/lib/libart.so (MterpInvokeVirtual+446) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #19    pc 003c8294    /system/lib/libart.so (artInvokeSuperTrampolineWithAccessCheck+3343) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #20    pc 001c9985    /system/lib/libart.so (_ZN3art22IndirectReferenceTable10VisitRootsEPNS_11RootVisitorERKNS_8RootInfoE+16) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #21    pc 001ced07    /system/lib/libart.so (_ZN3art11interpreter33ArtInterpreterToInterpreterBridgeEPNS_6ThreadEPKNS_7DexFile8CodeItemEPNS_11ShadowFrameEPNS_6JValueE+142) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #22    pc 001e23ed    /system/lib/libart.so (_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE+552) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #23    pc 003c0d75    /system/lib/libart.so (MterpInvokeDirect+360) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #24    pc 003c8394    /system/lib/libart.so (artInvokeSuperTrampolineWithAccessCheck+3599) [armeabi-v7a::d2078ba50169919802b98e67fdc80c58]<br>    #25    pc 001c9985    /system/lib/libart.so (_ZN3art22IndirectReferenceTable10VisitRootsEPNS_11RootVisitorERKNS_8RootInfoE+16) [armeabi-v7a::<br>E/CrashReport: #++++++++++++++++++++++++++++++++++++++++++#<br></code></pre></td></tr></table></figure>

<p>刚开始以为是so包的问题，但是用到so的地方和已经发版的应用没啥区别。排除这个问题的影响。<br>网上疯狂搜索，看到了这个<br><a href="https://www.jianshu.com/p/273c462896c3">https://www.jianshu.com/p/273c462896c3</a><br>说是因为安装包缺少flutter_assets导致的。解开安装包，发现现象一致。因为多渠道打包的问题，导致<code>flutter_assets</code>没有被打包进去，flutter的Issues#27027 <a href="https://github.com/flutter/flutter/issues/27028">https://github.com/flutter/flutter/issues/27028</a>  有提到这个，需要在fluuter module的build.gradle(flutter module&#x2F;.android&#x2F;Flutter&#x2F;build.gradle)中配置同样的渠道信息。</p>
<p><img src="/image/flutter/flutter_muilty_flavor.png" alt="问题原因"></p>
<p>配置完了打包安装运行还是包上面的错误。根据上面文章，找到flutter安装目录下的打包使用的gradle,<code>flutter/packages/flutter_tools/gradle/flutter.gradle</code>文件，其中有这么个方法</p>
<p><code>private void addFlutterTask(Project project)</code></p>
<p><img src="/image/flutter/copy_flutter_assets_task.png" alt="copyFlutterAssetsTask"></p>
<p>其中定义了合并资源的task：<code> Task mergeAssets = project.tasks.findByPath(&quot;:$&#123;mainModuleName&#125;:merge$&#123;variant.name.capitalize()&#125;Assets&quot;)</code></p>
<p>这里面的变量<code>mainModuleName</code>默认是<code>app</code>,但是我们的工程的主module不是这个名字，这个task就不会被执行。</p>
<p>加上打印日志，果然<code>mergeAssets </code>是null，导致资源文件不会被打包进去。</p>
<p>这个问题有人发现了，并且提交了 Pull request,地址 <a href="https://github.com/flutter/flutter/pull/27154">https://github.com/flutter/flutter/pull/27154</a></p>
<p>解决方案是在我们工程的<code>setting.gradle</code>文件中指定主module的名字</p>
<p><code>setBinding(new Binding([gradle: this, mainModuleName: &#39;example&#39;]))</code></p>
<p>关于上面的多渠道打包的问题，有人说flutter module中的.android文件夹是flutter自己生成的，提交代码的时候并不会提交这个文件夹下的任何内容。我们可以魔改一下上面提到的<code>flutter.gradle</code>文件，在打多渠道包的时候将当前的渠道信息传进去，在gradle文件中读取一下渠道信息就好。</p>
<p>这里需要提一下AS生成的合并资源任务名字：比如当前渠道是<code>normal</code>,主工程的名字是<code>example</code>,生成的任务则是<code>exampleMergeNormalDebugAssets</code>和<code>exampleMergeNormalReleaseAssets</code>。可以在AS中打开gradle任务预览，在flutter这个module中<code>Task--&gt;other</code>分组中找到该任务。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">String flavor = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">try</span>&#123;<br>    String tempFlavor = project.rootProject.ext.app.flavor<br>    <span class="hljs-keyword">if</span>(tempFlavor!=<span class="hljs-literal">null</span> &amp;&amp; !tempFlavor.empty)&#123;<br>        flavor = tempFlavor<br>    &#125;<br>    <br>&#125; <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    println e<br>&#125;<br><br>Task mergeAssets<br><br><span class="hljs-keyword">if</span>(flavor!=<span class="hljs-literal">null</span> &amp;&amp; !flavor.empty)&#123;<br>    mergeAssets = project.tasks.findByPath(<span class="hljs-string">&quot;:$&#123;mainModuleName&#125;:merge$&#123;flavor.capitalize()&#125;$&#123;variant.name.capitalize()&#125;Assets&quot;</span>)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    mergeAssets = project.tasks.findByPath(<span class="hljs-string">&quot;:$&#123;mainModuleName&#125;:merge$&#123;variant.name.capitalize()&#125;Assets&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android爬坑之旅</tag>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Android的消息机制</title>
    <url>/2017/03/23/Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>　　Android消息机制主要是指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper的支撑。MessageQueue的中文翻译是消息队列，它的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息队列。Looper可以理解为消息循环。由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper就填补了这个功能，Looper会以无限循环的形式去查找是否有新消息，如果有的话就处理消息，否则就等待。Looper中还有一个特殊的概念：ThreadLocal，ThreadLocal并不是线程，它的作用是可以在每个线程中存储数据。Handler创建的时候会采用当前线程的Looper来构造消息循环系统，ThreadLocal可以在不同的线程中互不干扰的存储并提供数据，Handler可以通过ThreadLocal轻松获取每个线程的Looper。需要注意的是，线程默认是没有Looper的，如果需要使用Handler就必须为现成创建Looper，我们经常提到的主线程，也叫UI线程，它就是ActivityThread，ActivityThread被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。</p>
<span id="more"></span>

<h3 id="ThreadLocal的工作原理"><a href="#ThreadLocal的工作原理" class="headerlink" title="ThreadLocal的工作原理"></a>ThreadLocal的工作原理</h3><p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只能在指定的线程中才可以获取到存储的数据，对于其他线程来说则无法获取到，我们在使用的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;Thread#1&quot;</span>)&#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>               mBooleanThreadLocal.set(<span class="hljs-literal">false</span>);<br>               Log.d(<span class="hljs-string">&quot;huangyuan&quot;</span>,<span class="hljs-string">&quot;Thread#1&quot;</span> + mBooleanThreadLocal.get());<br>           &#125;<br>       &#125;.start();<br><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;Thread#2&quot;</span>)&#123;<br><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>               mBooleanThreadLocal.set(<span class="hljs-literal">true</span>);<br>               Log.d(<span class="hljs-string">&quot;huangyuan&quot;</span>,<span class="hljs-string">&quot;Thread#2&quot;</span> + mBooleanThreadLocal.get());<br>           &#125;<br>       &#125;.start();<br></code></pre></td></tr></table></figure>
<p>　　这样，我们虽然在不同的线程中访问的是同一个ThreadLocal对象，但是他们的值却是不一样的。这是因为不同的线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值。<br>ThreadLocal是一个泛型类，定义为<code>public class ThreadLocal&lt;T&gt;</code>,首先看ThreadLocal的set方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>       <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>       <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>           map.set(<span class="hljs-built_in">this</span>, value);<br>       <span class="hljs-keyword">else</span><br>           createMap(t, value);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>　　上面的方法中，首先会通过getMap方法获取ThreadLocalMap（存储线程的ThreadLocal数据），ThreadLocalMap是ThreadLocal类的静态内部类，其内部包含了一个静态内部类Entry，声明如下<code>static class Entry extends WeakReference&lt;ThreadLocal&gt;</code>,ThreadLocalMap类中有一个Entry类型的数组<code>private Entry[] table;</code>,下面是set方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(ThreadLocal key, Object value)</span> &#123;<br><br>          <span class="hljs-comment">// We don&#x27;t use a fast path as with get() because it is at</span><br>          <span class="hljs-comment">// least as common to use set() to create new entries as</span><br>          <span class="hljs-comment">// it is to replace existing ones, in which case, a fast</span><br>          <span class="hljs-comment">// path would fail more often than not.</span><br><br>          Entry[] tab = table;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[i];<br>               e != <span class="hljs-literal">null</span>;<br>               e = tab[i = nextIndex(i, len)]) &#123;<br>              <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> e.get();<br><br>              <span class="hljs-keyword">if</span> (k == key) &#123;<br>                  e.value = value;<br>                  <span class="hljs-keyword">return</span>;<br>              &#125;<br><br>              <span class="hljs-keyword">if</span> (k == <span class="hljs-literal">null</span>) &#123;<br>                  replaceStaleEntry(key, value, i);<br>                  <span class="hljs-keyword">return</span>;<br>              &#125;<br>          &#125;<br><br>          tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(key, value);<br>          <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> ++size;<br>          <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>              rehash();<br>      &#125;<br></code></pre></td></tr></table></figure>
<p>ThreadLocal的get方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>        <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>            ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> (T)e.value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> setInitialValue();<br>    &#125; <br></code></pre></td></tr></table></figure>
<p>　　从ThreadLocal的set和get方法可以看出，他们所操作的对象都是当前线程的ThreadLocalMap对象的table数组，因此在不同线程中访问同一个ThreadLocal的set和get方法，他们对ThreadLocal所做的读写操作仅限于各自线程的内部，这就是为什么ThreadLocal可以在多个线程中互不干扰的存储和修改数据。</p>
<h3 id="消息队列的工作原理"><a href="#消息队列的工作原理" class="headerlink" title="消息队列的工作原理"></a>消息队列的工作原理</h3><p>　　消息队列在Android中指的是MessageQueue，MessageQueue主要包含两个操作，插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为enqueueMessage和next，其中enqueueMessage的作用是往消息队列中插入一跳消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除，尽管MessageQueue叫消息队列，但是它的内部实现并不是用的队列，实际上它是通过一个单链表的数据结构来维护消息列表，单链表在插入和删除上比较有优势。下面是enqueueMessage的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                        msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>                Log.w(TAG, e.getMessage(), e);<br>                msg.recycle();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            msg.markInUse();<br>            msg.when = when;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-type">boolean</span> needWake;<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>                <span class="hljs-comment">// New head, wake up the event queue if blocked.</span><br>                msg.next = p;<br>                mMessages = msg;<br>                needWake = mBlocked;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span><br>                <span class="hljs-comment">// up the event queue unless there is a barrier at the head of the queue</span><br>                <span class="hljs-comment">// and the message is the earliest asynchronous message in the queue.</span><br>                needWake = mBlocked &amp;&amp; p.target == <span class="hljs-literal">null</span> &amp;&amp; msg.isAsynchronous();<br>                Message prev;<br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    prev = p;<br>                    p = p.next;<br>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                        needWake = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>                prev.next = msg;<br>            &#125;<br><br>            <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>            <span class="hljs-keyword">if</span> (needWake) &#123;<br>                nativeWake(mPtr);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>从其实现来安，主要操作其实就是单链表的插入操作。<br>next的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span><br>        <span class="hljs-comment">// This can happen if the application tries to restart a looper after quit</span><br>        <span class="hljs-comment">// which is not supported.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>        <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>                Binder.flushPendingCommands();<br>            &#125;<br><br>            nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>                <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        prevMsg = msg;<br>                        msg = msg.next;<br>                    &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>                &#125;<br>                <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                        <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>                        nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// Got a message.</span><br>                        mBlocked = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                            prevMsg.next = msg.next;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            mMessages = msg.next;<br>                        &#125;<br>                        msg.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>                        msg.markInUse();<br>                        <span class="hljs-keyword">return</span> msg;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// No more messages.</span><br>                    nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span><br>                <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                    dispose();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// If first time idle, then get the number of idlers to run.</span><br>                <span class="hljs-comment">// Idle handles only run if the queue is empty or if the first message</span><br>                <span class="hljs-comment">// in the queue (possibly a barrier) is due to be handled in the future.</span><br>                <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span><br>                        &amp;&amp; (mMessages == <span class="hljs-literal">null</span> || now &lt; mMessages.when)) &#123;<br>                    pendingIdleHandlerCount = mIdleHandlers.size();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.</span><br>                    mBlocked = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-literal">null</span>) &#123;<br>                    mPendingIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>                &#125;<br>                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>            &#125;<br><br>            <span class="hljs-comment">// Run the idle handlers.</span><br>            <span class="hljs-comment">// We only ever reach this code block during the first iteration.</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];<br>                mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    keep = idler.queueIdle();<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                    Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (!keep) &#123;<br>                    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                        mIdleHandlers.remove(idler);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.</span><br>            pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">// While calling an idle handler, a new message could have been delivered</span><br>            <span class="hljs-comment">// so go back and look again for a pending message without waiting.</span><br>            nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>可以返现next方法是一个无限循环的方法，如果消息队列为空，那么next方法会一直阻塞在这里，当有消息到来时，next方法会返回这条消息并将其从单链表中移除</p>
<h3 id="Looper的工作原理"><a href="#Looper的工作原理" class="headerlink" title="Looper的工作原理"></a>Looper的工作原理</h3><p>　　Looper在Android的消息机制中扮演者消息循环的角色，具体来说就是它会不停地从MessageQueue中查看是否有新消息，如果有新消息就会立刻处理，否则就一直阻塞在那里。首先看一下它的构造方法，在构造中它会创建一个MessageQueue也就是消息队列，然后将当前线程的对象保存起来，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>      mQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(quitAllowed);<br>      mThread = Thread.currentThread();<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>　　Handler的工作需要Looper，没有Looper的线程就会报错，我们可以通过Looper.prepare()即可为当前线程创建一个Looper，接着通过Looper.loop()来开启消息循环。Looper除了prepare方法外，还提供了prepareMainLoop方法，这个方法主要是给主线程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法来实现的。由于主线程的Looper比较特殊，所以Looper提供了一个getMainLooper方法，通过它可以在任何地方获取到主线程的Looper。Looper也是可以退出的，Looper提供了quit和quitSafely来退出一个Looper，二者的区别是：quit会直接突出Looper，而quitSafely只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全的退出。Looper退出后，通过Handler发送的消息会失败，这个时候Handler的send方法会返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来总之消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。<br> Looper最重要的一个方法是loop方法，只有调用了loop后，消息循环系统才会真正的起作用，实现如下：<br> <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Run the message queue in this thread. Be sure to call</span><br><span class="hljs-comment">   * &#123;<span class="hljs-doctag">@link</span> #quit()&#125; to end the loop.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br>      <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> me.mQueue;<br><br>      <span class="hljs-comment">// Make sure the identity of this thread is that of the local process,</span><br>      <span class="hljs-comment">// and keep track of what that identity token actually is.</span><br>      Binder.clearCallingIdentity();<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ident</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br><br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> queue.next(); <span class="hljs-comment">// might block</span><br>          <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-comment">// No message indicates that the message queue is quitting.</span><br>              <span class="hljs-keyword">return</span>;<br>          &#125;<br><br>          <span class="hljs-comment">// This must be in a local variable, in case a UI event sets the logger</span><br>          <span class="hljs-keyword">final</span> <span class="hljs-type">Printer</span> <span class="hljs-variable">logging</span> <span class="hljs-operator">=</span> me.mLogging;<br>          <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>              logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> +<br>                      msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>          &#125;<br><br>          <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">traceTag</span> <span class="hljs-operator">=</span> me.mTraceTag;<br>          <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>              Trace.traceBegin(traceTag, msg.target.getTraceName(msg));<br>          &#125;<br>          <span class="hljs-keyword">try</span> &#123;<br>              msg.target.dispatchMessage(msg);<br>          &#125; <span class="hljs-keyword">finally</span> &#123;<br>              <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>                  Trace.traceEnd(traceTag);<br>              &#125;<br>          &#125;<br><br>          <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>              logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br>          &#125;<br><br>          <span class="hljs-comment">// Make sure that during the course of dispatching the</span><br>          <span class="hljs-comment">// identity of the thread wasn&#x27;t corrupted.</span><br>          <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">newIdent</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>          <span class="hljs-keyword">if</span> (ident != newIdent) &#123;<br>              Log.wtf(TAG, <span class="hljs-string">&quot;Thread identity changed from 0x&quot;</span><br>                      + Long.toHexString(ident) + <span class="hljs-string">&quot; to 0x&quot;</span><br>                      + Long.toHexString(newIdent) + <span class="hljs-string">&quot; while dispatching to &quot;</span><br>                      + msg.target.getClass().getName() + <span class="hljs-string">&quot; &quot;</span><br>                      + msg.callback + <span class="hljs-string">&quot; what=&quot;</span> + msg.what);<br>          &#125;<br><br>          msg.recycleUnchecked();<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><br> 　　loop方法是一个死循环，唯一跳出循环的方式是MessageQueue的next方法返回了null，当Looper的quit方法被调用时，Looper就会通知消息队列退出，当消息队列被标记为退出状态时，它的next方法就会返回null，也就是说，Looper必须退出，否则loop方法就会无限循环下去，loop方法会调用MessageQueue的next方法来获取新消息，而next方法是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里，如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息，  msg.target.dispatchMessage(msg)，这里的  msg.target是发送这条消息的handler对象，这样Handler发送的消息最终又交个它的  dispatchMessage(msg);方法来处理了，但是这里不同的是，Handler的dispatchMessage方法是在创建Handler时所使用的Looper中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行了。</p>
<h3 id="Handler的工作原理"><a href="#Handler的工作原理" class="headerlink" title="Handler的工作原理"></a>Handler的工作原理</h3><p> Handler的工作主要包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一列方法来实现的。发送一条消息的典型过程如下：<br> <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(Message msg)</span><br>   &#123;<br>       <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);<br>   &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageDelayed</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> delayMillis)</span><br>   &#123;<br>       <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;<br>           delayMillis = <span class="hljs-number">0</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);<br>   &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageAtTime</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>       <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> mQueue;<br>       <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>                   <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);<br>           Log.w(<span class="hljs-string">&quot;Looper&quot;</span>, e.getMessage(), e);<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<br>   &#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(MessageQueue queue, Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>       msg.target = <span class="hljs-built_in">this</span>;<br>       <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>           msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>       &#125;<br>       <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>   &#125;<br></code></pre></td></tr></table></figure><br> 　　可以发现，Handler发送消息的过程仅仅是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这时Handler就是进入了处理消息的阶段。dispatchMessage的实现如下：<br> <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) &#123;<br>        handleCallback(msg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        handleMessage(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br> Handler处理消息的过程如下：</p>
<ol>
<li>检查Message的callback是否为null，不为null就通过handleCallback来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。handleCallback的逻辑如下： <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleCallback</span><span class="hljs-params">(Message message)</span> &#123;<br>       message.callback.run();<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>其次，检查mCallback是否为null，不为null就调用没CallBack的HandlerMessage方法来处理消息，Callback是个接口，它的定义如下：</li>
</ol>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Callback interface you can use when instantiating a Handler to avoid</span><br><span class="hljs-comment">    * having to implement your own subclass of Handler.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> msg A &#123;<span class="hljs-doctag">@link</span> android.os.Message Message&#125; object</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> True if no further handling is desired</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callback</span> &#123;<br>       <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>通过Callback可以采用如下方式来创建Handler对象：Handler handler &#x3D; new Handler(callback)。</p>
<ol start="3">
<li>最后，调用Handler的handleMessahe方法来处理消息。</li>
</ol>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-ERGIP协议</title>
    <url>/2014/05/19/CCNA-ERGIP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>学习过程中的笔记，比较零散。</p>
<span id="more"></span>

<h4 id="EIPGRP（企业级、高级的路由选择协议）"><a href="#EIPGRP（企业级、高级的路由选择协议）" class="headerlink" title="EIPGRP（企业级、高级的路由选择协议）"></a>EIPGRP（企业级、高级的路由选择协议）</h4><p>（cisco私有的协议，只有cisco的设备才支持）</p>
<p>特点</p>
<ul>
<li><p>高级距离矢量型协议（有没有发送路由信息）</p>
</li>
<li><p>收敛速度快（DUAL算法，扩散更新算法）</p>
</li>
<li><p>支持VLSM和不连续子网</p>
</li>
<li><p>部分更新（网络已经收敛，在网络拓扑不出现变动的时候，不在发送更新信息,只向收到变化影响路由条目的路由器发送变化的路由）</p>
</li>
<li><p>支持多种网络层协议</p>
</li>
<li><p>支持可扩展的网络设计（没有太多的设计要求）</p>
</li>
<li><p>使用组播或者单播进行更新（224.0.0.0）</p>
</li>
<li><p>可以在网络中的任何一点，进行手工汇总，并且支持超网汇总</p>
</li>
<li><p>100%支持无环路的无类路由</p>
</li>
<li><p>在wan和lan上容易配置</p>
</li>
<li><p>可以支持等开销或者非等开销的负载均衡</p>
</li>
</ul>
<h4 id="工作原理-邻居机制"><a href="#工作原理-邻居机制" class="headerlink" title="工作原理 邻居机制"></a>工作原理 邻居机制</h4><p>EIGRP 三张表</p>
<p>邻居(下一跳)表(发送更新之前先搜寻邻居)</p>
<p>邻居表建立之后交换路由信息</p>
<p>拓扑表(从邻居学习来的路由表)(运行DUAL算法,选择最优路径)</p>
<p>路由表（选择出来的最优路径）</p>
<h5 id="DUAL-算法"><a href="#DUAL-算法" class="headerlink" title="DUAL 算法"></a>DUAL 算法</h5><p>1  选择到达目标网络的最优的无环的路径</p>
<p>2 AD  下一跳路由到达目标网络的开销</p>
<p>3 FD  本地路由到达目标网络的开销&#x3D;AD+本地路由到达通告给我AD的下一跳路由的开销</p>
<p>lowest－cost＝lowest　FD</p>
<p>（current）successor&#x3D; 到达目标网络的最优的下一跳路由器</p>
<p>Feasible successor &#x3D;到达目标网络的次优的下一跳路由器</p>
<p>FC 可行条件  ＡＤ＜ＦＤｍｉｎ</p>
<p>FC 用来防环</p>
<p>EIGRP  数据包直接使用IP协议，协议号88</p>
<p>——hello   发现维护邻接关系（唯一周期性发送的）</p>
<p>当线路&gt;t1  周期5秒  当三个周期以上没有收到hello  认为邻居挂掉</p>
<p>当线路&lt;t1（１。５４４M）   周期30  同上</p>
<p>——update  发送路由更新（路由信息）</p>
<p>——query    向邻居查询特定路由信息</p>
<p>——reply    响应query查询</p>
<p>——ACK     确定数据包</p>
<p>（rtp  确定收到  可靠传输）</p>
<p><img src="/image/ccna/ERGIP_ket_technologies.png" alt="geocoderSearch"></p>
<p>符合度量值（五种）</p>
<p>带宽  延时 可靠性  负载 MTU</p>
<p>默认使用带宽和延时（可靠性和负载是变值）</p>
<p>K1   k2   k3  k4  k5 </p>
<p>10100(对应五个度量值)</p>
<p>EIGRP建立邻接关系的条件</p>
<p>AS号一样（进程域）</p>
<p>K值</p>
<p>认证</p>
<p>ERGIP　精确通告</p>
<p>Router　　ERGIP　１</p>
<p>no auto-suｍｍary</p>
<p>network　目标IP 反码(与子网掩码相反) (０表示匹配１表示无所谓)</p>
<p>ERGIP的表示是E(跳数最大100 内部管理距离90 外部管理距离170）　</p>
<p>show ipprotocols</p>
<p>show ip eigrp neighbor(邻居表)</p>
<p>show ip eigrp topology</p>
<p>show ip route ergip</p>
<p>show ip ergip traffic</p>
<p>在接口修改</p>
<p>ip hello-interval ergip as号 时间</p>
<p>ip hold-time ergip as号 三倍于hello时间</p>
<p>修改复合度量值　</p>
<p>Metric　weights　０１０１００</p>
<p>第一个只支持０。</p>
<p>检查K值　全网的K值必须一样</p>
<p><img src="/image/ccna/ERGIP_MD5_AUTH.png" alt="geocoderSearch"></p>
<p>keychain创建好之后每个支持加密的协议都可以用</p>
<p> EIGRP可以在网络中的任何一点进行路由汇总（支持超网汇总）</p>
<p>在接口级别上进行负载均衡</p>
<p> bandwidth  。。。。K单位为K  进行负载均衡</p>
<p>EIGRP Load Balancing</p>
<p>默认情况下EIGRP 使用等开销</p>
<p>默认最多在4条等开销路径上进行负载均衡</p>
<p>最多配置到16条路径上进行负载均衡</p>
<p>通过 maximum-paths 命令指定最大的路径</p>
<p>非等开销</p>
<p>Unequal-Cost 负载均衡</p>
<p>variance 数字</p>
<p>用法  ：  将最优的FD×variance值，只要大于某个线路的FD   改线路就会自动加进来</p>
<p><img src="/image/ccna/ERGIP_Variance.png" alt="geocoderSearch"></p>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-DHCP和NAT</title>
    <url>/2014/05/19/CCNA-DHCP%E5%92%8CNAT/</url>
    <content><![CDATA[<p>学习过程中的笔记，比较零散</p>
<span id="more"></span>

<h4 id="动态主机配置协议：dynamic-host-configuration-protocol-架构为C-x2F-S-客户端-x2F-服务器-前身是-boot-protocol"><a href="#动态主机配置协议：dynamic-host-configuration-protocol-架构为C-x2F-S-客户端-x2F-服务器-前身是-boot-protocol" class="headerlink" title="动态主机配置协议：dynamic host configuration protocol  架构为C&#x2F;S 客户端&#x2F;服务器   前身是 boot protocol"></a>动态主机配置协议：dynamic host configuration protocol  架构为C&#x2F;S 客户端&#x2F;服务器   前身是 boot protocol</h4><p>DHCP使用UDP协议，端口号为67(客户端)，68（服务端）</p>
<p>IP可以和mac绑定</p>
<p>工作过程如下：</p>
<p>C —-&gt;Ｓ（discover message）发现消息，在局域网内广播发送</p>
<p>S —-&gt;Ｃ（offer message） 回复消息  单播响应请求的客户端</p>
<p>C —-&gt;Ｓ（request message）请求消息  广播发送（因为一个局域网可能有多个路由器，先收到哪个服务器的offer就用谁的IP）</p>
<p>S —-&gt;Ｃ (acknowledge message) 确认消息  ACK消息</p>
<p>DHCP　configuration　Ｏｎ　IOS</p>
<p>（dhcp只能配置在以太网上，串口是没有办法配置dhcp的）</p>
<table>
<thead>
<tr>
<th>（config）#service dhcp</th>
<th>启动DHCP服务</th>
</tr>
</thead>
<tbody><tr>
<td>(config)# ip dhcp pool name</td>
<td>指定地址池的名字</td>
</tr>
<tr>
<td>(dhcp-config)#network 192.168.1.0 255.255.255.0</td>
<td>指定为哪个网段服务</td>
</tr>
<tr>
<td>(dhcp-config)#default-router 192.168.1.254</td>
<td>可选，指定网关</td>
</tr>
<tr>
<td>(dhcp-config)#domain-name name</td>
<td>可选，指定域名</td>
</tr>
<tr>
<td>(dhcp-config)#dns-server IP IP</td>
<td>可选，DNS服务器</td>
</tr>
<tr>
<td>(dhcp-config)#lease 7</td>
<td>可选，租约期，单位是天</td>
</tr>
<tr>
<td>config）# ip dhcp excluded-address 192.168.1.1 192.168.1.10</td>
<td>排除不想分配的IP地址</td>
</tr>
</tbody></table>
<h4 id="NAT：-网络地址转换，用来修改IP数据包中的源、目的地址"><a href="#NAT：-网络地址转换，用来修改IP数据包中的源、目的地址" class="headerlink" title="NAT： 网络地址转换，用来修改IP数据包中的源、目的地址"></a>NAT： 网络地址转换，用来修改IP数据包中的源、目的地址</h4><h5 id="私有IP地址"><a href="#私有IP地址" class="headerlink" title="私有IP地址"></a>私有IP地址</h5><p>A类  10.0.0.0 – 10.255.255.255</p>
<p>B类 172.16.0.0 – 172.31.255.255</p>
<p>C类 192.168.0.0 – 192.168.255.255</p>
<p>只能存在于内网中，是不能出现在互联网上的</p>
<h5 id="为何使用NAT技术"><a href="#为何使用NAT技术" class="headerlink" title="为何使用NAT技术"></a>为何使用NAT技术</h5><p>1 节省IP地址 （NAT + VLSM&#x2F;CIDR）</p>
<p>2 安全考虑，隐藏内部真实的IP地址</p>
<p>3 NAT TCP负载均衡</p>
<p>4 解决地址冲突问题（公司合并）</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>1 影响路由器的转发性能（额外修改IP地址，计算校验和等）</p>
<p>2 破坏了IP的端到端特性</p>
<p>3 与很多安全相关协议不兼容（IPSec等）</p>
<h5 id="NAT-分类"><a href="#NAT-分类" class="headerlink" title="NAT  分类"></a>NAT  分类</h5><p>1 静态NAT</p>
<p>–手工配置NAT映射表</p>
<p>– 一对一转换</p>
<p>2 动态NAT</p>
<p>– 定义地址池，动态创建NAT映射表</p>
<p>– 一对一转换</p>
<p>3 PAT（NAT Overload NAT过载） 就是我们平时说的NAT转换</p>
<p>– 多对一转换</p>
<p>– 通过端口号标识不同数据流（和通信的端口号没有关系）</p>
<p><img src="/image/ccna/nat.png" alt="nat网络拓扑"></p>
<p>模拟网络连接如图：</p>
<p>C1、C2和NAT服务器在192.168.1.0&#x2F;24的网段，其中NAT服务器的IP是192.168.1.254，NAT服务器通过窗口和ISP相连，公网地址在61.1.1.0&#x2F;24网段</p>
<p>配置名命令（没有全拼，自己补全即可）</p>
<p>（需要指定转换的方向，即哪边是内网，哪边是外网）</p>
<p>① 静态NAT ，一对一关系(不要忘了指定转换方向，即哪边是内网，哪边是外网)</p>
<p>在 c1上的配置</p>
<p>1）指定接口的IP的地址，并指定缺省网关</p>
<p>conf t</p>
<p>int f0&#x2F;0</p>
<p>ip add 192.168.1.1 255.255.255.</p>
<p>no sh</p>
<p>ip route 0.0.0.0 0.0.0.0 192.168.1.254</p>
<p>在C2上</p>
<p>指定接口的IP，并指定缺省网关</p>
<p>conf t</p>
<p>int f0&#x2F;0</p>
<p>ip add 192.168.1.2 255.255.255.</p>
<p>no sh</p>
<p>ip route 0.0.0.0 0.0.0.0 192.168.1.254</p>
<p>在NAT服务器上</p>
<p>制定IP地址，并进行配置，命令如下</p>
<p>Conf t</p>
<p>Int f0&#x2F;0</p>
<p>Ip add 192.168.1.254 255.255.255.0</p>
<p>No sh</p>
<p>Int s1&#x2F;1  (在和ISP相连的接口上配置IP)</p>
<p>Ip add 61.1.1.1 255.255.255.0</p>
<p>Cl ra 64000</p>
<p>No sh </p>
<p>End</p>
<p>(NAT映射)</p>
<p>Ip nat inside source static 192.168.1.1(源IP地址) 61.1.1.11(目标IP地址)</p>
<p>Ip nat inside source static 192.168.1.2(源IP地址) 61.1.1.12(目标IP地址)</p>
<p>(可以通过 show ip nat traslations查看转换表)</p>
<p>Int fa0&#x2F;0</p>
<p>Ip nat inside(指定为内网，即入口)</p>
<p>Int s1&#x2F;1</p>
<p>Ip nat outside（指定为外网，即出口）</p>
<p>3 在ISP上</p>
<p>指定和NAT相连的接口Ip</p>
<p>Conf t </p>
<p>Int s1&#x2F;1</p>
<p>Ip add 61.1.1.2 255.255.255.0</p>
<p>Cl ra 64000 </p>
<p>No sh </p>
<p>End</p>
<p>②动态NAT(不要忘了指定转换方向，即哪边是内网，哪边是外网)</p>
<p>在nat上</p>
<p>Ip nat pool pool-name 61.1.1.10 61.1.1.20 netmask 255.255.255.0</p>
<p>(定义访问控制列表)</p>
<p>Access-list 1 permit 192.168.1.0 0.0.0.255</p>
<p>Ip nat inside source list 1 pool pool-name</p>
<p>在C1、c2和IPS上的配置和静态nat相同</p>
<p>③NAT过载 （多个内网对应一个外网）(不要忘了指定转换方向，即哪边是内网，哪边是外网)</p>
<p>Access-list 1 permit 192.168.1.0 0.0.0.255</p>
<p>Ip nat inside source list 1 pool pool-name</p>
<p>Ip nat inside source list 1 interface s1&#x2F;1 overload</p>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-Internet connection</title>
    <url>/2014/05/19/CCNA-Internet-connection/</url>
    <content><![CDATA[<p>学习过程中的笔记，比较零散</p>
<span id="more"></span>

<h4 id="主流的广域网连接"><a href="#主流的广域网连接" class="headerlink" title="主流的广域网连接"></a>主流的广域网连接</h4><p>包交换：运行商可以将一条线路租给多个用户，因为他们的网络需要量小。</p>
<p>DSL（数字用户线），家庭终端用户和中小型企业（ADSL非对称用户线，意思是上行流量和下行流量不相等，下行速率较高，上行速率较低）ADSL技术实际上只应用于家庭ADSL猫和网络运营商的DSLAM的边界部分，而运营商内部还是高速的交换网络。是一层技术。解决长距离传输问题</p>
<p>再上层是PPP协议</p>
<p>DSL的优点：</p>
<p>速度较快，可以达到８Ｍ</p>
<p>可同时进行声音和数据传输</p>
<p>可以２４小时在线</p>
<p>可以和传统的模拟电话线路兼容</p>
<p>缺点：</p>
<p>限制多</p>
<p>需要本地电话公司的支持</p>
<p>开放的线路，安全性较差</p>
<h4 id="串行接口封装"><a href="#串行接口封装" class="headerlink" title="串行接口封装"></a>串行接口封装</h4><p>Circuit switching 电路交换：在通信之前，要先建立连接，建立好之后线路专属于某以用户。但是连接速率低，通常是在异步线缆上进行，通常基于PSTN（ puclic switched telephon newwork公共电话交换网络)：简单，可用性高，费用低</p>
<p>租用线路（leased Line）：速度快，费用高。线路是专门为用户预留的</p>
<p>WAN connection bandwidth：串行接口要配置始终频率，一般是在DCE端进行配置，DTE端是用户端（实验室环境下两台路由器之间的线缆是模拟的广域网网云的环境。）</p>
<p>DTE和DCE端是线缆决定的，线缆的DCE端插到哪个端口，哪边就是DCE端。</p>
<p>Point－to－point　considerations</p>
<p>优点：</p>
<p>简单、质量高、可用性高；</p>
<p>缺点：</p>
<p>费用高、灵活性差</p>
<p>思科的设备和别的设备在二层封装是不一样的，假如思科的路由器和华为的路由器Ｗａｎ口相连，是连接不通的，因为思科的二层封装是修改过的。</p>
<p>修改接口的封装类型命令如下：</p>
<p>Interface　s０／０／０（要修改的接口）</p>
<p>Encapsulation　封装类型（Ｈｄｌｃ　PPP　Ｓｔｕｎ等）</p>
<p>默认是hdlc</p>
<p>不同厂商的设备相连一半时PPP协议</p>
<p>PPP协议：认证、压缩、多链路、回拨；</p>
<h4 id="Frame-relay（帧中继协议）："><a href="#Frame-relay（帧中继协议）：" class="headerlink" title="Frame　relay（帧中继协议）："></a>Frame　relay（帧中继协议）：</h4><p>工作在用户端和运营商边界的协议</p>
<p>ATM 异步传输模式 属于信源交换   将数据分为53字节的定长信源；通常是在硬件之内完成，通常运行于运营商内部高速网络</p>
<p>ISDN。。。。大概只出现过一年的时间左右，就过度到adsl了</p>
<p>工作在用户端到运营商的边界处（称为最后一公里）</p>
<p>使用了虚电路的概念</p>
<p>在一根电缆上通过多路复用技术划分出virtual circuits （虚拟电路）租用给多个用户，用户感觉就像租用了专线一样</p>
<p>虚拟电路分为临时线路（SVC）和永久线路（PVC）</p>
<p>帧中继通过DLCI号（只具有本地意义，不一定全局唯一，通常情况下做成全局唯一的）来分辨每个虚拟电路（二层编址技术  0-1024）</p>
<p>帧中继有两种封装形式：cisco（思科设备私有的）和IETF封装</p>
<p>LIM：本地管理接口，两个设备之间使用的信令标准。有三种类型：</p>
<p>Cisco  ansi  Q933a  可以理解为设备之间的语言</p>
<p>配置的时候注意设备间使用的封装类型和信令标准</p>
<p>帧中继 是NBMA网络，不支持广播和组播 </p>
<p>帧中继通过逆向ARP解决IP–&gt;DLCI号的映射</p>
<p>帧中继互联拓扑结构：</p>
<p>全互联、部分互联、星形连接</p>
<p>可以将一个帧中继接口划分为多个子接口：可以将线路隔离，可以解决水平分割问题；</p>
<p>点对点子接口可以解决水平分割问题，但是浪费IP地址</p>
<p>多点子接口不可以解决水平分割问题，但是不浪费IP地址</p>
<h4 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h4><p>PPP协议可以说是应用最广泛的广域网二层协议，分为两个部分：NCP（网络控制协议，在三层与二层做兼容转换），LCP（链路控制协议，建立拆除线路）；</p>
<p>PPP协议的特点：（LCP的实现）（不同厂商的设备可以连接）</p>
<p>1 支持认证（2层的认证机制）</p>
<p>2 支持回拨（通常用于企业集中化管理账单）</p>
<p>3支持压缩（启用压缩之后，所有通过线缆的数据都是被压缩，相当于侧面提高了传输速率）</p>
<p>4支持多链路（允许将多个物理线路捆绑成一个逻辑线路，提高传输s速率）</p>
<p>《TCP&#x2F;IP协议详解》80年代的书</p>
<p>PPP连接建立的过程：</p>
<p>1 请求建立连接；</p>
<p>2 LCP控制连接（可能会有认证）</p>
<p>3 NCP处理；</p>
<p>PPP认证分为两种：PAP（明文认证）和CHAP（挑战握手认证协议（三次握手双向认证））使用的是路由器的全局用户名密码</p>
<p>配置命令：（线路两端的封装协议必须一样）</p>
<p>Interface　ｓ０／０／０</p>
<p>Encapsulation　ppp</p>
<p>认证：</p>
<p>①PAP认证（有发起方和接收方）</p>
<p>在全局模式下：</p>
<p>Username name password passwd</p>
<p>在要启用认证的接口上：</p>
<p>Ppp authentication pap</p>
<p>在线路另一端</p>
<p>全局配置模式下：</p>
<p>Ppp pap sent-usernam name password passed</p>
<p>②CHAP认证：</p>
<p>建立的用户名是对端的主机名，密码必须要一样</p>
<p>在一端：</p>
<p>全局配置模式：</p>
<p>Username　对端的主机名　password　密码</p>
<p>Ppp　authentication　CHAP</p>
<p>另一端相同的配置</p>
<p>查看过程可用　debug　ppp　negotiation</p>
<h4 id="交换基础"><a href="#交换基础" class="headerlink" title="交换基础"></a>交换基础</h4><p>HUB连接：会产生数据冲突</p>
<p>Bridges（网桥）：具有二层的过滤功能（基于二层的mac地址进行过滤），（还是属于软件处理）可以互联多个网段。</p>
<p>switches（交换机）：属于硬件处理，可以线速转发。</p>
<p>划分了多个冲突域，每个接口下的终端设备属于一个独立的冲突域，不会产生数据冲突。</p>
<p>全双工模式，可以同时进行收和发允许线缆两端速度不一样。</p>
<p>可以通过mac table 对数据进行智能转发，而且mac table是可以学习的</p>
<p>交换机刚开机的时候mac table是空的，在转发过程中进行学习。当不知道目标mac地址在哪的时候，会把数据从其余的接口泛洪出去。对局域网的组播和广播数据进行泛洪操作。</p>
<p>特点：</p>
<p>多接口，很高冗余性，线速转发，可以混合不同的接口速度，快速转发</p>
<p>三种工作模式：</p>
<p>直通交换，无碎片交换，存储转发交换</p>
<h4 id="VLAN和Trunks"><a href="#VLAN和Trunks" class="headerlink" title="VLAN和Trunks"></a>VLAN和Trunks</h4><p>划分冲突域，具有二层隔离性，一个vlan相当于一个冲突域，等于一个局域网。vlan隔离之后是两个子网，达到路由的隔离性。</p>
<p>不同vlan通信需要通过三层设备。</p>
<p>vlan的划分是在接口上划分的，不同的vlan是不同的逻辑子网</p>
<p>划分出来的vlan就相当于两个处于不同网段的交换机</p>
<p>vlan可以隔离广播域。</p>
<p>Trunks 允许不同交换机的相同Vlan通信，允许在一根线路上承载多个vlan信息，这个接口就是Trunk接口。</p>
<p>所有没打标记的数据包，统一划给native Vlan</p>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-OSI模型</title>
    <url>/2014/05/19/CCNA-OSI%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>只是学习过程中的笔记，较为零散，</p>
<span id="more"></span>

<h4 id="七层介绍"><a href="#七层介绍" class="headerlink" title="七层介绍"></a>七层介绍</h4><p>7  application</p>
<p>6  presentation</p>
<p>5  session</p>
<p>4  transport</p>
<p>3  network</p>
<p>2  data link</p>
<p>1  physical</p>
<p>优点：流水化作业</p>
<p>标准化借口 模块独立</p>
<p>物理层： 底层数据传输 （方式标准等）</p>
<p>数据链路层：数据的基本格式以及数据在电缆上的传输，如何访问底层介质</p>
<p>网络层：三层IP编址和路由</p>
<p>传输层：端到端通信的功能  TCP UDP 定义源和目标之间如何传输数据以及保证传输的可靠性。</p>
<p>会话层：</p>
<p>表示层：数据格式（视频格式：avi什么的），提供基本压缩和加密功能</p>
<p>应用层：应用软件</p>
<p>数据封装：data encapsulation</p>
<p>数据由应用程序产生（如QQ聊天）</p>
<p>每层的信息保存在报头里面（HDR&#x3D;header）</p>
<p>数据解封装：data de-encapsulation</p>
<p>逐渐分析报头。</p>
<p>传输层：段 segment</p>
<p>网络层：包 packets</p>
<p>数据链路层： 侦 frames</p>
<p>物理层：比特流 bits</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层节电缆：主要是交换机，网卡，早期还有网桥。</p>
<p>lan：local area network</p>
<p>短距离 直接相连</p>
<p>共享型网络（介质共享）</p>
<p>Mac 地址：48bit  (固化地址，保存在网卡的rom里面，不可以改变)</p>
<p>24bit组织唯一标识符（哪一个公司）（oui）24bit厂商生产的设备（vendor   </p>
<p>assigned）</p>
<p>一个网段内是通过mac地址进行通信</p>
<p>载波监听多路访问&#x2F;冲突检测（csma&#x2F;cd）有线</p>
<p>载波监听多路访问&#x2F;冲突避免（csma&#x2F;ca）无线</p>
<p>netsh wlan set hostednetwork mode&#x3D;allow</p>
<p>netsh wlan set hostednetwork ssid&#x3D;AA key&#x3D;12345678 </p>
<p>netsh wlan start hostednetwork</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>mac编址的问题：没有层次化，所有设备处在一个广播域（单播组播广播）设备的查找比较困难（去找张三）难以对设备区分应用策略</p>
<p>网络层：IP编址和路由功能</p>
<p>IP协议：网络划分，便于查找（地区的划分）便于定位</p>
<p>32位（网络地址 主机地址）面向非连接的编址（区别于源和目标在传输数据之前是否需要一定的连接）</p>
<p>IP协议是尽力而为的协议，不保证传输的的可靠性，没有数据恢复机制（没有重复发送）</p>
<p>不同网络之间通信必须要有路由（同一个网段ps）：通过路由表的记录，在不同的网段之间相互转发数据。</p>
<p>主机部分全为0的是网络地址 全为1是广播地址 </p>
<p>A类10.0.0.0   —— 10.255.255.255</p>
<p>B类172.16.0.0  —— 172.31.255.255</p>
<p>C类192.168.0.0  —— 192.168.255.255</p>
<p>私有地址  余下的是共有地址</p>
<p>DHCP 动态主机配置协议</p>
<p>DNS  域名解析服务</p>
<p>ARP（同一层）地址解析协议</p>
<p>ICMP  Internet控制报文协议  用来返回错误消息（目标主机不可达，数据损坏）</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层 ：端到端的通信  保证传输的可靠性  比如差错恢复机制</p>
<p>会话的多路复用</p>
<p>对数据进行分段</p>
<p>流控机制（网络拥塞 减少流量）</p>
<p>面向连接的协议</p>
<p>1、多路复用，一个协议可能为多个上层协议提供统一的服务</p>
<p>通过端口号   区分上层的应用程序</p>
<p>2 tcp（可靠的  但效率低）工作在第四层  提供访问网络层的功能  没有数据恢复  面向连接  全双工  差错校验 数据序列号标识   保证数据的可靠传输   有确认  差错恢复机制</p>
<p>三次握手：A请求建立连接同时协商某些状态（SYN）  B返回信息　　　A　确定　　　　整个连接建立</p>
<p>流控机制</p>
<p>3udp（类似于IP  尽力而为，不保证可靠性 非顺序  效率高）面向非连接（传输之前没有协商，不保证传输的可靠性）</p>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-VLSM子网划分</title>
    <url>/2014/05/19/CCNA-VLSM%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>学习过程中的笔记，比较零散</p>
<span id="more"></span>

<p>运营商分配了什么网段</p>
<p>基于需求  判断需要借用多少位 子网中有多少主机</p>
<p>进行运算</p>
<p>ex：</p>
<p>IP address 192.168.221.38</p>
<p>Subnet mask 29 （255.255.255.248）</p>
<p>属于哪个子网（192.168.221.32）</p>
<p>第一个子网  192.168.221.32</p>
<p>第一个主机IP地址 192.168.221.33</p>
<p>最后一个主机IP 192.168.221.39</p>
<p>下一个子网  192.168.221.40</p>
<p><img src="/image/ccna/VLSM_classA.png" alt="VLSM-classA"></p>
<p><img src="/image/ccna/VLSM_classB.png" alt="VLSM-classB"></p>
<p><img src="/image/ccna/VLSM_classC.png" alt="VLSM-classC"></p>
<p>子网划分带来的：</p>
<p>路由汇总 </p>
<p>多出很多网段  需要路由转发  需要路由表</p>
<p>占用较多的内存  </p>
<p>路由转发数据   只匹配子网掩码规定的位数</p>
<p> 比对最长的（最精确匹配）</p>
<p>路由汇总  减少检测的子网掩码位数</p>
<p>根据实际情况确定是否需要禁止汇总路由</p>
<p>路由汇总带来的：</p>
<p>1减少路由表条目</p>
<p>2隐藏拓扑变动</p>
<p>-1由于汇总  减少了匹配位数   对于不连续的网段 可能导致 数据转发错误</p>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-ospf协议</title>
    <url>/2014/05/19/CCNA-ospf%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>学习过程中的笔记，比较零散</p>
<span id="more"></span>

<p>开放式最短路径优先  open 最短路径优先算法 </p>
<p>高级企业级路由协议</p>
<p>链路状态型的路由选择协议</p>
<p>每个路由的选择是每个路由器独立选择的   不是靠别的路由器告诉的</p>
<p>DU（距离矢量型） 交换的是route</p>
<p>LS （链路状态型）交换的是linkstate（描绘网络拓扑的信息）</p>
<p>链路状态型</p>
<p>拥有全网的路由信息,并且每个路由器的路由信息都是一致的  </p>
<p>链路状态信息通过LSA数据结构进行描述 </p>
<p>路由器之间相互交换链路好状态信息,构成LSDB(拓扑数据库 链路状态数据库)</p>
<p>运行spf  构建spftree  触发更新  部分有界更新</p>
<p>OSPF 维护三张表</p>
<p>1邻居表</p>
<p>2拓扑表</p>
<p>3路由表   </p>
<p>建立邻居关系，相互交换LSDB建立拓扑表（网络地图），基于拓扑表运行SPF算法，选择最优路径，构建路由表。</p>
<p><img src="/image/ccna/link-state_routing_protocels.png" alt="链路状态型"></p>
<p>运行两次SPF算法，第一次构建全局拓扑表，去掉环路，第二次运行时删除次优路径，构建路由表。</p>
<p>OSPF算法需要rourte-id唯一标识每一台路由器</p>
<p>使用环回接口做为route-id的原因是：</p>
<p>环回接口并不是实际通信接口，指定起来比较方便。一台路由器上至少要有一个IP才能开启OSPF算法</p>
<p><img src="/image/ccna/link-state_routing_protocels_router_id.png.png" alt="链路状态型"></p>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-rip协议</title>
    <url>/2014/05/19/CCNA-rip%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>学习过程中的笔记，比较零散</p>
<span id="more"></span>

<h4 id="距离矢量型路由选择协议"><a href="#距离矢量型路由选择协议" class="headerlink" title="距离矢量型路由选择协议"></a>距离矢量型路由选择协议</h4><p>距离&#x3D;跳数（经过几层三层设备，三层以下不算，没有路由）</p>
<p>矢量&#x3D;出接口（方向）</p>
<p>路由器周期性的从接口向外发送本机的完整路由表</p>
<p>对于rip，周期是30秒</p>
<h4 id="问题-缺点"><a href="#问题-缺点" class="headerlink" title="问题 缺点"></a>问题 缺点</h4><p>根据跳数选择，不精确</p>
<p>不一致的路由信息会导致路由环路</p>
<p>导致路由环路的原因：</p>
<p>更新不同步（跳数到无穷大，因此，定义最大跳数15，16跳为不可达，缺点，限制的最大网络直径）</p>
<p>水平分割，split horizon（永远不会将路由信息从接受这个信息的接口上发送回去）</p>
<p>路由毒化（route poisoning）网络down掉之后不是仅仅将路由条目删除，并且把其度量值标记为无限大（16跳），通告网络（类似与泛洪过程，会覆盖水平分割机制，）</p>
<p>毒性逆转 </p>
<p>抑制计时器（hold-down timer）：防止因更新不同步引起的问题（接收到次优路由信息不立即相信）</p>
<p>触发更新（triggered updates）网络拓扑发生变动时，立即发送更新信息，不必等待计时器</p>
<h4 id="距离矢量——收敛过程"><a href="#距离矢量——收敛过程" class="headerlink" title="距离矢量——收敛过程"></a>距离矢量——收敛过程</h4><p>路由器在没有配置协议的时候只知道直连的路由</p>
<p>路由器从收集到的源信息中选择到达目标地址的最佳路径</p>
<p>对比自己的路由表，将没有的路由信息加入到自己的路由表中，并且跳数加1，将学习到的路由器做为下一跳的出接口</p>
<p>学习到所有的路由信息才算收敛完成</p>
<p>路由失效</p>
<p>当有一台路由器挂了，与其直连的路由会将接口路由新删除，对于学习来的路由信息，会加上失效计时器（180秒，六个更新周期）每收到一个更新，就会重置。当180秒之后没有收到更新，就会将接口置为possible down</p>
<p>刷新计时器（240秒）过去240秒，删除</p>
<h4 id="Rip（route-information-protocol）"><a href="#Rip（route-information-protocol）" class="headerlink" title="Rip（route information protocol）"></a>Rip（route information protocol）</h4><p>距离矢量型路由协议（判断方法：是否直接发送路由信息）</p>
<ul>
<li>RIPv1是有类别的，RIPv2是无类别的，RIPng是IPv6版本</li>
<li>RIP使用跳数（hop：三层设备）作为度量标准</li>
<li>使用UDP协议，端口号520</li>
<li>周期性发送更新（默认30秒）</li>
<li>Ripv1使用广播更新（255.255.255.255）</li>
<li>Ripv2使用组播更新（224.0.0.9）</li>
<li>RIP计时器：更新update-30s，失效invalid-180s，抑制holddown-180s，刷新flush-240s</li>
</ul>
<h4 id="rip配置命令"><a href="#rip配置命令" class="headerlink" title="rip配置命令"></a>rip配置命令</h4><p>Route rip</p>
<p>Version 1</p>
<p>Network 10.0.0.0(直连的网络，只宣告主类网络)</p>
<p>Network 172.168.0.0（直连网络，只宣告主类网络）</p>
<p>No auto-summary</p>
<p>Clear ip route *   清空路由表</p>
<p>Show IP rip database  （看rip底层数据库）</p>
<p>Debug IP  rip</p>
<p>抖动计时器 （上下浮动15%）不一定是精确的30，防止网络流量过大</p>
<p>一个rip更新最多携带25个路由</p>
<p>调整RIP默认计时器</p>
<p>修改计时器的目的一般是为了加快收敛速度,并且所有的路由计时器一定要一致,一般情况下不要修改默认计时器,否则可能导致由于更新时间导致的路由信息不一致情况</p>
<p>Timer basic 30 180 180 240</p>
<p>更新计时器  失效  抑制  刷新</p>
<p>只有RIPv2支持认证(加密)</p>
<p>启用明文认证之后   只能携带24个路由信息</p>
<p>启用md5认证  只能携带 23个路由信息</p>
<p>在接口下启用认证</p>
<p>1   创建密钥数据库</p>
<p>Key chain  数据库名字</p>
<p>Key 1</p>
<p>Key-string 密码  空格也算</p>
<p>2  启动密钥认证</p>
<p>IP rip authentication mode [text | md5]</p>
<p>3  挂载密钥</p>
<p>Ip rip authentication key-chain 密钥链（名字） （挂载可以不一样）</p>
<p>RIPv2手工汇总</p>
<p>只支持子网汇总，不支持超网（不超过主类网的边界）汇总</p>
<p>在接口处启用</p>
<p>Ip summary-address rip 汇总后的IP  子网掩码</p>
<p>关闭水平分割（no ip split-rizon）</p>
<p>水平分割默认生效</p>
<p>RIp被动接口及单播更新</p>
<p>被动接口只接收不发送路由更新</p>
<p>Passive-interface </p>
<p>只向指定的设备发送路由更新(单播)</p>
<p>Neighbor  ip地址</p>
<p>然后配置缺省路由，达到隐藏网络的地址</p>
<p>Ripv1  和  ripv2并存（兼容一些不支持ripv2的老式路由器）</p>
<p>在接口上指定发送接收什么版本的rip</p>
<p>Ip rip send version</p>
<p>Ip rip received version</p>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-广域网和ACL</title>
    <url>/2014/05/19/CCNA-%E5%B9%BF%E5%9F%9F%E7%BD%91%E5%92%8CACL/</url>
    <content><![CDATA[<p>学习过程中的笔记，比较零散</p>
<span id="more"></span>

<h4 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h4><p>局域网内基本上是以太网相连，通常最大传输距离为100米。</p>
<p>广域网技术一般是用来节约成本的</p>
<p>广域网不等于Internet  Internet只是广域网的一种</p>
<p>广域网技术往往只涉及下OSI两层（数据链路层和物理层）对上层没有影响 </p>
<p>分为DTE端（客户端）  DCE端（服务商端，在配置的时候时钟频率只能配置在DCE端）</p>
<p>在局域网中二层使用的是mac协议 </p>
<p>wan数据链路层协议：</p>
<p>HDLC</p>
<p>PPP</p>
<p>Frame Relay（帧中继） </p>
<p>ATM（异步传输网络）　</p>
<p>ISDN</p>
<p>WAN分为专用线路（租用线路）和</p>
<p>交换线路（电路交换，PSTN，家用电话，属于模拟信号传输；包交换（廉价，信号一般），数字信号交换；信源交换（速度快，费用高），数字信号交换，AMT，异步传输网络）</p>
<p>广域网分为闭网和开网</p>
<h4 id="ACL-访问控制列表（access-control-list）"><a href="#ACL-访问控制列表（access-control-list）" class="headerlink" title="ACL-访问控制列表（access control list）"></a>ACL-访问控制列表（access control list）</h4><p>对IP网络流量进行配置，允许或者不允许某些包连接某些服务器</p>
<p>对流量进行分类</p>
<p>可以把它简单认为是一个防火墙</p>
<p>当把ACL当作过滤器来使用的时候</p>
<p>允许或者不允许某些包通过路由器</p>
<p>没有ACL的时候，所有的包都是允许到所有的地方去的</p>
<p>ACL所能分辨的信息到4层，ACL也称为包防火墙，可以根据流量的TCP&#x2F;IP或者UDP或者端口号来进行过滤，但是并不能进行内容过滤</p>
<p>ACL可以对流量进行分类，不会对流量进行过滤，只能起到分检器的作用</p>
<p>当数据包进去路由器的时候，先检查路由表，有的话去检查出接口是够挂载ACL（ACL当做过滤器来使用的时候，是需要绑定接口的，两个方向：出向还是入向，即检测进来的还是检测出去的包。一个接口上最多挂两个ACL，也就是说每个方向挂载一个，可以在一个ACL上设定多个规则），是的话进行ACL控制测试，ACL允许该包通过的话就转发。若其中任意过程为否，该包丢弃。</p>
<p>一个ACL可以设定多个判定条件，只要匹配一个就可以转发，多个条件之间的逻辑关系是或，当匹配到其中一个判定条件的时候，立即执行该条件后的动作，若全部不匹配，则将该包丢弃。</p>
<p>ACL分为两种类型：</p>
<p>标准ACL：速度快，只能基于发送的源IP地址进行判断</p>
<p>扩展ACL：扩展的ACL较为精细一点，可以基于源地址，目标地址，协议，端口号进行判断。速度相对来说慢一点。</p>
<p>怎么区分两种ACL：基于编号：当编号在1-99，1300-1999就是标准的</p>
<p>当编号是100-199，2000-2699就是扩展的</p>
<p>基于命名：明确指出ACL类型</p>
<p>标准访问控制列表的语法格式</p>
<p>Access-list access-list-number</p>
<p>｛permit | deny | remark｝source 【mask】</p>
<p>示例：</p>
<p>拒绝所有来自1.1.1.1的数据包</p>
<p>Access-list 1 deny 1.1.1.1 0.0.0.0（反码，0表示匹配，1表示无所谓）</p>
<p>Access-list 1 permit 0.0.0.0 255.255.255.255 （因为默认是拒绝所有，没有这条命令数据包是无法通过的）</p>
<p>或者： access-list 1 deny host 1.1.1.1</p>
<p>Access-list 1 permit any  （host和any是预先设定好的通配符）</p>
<p>允许所有来自192.168.1.0&#x2F;24的数据包</p>
<p>Access-list 1 permit 192.168.1.0 0.0.0.255</p>
<p>配置完之后还要绑定到端口。</p>
<p>（规则顺序很重要，但是编号ACL不允许删除单独的一条规则</p>
<p>例如 </p>
<p>Access-list 1 deny 1.1.1.0 0.0.0.255</p>
<p>Access-list 1 permit 1.1.1.1 0.0.0.0</p>
<p>这样的话第二条规则永远不会生效，因为在匹配了第一条规则后，就会立即执行第一条规则之后的动作，不再向下进行匹配）</p>
<p>在接口配置模式下：</p>
<p>Ip access-group access-list-number ｛in | out｝</p>
<p>标准ACL配置大体分为两步：</p>
<p>①：在全局配置模式下创建访问控制列表，并且设定规则</p>
<p>②：在接口配置模式下挂载ACL，并指定方向。</p>
<p>扩展访问控制列表语法格式</p>
<p>示例</p>
<p>拒绝所有从1.1.1.1 到2.2.2.2 的ping包（ping使用的是ICMP协议）</p>
<p>Access-list 100 deny icmp host 1.1.1.1 host 2.2.2.2</p>
<p>Access-list 100 permit ip any any</p>
<p>拒绝所有从1.1.1.0&#x2F;24 到2.2.2.0&#x2F;24的http流量</p>
<p>Access-list 100 deny tcp 1.1.1.0 0.0.0.255 2.2.2.0 0.0.0.255 eq（端口号） 80</p>
<p>命名访问控制列表（可以单独删除其中的一条规则）</p>
<p>示例：</p>
<p>Ip access-list standard name</p>
<p>Deny host 172.16.4.13</p>
<p>Permit 172.16.4.0 0.0.0.255</p>
<p>Interface e0</p>
<p>Ip access-group name ｛out | in｝</p>
<p>删除的时候可以直接no其中一条</p>
<p>Remark 注释  没有什么意义，只是简单的注释</p>
<p>可以通过 show access-list 查看</p>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-数据包发送流程及网络相关命令</title>
    <url>/2014/05/19/CCNA-%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B%E5%8F%8A%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>学习过程中的笔记，比较零散</p>
<span id="more"></span>

<p>同一个网段:</p>
<p>应用程序产生数据  传给IP层(判断是否处于同一个网段  封装)  二层MAC(封装   查本机的ARP表（MAC表) 没有的话,用ARP协议   （要有源MAC和目标MAC）)</p>
<p>主要就是封装和节封装的过程</p>
<p>封装进去的信息主要是源和目标的IP地址和MAC地址</p>
<p>处于不同的网段的时候   路由器先发送给网关   网关通过路由表进行比较转发 下同  只是源IP是网关的地址</p>
<p>Ping 命令</p>
<table>
<thead>
<tr>
<th>-t</th>
<th>持续ping目标主机直到接收到停止信号</th>
</tr>
</thead>
<tbody><tr>
<td>-a</td>
<td>将目标IP地址解析成主机名</td>
</tr>
<tr>
<td>-n</td>
<td>对目标主机的ping的次数</td>
</tr>
<tr>
<td>-l</td>
<td>ping包的大小</td>
</tr>
<tr>
<td>-f</td>
<td>设置IP包的DF位</td>
</tr>
</tbody></table>
<p>Nslookup</p>
<p>Ｔｒａｃｅｒｔ</p>
<table>
<thead>
<tr>
<th>-d</th>
<th>不进行IP到主机名的解析</th>
</tr>
</thead>
<tbody><tr>
<td>-h</td>
<td>搜索最大的跳数</td>
</tr>
<tr>
<td>-w</td>
<td>超时时间</td>
</tr>
</tbody></table>
<p>Route print</p>
<p>Route add</p>
<p>Route change</p>
<p>Route delete</p>
<p>Arp</p>
<table>
<thead>
<tr>
<th>－ｓ</th>
<th>绑定静态ARP</th>
</tr>
</thead>
<tbody><tr>
<td>－ｄ</td>
<td>删除ARP信息</td>
</tr>
<tr>
<td>-a</td>
<td>显示所有的ARP信息</td>
</tr>
</tbody></table>
<p>Ipconfig</p>
<table>
<thead>
<tr>
<th>&#x2F;all</th>
<th>显示所有适配器的TCP&#x2F;IP配置</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;renew</td>
<td>更新适配器的DHCP配置</td>
</tr>
<tr>
<td>&#x2F;release</td>
<td>更新DHCP租约期</td>
</tr>
<tr>
<td>&#x2F;displaydns</td>
<td>显示DNS缓存信息</td>
</tr>
</tbody></table>
<p>Netstat</p>
<table>
<thead>
<tr>
<th>－ａ</th>
<th>显示所有连接及监听端口</th>
</tr>
</thead>
<tbody><tr>
<td>－ｎ</td>
<td>不进行IP到主机名的解析</td>
</tr>
<tr>
<td>－ｐ</td>
<td>只显示指定的协议</td>
</tr>
<tr>
<td>－ｓ</td>
<td>显示每个协议的状态</td>
</tr>
<tr>
<td>－ｅ</td>
<td>显示以太网信息</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-静态路由和动态路由</title>
    <url>/2014/05/19/CCNA-%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<p>学习过程中的笔记，比较零散</p>
<span id="more"></span>

<h4 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h4><h5 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h5><ul>
<li><p>负责在不同网段之间进行数据转发(三层路由)</p>
</li>
<li><p>通过路由表进行三层数据转发(基于路由表)</p>
</li>
<li><p>维护路由表信息</p>
</li>
<li><p>在冗余路径中进行最优路径判断</p>
</li>
<li><p>在三层转发时应用特定的转发策略</p>
</li>
</ul>
<h5 id="静态路由-static-routes"><a href="#静态路由-static-routes" class="headerlink" title="静态路由 static routes"></a>静态路由 static routes</h5><ul>
<li><p>管理员手动输入</p>
</li>
<li><p>占用路由器资源小</p>
</li>
<li><p>可以严格控制路由转发</p>
</li>
<li><p>支持广泛</p>
</li>
<li><p>出现网络拓扑变动的时候无法自动更新</p>
</li>
<li><p>当网络很大的时候管理复杂</p>
</li>
</ul>
<h5 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h5><p>在全局配置模式下</p>
<p>Router(config)# Ip route network [mask]</p>
<p>(目标网络   子网掩码  下一跳出口)</p>
<p>跟下一跳出接口在一定条件下有备份作用,冗余.</p>
<p>缺省路由   0.0.0.0 0.0.0.0  </p>
<h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>当我们拥有到达目标网络的多个路径的时候,我们可以配置中间的路由器在这些路径上进行负载均衡</p>
<p>底层网络的负载均衡:</p>
<p>1、基于数据包</p>
<p>2、基于数据流</p>
<h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>路由协议用在不同路由器之间,用来判断到远程网络的路径并维护路由器的路由表</p>
<p>当路径决定之后,路由器会将被路由协议转发到目的网络</p>
<p>动态路由协议是运行在路由器上的一个程序,相同的动态路由协议通过在不同的路由器之间交换此动态路由协议规定的数据包来交换各自的路由信息,从而达到学习路由,维护路由表,发现拓扑变动的目的.</p>
<h4 id="动态路由协议分类"><a href="#动态路由协议分类" class="headerlink" title="动态路由协议分类"></a>动态路由协议分类</h4><h5 id="按应用范围分-IGP-amp-EGP-现在使用BGPv4"><a href="#按应用范围分-IGP-amp-EGP-现在使用BGPv4" class="headerlink" title="按应用范围分 IGP &amp; EGP(现在使用BGPv4)"></a>按应用范围分 IGP &amp; EGP(现在使用BGPv4)</h5><p>IGP（内部网关协议）应用于普通企业(在一个自治系统(as)之内路由)</p>
<p>EGP（外部网关协议）路由整个互联网(在多个自治系统（as）之间路由)</p>
<p>自治系统autonomous system是处在同一个管理范围的网络集合（管理范围比网络范围大）</p>
<p>as有个编号 0<del>65535    64512</del>65535是私有的，不能出现在公网中</p>
<h5 id="按算法分"><a href="#按算法分" class="headerlink" title="按算法分"></a>按算法分</h5><p>距离矢量型 distance vector（贝尔曼 福特）</p>
<p>高级距离矢量型  advanced distance vector（DUAL cisoc私有）</p>
<p>链路状态型link-state（SPF 最短路径优先）</p>
<h4 id="Classful-roting-有类别路由协议"><a href="#Classful-roting-有类别路由协议" class="headerlink" title="Classful roting  有类别路由协议"></a>Classful roting  有类别路由协议</h4><p>有类别路由选择协议在路由更新中不携带子网掩码</p>
<p>在一个网络中只能使用相同的子网掩码(不支持不连续的子网)</p>
<p>在主类网的边界会进行自动汇总</p>
<p>常见有类别路由协议</p>
<p>1 ripv1</p>
<p>2 IGRP</p>
<h5 id="有类别路由协议学习路由的规则"><a href="#有类别路由协议学习路由的规则" class="headerlink" title="有类别路由协议学习路由的规则"></a>有类别路由协议学习路由的规则</h5><p>有类别路由协议在更新时不携带子网掩码,在学习路由过程中:</p>
<p>1 首先判断接口接受的路由与接受接口配置的IP地址是否处于同一个主类网.</p>
<p>2如果处于同一个主类网,则使用接受接口配置的子网掩码做为接受路由的子网掩码</p>
<p>3如果接收路由与接收接口配置的IP地址不在同一个主类网中,则使用接收路由自身所属的主类网子网掩码作为该路由子网掩码(在主类网边界出现自动汇总)</p>
<h4 id="Classlessrouting-无类别路由协议"><a href="#Classlessrouting-无类别路由协议" class="headerlink" title="Classlessrouting 无类别路由协议"></a>Classlessrouting 无类别路由协议</h4><p>在路由更新中携带子网掩码(CIDR 无类别域间路由 classless Internet domain route)</p>
<p>支持VLSM,在同一个网络中可以拥有不同的子网掩码</p>
<p>在网络中支持手工汇总</p>
<p>常见的无类别路由选择协议</p>
<p>RIPv2  EIGRP  OSPF ISIS  BGPv4</p>
<p>RIPv2和EIGRP默认会在主类网边界进行自动汇总,需要手工关闭</p>
<h5 id="最佳路由判定标准"><a href="#最佳路由判定标准" class="headerlink" title="最佳路由判定标准"></a>最佳路由判定标准</h5><p>RIP  根据跳数（hop count）（经过几个路由器）</p>
<p>OSPF 根据带宽（cost）线路的速度</p>
<p>带宽 bandwidth</p>
<p>延时 delay</p>
<p>可靠性  reliable</p>
<p>负载 load</p>
<p>度量值不能变</p>
<p><img src="/image/ccna/Classlessrouting_ad.png" alt="geocoderSearch"></p>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ConstraintLayout</title>
    <url>/2018/08/09/ConstraintLayout/</url>
    <content><![CDATA[<p><a href="https://developer.android.google.cn/reference/android/support/constraint/ConstraintLayout">https://developer.android.google.cn/reference/android/support/constraint/ConstraintLayout</a><br>A ConstraintLayout is a ViewGroup which allows you to position and size widgets in a flexible way.</p>
<span id="more"></span>
<h3 id="版本支持"><a href="#版本支持" class="headerlink" title="版本支持"></a>版本支持</h3><p>ConstraintLayout是一个支持库，向前兼容到Android9，以后还会添加更多的新特性。现在公司的产品的最低版本支持都在2.3之上，部分产品最低版本支持保持在4.4之上。这就意味着我们不需要关心最低版本支持的事情。</p>
<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><p>在使用新特性的时候是不能有循环依赖的，比如相对定位，不能A依赖于B的位置，B依赖C的位置，而C又依赖A的位置</p>
<h4 id="Relative-positioning"><a href="#Relative-positioning" class="headerlink" title="Relative positioning"></a>Relative positioning</h4><p>相对定位是ConstraintLayout中最基本的构建方式，也就是一个空间相对于另外一个空间进行位置确定，可以在横向和竖向上进行约束：</p>
<blockquote>
<p>Horizontal Axis: left, right, start and end sides<br>  Vertical Axis: top, bottom sides and text baseline</p>
</blockquote>
<p>如果我们需要让ButtonB在ButtonA的右侧，如下图：<br><img src="/image/Android/ConstraintLayout/relative_positioning_example.png" alt="Relative Positioning Example"></p>
<p>在布局文件中只需要：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/buttonA&quot;</span> <span class="hljs-attr">...</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/buttonB&quot;</span> <span class="hljs-attr">...</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintLeft_toRightOf</span>=<span class="hljs-string">&quot;@+id/buttonA&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>这就告诉系统 让buttonB的左边约束于buttonA的右边<br>下面列出了所有可用的约束方式：</p>
<ul>
<li>layout_constraintLeft_toLeftOf</li>
<li>layout_constraintLeft_toRightOf</li>
<li>layout_constraintRight_toLeftOf</li>
<li>layout_constraintRight_toRightOf</li>
<li>layout_constraintTop_toTopOf</li>
<li>layout_constraintTop_toBottomOf</li>
<li>layout_constraintBottom_toTopOf</li>
<li>layout_constraintBottom_toBottomOf</li>
<li>layout_constraintBaseline_toBaselineOf</li>
<li>layout_constraintStart_toEndOf</li>
<li>layout_constraintStart_toStartOf</li>
<li>layout_constraintEnd_toStartOf</li>
<li>layout_constraintEnd_toEndOf</li>
</ul>
<p>各约束位置如下：<br><img src="/image/Android/ConstraintLayout/relative_position_constraint.png" alt="relative_position_constraint"><br>上面这些约束关系全部都是本身相对于另外一个控件(使用@id方式引用另外控件)或者父布局(使用parent方式引用父控件)进行约束</p>
<h4 id="Margins"><a href="#Margins" class="headerlink" title="Margins"></a>Margins</h4><p><img src="/image/Android/ConstraintLayout/relative_positioning_margins.png" alt="Relative Positioning Margins"><br>这里的外边距和其他布局方式的外边距一样，不能是负数，属性如下：</p>
<ul>
<li>android:layout_marginStart</li>
<li>android:layout_marginEnd</li>
<li>android:layout_marginLeft</li>
<li>android:layout_marginTop</li>
<li>android:layout_marginRight</li>
<li>android:layout_marginBottom</li>
</ul>
<p>添加的一个新属性是 <code>maiginGone</code>,当一个约束目标的可见性为GONE的时候(View.GONE)，可以改变当前控件的外边距，比如B是相对于A进行约束，当A不可见的时候，可以改变B的外边距，也就是B的外边距可以根据Ade可见性设置不同的值，属性如下</p>
<ul>
<li>layout_goneMarginStart</li>
<li>layout_goneMarginEnd</li>
<li>layout_goneMarginLeft</li>
<li>layout_goneMarginTop</li>
<li>layout_goneMarginRight</li>
<li>layout_goneMarginBottom</li>
</ul>
<h4 id="Centering-positioning-and-bias"><a href="#Centering-positioning-and-bias" class="headerlink" title="Centering positioning and bias"></a>Centering positioning and bias</h4><p>** Centering Positioning **<br>如果对一个控件的左右(上下)都添加的约束，那么ConstraintLayout的表现就像有两个大小相等方向相反的力在拉这个控件一个样，比如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.ConstraintLayout</span> <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button&quot;</span> <span class="hljs-attr">...</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent/&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag">&lt;/&gt;</span></span><br></code></pre></td></tr></table></figure>
<p>表现如下：<br><img src="/image/Android/ConstraintLayout/centering_positioning.png" alt="Centering Positioning"><br>这样就会产生居中效果，如果子控件和父控件的尺寸相同，这写属性就没有意义了</p>
<p>** bias **<br>当遇到上面这种约束的时候，我们可以使用<code>bias</code>属性让控件偏向于哪一个方向,属性如下：</p>
<ul>
<li>layout_constraintHorizontal_bias</li>
<li>layout_constraintVertical_bias<br>例如，如下代码：<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.ConstraintLayout</span> <span class="hljs-attr">...</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button&quot;</span> <span class="hljs-attr">...</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintHorizontal_bias</span>=<span class="hljs-string">&quot;0.3&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent/&gt;</span></span><br><span class="hljs-string"><span class="hljs-tag">&lt;/&gt;</span></span><br></code></pre></td></tr></table></figure>
表现如下：<br><img src="/image/Android/ConstraintLayout/centering_positioning_with_bias.png" alt="Centering Positioning with Bias"></li>
</ul>
<h4 id="Circular-positioning-Added-in-1-1"><a href="#Circular-positioning-Added-in-1-1" class="headerlink" title="Circular positioning (Added in 1.1)"></a>Circular positioning (Added in 1.1)</h4><p>这个属性是1.1版本添加进去的，可以使用<code>angle</code>和<code>distance</code>来约束一个控件的中心点和另外一个空间的中心点的位置关系，这样就可以把空间定位在一个圆上，可用属性如下：</p>
<ul>
<li>**layout_constraintCircle ** : references another widget id</li>
<li>**layout_constraintCircleRadius ** : the distance to the other widget center</li>
<li>**layout_constraintCircleAngle ** : which angle the widget should be at (in degrees, from 0 to 360)</li>
</ul>
<p>示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/buttonA&quot;</span> <span class="hljs-attr">...</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/buttonB&quot;</span> <span class="hljs-attr">...</span></span><br><span class="hljs-tag">      <span class="hljs-attr">app:layout_constraintCircle</span>=<span class="hljs-string">&quot;@+id/buttonA&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">app:layout_constraintCircleRadius</span>=<span class="hljs-string">&quot;100dp&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">app:layout_constraintCircleAngle</span>=<span class="hljs-string">&quot;45&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>表现如下：<br><img src="/image/Android/ConstraintLayout/circular_positioning.png" alt="Circular Positioning"></p>
<h4 id="Visibility-behavior"><a href="#Visibility-behavior" class="headerlink" title="Visibility behavior"></a>Visibility behavior</h4><p>ConstraintLayout对于被标记为GONE的控件有特殊的处理。一般布局中，GONE控件是不会展示在界面上并且不再属于布局的一部分，但是在布局计算上，ConstraintLayout和传统布局有很大的区别</p>
<ol>
<li>传统布局下，GONE控件会被认为大小是0，也就是一个点</li>
<li>在ConstraintLayout中其大小仍然按照可见大小计算，但是其外边距为0</li>
</ol>
<p><img src="/image/Android/ConstraintLayout/visibility_behavior.png" alt="Visibility Behavior"></p>
<h4 id="Dimension-constraints"><a href="#Dimension-constraints" class="headerlink" title="Dimension constraints"></a>Dimension constraints</h4><h5 id="Minimum-dimensions-on-ConstraintLayout"><a href="#Minimum-dimensions-on-ConstraintLayout" class="headerlink" title="Minimum dimensions on ConstraintLayout"></a>Minimum dimensions on ConstraintLayout</h5><p>可以像普通控件一样设置最小最大尺寸,属性如下：</p>
<ul>
<li>** android:minWidth ** set the minimum width for the layout</li>
<li>** android:minHeight ** set the minimum height for the layout</li>
<li>** android:maxWidth ** set the maximum width for the layout</li>
<li>** android:maxHeight ** set the maximum height for the layout</li>
</ul>
<p>这些属性当ConstraintLayout的宽高为<code>WRAP_CONTENT</code>时有效。</p>
<h5 id="Widgets-dimension-constraints"><a href="#Widgets-dimension-constraints" class="headerlink" title="Widgets dimension constraints"></a>Widgets dimension constraints</h5><p>可以通过<code>android:layout_width</code>和<code>android:layout_height</code>设置控件的尺寸，有三种方式：</p>
<ul>
<li>固定值</li>
<li>WRAP_CONTENT</li>
<li>0dp, 相当于<code>MATCH_CONSTRAINT</code></li>
</ul>
<p>前两种方式和普通布局表现出来的行为一样。最后一种会通过约束来重新设置控件尺寸，如果设置了margin，在布局计算的时候也会被考虑进去。<br> <img src="/image/Android/ConstraintLayout/dimension_constraints.png" alt="Dimension Constraints"><br>上图中的a是wrap_content,b是0dp，c是设置了margin的0dp。需要注意的是，在ConstraintLayout中，MATCH_PARENT是不推荐使用的。</p>
<h5 id="WRAP-CONTENT-enforcing-constraints-Added-in-1-1"><a href="#WRAP-CONTENT-enforcing-constraints-Added-in-1-1" class="headerlink" title="WRAP_CONTENT:enforcing constraints (Added in 1.1)"></a>WRAP_CONTENT:enforcing constraints (Added in 1.1)</h5><p>如果控件实际尺寸超过了约束的尺寸，那么约束就会失效，这时候可以添加如下属性来限制：</p>
<ul>
<li>app:layout_constrainedWidth&#x3D;”true|false”</li>
<li>app:layout_constrainedHeight&#x3D;”true|false”</li>
</ul>
<p>将B控件约束于A控件和父控件的中间，尺寸都为<code>wrap_content</code><br><img src="/image/Android/ConstraintLayout/wrap_content_enforcing_constraints1.png" alt="enforcing constraints"><br>这时候如果将B控件填充很长的文件，那么B控件的左侧则会突破约束，和A控件的中心对齐，如果我们不想要这种方式，还是要求B的左侧和Ade右侧对齐，则可以天剑<br><code>layout_constrainedWidth=&quot;true&quot;</code>属性进行约束，实例如下：<br><img src="/image/Android/ConstraintLayout/wrap_content_enforcing_constraints2.png" alt="约束失效"><br><img src="/image/Android/ConstraintLayout/wrap_content_enforcing_constraints3.png" alt="添加强制约束属性"></p>
<h5 id="MATCH-CONSTRAINT-dimensions-Added-in-1-1"><a href="#MATCH-CONSTRAINT-dimensions-Added-in-1-1" class="headerlink" title="MATCH_CONSTRAINT dimensions (Added in 1.1)"></a>MATCH_CONSTRAINT dimensions (Added in 1.1)</h5><p>当控件的尺寸被设置为<code>MATCH_CONSTRAINT</code>时，默认的行为是占据所有的剩余空间，可以使用如下属性来更改此行为：</p>
<ul>
<li>** layout_constraintWidth_min ** 和 ** layout_constraintHeight_min ** : will set the minimum size for this dimension</li>
<li>** layout_constraintWidth_max ** 和 ** layout_constraintHeight_max ** : will set the maximum size for this dimension</li>
<li>** layout_constraintWidth_percent ** 和 ** layout_constraintHeight_percent ** : will set the size of this dimension as a percentage of the parent</li>
</ul>
<h5 id="Percent-dimension"><a href="#Percent-dimension" class="headerlink" title="Percent dimension"></a>Percent dimension</h5><p>To use percent, you need to set the following:<br>想要使用百分比布局，需要设置如下属性：</p>
<ol>
<li>控件宽高设置为 <code>MATCH_CONSTRAINT</code> (0dp)</li>
<li><code>app:layout_constraintWidth_default</code>属性值设置为<code>percent</code> </li>
<li>设置 <code>layout_constraintWidth_percent</code>或者<code>layout_constraintHeight_percent</code>属性值(0-1之间)</li>
</ol>
<p>下面的TextView控件将占据剩余宽度的50%和剩余高度的50%,示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/textView6&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/colorAccent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintHeight_default</span>=<span class="hljs-string">&quot;percent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintHeight_percent</span>=<span class="hljs-string">&quot;0.5&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintWidth_default</span>=<span class="hljs-string">&quot;percent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintWidth_percent</span>=<span class="hljs-string">&quot;0.5&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<h5 id="Ratio"><a href="#Ratio" class="headerlink" title="Ratio"></a>Ratio</h5><p>可以设置控件的宽高比例，为了实现这种方式，需要让控件的宽或者高设置为0dp(MATCH_CONSTRAINT)，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintDimensionRatio</span>=<span class="hljs-string">&quot;1:1&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>这样的话，高度会随着宽度的改变而改变，并且大小和宽度一致。设置宽高比的方式有两种：</p>
<ol>
<li>一个浮点数，<code>受约束的一方的尺寸/另一方尺寸</code>得到的数字</li>
<li>宽度:高度</li>
</ol>
<p>如果宽高两个方向同时设置了0dp(MATCH_CONSTRAINT)，系统会设置满足比例的最大尺寸，这种情况下还要保持宽高比例，需要在比例前面添加W或者H以确定受约束的是高还是宽。</p>
<blockquote>
<p>You can also use ratio if both dimensions are set to MATCH_CONSTRAINT (0dp). In this case the system sets the largest dimensions the satisfies all constraints and maintains the    aspect ratio specified. To constrain one specific side based on the dimensions of another, you can pre append W,” or H, to constrain the width or height respectively. For          example, If one dimension is constrained by two targets (e.g. width is 0dp and centered on parent) you can indicate which side should be constrained, by adding the letter W (for   constraining the width) or H (for constraining the height) in front of the ratio, separated by a comma:<br>  <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintDimensionRatio</span>=<span class="hljs-string">&quot;H,16:9&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><br>will set the height of the button following a 16:9 ratio, while the width of the button will match the constraints to parent.</p>
</blockquote>
<h4 id="Chains"><a href="#Chains" class="headerlink" title="Chains"></a>Chains</h4><p>Chains 在单轴（水平或垂直）上提供类似组的行为。另一个轴可以独立地约束。</p>
<h5 id="Creating-a-chain"><a href="#Creating-a-chain" class="headerlink" title="Creating a chain"></a>Creating a chain</h5><p>如果一组小部件通过双向连接链接在一起，则它们被视为链（参见下图，显示最小链，具有两个小部件）。<br><img src="/image/Android/ConstraintLayout/chain.png" alt="chain"></p>
<h5 id="Chain-heads"><a href="#Chain-heads" class="headerlink" title="Chain heads"></a>Chain heads</h5><p>横向上，Chain头部是Chain最左边的控件；纵向上，Chain头部是Chain最顶部的控件。<br><img src="/image/Android/ConstraintLayout/chain_head.png" alt="chain head"></p>
<h5 id="Margins-in-chains"><a href="#Margins-in-chains" class="headerlink" title="Margins in chains"></a>Margins in chains</h5><p>如果连接时定义了外边距，Chain就会发生变化。在SPREAD CHAIN中，外边距会从已经分配好的空间中去掉。原文如下：</p>
<blockquote>
<p>If margins are specified on connections, they will be taken in account. In the case of spread chains, margins will be deducted from the allocated space.</p>
</blockquote>
<h5 id="Chain-Style"><a href="#Chain-Style" class="headerlink" title="Chain Style"></a>Chain Style</h5><p>当对Chain的第一个元素设置layout_constraintHorizontal_chainStyle或layout_constraintVertical_chainStyle属性，Chain就会根据特定的样式（默认样式为CHAIN_SPREAD）进行相应变化，样式类型如下：</p>
<ul>
<li>CHAIN_SPREAD – 元素呗分散开 (默认样式) </li>
<li>Weighted chain – 在 CHAIN_SPREAD mo样式中,如果某些控件设置了<code>MATCH_CONSTRAINT</code>属性, 他们将平分剩余空间 </li>
<li>CHAIN_SPREAD_INSIDE – Chain的头尾元素紧贴父容器</li>
<li>CHAIN_PACKED – Chain中的所有控件合并在一起后在剩余的空间中居中</li>
</ul>
<p>图示如下：<br><img src="/image/Android/ConstraintLayout/chain_styles.png" alt="chain styles"></p>
<h5 id="Weighted-chains"><a href="#Weighted-chains" class="headerlink" title="Weighted chains"></a>Weighted chains</h5><p>默认的Chain会在空间里平均散开。如果其中有一个或多个元素使用了MATCH_CONSTRAINT属性，那么他们会将剩余的空间平均填满。属性layout_constraintHorizontal_height和layout_constraintVertical_weight控制使用MATCH_CONSTRAINT的元素如何均分空间。 例如，一个Chain中包含两个使用MATCH_CONSTRAINT的元素，第一个元素使用的权重为2，第二个元素使用的权重为1，那么被第一个元素占用的空间是第二个元素的2倍。</p>
<h5 id="Margins-and-chains-in-1-1"><a href="#Margins-and-chains-in-1-1" class="headerlink" title="Margins and chains (in 1.1)"></a>Margins and chains (in 1.1)</h5><p>在chain中是可以使用margin属性的，例如，在一个水平的chain中，一个元素定义了right_magin&#x3D;10dp,下一个元素定义了margin_left&#x3D;5dp，那么两者之间的间距就是15dp.</p>
<h4 id="Virtual-Helpers-objects"><a href="#Virtual-Helpers-objects" class="headerlink" title="Virtual Helpers objects"></a>Virtual Helpers objects</h4><h5 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h5><p><code>Guideline</code>是只能用在<code>ConstraintLayout</code>布局里面的一个工具类，用于辅助布局，类似为辅助线，可以设置<code>android:orientation</code>属性来确定是横向的还是纵向的。 </p>
<ul>
<li>当设置为vertical的时候，Guideline的宽度为0，高度是parent也就是ConstraintLayout的高度 </li>
<li>同样设置为horizontal的时候，高度为0，宽度是parent的宽度</li>
</ul>
<p>定位Guideline有三种方式，这三种方式只能选择一个</p>
<ul>
<li>指定距离左侧或顶部的固定距离（layout_constraintGuide_begin） </li>
<li>指定距离右侧或底部的固定距离（layout_constraintGuide_end） </li>
<li>指定在父控件中的宽度或高度的百分比（layout_constraintGuide_percent）</li>
</ul>
<p>示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.Guideline</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/vertical_guideline&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintGuide_percent</span>=<span class="hljs-string">&quot;0.5&quot;</span> /&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.Guideline</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/horizontal_guideline&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintGuide_percent</span>=<span class="hljs-string">&quot;0.5&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>声明了一个垂直居中，一个水平居中的GuideLine，效果如下，这两个控件在View上是不可见的。<br><img src="/image/Android/ConstraintLayout/guideLine_declaration.png" alt="guideline declaration"></p>
<p>接着就可以根据这两条辅助线来定位其他控件了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;top_left&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/top_left_button&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;@id/horizontal_guideline&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintRight_toLeftOf</span>=<span class="hljs-string">&quot;@id/vertical_guideline&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;top_right&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/top_right_button&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;@id/horizontal_guideline&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;@id/vertical_guideline&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;bottom_right&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/bottom_right_button&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;@id/vertical_guideline&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;@id/horizontal_guideline&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;bottom_left&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/bottom_left_button&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;@id/vertical_guideline&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;@id/horizontal_guideline&quot;</span> /&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>效果如下：<br><img src="/image/Android/ConstraintLayout/guideline_relative.png" alt="guideline_relative"></p>
<h5 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h5><p>Barrier可以引用多个控件，根据他们之中最大的宽高来创建一个虚拟的guideline，<br>假设我们有两个按钮，<code>@id/button1</code>和<code>@id/button2</code>,让Barrier的constraint_referenced_ids属性引用这两个id，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.Barrier</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/barrier&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:barrierDirection</span>=<span class="hljs-string">&quot;end&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:constraint_referenced_ids</span>=<span class="hljs-string">&quot;button1,button2&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>示例如下：<br><img src="/image/Android/ConstraintLayout/barrier1.png" alt="barrier"><br>图中蓝色的线就是<code>Barrier</code>，<code>Barrier</code>所在问的方位由<code>barrierDirection</code>确定，可以设置为<code>start</code>,<code>end</code>,<code>top</code>,<code>bottom</code>,<code>right</code>,<code>left</code><br>这时候我们改变一个两个按钮的宽度，让button2的宽度小于button1，则效果如下：<br><img src="/image/Android/ConstraintLayout/barrier2.png" alt="barrier"><br>这样我们就可以把其他控件约束于barrier的右侧，使得button1和button2不会覆盖(被覆盖)其他控件</p>
<h5 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h5><p>Group可以包含多个对其他控件的引用，这样我们操作这个group就相当于操作引用的控件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.Group</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;gone&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/button_group&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:constraint_referenced_ids</span>=<span class="hljs-string">&quot;login,register,modify_password&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>
<p>像上面这样，只要操作Group的<code>visibility</code>属性，就相当于同时操作<code>@id/login</code>,<code>@id/register</code>,<code>@id/modify_password</code>这三个控件的<code>visibility</code>属性。</p>
<h5 id="Placeholders"><a href="#Placeholders" class="headerlink" title="Placeholders"></a>Placeholders</h5><p>顾名思义就是一个用来占位的东西，对于样式相同，功能不同的界面，可以把样式做成style或者使用PlaceHolders来做：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">merge</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:layout_editor_absoluteX</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;81dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:parentTag</span>=<span class="hljs-string">&quot;android.support.constraint.ConstraintLayout&quot;</span>&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.Placeholder</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/template_main_image&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:content</span>=<span class="hljs-string">&quot;@+id/top_image&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintDimensionRatio</span>=<span class="hljs-string">&quot;16:9&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.Placeholder</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/template_save&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:content</span>=<span class="hljs-string">&quot;@+id/save&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@+id/template_delete&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintHorizontal_bias</span>=<span class="hljs-string">&quot;0.5&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toStartOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;460dp&quot;</span> /&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.Placeholder</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/template_delete&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:content</span>=<span class="hljs-string">&quot;@+id/delete&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@+id/template_cancel&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintHorizontal_bias</span>=<span class="hljs-string">&quot;0.5&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@+id/template_save&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;460dp&quot;</span> /&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.Placeholder</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/template_cancel&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:content</span>=<span class="hljs-string">&quot;@+id/cancel&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toStartOf</span>=<span class="hljs-string">&quot;@+id/template_edit&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintHorizontal_bias</span>=<span class="hljs-string">&quot;0.5&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@+id/template_delete&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;460dp&quot;</span> /&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.Placeholder</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/template_edit&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:content</span>=<span class="hljs-string">&quot;@+id/edit&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintEnd_toEndOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintHorizontal_bias</span>=<span class="hljs-string">&quot;0.5&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintStart_toEndOf</span>=<span class="hljs-string">&quot;@+id/template_cancel&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:layout_editor_absoluteY</span>=<span class="hljs-string">&quot;460dp&quot;</span> /&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">merge</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>如果想要在预览界面看起来像是在ConstraintLayout里面的话就加上<code>tools:parentTag=&quot;android.support.constraint.ConstraintLayout&quot;</code><br>预览如下：<br><img src="/image/Android/ConstraintLayout/constraint_layout_placeholder_preview.png" alt="constraintLayout placeholder preview"><br>在上面的布局文件中，每一个Placeholder都添加了<code>app:content</code>属性，表示要用这个属性指定的id对应的控件来替换<code>Placeholder</code>，<br>在其他布局文件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.ConstraintLayout</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/root&quot;</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/constraint_layout_placeholder&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/main_title_image&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/main_title_image&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span> /&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/save&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:srcCompat</span>=<span class="hljs-string">&quot;@drawable/ic_save_black_24dp&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/edit&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:srcCompat</span>=<span class="hljs-string">&quot;@drawable/ic_edit_black_24dp&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/cancel&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">app:srcCompat</span>=<span class="hljs-string">&quot;@drawable/ic_cancel_black_24dp&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageButton</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/delete&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;16dp&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">app:srcCompat</span>=<span class="hljs-string">&quot;@drawable/ic_delete_black_24dp&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.constraint.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>首先使用<code>include</code>标签将模板包含进来，然后创建其他需要替换的控件：<br><img src="/image/Android/ConstraintLayout/merge_constraint_layout_placeholder_preview.png" alt="merge constraintLayout placeholder preview"><br>当然也可以在代码中调用<code>Placeholder.setContent(id)</code>动态替换，配合<code>CoordinatorLayout</code>可以做出比较好玩的动画效果：<br><img src="/image/Android/ConstraintLayout/constraintLayout_placeholderand_CoordinatorLayout.gif" alt="constraintLayout placeholder + CoordinatorLayout"><br>代码在这里<br><a href="https://github.com/Thumar/Placeholder">https://github.com/Thumar/Placeholder</a></p>
<p><code>ConstraintLayout</code> 1.1版本之后的东西常用的差不多就这些了</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Coordinatorlayout</title>
    <url>/2018/08/20/Coordinatorlayout/</url>
    <content><![CDATA[<p>上图的动画其实挺简单的，如果你知道的话，就不要继续往下看了，那是在浪费时间。</p>
<span id="more"></span>
<p>主要用的前几年推出的几个support包，可惜国内没有流行起来。</p>
<p>简单直接放代码：<br>gradle依赖：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">implementation <span class="hljs-string">&#x27;com.android.support:appcompat-v7:28.0.0-rc01&#x27;</span><br>implementation <span class="hljs-string">&#x27;com.android.support.constraint:constraint-layout:1.1.2&#x27;</span><br>implementation <span class="hljs-string">&#x27;com.android.support:design:28.0.0-rc01&#x27;</span><br></code></pre></td></tr></table></figure>

<p>布局文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.CoordinatorLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:fitsSystemWindows</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.AppBarLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;160dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:fitsSystemWindows</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:theme</span>=<span class="hljs-string">&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.CollapsingToolbarLayout</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/collapsingToolbarLayout&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:fitsSystemWindows</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:collapsedTitleTextAppearance</span>=<span class="hljs-string">&quot;@style/TextAppearance.AppCompat.Title&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:contentScrim</span>=<span class="hljs-string">&quot;?attr/colorPrimaryDark&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:expandedTitleMarginStart</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:expandedTitleTextAppearance</span>=<span class="hljs-string">&quot;@style/TextAppearance.AppCompat.Title&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:layout_scrollFlags</span>=<span class="hljs-string">&quot;scroll|exitUntilCollapsed&quot;</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:fitsSystemWindows</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;fitXY&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:src</span>=<span class="hljs-string">&quot;@drawable/title_bg&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">app:layout_collapseMode</span>=<span class="hljs-string">&quot;parallax&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">app:layout_collapseParallaxMultiplier</span>=<span class="hljs-string">&quot;0.5&quot;</span> /&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.Toolbar</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/toolbar&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;?attr/actionBarSize&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">android.support.design.widget.CollapsingToolbarLayout</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">android.support.design.widget.AppBarLayout</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.RecyclerView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/recyclerview&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">&quot;@string/appbar_scrolling_view_behavior&quot;</span> /&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.design.widget.CoordinatorLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>activity代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-type">Toolbar</span> <span class="hljs-variable">toolbar</span> <span class="hljs-operator">=</span> findViewById(R.id.toolbar);<br>        setSupportActionBar(toolbar);<br><br>        <span class="hljs-type">CollapsingToolbarLayout</span> <span class="hljs-variable">collapsingToolbarLayout</span> <span class="hljs-operator">=</span> findViewById(R.id.collapsingToolbarLayout);<br>        collapsingToolbarLayout.setTitle(<span class="hljs-string">&quot;Test CoordinatorLayout&quot;</span>);<br>        collapsingToolbarLayout.setContentScrimColor(Color.GRAY);<br>        collapsingToolbarLayout.setCollapsedTitleTextColor(ContextCompat.getColor(<span class="hljs-built_in">this</span>,R.color.colorAccent));<br>        collapsingToolbarLayout.setExpandedTitleColor(Color.WHITE);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span> ;i ++)&#123;<br>            data.add(<span class="hljs-string">&quot;item -- &gt;&quot;</span> + i);<br>        &#125;<br>        <span class="hljs-type">RecyclerView</span> <span class="hljs-variable">recyclerView</span> <span class="hljs-operator">=</span> findViewById(R.id.recyclerview);<br><br>        <span class="hljs-type">LinearLayoutManager</span> <span class="hljs-variable">linearLayoutManager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearLayoutManager</span>(MainActivity.<span class="hljs-built_in">this</span>);<br>        linearLayoutManager.setOrientation(LinearLayoutManager.VERTICAL);<br>        recyclerView.setLayoutManager(linearLayoutManager);<br>        <span class="hljs-type">RecyclerViewAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecyclerViewAdapter</span>();<br>        recyclerView.setAdapter(adapter);<br>    &#125;<br><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecyclerViewAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecyclerView</span>.Adapter&lt;RecyclerViewAdapter.ViewHolder&gt;&#123;<br><br><br>        <span class="hljs-meta">@NonNull</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> ViewHolder <span class="hljs-title function_">onCreateViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup viewGroup, <span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> LayoutInflater.from(MainActivity.<span class="hljs-built_in">this</span>).inflate(android.R.layout.simple_list_item_1,viewGroup,<span class="hljs-literal">false</span>);<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewHolder</span>(view);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBindViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewHolder viewHolder, <span class="hljs-type">int</span> i)</span> &#123;<br><br>            viewHolder.textView.setText(data.get(i));<br>            viewHolder.textView.setTextColor(ContextCompat.getColor(MainActivity.<span class="hljs-built_in">this</span>,R.color.colorAccent));<br><br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getItemCount</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> data.size();<br>        &#125;<br><br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecyclerView</span>.ViewHolder&#123;<br><br>            TextView textView;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-title function_">ViewHolder</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View itemView)</span> &#123;<br>                <span class="hljs-built_in">super</span>(itemView);<br>                textView = itemView.findViewById(android.R.id.text1);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>不想多写什么了，可以自己去搜这些东西的用法。傲娇脸<del>_</del></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter BLoC 简单使用</title>
    <url>/2019/05/08/Flutter-BLoC-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Flutter的设计灵感部分来自于React，主要是数据与视图分离，由数据来驱动视图的渲染。而对于我们在实际工程中的应用，就目前状态来讲，只是用来做UI，并没有用Flutter来做多少业务逻辑，涉及到的逻辑也不过是界面之间的数据、状态传递等。但并不排除将来会将重心稍微往Flutter侧偏移。</p>
<p>目前使用StatefulWidget完全可以适应目前的需求。但是需要考虑到后续扩展，需要找一种能够解决状态同步问题的方案。在了解了几种方案后确定使用BLoC。</p>
<p><a href="https://juejin.im/post/5bac54c45188255c681589d3">https://juejin.im/post/5bac54c45188255c681589d3</a></p>
<p><a href="https://www.jianshu.com/p/e7e1bced6890">https://www.jianshu.com/p/e7e1bced6890</a></p>
<p><a href="https://www.jianshu.com/p/7573dee97dbb">https://www.jianshu.com/p/7573dee97dbb</a></p>
<span id="more"></span>

<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>Stream看起来和rx家族东西东西很像，我们可以通过<strong>StreamController</strong>的<strong>sink</strong>传输一些数据，然后监听<strong>StreamSubscription</strong>流来感知数据，甚至可以通过<strong>StreamTransformer</strong>对数据流进行操作。当然也可以通过Flutter提供的<strong>StreamBuilder</strong>来构建Widget，</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Center(<br>        child: StreamBuilder&lt;<span class="hljs-built_in">int</span>&gt;(<br>            stream: bloc.stream,<br>            initialData: bloc.value,<br>            builder: (BuildContext context, AsyncSnapshot&lt;<span class="hljs-built_in">int</span>&gt; snapshot) &#123;<br>              <span class="hljs-keyword">return</span> Text(<br>                <span class="hljs-string">&#x27;You hit me: <span class="hljs-subst">$&#123;snapshot.data&#125;</span> times&#x27;</span>,<br>                style: Theme.of(context).textTheme.display1,<br>              );<br>            &#125;),<br>      )<br></code></pre></td></tr></table></figure>

<p>这里的snapshot则是通过sink传输过来的数据，然后显示在Text控件中。</p>
<p>一个简单的Stream演示</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:async&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  StreamController streamController = StreamController();<br><br>  StreamSubscription subscription =<br>      streamController.stream.listen((event)&#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$event</span>&quot;</span>);<br>      &#125;);<br>  <br>  subscription.onData((data) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--&gt;<span class="hljs-subst">$data</span>&quot;</span>);<br>  &#125;);<br>  subscription.onDone(() =&gt; &#123;<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;on done&quot;</span>)&#125;);<br><br>  streamController.sink.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>  streamController.sink.add(<span class="hljs-string">&quot;123&quot;</span>);<br>  streamController.sink.add(<span class="hljs-string">&quot;def&quot;</span>);<br><br>  streamController.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们会得到这样一个输出：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">--&gt;abc<br>--&gt;123<br>--&gt;def<br>on done<br></code></pre></td></tr></table></figure>

<p>当然如果我们没有再次重写<code>subscription.onData</code>方法，则会执行<code>print(&quot;$event&quot;);</code>方法。</p>
<p><strong>Stream</strong>有两种类型：<strong>单订阅Stream和广播Stream</strong>。单订阅Stream只允许在该Stream的整个生命周期内使用单个监听器，即使第一个subscription被取消了，你也没法在这个流上监听到第二次事件；而广播Stream允许任意个数的subscription，你可以随时随地给它添加subscription，只要新的监听开始工作流，它就能收到新的事件。</p>
<h4 id="简化版的demo"><a href="#简化版的demo" class="headerlink" title="简化版的demo"></a>简化版的demo</h4><p>官方的计数器demo的简化版。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountBLoC</span>  </span>&#123;<br>  <span class="hljs-built_in">int</span> _count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">final</span> _controller = StreamController&lt;<span class="hljs-built_in">int</span>&gt;();<br>  Stream&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">get</span> stream =&gt; _controller.stream;<br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> value =&gt; _count;<br>  increment() &#123;<br>    _controller.sink.add(++_count);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> bloc = CountBLoC();<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&#x27;Top Page&#x27;</span>),<br>      ),<br>      body: Center(<br>        child: StreamBuilder&lt;<span class="hljs-built_in">int</span>&gt;(<br>            stream: bloc.stream,<br>            initialData: bloc.value,<br>            builder: (BuildContext context, AsyncSnapshot&lt;<span class="hljs-built_in">int</span>&gt; snapshot) &#123;<br>              <span class="hljs-keyword">return</span> Text(<br>                <span class="hljs-string">&#x27;You hit me: <span class="hljs-subst">$&#123;snapshot.data&#125;</span> times&#x27;</span>,<br>                style: Theme.of(context).textTheme.display1,<br>              );<br>            &#125;),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () =&gt; bloc.increment(),<br>        child: Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>首先我们定义了一个BLoC类，在里面声明了一个<strong>StreamController</strong>和一个<code>increment()</code>方法，当我们调用increment()方法的时候，则会将计数加1，然后丢到sink里面，这样我们在任何监听<code>streamController.stream</code>的地方都将会收到这个数据，然后进行之后的工作，在上面的代码中，监听者是<code>StreamBuilder</code>,当有数据流入的时候，它会进行UI重绘，将数据显示到控件上。</li>
<li>我们在点击按钮的时候，调用了<code>bloc.increment()</code>方法，产生了数据流。</li>
</ol>
<p>这很像mvp模式中的P层的作用，业务逻辑处理都在这里面进行，然后通知UI重绘，当然这只是一个很粗糙的样例。</p>
<h4 id="关于Bloc的可访问性"><a href="#关于Bloc的可访问性" class="headerlink" title="关于Bloc的可访问性"></a>关于Bloc的可访问性</h4><p>以上的功能都是基于BLoC进行的，所以BLoC的可访问性需要得到保证</p>
<ol>
<li><p><strong>全局单例（global Singleton）</strong>：这种方式很简单，但是不推荐，因为Dart中对类没有析构函数（destructor）的概念，因此资源永远无法释放。</p>
</li>
<li><p><strong>局部变量（local instance）</strong>：你可以创建一个Bloc局部实例，在某些情况下可以完美解决问题。但是美中不足的是，你需要在StatefulWidget中初始化，并记得在<code>dispose()</code>中释放它。</p>
</li>
<li><p><strong>由祖先（ancestor）来提供</strong>：这也是最常见的一种方法，通过一个实现了StatefulWidget的父控件来获取访问权。</p>
</li>
</ol>
<p>在大佬写的项目中有这种实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 所有 BLoCs 的通用接口</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlocBase</span> </span>&#123;<br>  <span class="hljs-keyword">void</span> dispose();<br>&#125;<br><br><span class="hljs-comment">// 通用 BLoC provider</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlocProvider</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BlocBase</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  BlocProvider(&#123;<br>    Key key,<br>    <span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.child,<br>    <span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.bloc,<br>  &#125;): <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-keyword">final</span> T bloc;<br>  <span class="hljs-keyword">final</span> Widget child;<br><br>  <span class="hljs-meta">@override</span><br>  _BlocProviderState&lt;T&gt; createState() =&gt; _BlocProviderState&lt;T&gt;();<br><br>  <span class="hljs-keyword">static</span> T of&lt;T <span class="hljs-keyword">extends</span> BlocBase&gt;(BuildContext context)&#123;<br>    <span class="hljs-keyword">final</span> type = _typeOf&lt;BlocProvider&lt;T&gt;&gt;();<br>    BlocProvider&lt;T&gt; provider = context.ancestorWidgetOfExactType(type);<br>    <span class="hljs-keyword">return</span> provider.bloc;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-built_in">Type</span> _typeOf&lt;T&gt;() =&gt; T;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_BlocProviderState</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">BlocProvider</span>&lt;<span class="hljs-title">BlocBase</span>&gt;&gt;</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose()&#123;<br>    widget.bloc.dispose();<br>    <span class="hljs-keyword">super</span>.dispose();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context)&#123;<br>    <span class="hljs-keyword">return</span> widget.child;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们使用的时候，</p>
<ol>
<li><p>自己定义处理逻辑的BLoC继承BLoCBase(这是为了能释放掉Stream资源)</p>
</li>
<li><p>之前我们定义了一个界面叫Joke，使用的时候直接用<code>new Joke()</code>就好了，现在我们需要</p>
</li>
<li><p>&#96;&#96;&#96;dart<br>BLoCProvider<JokeBLoC>(<br>  bloc: JokeBLoC(),<br>  child: Joke(),<br>)</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey"><br>当然为了能够使用BLoC,需要对Joke进行改造，改造之后是`JokeWithBLoC`,于是就成了这样<br><br>``` dart<br>BLoCProvider&lt;JokeBLoC&gt;(<br><span class="hljs-title">  bloc:</span> JokeBLoC(),<br><span class="hljs-title">  child:</span> JokeWithBLoC(),<br>)<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JokeBLoC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BLoCBase</span></span>&#123;<br><br>  <span class="hljs-comment">//处理数据返回</span><br>  StreamController&lt;<span class="hljs-built_in">List</span>&lt;JokeBean&gt;&gt; _resultController = StreamController.broadcast();<br>  Stream&lt;<span class="hljs-built_in">List</span>&lt;JokeBean&gt;&gt; <span class="hljs-keyword">get</span> outResultList =&gt; _resultController.stream;<br> <br>  <span class="hljs-comment">//处理刷新和加载更多</span><br>  StreamController&lt;<span class="hljs-built_in">bool</span>&gt; _indexController = StreamController&lt;<span class="hljs-built_in">bool</span>&gt;.broadcast();<br>  Sink&lt;<span class="hljs-built_in">bool</span>&gt; <span class="hljs-keyword">get</span> inJokesIndex =&gt; _indexController.sink;<br><br>  <span class="hljs-comment">//保存数据</span><br>  <span class="hljs-built_in">List</span>&lt;JokeBean&gt; datas = [];<br>  <span class="hljs-keyword">var</span> pageNumber = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//构造函数，开始监听分页信息，因为在JokeWithBLoC创建的时候就添加了数据</span><br>  NewsBLoC() &#123;<br>    _indexController.stream.listen(_handleIndex);<br>    <span class="hljs-comment">//错误处理</span><br>    _resultController.addError(<br>            (error) =&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;_jokeResultController error-&gt;<span class="hljs-subst">$&#123;error.toString()&#125;</span>&quot;</span>));<br>    _indexController.addError(<br>            (error) =&gt; <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;_jokeIndexController error-&gt;<span class="hljs-subst">$&#123;error.toString()&#125;</span>&quot;</span>));<br>  &#125;<br><br><span class="hljs-comment">//加载数据</span><br>  <span class="hljs-keyword">void</span> _handleIndex(<span class="hljs-built_in">bool</span> isLoadMore) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">if</span> (isLoadMore) &#123;<br>      pageNumber++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      pageNumber = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">String</span> dataUrl =<br>        <span class="hljs-string">&quot;https://i.jandan.net/?oxwlxojflwblxbsapi=jandan.get_duan_comments&amp;page=<span class="hljs-subst">$pageNumber</span>&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      Response&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&gt; response = <span class="hljs-keyword">await</span> Dio().<span class="hljs-keyword">get</span>(dataUrl);<br>      <span class="hljs-keyword">if</span> (response.statusCode == <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-keyword">var</span> jokeModel = JokeModel.fromJson(response.data);<br>          <span class="hljs-keyword">if</span>(isLoadMore)&#123;<br>            datas.addAll(jokeModel.comments);<br>          &#125;<span class="hljs-keyword">else</span>&#123;<br>            datas = jokeModel.comments;<br>          &#125;<br>        <span class="hljs-comment">//数据返回后添加到流中，这样JokeWithBLoC中StreamBuild会被调用</span><br>          _resultController.add(datas);<br><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>       showError();<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-built_in">print</span>(e.toString());<br>    &#125;<br>  &#125;<br>    <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-comment">//在这里关闭流</span><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JokeWithBLoC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  JokeBLoC jokeBLoC;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">//获取到BLoC</span><br>    jokeBLoC = BLoCProvider.of&lt;JokeBLoC&gt;(context);<br>    ScrollController _scrollController = <span class="hljs-keyword">new</span> ScrollController();<br>    _scrollController.addListener(() &#123;<br>      <span class="hljs-keyword">if</span> (_scrollController.position.pixels ==<br>          _scrollController.position.maxScrollExtent) &#123;<br>        <span class="hljs-comment">//滑动监听，通知BLoC加载下一页</span><br>        jokeBLoC.inJokesIndex.add(<span class="hljs-keyword">true</span>);<br>      &#125;<br>    &#125;);<br>    <span class="hljs-comment">//页面创建时，开始加载数据</span><br>    jokeBLoC.inJokesIndex.add(<span class="hljs-keyword">false</span>);<br><br>    <span class="hljs-keyword">return</span> RefreshIndicator(<br>      onRefresh: () =&gt; refresh(),<br>      child: StreamBuilder&lt;<span class="hljs-built_in">List</span>&lt;JokeBean&gt;&gt;(<br>        <span class="hljs-comment">//监听JokeBLoC中的加载数据的流信息</span><br>          stream: jokeBLoC.outResultList,<br>          builder:<br>              (BuildContext context, AsyncSnapshot&lt;<span class="hljs-built_in">List</span>&lt;JokeBean&gt;&gt; snapshot) &#123;<br>                <span class="hljs-comment">//当数据是空的时候，显示加载动画，这里有点问题：当请求出错时没有进行处理，会一直显示动画</span><br>            <span class="hljs-keyword">if</span> (snapshot.data == <span class="hljs-keyword">null</span> || snapshot.data.isEmpty) &#123;<br>              <span class="hljs-keyword">return</span> SpinKitWave(<br>                  color: Colors.redAccent, type: SpinKitWaveType.start);<br>            &#125;<br>						<span class="hljs-comment">//构建列表</span><br>            <span class="hljs-keyword">return</span> ListView.builder(<br>                controller: _scrollController,<br>                itemCount: snapshot.data == <span class="hljs-keyword">null</span> ? <span class="hljs-number">1</span> : snapshot.data.length + <span class="hljs-number">1</span>,<br>                itemBuilder: (BuildContext context, <span class="hljs-built_in">int</span> position) &#123;<br>                  <span class="hljs-keyword">return</span> _getRow(context, snapshot.data, position);<br>                &#125;);<br>          &#125;),<br>    );<br>  &#125;<br><br>  Future&lt;<span class="hljs-keyword">void</span>&gt; refresh() <span class="hljs-keyword">async</span> &#123;<br>    jokeBLoC.inJokesIndex.add(<span class="hljs-keyword">false</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>这是一个大佬写的<a href="https://github.com/boeledi/Streams-Block-Reactive-Programming-in-Flutter">https://github.com/boeledi/Streams-Block-Reactive-Programming-in-Flutter</a></p>
<p>想要跑起来需要自己去申请一个key，具体看<code>tmdb_api.dart</code></p>
<p>这是我写的 <a href="https://github.com/huangyuanlove/JanDan_flutter">https://github.com/huangyuanlove/JanDan_flutter</a></p>
<p><strong>不要过度设计你的代码</strong></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>CCNA-网络拓扑结构</title>
    <url>/2014/05/19/CCNA-%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>学习过程中的笔记，比较零散</p>
<span id="more"></span>

<p>在设计网络的时候用到qos</p>
<p>在哪些方面评估网络</p>
<p>1 速度 （speed）（路由器借口速度和包转发速度（PPs packet per second））</p>
<p>2开销 （cost）（钱的多少）</p>
<p>3安全 （security）（普通网络路由就行）</p>
<p>4有效性性 （availability）（要求故障时间短（如证券交易））</p>
<p>5可扩展性（scalability）（公司的扩展）</p>
<p>6  可靠性（reliable）</p>
<p>7拓扑结构（topology）（双线备份等）</p>
<p>（总线型  BUS Topology）</p>
<p>（星形 star topology）</p>
<p>（扩展星形）</p>
<p>环形（令牌环网  ring topology）</p>
<p>全网互联（每个交换机相连）（高成本）</p>
<p>部分互联</p>
<p>批量式应用程序（batch application）</p>
<p>类似于文件共享和下载</p>
<p>如FTP  TFTP </p>
<p>流量大，对延时和丢包不敏感</p>
<p>TCP协议可以重传输</p>
<p>交互式Interactive application</p>
<p>流量小 对延时敏感</p>
<p>如QQ聊天 ssh  mstsc</p>
<p>实时应用程序（real-time application）</p>
<p>对延时和丢包敏感</p>
<p>没有重传输</p>
<p>如 通话和视频（超过150MS  可以感受出来）</p>
<p>UDP协议</p>
]]></content>
      <tags>
        <tag>CCNA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter InheritedWidget和Notification</title>
    <url>/2019/07/08/Flutter-InheritedWidget%E5%92%8CNotification/</url>
    <content><![CDATA[<p>InheritedWidget是Flutter中非常重要的一个功能型Widget，它可以高效的将数据在Widget树中向下传递(只能向下传递，无法向上传递，如果需要向上传递可以使用Notification)、共享，这在一些需要在Widget树中共享数据的场景中非常方便，如Flutter中，正是通过InheritedWidget来共享应用主题(Theme)和Locale(当前语言环境)信息的。这里建议阅读以下<code>theme.dart</code>的源码</p>
<span id="more"></span>

<p>现在有一需求，从A界面打开B界面，在B界面对数据进行修改，返回A界面的时候，A界面显示的数据也是修改之后的。</p>
<p>两种方式：第一种我们可以在B界面修改数据之后做持久化存储，或者修改的数据做成全局静态字段，返回A界面后由A界面刷新</p>
<p>第二种就是使用InheritedWidget进行数据共享实现。</p>
<h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><h4 id="创建数据model和共享Widget"><a href="#创建数据model和共享Widget" class="headerlink" title="创建数据model和共享Widget"></a>创建数据model和共享Widget</h4><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritedTestModel</span> </span>&#123;<br>  <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-built_in">int</span> age;<br>  <span class="hljs-built_in">String</span> sex;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="继承InheritedWidget来共享数据"><a href="#继承InheritedWidget来共享数据" class="headerlink" title="继承InheritedWidget来共享数据"></a>继承InheritedWidget来共享数据</h4><p>这里我们需要继承<code>InheritedWidget</code>，并且声明一个静态方法，用来从BuildContext中获取共享数据。</p>
<p>还需要重写updateShouldNotify方法，如果返回true，则子树中依赖(build函数中有调用)本widget的子widget的<code>state.didChangeDependencies</code>会被调用。</p>
<p>下面是详细代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritedModelContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">InheritedWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> InheritedTestModel model;<br><br>  InheritedModelContext(&#123;Key key, <span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.model, <span class="hljs-meta">@required</span> Widget child&#125;)<br>      : <span class="hljs-keyword">super</span>(key: key, child: child);<br><br>  <span class="hljs-keyword">static</span> InheritedModelContext of(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> context.inheritFromWidgetOfExactType(InheritedModelContext);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">bool</span> updateShouldNotify(InheritedModelContext oldWidget) &#123;<br>    <span class="hljs-keyword">return</span> model.age != oldWidget.model.age ||<br>        model.name != oldWidget.model.name ||<br>        model.sex != oldWidget.model.sex;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个约定俗成的 <code>of</code>方法用来让子树获取到共享数据。至于为什么可以获取的数据，</p>
<blockquote>
<p>在 <code>Element</code> 的内部有一个 <code>Map&lt;Type, InheritedElement&gt; _inheritedWidgets;</code> 参数，**_inheritedWidgets 一般情况下是空的，只有当父控件是 InheritedWidget 或者本身是 InheritedWidgets 时，它才会有被初始化，而当父控件是 InheritedWidget  时，这个 Map 会被一级一级往下传递与合并。**</p>
<p>所以当我们通过 <code>context</code> 调用 <code>inheritFromWidgetOfExactType</code> 时，就可以通过这个 <code>Map</code>  往上查找，从而找到这个上级的 <code>InheritedWidget</code> 。</p>
<p>作者：恋猫de小郭链接：<a href="https://juejin.im/post/5d0634c7f265da1b91639232%E6%9D%A5%E6%BA%90%EF%BC%9A%E6%8E%98%E9%87%91%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://juejin.im/post/5d0634c7f265da1b91639232来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>
</blockquote>
<h4 id="在A界面创建数据，并共享到下一个界面"><a href="#在A界面创建数据，并共享到下一个界面" class="headerlink" title="在A界面创建数据，并共享到下一个界面"></a>在A界面创建数据，并共享到下一个界面</h4><p>我们首先在界面A创建一个共享的数据model，显示在界面上，然后通过上面定义的<code>InheritedModelContext</code>共享给下一个界面：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritedWidgetTestRouteState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">InheritedWidgetTestRoute</span>&gt; </span>&#123;<br>  InheritedTestModel model;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    model = <span class="hljs-keyword">new</span> InheritedTestModel();<br>    model.age = <span class="hljs-number">10</span>;<br>    model.name = <span class="hljs-string">&quot;abc&quot;</span>;<br>    model.sex = <span class="hljs-string">&quot;f&quot;</span>;<br>    <span class="hljs-keyword">super</span>.initState();<br>  &#125;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;InheritedWidget&quot;</span>),<br>      ),<br>      body: Center(<br>        child: Column(<br>          children: &lt;Widget&gt;[<br>            Text(<span class="hljs-string">&quot;age: <span class="hljs-subst">$&#123;model.age&#125;</span>&quot;</span>),<br>            Text(<span class="hljs-string">&quot;name: <span class="hljs-subst">$&#123;model.name&#125;</span>&quot;</span>),<br>            Text(<span class="hljs-string">&quot;sex: <span class="hljs-subst">$&#123;model.sex&#125;</span>&quot;</span>),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () &#123;<br>          Navigator.of(context).push(MaterialPageRoute(builder: (context)&#123;<br>          <span class="hljs-keyword">return</span>  InheritedModelContext(<br>            model: model,<br>            child: InheritedSecondPage(),<br>          );<br>          &#125;));<br>        &#125;,<br>        child: Icon(Icons.navigate_next),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="在B界面获取共享数据，并作出修改"><a href="#在B界面获取共享数据，并作出修改" class="headerlink" title="在B界面获取共享数据，并作出修改"></a>在B界面获取共享数据，并作出修改</h4><p>我们在B界面获取到共享数据并展示出来，通过点击按钮，改变共享数据的值，当我们返回上一个界面的时候会发现上个界面的显示也被改变了</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritedSecondPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">InheritedSecondPage</span>&gt; </span>&#123;<br>  InheritedModelContext modelContext;<br>  InheritedTestModel model;<br><br>  <span class="hljs-built_in">String</span> name = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-built_in">int</span> age = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">String</span> sex = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    modelContext = InheritedModelContext.of(context);<br>    model = modelContext.model;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;第二页&quot;</span>),<br>      ),<br>      body: Center(<br>        child: Column(<br>          children: &lt;Widget&gt;[<br>            Text(<span class="hljs-string">&quot;age: <span class="hljs-subst">$&#123;model.age&#125;</span>&quot;</span>),<br>            Text(<span class="hljs-string">&quot;name: <span class="hljs-subst">$&#123;model.name&#125;</span>&quot;</span>),<br>            Text(<span class="hljs-string">&quot;sex: <span class="hljs-subst">$&#123;model.sex&#125;</span>&quot;</span>),<br>            Column(<br>              children: &lt;Widget&gt;[<br>                FlatButton(<br>                  onPressed: () &#123;<br>                    setState(() &#123;<br>                      model.name = <span class="hljs-built_in">DateTime</span>.now().toLocal().toString();<br>                    &#125;);<br>                  &#125;,<br>                  child: Text(<span class="hljs-string">&quot;改变Name&quot;</span>),<br>                ),<br>                FlatButton(<br>                  onPressed: () &#123;<br>                    setState(() &#123;<br>                      model.age = <span class="hljs-built_in">DateTime</span>.now().millisecondsSinceEpoch;<br>                    &#125;);<br>                  &#125;,<br>                  child: Text(<span class="hljs-string">&quot;改变Age&quot;</span>),<br>                ),<br>                FlatButton(<br>                  onPressed: () &#123;<br>                    setState(() &#123;<br>                      model.sex = <span class="hljs-built_in">DateTime</span>.now().toString();<br>                    &#125;);<br>                  &#125;,<br>                  child: Text(<span class="hljs-string">&quot;改变sex&quot;</span>),<br>                ),<br>              ],<br>            ),<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><blockquote>
<p>Notification是Flutter中一个重要的机制，在Widget树中，每一个节点都可以分发通知，通知会沿着当前节点（context）向上传递，所有父节点都可以通过NotificationListener来监听通知，Flutter中称这种通知由子向父的传递为“通知冒泡”（Notification Bubbling），这个和用户触摸事件冒泡是相似的，但有一点不同：通知冒泡可以中止，但用户触摸事件不行。</p>
<p>源自  ：<a href="https://book.flutterchina.club/chapter8/notification.html">https://book.flutterchina.club/chapter8/notification.html</a></p>
</blockquote>
<h4 id="创建Model、InheritedWidget和上面一致"><a href="#创建Model、InheritedWidget和上面一致" class="headerlink" title="创建Model、InheritedWidget和上面一致"></a>创建Model、InheritedWidget和上面一致</h4><h4 id="定义Notification"><a href="#定义Notification" class="headerlink" title="定义Notification"></a>定义Notification</h4><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyNotification</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Notification</span></span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> msg;<br>  MyNotification(<span class="hljs-keyword">this</span>.msg);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="定义两个Widget，放在同一个界面中"><a href="#定义两个Widget，放在同一个界面中" class="headerlink" title="定义两个Widget，放在同一个界面中"></a>定义两个Widget，放在同一个界面中</h4><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() &#123;<br>    <span class="hljs-keyword">return</span> WidgetAState();<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetAState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">WidgetA</span>&gt; </span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br><br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> InheritedContext inheritedContext = InheritedContext.of(context);<br>    <span class="hljs-keyword">final</span> SinglePageModel model = inheritedContext.model;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;WidgetA build&quot;</span>);<br>    <span class="hljs-keyword">return</span> Center(<br>      child: Column(<br>        children: &lt;Widget&gt;[<br>          Text(<span class="hljs-string">&quot;当前页<span class="hljs-subst">$&#123;model.page&#125;</span>&quot;</span>),<br>          Text(<span class="hljs-string">&quot;内容：<span class="hljs-subst">$&#123;model.content&#125;</span>&quot;</span>),<br>          FlatButton(<br>            onPressed: () &#123;<br>              <span class="hljs-keyword">if</span>(model.page==<span class="hljs-keyword">null</span>)&#123;<br>                model.page = <span class="hljs-number">1</span>;<br>              &#125;<span class="hljs-keyword">else</span> &#123;<br>                model.page += <span class="hljs-number">1</span>;<br>              &#125;<br>              MyNotification(<span class="hljs-string">&quot;refresh&quot;</span>).dispatch(context);<br>              setState(() &#123;<br><br>              &#125;);<br><br><br>            &#125;,<br>            child: Icon(Icons.add),<br>          ),<br>          FlatButton(<br>            onPressed: () &#123;<br>              model.content = <span class="hljs-built_in">DateTime</span>.now().toLocal().toString();<br>              <span class="hljs-comment">//发送通知</span><br>              MyNotification(<span class="hljs-string">&quot;refresh&quot;</span>).dispatch(context);<br>              setState(() &#123;<br><br>              &#125;);<br>            &#125;,<br>            child: Text(<span class="hljs-string">&quot;改变content&quot;</span>),<br>          ),<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="创建界面并且监听自定义的通知"><a href="#创建界面并且监听自定义的通知" class="headerlink" title="创建界面并且监听自定义的通知"></a>创建界面并且监听自定义的通知</h4><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritedWidgetInSinglePage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() &#123;<br>    <span class="hljs-keyword">return</span> InheritedWidgetInSinglePageState();<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritedWidgetInSinglePageState</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">InheritedWidgetInSinglePage</span>&gt; </span>&#123;<br>  SinglePageModel model = SinglePageModel();<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;同一页面共享数据&quot;</span>),<br>      ),<br>      body: NotificationListener&lt;MyNotification&gt;(<br>      <span class="hljs-comment">//监听通知</span><br>        onNotification: (notification) &#123;<br>          setState(() &#123;&#125;);<br>        &#125;,<br>        child: InheritedContext(<br>          model: model,<br>          child: Column(<br>            children: &lt;Widget&gt;[<br>              Text(<span class="hljs-string">&quot;page:<span class="hljs-subst">$&#123;model.page&#125;</span>&quot;</span>),<br>              Text(<span class="hljs-string">&quot;content:<span class="hljs-subst">$&#123;model.content&#125;</span>&quot;</span>),<br>              FlatButton(<br>                onPressed: () &#123;<br>                  <span class="hljs-keyword">if</span> (model.page == <span class="hljs-keyword">null</span>) &#123;<br>                    model.page = <span class="hljs-number">1</span>;<br>                  &#125; <span class="hljs-keyword">else</span> &#123;<br>                    model.page += <span class="hljs-number">1</span>;<br>                  &#125;<br>                  setState(() &#123;&#125;);<br>                &#125;,<br>                child: Icon(Icons.add),<br>              ),<br>              WidgetA(),<br>              WidgetB(),<br>            ],<br>          ),<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () &#123;<br>          Navigator.of(context).push(MaterialPageRoute(builder: (context) &#123;<br>            <span class="hljs-keyword">return</span> InheritedContext(<br>              model: model,<br>              child: SecondPageWidget(),<br>            );<br>          &#125;));<br>        &#125;,<br>        child: Icon(Icons.navigate_next),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的<code>SecondPageWidget</code>和上面提到的B界面差不多，都是获取到共享数据后展示，点击按钮做出改变。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter中的provider</title>
    <url>/2019/07/01/Flutter%E4%B8%AD%E7%9A%84provider/</url>
    <content><![CDATA[<p>作为一个状态共享的解决方案，<strong>不复杂，好理解，代码量不大的情况下，可以方便组合和控制刷新颗粒度</strong> ， 而原 Google 官方仓库的状态管理 <a href="https://link.juejin.im/?target=https://github.com/google/flutter-provide">flutter-provide</a> 已宣告GG ， <a href="https://link.juejin.im/?target=https://github.com/rrousselGit/provider">provider</a> 成了它的替代品。和<code>scoped_moded</code>比起来，入侵性比较小，也适合比较复杂的应用场景。</p>
<p>具体的代码在 <a href="https://github.com/huangyuanlove/test_flutter/tree/master/lib/provider">https://github.com/huangyuanlove/test_flutter/tree/master/lib/provider</a> </p>
<span id="more"></span>

<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在pubspec.yaml中添加provider镜像：具体版本号可以在<code>https://pub.dev/packages/provider#-installing-tab-</code>查看</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br><br>  <span class="hljs-comment"># The following adds the Cupertino Icons font to your application.</span><br>  <span class="hljs-comment"># Use with the CupertinoIcons class for iOS style icons.</span><br>  <span class="hljs-attr">cupertino_icons:</span> <span class="hljs-string">^0.1.2</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">^3.0.0+1</span><br><span class="hljs-attr">dev_dependencies:</span><br>  <span class="hljs-attr">flutter_test:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br></code></pre></td></tr></table></figure>

<h4 id="创建数据model"><a href="#创建数据model" class="headerlink" title="创建数据model"></a>创建数据model</h4><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterModel</span> <span class="hljs-title">with</span> <span class="hljs-title">ChangeNotifier</span></span>&#123;<br>  <span class="hljs-built_in">int</span> _count = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> value =&gt; _count;<br><br>  <span class="hljs-keyword">void</span> increment()&#123;<br>    _count ++;<br>    notifyListeners();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里使用了 mixin 混入了 <code>ChangeNotifier</code>，这个类能够帮驻我们自动管理所有听众。当调用<code>notifyListeners()</code> 时，它会通知所有听众进行刷新。</p>
<p>为了能更加直观的看到每个widget的build过程，做个包装的widget，不是依靠<code>debugPrintLayouts = true;</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestTextWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;<br><br>  TestTextWidget(&#123;<span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.logTag,<span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.child&#125;);<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> logTag;<br>  <span class="hljs-keyword">final</span> Widget child;<br><br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-built_in">print</span>(logTag);<br>    <span class="hljs-keyword">return</span> child;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在每次build的时候打印一下日志,并且在源码的<code>text.dart</code>中的build方法打印了一下内容<code>print(&quot;Text build:$&#123;data&#125;&quot;);</code></p>
<h4 id="如何传递、共享数据"><a href="#如何传递、共享数据" class="headerlink" title="如何传递、共享数据"></a>如何传递、共享数据</h4><h5 id="向子节点传递数据"><a href="#向子节点传递数据" class="headerlink" title="向子节点传递数据"></a>向子节点传递数据</h5><p>我们在主页中加个按钮，点击后进入计数界面</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:provider/provider.dart&#x27;</span>;<br>FlatButton(<br>              child: Text(<span class="hljs-string">&quot;TestProvider&quot;</span>),<br>              onPressed: () &#123;<br>                <span class="hljs-keyword">final</span> counter = CounterModel();<br>                <span class="hljs-keyword">final</span> textSize = <span class="hljs-number">48</span>;<br>                Navigator.push(context, MaterialPageRoute(builder: (context) &#123;<br>                  <span class="hljs-keyword">return</span> Provider&lt;<span class="hljs-built_in">int</span>&gt;.value(<br>                    value: textSize,<br>                    child: ChangeNotifierProvider.value(<br>                      value: counter,<br>                      child: CounterFirstScreen(),<br>                    ),<br>                  );<br>                &#125;)).then((onValue) &#123;<br>                  <span class="hljs-built_in">print</span>(onValue);<br>                &#125;);<br>              &#125;,<br>            ),<br></code></pre></td></tr></table></figure>

<p>这里我们向子节点传递了两个值：<code>textSize</code>和<code>counter</code>，对于需求来讲，<code>textSize</code>是固定不变的，可以通过<code>Provider&lt;T&gt;.value</code>来传入，而<code>counter</code>是我们需要多个界面共享的数据(某个界面改变其中的字段，其他界面也需要跟着改变)。使用<code>ChangeNotifierProvider&lt;T&gt;.value</code>来传入和共享，</p>
<ul>
<li>1、 <strong>Provider</strong>  的内部 <code>DelegateWidget</code> 是一个 <code>StatefulWidget</code> ，所以可以更新且具有生命周期。</li>
<li>2、状态共享是使用了 <code>InheritedProvider</code> 这个 <code>InheritedWidget</code> 实现的。</li>
<li>3、巧妙利用 <code>MultiProvider</code> 和 <code>Consumer</code> 封装，实现了组合与刷新颗粒度控制。</li>
</ul>
<p>具体可以看 <a href="https://juejin.im/post/5d0634c7f265da1b91639232">https://juejin.im/post/5d0634c7f265da1b91639232</a></p>
<p>和 <a href="https://juejin.im/post/5d00a84fe51d455a2f22023f">https://juejin.im/post/5d00a84fe51d455a2f22023f</a></p>
<h4 id="在子节点中获取数据"><a href="#在子节点中获取数据" class="headerlink" title="在子节点中获取数据"></a>在子节点中获取数据</h4><p>我们在<code>CounterFirstScreen</code>的build方法中获取上个界面传进来的值，并且在界面上以不同的方式显示出来</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterFirstScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">final</span> _counter = Provider.of&lt;CounterModel&gt;(context);<br>    <span class="hljs-keyword">final</span> _textSize = Provider.of&lt;<span class="hljs-built_in">int</span>&gt;((context)).toDouble();<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;first screen rebuild&#x27;</span>);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&#x27;FirstPage&#x27;</span>),<br>      ),<br>      body: Center(<br>        child: Column(<br>          mainAxisSize: MainAxisSize.max,<br>          children: &lt;Widget&gt;[<br>            TestTextWidget(<br>              logTag: <span class="hljs-string">&quot;first page text counter&quot;</span>,<br><br>              child: Text(<br>                <span class="hljs-string">&#x27;Value: <span class="hljs-subst">$&#123;_counter.value&#125;</span>&#x27;</span>,<br>                style: TextStyle(fontSize: _textSize),<br>              ),<br>            ),<br>            TestTextWidget(<br>              logTag: <span class="hljs-string">&quot;first page text fix&quot;</span>,<br><br>              child: Text(<br>                <span class="hljs-string">&quot;固定文本，不需要重绘&quot;</span><br>              ),<br>            ),<br>          ],<br>        ),<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () =&gt; &#123;<br>              Navigator.of(context).push(MaterialPageRoute(builder: (context) &#123;<br><span class="hljs-comment">//                return Provider&lt;int&gt;.value(</span><br><span class="hljs-comment">//                  value: _textSize.toInt(),</span><br><span class="hljs-comment">//                  child: ChangeNotifierProvider.value(</span><br><span class="hljs-comment">//                    value: _counter,</span><br><span class="hljs-comment">//                    child: Provider&lt;Color&gt;.value(</span><br><span class="hljs-comment">//                      value: Colors.red.shade50,</span><br><span class="hljs-comment">//                      child: SecondPage(),</span><br><span class="hljs-comment">//                    ),</span><br><span class="hljs-comment">//                  ),</span><br><span class="hljs-comment">//                );</span><br>              <span class="hljs-keyword">return</span> MultiProvider(<br>                providers: [<br>                  Provider&lt;<span class="hljs-built_in">int</span>&gt;.value(value: _textSize.toInt()),<br>                  ChangeNotifierProvider.value(value: _counter),<br>                  Provider.value(value: Colors.red.shade50),<br><br>                ],<br>                child: SecondPage(),<br>              );<br>              &#125;))<br>            &#125;,<br><br>        child: Icon(Icons.navigate_next),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在build中我们通过<code>Provider.of&lt;T&gt;(context);</code>来获取顶层数据，这里泛型T指定了获取距离该界面最近的存储了T的祖先节点的数据。这里强烈建议在传入和获取值时加上泛型，经测试，传入相同类型的值，后面的回覆盖前面的。</p>
<p>当我们点击floatingActionButton的时候进入第二个界面，这里传入的数据比较多，可以通过MultiProvider或者嵌套Provider来做，在或者，把要传入的值封装成一个model来传入。在我们的业务上来看，并没有什么固定值需要以Provider的方式来传递，可以通过构造方法。</p>
<h5 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h5><p>我们在第二个界面中使用Consumer来获取共享数据，来达到控制局部刷新的目的。</p>
<p>我们需要在第二个界面中使用上一个界面中传过来的字体大小、文字内容、文字颜色。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Consumer&lt;<span class="hljs-built_in">int</span>&gt;(<br>              builder: (context, <span class="hljs-built_in">int</span> textSize, _) &#123;<br>                <span class="hljs-keyword">return</span> TestTextWidget(<br>                  logTag: <span class="hljs-string">&quot;secondPage.Consumer&lt;int&gt;&quot;</span>,<br>                  child: Text(<br>                    <span class="hljs-string">&quot;textSize <span class="hljs-subst">$&#123;textSize + <span class="hljs-number">5</span>&#125;</span>&quot;</span>,<br>                    style: TextStyle(fontSize: (textSize + <span class="hljs-number">5</span>).toDouble()),<br>                  ),<br>                );<br>              &#125;,<br>            ),<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Consumer3&lt;CounterModel, <span class="hljs-built_in">int</span>, Color&gt;(<br>              builder: (context, CounterModel counter, <span class="hljs-built_in">int</span> textSize,<br>                  Color color, _) &#123;<br>                <span class="hljs-keyword">return</span> TestTextWidget(<br>                  logTag: <span class="hljs-string">&quot;SecondPage Consumer3&lt;CounterModel, int, Color&gt;&quot;</span>,<br>                  child: Text(<br>                    <span class="hljs-string">&#x27;Value:<span class="hljs-subst">$&#123;counter.value&#125;</span>&#x27;</span>,<br>                    style:<br>                        TextStyle(fontSize: textSize.toDouble(), color: color),<br>                  ),<br>                );<br>              &#125;,<br>            ),<br></code></pre></td></tr></table></figure>

<p>Consumer 使用了 <a href="https://link.juejin.im/?target=https://en.wikipedia.org/wiki/Builder_pattern"><strong>Builder</strong></a> 模式，收到更新通知就会通过 builder 重新构建。<code>Consumer&lt;T&gt;</code> 代表了它要获取祖先中的哪种Model。</p>
<p>从源码中可以看出，作者帮我们做到了 Consumer6。。。。。。并且还能看出来，Consumer中就是使用Provider实现的，它的经典之处在于能够在复杂项目中，<strong>极大地缩小你的控件刷新范围</strong>。<code>Provider.of&lt;T&gt;(context)</code> 将会把调用了该方法的 context 作为听众，并在 <code>notifyListeners</code> 的时候通知其刷新。</p>
<p>我们上面也提到了在Text的build方法中加了日志，当我们进入第一页的时候，控制台输出：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">I/flutter (<span class="hljs-number">26320</span>): first screen rebuild                                 <br>I/flutter (<span class="hljs-number">26320</span>): tag:第一个界面中显示计数的TestTextWidget             <br>I/flutter (<span class="hljs-number">26320</span>): Text build:Value: <span class="hljs-number">0</span>                                  <br>I/flutter (<span class="hljs-number">26320</span>): tag:第一个界面中固定的文本                           <br>I/flutter (<span class="hljs-number">26320</span>): Text build:固定文本，不需要重绘                      <br>I/flutter (<span class="hljs-number">26320</span>): Text build:FirstPage  <br></code></pre></td></tr></table></figure>

<p>进入第二个界面的时候：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">I/flutter (<span class="hljs-number">26320</span>): second screen rebuild<br>I/flutter (<span class="hljs-number">26320</span>): SecondPage Consumer3&lt;CounterModel, <span class="hljs-keyword">int</span>, Color&gt;<br>I/flutter (<span class="hljs-number">26320</span>): Text build:Value:<span class="hljs-number">0</span><br>I/flutter (<span class="hljs-number">26320</span>): secondPage<span class="hljs-variable">.Consumer</span>&lt;<span class="hljs-keyword">int</span>&gt;<br>I/flutter (<span class="hljs-number">26320</span>): Text build:textSize <span class="hljs-number">53</span><br>I/flutter (<span class="hljs-number">26320</span>): tag:第二个界面中固定不变的TestTextWidget<br>I/flutter (<span class="hljs-number">26320</span>): Text build:第二个界面的固定文本 TestTextWidget<span class="hljs-variable">.child</span><br>I/flutter (<span class="hljs-number">26320</span>): Text build:SecondPage fix text<br>I/flutter (<span class="hljs-number">26320</span>): Text build:Second Page<br>I/flutter (<span class="hljs-number">26320</span>): first screen rebuild<br>I/flutter (<span class="hljs-number">26320</span>): tag:第一个界面中显示计数的TestTextWidget<br>I/flutter (<span class="hljs-number">26320</span>): Text build:Value: <span class="hljs-number">0</span><br>I/flutter (<span class="hljs-number">26320</span>): tag:第一个界面中固定的文本<br>I/flutter (<span class="hljs-number">26320</span>): Text build:固定文本，不需要重绘<br>I/flutter (<span class="hljs-number">26320</span>): Text build:FirstPage<br></code></pre></td></tr></table></figure>

<p>在第二个界面点击加号的时候</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><br>I/flutter (<span class="hljs-number">26320</span>): first screen rebuild<br>I/flutter (<span class="hljs-number">26320</span>): tag:第一个界面中显示计数的TestTextWidget<br>I/flutter (<span class="hljs-number">26320</span>): Text build:Value: <span class="hljs-number">1</span><br>I/flutter (<span class="hljs-number">26320</span>): tag:第一个界面中固定的文本<br>I/flutter (<span class="hljs-number">26320</span>): Text build:固定文本，不需要重绘<br>I/flutter (<span class="hljs-number">26320</span>): Text build:FirstPage<br>I/flutter (<span class="hljs-number">26320</span>): SecondPage Consumer3&lt;CounterModel, <span class="hljs-keyword">int</span>, Color&gt;<br>I/flutter (<span class="hljs-number">26320</span>): Text build:Value:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>再次点击加号</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog">I/flutter (<span class="hljs-number">26320</span>): first screen rebuild<br>I/flutter (<span class="hljs-number">26320</span>): tag:第一个界面中显示计数的TestTextWidget<br>I/flutter (<span class="hljs-number">26320</span>): Text build:Value: <span class="hljs-number">2</span><br>I/flutter (<span class="hljs-number">26320</span>): tag:第一个界面中固定的文本<br>I/flutter (<span class="hljs-number">26320</span>): Text build:固定文本，不需要重绘<br>I/flutter (<span class="hljs-number">26320</span>): Text build:FirstPage<br>I/flutter (<span class="hljs-number">26320</span>): SecondPage Consumer3&lt;CounterModel, <span class="hljs-keyword">int</span>, Color&gt;<br>I/flutter (<span class="hljs-number">26320</span>): Text build:Value:<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>可以看出来，第一个界面是全部重建可一次，而在第二个界面中，只有监听了CountModel的Text重建了。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter异常处理</title>
    <url>/2020/07/27/Flutter%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>Flutter异常和Java异常类似，都是代码运行时发生的错误事件，我们可以通过与Java类似的try-catch机制来捕获这个异常，和java不同的地方在于 Dart 采用事件循环的机制来运行任务，各个任务的运行状态是互相独立的，也就是说，即便某个任务出现了异常我们没有捕获它，Dart 程序也不会退出，只会导致当前任务后续的代码不会被执行，用户仍可以继续使用其他功能。</p>
<span id="more"></span>

<p>dart中的异常分为App异常和Framework异常，根据来源不同，捕获方式也不同。App异常我们可以通过try–catch或者异步调用中的catchError捕获；Framework中的异常可以通过自定义ErrorWidget.builder进行捕获+展示</p>
<h3 id="App异常的捕获方式"><a href="#App异常的捕获方式" class="headerlink" title="App异常的捕获方式"></a>App异常的捕获方式</h3><p>App异常，就是应用代码的异常，通常由未处理应用层其他模块所抛出的异常引起。根据异常代码的执行时序，App异常可以分为两类，即同步异常和异步异常:同步异常可以通过try-catch机制捕获，异步异常则需要采用Future 提供的catchError语句捕获。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//异常捕获</span><br><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-keyword">throw</span> StateError(<span class="hljs-string">&quot;this is a dart exception&quot;</span>);<br><br>&#125;<span class="hljs-keyword">catch</span> (e)&#123;<br>  <span class="hljs-built_in">print</span>(e);<br>&#125;<br><br><br>Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>))<br>.then((value) =&gt; <span class="hljs-keyword">throw</span> StateError(<span class="hljs-string">&quot;this is a dart exception in future&quot;</span>) )<br>.catchError((e)=&gt;<span class="hljs-built_in">print</span>(e));<br><br><br><span class="hljs-comment">//无法捕获</span><br><span class="hljs-keyword">try</span>&#123;<br>  Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>))<br>      .then((value) =&gt; <span class="hljs-keyword">throw</span> StateError(<span class="hljs-string">&quot;this is a dart exception in future by try catch&quot;</span>) );<br>&#125;<span class="hljs-keyword">catch</span>(e)&#123;<br>  <span class="hljs-built_in">print</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，这两种方式是不能混用的。无法使用try- -catch去捕获一个异步调用所抛出的异常的。如果我们想集中管理代码中的所有异常，Flutter 也提供了Zone.runZoned 方法。我们可以给代码执行对象指定一-个Zone，在Dart中，Zone表示一个代码执行的环境范围，其概念类似沙盒，不同沙盒之间是互相隔离的。如果我们想要观察沙盒中代码执行出现的异常，沙盒提供了onError回调函数，拦截那些在代码执行对象中的未捕获异常。<br>在下面的代码中，我们将可能抛出异常的语句放置在了Zone里。可以看到，在没有使用try-catch和catchError的情况下，无论是同步异常还是异步异常，都可以通过Zone直接捕获到:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//runZoned</span><br>runZoned(() &#123;<br>  <span class="hljs-keyword">throw</span> StateError(<span class="hljs-string">&quot;this is a dart exception in future&quot;</span>);<br>  <br>&#125;, onError: (<span class="hljs-built_in">dynamic</span> e, StackTrace stack) &#123;<br>  <span class="hljs-built_in">print</span>(e);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;catch exception by zone&quot;</span>);<br>&#125;);<br><br><br>runZoned(() &#123;<br>  Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>))<br>      .then((value) =&gt;<br>  <span class="hljs-keyword">throw</span> StateError(<span class="hljs-string">&quot;this is a dart exception in future by try catch&quot;</span>));<br>&#125;, onError: (<span class="hljs-built_in">dynamic</span> e, StackTrace stack) &#123;<br>  <span class="hljs-built_in">print</span>(e);<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;catch future exception by zone&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>



<h2 id="Framework-异常捕获"><a href="#Framework-异常捕获" class="headerlink" title="Framework 异常捕获"></a>Framework 异常捕获</h2><p>Framework异常，就是Flutter框架引发的异常，通常是由应用代码触发了Flutter 框架底层的异常判断引起的。比如，当布局错误时(具体一点就是Text控件的构造方法传入null)，Flutter 就会自动展示一个包含错误信息的红色页面，这其实是因为，Flutter 框架在调用build方法构建页面时进行了try- -catch的处理，并提供了一个ErrorWidget，用于在出现异常时进行信息提示:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//abstract class ComponentElement extends Element </span><br><span class="hljs-comment">//StatelessElement extends 	 ComponentElement</span><br><span class="hljs-comment">// StatefulElement extends 	 ComponentElement</span><br><br>built = ErrorWidget.builder(<br>        _debugReportException(<br>          ErrorDescription(<span class="hljs-string">&#x27;building <span class="hljs-subst">$this</span>&#x27;</span>),<br>          e,<br>          stack,<br>          informationCollector: () <span class="hljs-keyword">sync</span>* &#123;<br>            <span class="hljs-keyword">yield</span> DiagnosticsDebugCreator(DebugCreator(<span class="hljs-keyword">this</span>));<br>          &#125;,<br>        )<br></code></pre></td></tr></table></figure>

<p>这个页面反馈的信息比较丰富，适合开发期定位问题。但我们并不想让用户看到这种错误信息，希望给用户展示一个更加友好的页面。因此，我们通常会重写ErrorWidget.builder方法，返回我们自定义的展示信息，下面我们直接返回了一个居中的Text控件:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails) &#123;<br>     <span class="hljs-keyword">return</span> Scaffold(<br>       body: Center(<br>         child: Text(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;flutterErrorDetails.exception&#125;</span>&quot;</span>),<br>       ),<br>     );<br>   &#125;;<br></code></pre></td></tr></table></figure>



<h4 id="异常统一处理"><a href="#异常统一处理" class="headerlink" title="异常统一处理"></a>异常统一处理</h4><p>为了集中处理框架异常，Flutter 提供了FlutterError类，这个类的onError属性会在接收到框架异常时执行相应的回调。因此，要实现自定义捕获逻辑，我们只要为它提供一个自定义的错误处理回调即可。<br>在下面的代码中，我们使用Zone提供的handleUncaughtError语句，将Flutter框架的异常统- -转发到当前的Zone中，这样我们就可以统一使用Zone去处理应用内的所有异常了:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-keyword">void</span> main() &#123;<br>  FlutterError.onError = (FlutterErrorDetails details) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-comment">//转发至zone</span><br>    Zone.current.handleUncaughtError(details.exception, details.stack);<br>  &#125;;<br><br>  runZoned&lt;Future&lt;<span class="hljs-built_in">Null</span>&gt;&gt;(() <span class="hljs-keyword">async</span> &#123;<br>    runApp(MyApp());<br>  &#125;, onError: (error, stackTrace) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-comment">//在这里处理异常 搞个channel，转发到原生，上报到bugly平台</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------&quot;</span>);<br>    <span class="hljs-built_in">print</span>(error);<br>    <span class="hljs-built_in">print</span>(stackTrace);<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-------&quot;</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-内存分配与回收策略</title>
    <url>/2017/04/07/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>　　Java技术体系中所提倡的自动内存管理最终可以归结为自动化的解决了两个问题：给对象分配内存以及回收分配给对象的内存。对象的内存分配，往大方向讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配)，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分百固定的，其细节取决于当前使用的是哪一种垃圾回收器组合，还有虚拟机中与内存相关的参数设置。</p>
<span id="more"></span>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>　　大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。虚拟机提供了-XX：+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。<br>　　新生代GC(Minor GC):指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。<br>　　老年代GC(Major GC&#x2F;Full GC):指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC，(但非绝对的，在Parallel Scavenge收集器的手机策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>　　所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组，大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前出发垃圾收集以获取足够的连续空间来”安置”它们。</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>　　既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄(Age)计数器。如果对象在Eden出生并经过第一个Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每经过一个Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认是15岁)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：<br>MaxTenuringThreshold设置。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>　　为了能更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果Survivor空间中相同的年龄所有对象大小的总和大于Survivor空间的一般，年龄大于或等于改年龄的对象就可以直接进入老年代，无序等到MaxTenuringThreshold中要求的年龄。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>　　在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。<br>新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况(最极端的情况就是内存回收后新生代中所有对象都存活)，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。 与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。<br>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败(Handle Promotion Failure)。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。 虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM-垃圾收集算法与实现</title>
    <url>/2017/03/30/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>　　由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，这里只是介绍几种算法的思想及其发展过程。</p>
<span id="more"></span>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>　　最基础的算法是”标记-清除”(Mark-Sweep)算法，算法分为’标记’和’清除’两个阶段：首先标记处所有需要回收的对象，在标记后统一回收所有被标记的对象。它的主要不足有两个：一个事效率问题，标记和清除两个过程的效率都不高；另外一个事空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h4 id="1-复制算法"><a href="#1-复制算法" class="headerlink" title="1. 复制算法"></a>1. 复制算法</h4><p>　　它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效，只是这种算法的代价是将内存缩小为了原来的一般，代价太高。<br>现在的商业虚拟机都采用这种手机算法回收新生代，IBM公司的专门研究表明，新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<h4 id="2-标记-整理算法"><a href="#2-标记-整理算法" class="headerlink" title="2. 标记-整理算法"></a>2. 标记-整理算法</h4><p>　　复制收集短发在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费一半的空间，就需要额外的控件进行分配担保，以应对被使用的的内存中所有对象都100%存活的极端情况，所以在老年代一半不能直接选用这种算法。<br>根据老年代的特点，有人提出了另外一种”标记-整理”(Mark-Compact)算法，标记过程任然与”标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端便捷以外的内存。</p>
<h4 id="3-分代收集算法"><a href="#3-分代收集算法" class="headerlink" title="3. 分代收集算法"></a>3. 分代收集算法</h4><p>　　当前商业虚拟机的垃圾收集都采用”分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象的存货周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用”标记-清理”或者”标记-整理”算法来进行回收。</p>
<h3 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h3><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>　　从可达性分析中从GC Roots节点引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。<br>另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行—-这里<code>一致性</code>的意思是指在这个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到抱枕。这点是导致GC进行时必须停顿所有Java执行线程(Sun将这件事情称为”Stop The World”)的其中一个重要原因，即使是在号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。<br>由于目前的主流java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏的检查完所有执行上下文和全局引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，这样，GC在扫描时就可以直接得知这些信息了。</p>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>　　在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。 Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。 所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、 异常跳转等，所以具有这些功能的指令才会产生Safepoint。<br>对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。 这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。 现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。<br>而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>　　使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。 对于这种情况，就需要安全区域（Safe Region）来解决。<br>安全区域是指在一段代码片段之中，引用关系不会发生变化。 在这个区域中的任意地方开始GC都是安全的。 我们也可以把Safe Region看做是被扩展了的Safepoint。<br>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存区域</title>
    <url>/2017/03/27/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域.这些区域都有各自的用途,以及创建和销毁的时间.有的区域随着虚拟机进程的启动而存在,有些区域则依赖用户线程的启动和结束而建立和销毁.根据《Java虚拟机规范(JavaSE 7版)》的规定,Java虚拟机所管理的内存将会包括以下几个运行时数据区域.如下所示:<br><img src="/image/JVM/JVM_RunTime_Area.png" alt="JVM内存区域"></p>
<span id="more"></span>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>　　<code>程序计数器</code>(Program Counter Register)是一块较小的内存空间,它可以看作是当前线程所执行的字节码的行号指示器.在虚拟机的概念模型里(仅是概念模型,各种虚拟机可能会通过一些更高效的方式去实现),字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成.<br>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令.因此,为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为”线程私有”的内存.如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是Native方法,这个计数器值则为空(Undefined).此内存区域是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域.</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>　　与程序计数器一样,Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的,它的生命周期与线程相同.虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息.每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程.经常有人把Java内存区分为堆内存(Heap)和栈内存(Stack),这种分法比较粗糙,Java内存区域的划分实际上远比这复杂. 这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块.所指的”栈”就是现在讲的虚拟机栈,或者说是虚拟机栈中局部变量表部分.局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型,它不等同于对象本身,可能是一个指向对象起始地址的引用指针,也可能是指向一个代表对象的句柄或其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址).其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot),其余的数据类型只占用1个. 局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,这个方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小.在Java虚拟机规范中,对这个区域规定了两种异常状况:如果线程请求的栈深度大于虚拟机所允许的深度,将抛出<code>StackOverflowError</code>异常;如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展,只不过Java虚拟机规范中也允许固定长度的虚拟机栈),如果扩展时无法申请到足够的内存,就会抛出<code>OutOfMemoryError</code>异常.</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>　　本地方法栈(Native Method Stack)与虚拟机栈所发挥的作用是非常相似的,它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务. 在虚拟机规范中对本地方法栈中方法使用的语言、 使用方式与数据结构并没有强制规定,因此具体的虚拟机可以自由实现它. 甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接就把本地方法栈和虚拟机栈合二为一. 与虚拟机栈一样,本地方法栈区域也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常.</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>　　对于大多数应用来说,Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块.Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建.此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例都在这里分配内存.这一点在Java虚拟机规范中的描述是:所有的对象实例以及数组都要在堆上分配,但是随着JIT编译器的发展与逃逸分析技术逐渐成熟,栈上分配、标量替换优化技术将会导致一些微妙的变化发生,所有的对象都分配在堆上也渐渐变得不是那么”绝对”了.Java堆是垃圾收集器管理的主要区域,因此很多时候也被称做”GC堆”(Garbage Collected Heap).从内存回收的角度来看,由于现在收集器基本都采用分代收集算法,所以Java堆中还可以细分为:新生代和老年代;再细致一点的有Eden空间、From Survivor空间、To Survivor空间等.从内存分配的角度来看,线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB).不过无论如何划分,都与存放内容无关,无论哪个区域,存储的都仍然是对象实例,进一步划分的目的是为了更好地回收内存,或者更快地分配内存.根据Java虚拟机规范的规定,Java堆可以处于物理上不连续的内存空间中,只要逻辑上是连续的即可,就像我们的磁盘空间一样.在实现时,既可以实现成固定大小的,也可以是可扩展的,不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制). 如果在堆中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出<code>OutOfMemoryError</code>异常.</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>　　方法区(Method Area)与Java堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据.虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫做Non-Heap(非堆),目的应该是与Java堆区分开来.对于习惯在HotSpot虚拟机上开发、 部署程序的开发者来说,很多人都更愿意把方法区称为”永久代”(Permanent Generation),本质上两者并不等价,仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区,或者说使用永久代来实现方法区而已,这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存,能够省去专门为方法区编写内存管理代码的工作.对于其他虚拟机(如BEA JRockit、 IBM J9等)来说是不存在永久代的概念的.原则上,如何实现方法区属于虚拟机实现细节,不受虚拟机规范约束,但使用永久代来实现方法区,现在看来并不是一个好主意,因为这样更容易遇到内存溢出问题(永久代有-XX:MaxPermSize的上限,J9和JRockit只要没有触碰到进程可用内存的上限,例如32位系统中的4GB,就不会出现问题),而且有极少数方法(例如String.intern())会因这个原因导致不同虚拟机下有不同的表现. 因此,对于HotSpot虚拟机,根据官方发布的路线图信息,现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了,在目前已经发布的JDK1.7的HotSpot中,已经把原本放在永久代的字符串常量池移出.Java虚拟机规范对方法区的限制非常宽松,除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外,还可以选择不实现垃圾收集.相对而言,垃圾收集行为在这个区域是比较少出现的,但并非数据进入了方法区就如永久代的名字一样”永久”存在了.这区域的内存回收目标主要是针对常量池的回收和对类型的卸载,一般来说,这个区域的回收”成绩”比较难以令人满意,尤其是类型的卸载,条件相当苛刻,但是这部分区域的回收确实是必要的.根据Java虚拟机规范的规定,当方法区无法满足内存分配需求时,将抛出<code>OutOfMemoryError</code>异常.</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>　　运行时常量池(Runtime Constant Pool)是方法区的一部分. Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池(Constant Pool Table),用于存放编译期生成的各种字面量和符号引用,这部分内容将在类加载后进入方法区的运行时常量池中存放.Java虚拟机对Class文件每一部分(自然也包括常量池)的格式都有严格规定,每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行,但对于运行时常量池,Java虚拟机规范没有做任何细节的要求,不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域.不过,一般来说,除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中.运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性,Java语言并不要求常量一定只有编译期才能产生,也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新的常量放入池中,这种特性被开发人员利用得比较多的便是String类的intern()方法.既然运行时常量池是方法区的一部分,自然受到方法区内存的限制,当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常.</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>　　直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域.但是这部分内存也被频繁地使用,而且也可能导致<code>OutOfMemoryError</code>异常出现,所以我们放到这里一起讲解.在JDK 1.4中新加入了NIO(New Input&#x2F;Output)类,引入了一种基于通道(Channel)与缓冲区(Buffer)的I&#x2F;O方式,它可以使用Native函数库直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作.这样能在一些场景中显著提高性能,因为避免了在Java堆和Native堆中来回复制数据.显然,本机直接内存的分配不会受到Java堆大小的限制,但是,既然是内存,肯定还是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制.服务器管理员在配置虚拟机参数时,会根据实际内存设置-Xmx等参数信息,但经常忽略直接内存,使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制),从而导致动态扩展时出现<code>OutOfMemoryError</code>异常.</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收-对象已死？</title>
    <url>/2017/03/29/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%EF%BC%9F/</url>
    <content><![CDATA[<p>　　在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还<code>存活</code>着，哪些已经<code>死去</code>(即不能再被任何途径使用的对象)。</p>
<span id="more"></span>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>　　很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1;当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>客观来讲，引用计数法(Reference Counting)的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，但是，至少主流的Java虚拟机里面没有选用引用计数器算法来管理内存，其中主要的原因是它很难解决对象之间相互循环引用的问题。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>　　在主流的商用程序语言的主流实现中，都是通过可达性分析(Reachability Analysis)来判定对象是否存活的。这个算吗的基本思路就是通过一系列的称为<code>GC Roots</code>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何引用链相连时(在图论中，就是从GC Roots到这个对象不可达)，则证明此对象是不可用的。在Java语言中，可作为GC Roots的对象包括一下几种：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象。</li>
<li>方法区中静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI(一般说的Native方法)引用的对象</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>　　即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候他们暂时处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为”没有必要执行”。<br>如果这个对象呗判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做<code>F-Queue</code>的队列之中，并在稍后由一个虚拟机自动建立的、优先级低的Finalizer线程去执行它。这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是：如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能会导致<code>F-Queue</code>队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象 逃脱死亡命运的最后一次机会，稍后GC将对<code>F-Queue</code>中的对象进行第二次小规模的标记。</p>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>　　很多人认为方法区是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机方法区实现垃圾收集，而且在方法区中进行垃圾收集的性价比一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此。<br>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例：假如一个字符串”ABC”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”ABC”的，换句话说，就是没有任何String对象引用常量池中的”ABC”常量，也没有其他地方引用了这个字面量，如果这时繁盛内存回收，而且必要的话，这个”ABC”常量就会被系统清理出常量池，常量池中的其他类、方法、字段的符号引用也与此类似。<br>判定一个常量是否是”废弃常量”比较简单，而要判定一个类是否是”无用的类”的条件则相对苛刻许多。类需要同时满足下面三个调教才能算是”无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对用的java.lang.Class对象没有在任何对方被引用，无法在任何地方通过反射访问该类的方法。<br>　　虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClassLoading、 -XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。在大量使用反射、 动态代理、 CGLib等ByteCode框架、 动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</li>
</ul>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java使用Protocol Buffer与服务端交互</title>
    <url>/2023/05/09/Java%E4%BD%BF%E7%94%A8Protocol-Buffer%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p>最近和三方对接时，对方给出的接口文档是使用protol buffer进行交互的，并非是我们常见的json、xml这种格式，了解了一下这种格式或者说交协议的特点。<br>首先，Protocol Buffer序列化之后是二进制流，不进行反序列化基本不可读。<br>其次，序列化之后的体积很小，适合网络传输或者设备之间传输<br>最后，可以跨平台、跨语言使用<br>不过这些特点既是优点也是缺点：序列化之后的数据不可读，还原序列化之后的数据需要事先定义好的数据格式</p>
<span id="more"></span>

<h4 id="安装Protocol-Buffer的编译器"><a href="#安装Protocol-Buffer的编译器" class="headerlink" title="安装Protocol Buffer的编译器"></a>安装Protocol Buffer的编译器</h4><p>我们需要使用相应的编译器将<code>.proto</code>文件转化为对应的编程语言的代码。<br>编译器可以在这里下载<a href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a><br>这里我下载的版本是22.3。下载完成后解压、添加环境变量，命令行执行 <code>protoc --version</code>能够输出版本号就可以了</p>
<h4 id="编写-proto文件"><a href="#编写-proto文件" class="headerlink" title="编写 .proto文件"></a>编写 .proto文件</h4><p>文件内容及格式可以参考这里<a href="https://protobuf.dev/">https://protobuf.dev/</a><br>下面是一个示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs protocol">syntax = &quot;proto2&quot;;<br><br>package tutorial;<br><br>option java_multiple_files = true;<br>option java_package = &quot;com.example.tutorial.protos&quot;;<br>option java_outer_classname = &quot;AddressBookProtos&quot;;<br><br>message Person &#123;<br>  optional string name = 1;<br>  optional int32 id = 2;<br>  optional string email = 3;<br><br>  enum PhoneType &#123;<br>    MOBILE = 0;<br>    HOME = 1;<br>    WORK = 2;<br>  &#125;<br><br>  message PhoneNumber &#123;<br>    optional string number = 1;<br>    optional PhoneType type = 2 [default = HOME];<br>  &#125;<br><br>  repeated PhoneNumber phones = 4;<br>&#125;<br><br>message AddressBook &#123;<br>  repeated Person people = 1;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>然后我们需要使用上面安装好的编译工具将文件编译转化为对应编程语言的文件，这里使用的是java</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><br>protocol --java_out=src/main/java src/main/protobuf/AddressBookProtos.proto<br><br></code></pre></td></tr></table></figure>
<p><code>src/main/java</code>是输出文件的位置，<code>src/main/protobuf/tgssp.proto</code>是数据格式文件的位置</p>
<p>没有报错的话，我们就可以在输出文件的位置看到生成的java文件了</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>想要使用该文件，我们需要在工程中引入相应的依赖库，这里还是用java举例</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;com.google.protobuf&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;protobuf-java&#x27;</span>, <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.22.3&#x27;</span><br></code></pre></td></tr></table></figure>

<p>因为上面的<code>.proto</code>文件中定义的<code>java_multiple_files</code>为true，所以这里是分开生成的文件。<br>然后我们就可以使用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> Person.newBuilder()<br>        .setEmail(<span class="hljs-string">&quot;123@123.com&quot;</span>)<br>        .setId(<span class="hljs-number">1</span>)<br>        .setName(<span class="hljs-string">&quot;null&quot;</span>)<br>        .build();<br><span class="hljs-type">AddressBook</span> <span class="hljs-variable">addressBook</span> <span class="hljs-operator">=</span> AddressBook.newBuilder()<br>        .addPeople(person)<br>        .build();<br>System.out.println(addressBook);<br></code></pre></td></tr></table></figure>
<p>当然我们也可以将<code>addressBook</code>对象调用<code>toByteArray()</code>方法序列化为二进制数据流;也可以调用<code>AddressBook.parseFrom(byte[] bytes)</code>从二进制数据中反序列化</p>
<h4 id="与服务器交互"><a href="#与服务器交互" class="headerlink" title="与服务器交互"></a>与服务器交互</h4><p>这里为了方便，直接使用的apache的网络请求库，使用其他库原理是一样的<br>依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;org.apache.httpcomponents&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;httpcore&#x27;</span>, <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;4.4.14&#x27;</span><br>implementation <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;org.apache.httpcomponents&#x27;</span>, <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;httpclient&#x27;</span>, <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;4.5.13&#x27;</span><br></code></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpPost</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(<span class="hljs-string">&quot;https://a.b.com&quot;</span>);<br>request.setEntity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayEntity</span>(tgrequest.toByteArray()));<br><span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.execute(request);<br><span class="hljs-comment">// 处理 HTTP 响应</span><br><span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> response.getEntity();<br><span class="hljs-keyword">if</span> (entity != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 将响应实体转换为字节数组</span><br>    <span class="hljs-type">byte</span>[] data = toByteArray(entity.getContent());<br>    <span class="hljs-type">AddressBook</span> <span class="hljs-variable">addressBook</span> <span class="hljs-operator">=</span> AddressBook.parseFrom(data);<br>    System.out.println(addressBook);<br>&#125;<br><br><span class="hljs-comment">//读取响应</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] toByteArray(InputStream in) <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4096</span>];<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-keyword">while</span> ((len = in.read(buffer)) != -<span class="hljs-number">1</span>) &#123;<br>        out.write(buffer, <span class="hljs-number">0</span>, len);<br>    &#125;<br>    <span class="hljs-keyword">return</span> out.toByteArray();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>到这里就算是完成了一次使用protocol buffer的交互</p>
<h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>我们可以使用<code>protostuff</code>这个库，从而不借助<code>.proto</code>文件就可以直接对POJO进行序列化和反序列化。<br>详情可以查看这个仓库 <a href="https://github.com/protostuff/protostuff">https://github.com/protostuff/protostuff</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发多线程同步</title>
    <url>/2018/03/20/Java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>最近遇到了多线程并发同步问题，找到了<code>java.util.concurrent</code>包下的<code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>这三个类。<br><code>CountDownLatch</code>可以实现类似计数器的功能，例如线程A需要等待B、C、D三个线程执行完成之后才可以执行。<br><code>CyclicBarrier</code>可以实现让一组(多个)线程等待至某个状态之后再全部同时执行，当所有线程都被释放以后，CyclicBarrier可以被重用。<br><code>Semaphore</code>可以控制同时访问的线程个数，通过<code>acquire()</code>获取一个许可，如果没有就等待，而<code>release()</code>释放一个许可。</p>
<span id="more"></span>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch类只有一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>        <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里的count是一个计数值，表示要等待多少任务，每次调用该对象示例的<code>countDown()</code>方法，该值都会减1，当count为0时表示没有需要等待的任务。常用的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123; &#125;;   <span class="hljs-comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123; &#125;;  <span class="hljs-comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123; &#125;;  <span class="hljs-comment">//将count值减1</span><br></code></pre></td></tr></table></figure>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCountDownLatch</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);<br>	<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;one&quot;</span>) &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				System.out.println(<span class="hljs-string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;正在执行&quot;</span>);<br>				Thread.sleep(<span class="hljs-number">3000</span>);<br>				System.out.println(<span class="hljs-string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;执行完毕&quot;</span>);<br>				latch.countDown();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>		&#125;;<br>	&#125;.start();<br>	<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;two&quot;</span>) &#123;<br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				System.out.println(<span class="hljs-string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;正在执行&quot;</span>);<br>				Thread.sleep(<span class="hljs-number">3000</span>);<br>				System.out.println(<span class="hljs-string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;执行完毕&quot;</span>);<br>				latch.countDown();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>		&#125;;<br>	&#125;.start();<br><br>	<span class="hljs-keyword">try</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;等待2个线程执行完成&quot;</span>);<br>		latch.await();<br>		System.out.println(<span class="hljs-string">&quot;子线程已经执行完毕&quot;</span>);<br>	&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>		e.printStackTrace();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>该类有两个构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties)</span><br></code></pre></td></tr></table></figure>
<p>参数parties是指让多少个线程或者任务等待至barrier状态，参数barrierAction是当这些线程都到达barrier状态后会执行的内容。<br>该类里面有两个比较重要的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123; &#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><span class="hljs-keyword">throws</span> InterruptedException,BrokenBarrierException,TimeoutException &#123; &#125;;<br></code></pre></td></tr></table></figure>
<p>无参的方法比较常用，用来挂起当前线程，直到所有线程都达到barrier状态再同时执行后续任务。<br>有参的方法是让线程等待一定时间，如果线程还没有达到barrier状态，就让到达barrier状态的线程执行后续任务。<br>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCyclicBarrier</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//	CyclicBarrier barrier = new CyclicBarrier(5);</span><br>	<span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">5</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>		<br>		<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>			System.out.println(<span class="hljs-string">&quot;所有线程执行完毕，随机挑选一个线程来执行打印&quot;</span>);<br>			System.out.println(<span class="hljs-string">&quot;挑选的线程为&quot;</span> + Thread.currentThread().getName());<br>				<br>		&#125;<br>	&#125;);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Writer</span>(barrier, <span class="hljs-string">&quot;thread:&quot;</span> + i).start();<br>	&#125;<br><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Writer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>	<span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-title function_">Writer</span><span class="hljs-params">(CyclicBarrier cyclicBarrier, String threadName)</span> &#123;<br>		<span class="hljs-built_in">this</span>.cyclicBarrier = cyclicBarrier;<br>		<span class="hljs-keyword">if</span> (threadName != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-built_in">this</span>.setName(threadName);<br>		&#125;<br><br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>		<span class="hljs-keyword">try</span> &#123;<br>			System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;正在作业中&quot;</span>);<br>			Thread.sleep(<span class="hljs-number">5000</span>);<br>			System.out.println(<span class="hljs-string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;作业完成&quot;</span>);<br>			cyclicBarrier.await();<br>			System.out.println(<span class="hljs-string">&quot;所有线程作业完毕，线程&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;继续理其他任务&quot;</span>);<br><br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>			<br>			e.printStackTrace();<br>		&#125;<br><br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>值得注意的是，CyclicBarrier是可以<strong>重用</strong>的。</p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>该类提供了两个构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> permits)</span> &#123;          <span class="hljs-comment">//参数permits表示许可数目，即同时可以允许多少线程进行访问</span><br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(permits);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> permits, <span class="hljs-type">boolean</span> fair)</span> &#123;    <span class="hljs-comment">//这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可</span><br>    sync = (fair)? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(permits) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(permits);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面是该类中比较重要的几个方法，首先是acquire()、release()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;  &#125;     <span class="hljs-comment">//获取一个许可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> permits)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123; &#125;    <span class="hljs-comment">//获取permits个许可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123; &#125;          <span class="hljs-comment">//释放一个许可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> permits)</span> &#123; &#125;    <span class="hljs-comment">//释放permits个许可</span><br></code></pre></td></tr></table></figure>
<p>acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。<br>release()用来释放许可。注意，在释放许可之前，必须先获获得许可。<br>这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123; &#125;;    <span class="hljs-comment">//尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123; &#125;;  <span class="hljs-comment">//尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> permits)</span> &#123; &#125;; <span class="hljs-comment">//尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> permits, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123; &#125;; <span class="hljs-comment">//尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span><br></code></pre></td></tr></table></figure>
<p>另外还可以通过availablePermits()方法得到可用的许可数目。<br>假如5个线程要使用3个资源，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSemaphore</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;            <span class="hljs-comment">//线程数</span><br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">//资源数目</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;线程&quot;</span> +i,semaphore).start();<br>	&#125;<br>	<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>		<span class="hljs-keyword">private</span> Semaphore semaphore;<br>		<br>		<span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name, Semaphore semaphore)</span> &#123;<br>			<span class="hljs-built_in">super</span>();<br>			<span class="hljs-built_in">this</span>.setName(name);<br>			<span class="hljs-built_in">this</span>.semaphore = semaphore;<br>		&#125;<br><br>		<span class="hljs-meta">@Override</span><br>		<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				semaphore.acquire();<br>				System.out.println(<span class="hljs-string">&quot;线程：&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;占用一个资源&quot;</span>);<br>				Thread.sleep(<span class="hljs-number">3000</span>);<br>				System.out.println(<span class="hljs-string">&quot;线程：&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;释放一个资源&quot;</span>);<br>				semaphore.release();<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>		&#125;<br><br>	&#125;<br></code></pre></td></tr></table></figure>
<p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：<br>CountDownLatch一般用于某个线程等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins安装与使用</title>
    <url>/2017/06/28/Jenkins%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>公司需求，业务越来越多，服务器越来越多，后台部署项目麻烦的要死，于是上了<code>jenkins</code>这货。<br>关于这货是干嘛的，请移步这里<a href="https://jenkins.io/">https://jenkins.io/</a>,下载请移步这里<a href="https://jenkins.io/download/">https://jenkins.io/download/</a><br>安装环境：ubuntu 16.04、tomcat7(这个是因为Jenkins是个war包)、maven(这个是因为后台的项目是maven工程)、jdk8(这个是因为需要tomcat)、gradle(构建Android工程)、SDK(构建Android工程)</p>
<span id="more"></span>
<h4 id="Jenkins-环境"><a href="#Jenkins-环境" class="headerlink" title="Jenkins 环境"></a>Jenkins 环境</h4><p>安装JDK、Tomcat、MAVEN(如有需要)、gradle(构建Android工程)、SDK(构建Android工程)</p>
<h4 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h4><p>在上面的下载地址下载war，丢到tomcat的webapps文件夹下，然后启动tomcat，浏览器访问jenkin工程<code>127.0.0.1:8080/jenkins</code>如下图所示：<br><img src="/image/jenkins/jenkins_start.png" alt="jenkins首次启动"><br>打开红字提示的文件，里面是首次进入时需要的密码,点击右下角continue。</p>
<h5 id="jenkins安装插件"><a href="#jenkins安装插件" class="headerlink" title="jenkins安装插件"></a>jenkins安装插件</h5><p>可以自定义也可以安装推荐的插件，我这里安装的是建议的插件.稍等一会，插件安装完成后会自动跳转到创建jenkins用户的界面</p>
<h5 id="创建jenkins用户"><a href="#创建jenkins用户" class="headerlink" title="创建jenkins用户"></a>创建jenkins用户</h5><p>按照提示创建即可，点击右下角<code>Save and finish</code></p>
<h5 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h5><p>以后再次访问jenkins的时候就不用再去使用初始密码，只需要使用上一步创建的账号即可，登录后首界面如下，<br><img src="/image/jenkins/jenkins_index.png" alt="jenkins首页"><br>点击左侧的<code>系统管理</code>，在中间列出的工具里面点击<code>Global Tool Configuration</code>，指定JDK和MAVEN的路径，如下<br><img src="/image/jenkins/jenkins_jdk.png" alt="jenkins配置JDK"><br><img src="/image/jenkins/jenkins_maven.png" alt="jenkins配置MAVEN"><br>然后Save保存</p>
<h4 id="创建一个新的Maven工程"><a href="#创建一个新的Maven工程" class="headerlink" title="创建一个新的Maven工程"></a>创建一个新的Maven工程</h4><p>点击左侧菜单栏<code>新建</code>,输入工程名字，然后选择<code>构建一个只有风格的软件项目</code>,然后<code>ok</code><br><img src="/image/jenkins/jenkins_create_new_project.png" alt="jenkins创建新工程"></p>
<h4 id="配置工程"><a href="#配置工程" class="headerlink" title="配置工程"></a>配置工程</h4><p>在新的界面可以配置项目的构建、源码管理等<br>我的工程是存放在git上面的，所以就选择git<br><img src="/image/jenkins/jenkins_config_project.png" alt="jenkins源码管理"><br>构建触发器可以配置在什么时间配置，我们暂时没有，需要手动点击构建才行<br>构建环境没有配置<br>构建一项选择 <code>Invoke top-level Maven target</code>,当然根据需求可以选择其他构建方式<br><code>Maven Version</code>是上面配置maven时选择的别名，<code>Goals</code>是需要执行的maven命令(前面不需要加maven)<br><img src="/image/jenkins/jenkins_project_build.png" alt="jenkins构建项目"><br>点击左下角保存</p>
<h4 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h4><p>点击左侧的立即构建，可以在构建历史中查看原来构建的个过程<br><img src="/image/jenkins/jenkins_start_build_project.png" alt="jenkins构建"><br>点击构建历史列表里面对应构建历史的小圆点，可以查看控制台输出<br><img src="/image/jenkins/jenkins_build_history.png" alt="jenkins构建历史"><br><img src="/image/jenkins/jenkins_build_console_output.png" alt="jenkins"><br>ps：如果是普通用户启动的tomcat，使用git管理源码，则下载下来的工程源码在<code>/home/username/.jenkins/workspace</code>，如果是root用户，则在 <code>/root/.jenkins/workspace</code>下<br>pps:据说<code>jenkins</code>的包不需要tomcat也可以，执行<code>java -jar ***.war</code>即可</p>
]]></content>
      <tags>
        <tag>jenkins</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>JetPack中的LiveData、ViewModel、LifeCycle</title>
    <url>/2019/05/28/JetPack-LiveData-ViewModel-LifeCycle/</url>
    <content><![CDATA[<p>2018年谷歌I&#x2F;O 发布了一系列辅助android开发者的实用工具，合称Jetpack，以帮助开发者构建出色的 Android 应用。<br>这次发布的 Android Jetpack 组件覆盖以下 4 个方面：Architecture、Foundation、Behavior 以及 UI。<br>该系列博客介绍一下Jetpack中常用组件，本篇介绍LiveData、ViewModel、LifeCycle。最后借助于<a href="https://github.com/android/sunflower">https://github.com/android/sunflower</a> 来写一个完整的应用</p>
<span id="more"></span>


<h4 id="lifecycle"><a href="#lifecycle" class="headerlink" title="lifecycle"></a>lifecycle</h4><p>原文：<a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle">https://developer.android.google.cn/topic/libraries/architecture/lifecycle</a><br>说白了，就是一个接口回调，可以使用注解的方式来相应声明周期的回调，并且已经帮我们处理好了各种各样的意外状况(比如我们在onStart中做了比较多的操作，用户点了home键，导致onStop在OnStart完成之前被调用了)</p>
<p>Lifecycle是一个包含有关组件生命周期状态的信息(如Activity或Fragment)的类，允许其他对象观察此状态<br>Lifecycle使用两个枚举类<code>Event</code>和<code>State</code>来追踪组件的生命周期<br><img src="/image/Android/jetpack/lifecycle-states.png" alt="LifeCycler"><br>代码如下<br>定义一个Observer实现LifecycleObserver接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLifecycleObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LifecycleObserver</span> &#123;<br>    <span class="hljs-keyword">private</span> String tag;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyLifecycleObserver</span><span class="hljs-params">(String tag)</span>&#123;<br>        <span class="hljs-built_in">this</span>.tag = tag;<br>    &#125;<br>    <span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span>&#123;<br>        Log.e(tag,<span class="hljs-string">&quot;ON_CREATE&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span>&#123;<br>        Log.e(tag,<span class="hljs-string">&quot;ON_START&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResume</span><span class="hljs-params">()</span>&#123;<br>        Log.e(tag,<span class="hljs-string">&quot;ON_RESUME&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPause</span><span class="hljs-params">()</span>&#123;<br>        Log.e(tag,<span class="hljs-string">&quot;ON_PAUSE&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStop</span><span class="hljs-params">()</span>&#123;<br>        Log.e(tag,<span class="hljs-string">&quot;ON_STOP&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span>&#123;<br>        Log.e(tag,<span class="hljs-string">&quot;ON_DESTROY&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在Activity中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_lifecycle_observer);<br>        getLifecycle().addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLifecycleObserver</span>(<span class="hljs-string">&quot;Activity&quot;</span>));<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里要求Activity继承自实现了<code>LifecycleOwner</code>接口的类，比如<code>AppCompatActivity</code>等。<br>如果因为某些原因没有办法继承这种Activity，我们可以自己实现<code>LifecycleOwner</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WithoutLifeCycleActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LifecycleOwner</span> &#123;<br><br>    <span class="hljs-keyword">private</span> LifecycleRegistry lifecycleRegistry;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_without_life_cycle);<br>        lifecycleRegistry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LifecycleRegistry</span>(<span class="hljs-built_in">this</span>);<br>        lifecycleRegistry.markState(Lifecycle.State.CREATED);<br>        getLifecycle().addObserver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLifecycleObserver</span>(<span class="hljs-string">&quot;lifecycleRegistry&quot;</span>));<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onStart();<br>        lifecycleRegistry.markState(Lifecycle.State.STARTED);<br>    &#125;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Lifecycle <span class="hljs-title function_">getLifecycle</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> lifecycleRegistry;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h4><p>原文：<a href="https://developer.android.google.cn/topic/libraries/architecture/livedata">https://developer.android.google.cn/topic/libraries/architecture/livedata</a><br>LiveData和RxJava很像，但是LiveData可以和LifeCycle绑定，来防止内存泄漏。因为LiveData仅通知处于活动状态的观察者有关更新的信息，<br>注册观查LiveData对象的非活动观察者不会收到有关更改的通知(当然我们也可以声明任何状态下都能手打通知)。<br>如果Observer类表示的观察者生命周期处于STARTED或RESUMED状态，则LiveData会将其视为处于活动状态。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LiveDataActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> MutableLiveData&lt;String&gt; liveData;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_live_data);<br>        liveData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutableLiveData</span>&lt;&gt;();<br>        liveData.observe(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onChanged</span><span class="hljs-params">(String s)</span> &#123;<br>                Log.e(<span class="hljs-string">&quot;observe&quot;</span>,s);<br>            &#125;<br>        &#125;);<br>        liveData.observeForever(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onChanged</span><span class="hljs-params">(String s)</span> &#123;<br>                Log.e(<span class="hljs-string">&quot;observeForever&quot;</span>,s);<br>            &#125;<br>        &#125;);<br>        liveData.setValue(<span class="hljs-string">&quot;onCreate&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onStart();<br>        liveData.setValue(<span class="hljs-string">&quot;onStart&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResume</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onResume();<br>        liveData.setValue(<span class="hljs-string">&quot;onResume&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onStop();<br>        liveData.setValue(<span class="hljs-string">&quot;onStop&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        liveData.setValue(<span class="hljs-string">&quot;onDestroy&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们打开界面,按下home键，然后返回到界面，然后按返回键，可以发现如下log：<br>打开界面</p>
<blockquote>
<p>E&#x2F;observeForever: onCreate<br>  E&#x2F;observeForever: onStart<br>  E&#x2F;observe: onStart<br>  E&#x2F;observe: onResume<br>  E&#x2F;observeForever: onResume</p>
</blockquote>
<p>按下home键</p>
<blockquote>
<p>E&#x2F;observeForever: onStop</p>
</blockquote>
<p>返回界面</p>
<blockquote>
<p>E&#x2F;observeForever: onStart<br>  E&#x2F;observe: onStart<br>  E&#x2F;observe: onResume<br>  E&#x2F;observeForever: onResume</p>
</blockquote>
<p>按下返回键</p>
<blockquote>
<p>E&#x2F;observeForever: onStop<br>  E&#x2F;observeForever: onDestroy</p>
</blockquote>
<p>如果我们将LiveData和LifeCycle绑定后，在界面处于非活动状态是收不到通知的。<br>LiveData经常和Room及ViewModel一块使用</p>
<h4 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h4><p>原文：<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel">https://developer.android.google.cn/topic/libraries/architecture/viewmodel</a><br>ViewModel是以关联生命周期的方式来存储和管理UI相关的数据的类，即使configuration发生改变（比如旋转屏幕），数据仍然可以存在不会销毁。并且我们还可以通过ViewModelProviders在不同的Fragment之间共享数据。<br>实现ViewModel，这里省略掉了getter和setter方法。其实我们可以把每个属性都用<code>MutableLiveData</code>包装一下，这样当属性发生变化的时候，我们就可以立刻知道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AndroidViewModel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserViewModel</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Application application)</span> &#123;<br>        <span class="hljs-built_in">super</span>(application);<br>    &#125;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> MutableLiveData&lt;Integer&gt; valueChanged = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutableLiveData</span>&lt;&gt;();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Activity中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModelActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    ActivityViewModelBinding binding;<br>    <span class="hljs-keyword">private</span> UserViewModel userViewModel;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        binding = DataBindingUtil.setContentView(<span class="hljs-built_in">this</span>,R.layout.activity_view_model);<br>        userViewModel = ViewModelProviders.of(<span class="hljs-built_in">this</span>).get(UserViewModel.class);<br>        userViewModel.getValueChanged().observeForever(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onChanged</span><span class="hljs-params">(Integer integer)</span> &#123;<br>                binding.setUser(userViewModel);<br>            &#125;<br>        &#125;);<br><br><br>        binding.save.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                userViewModel.setSex(binding.sex.getText().toString());<br>                userViewModel.setName(binding.name.getText().toString());<br>                userViewModel.setAge(Integer.valueOf(binding.age.getText().toString()));<br>                userViewModel.getValueChanged().postValue(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;);<br>    <br>        binding.reset.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                userViewModel.setAge(<span class="hljs-number">11</span>);<br>                userViewModel.setName(<span class="hljs-string">&quot;aa&quot;</span>);<br>                userViewModel.setSex(<span class="hljs-string">&quot;M&quot;</span>);<br>                userViewModel.getValueChanged().postValue(<span class="hljs-number">1</span>);<br>                binding.setUser(userViewModel);<br>            &#125;<br>        &#125;);<br>        binding.setUser(userViewModel);<br>    <br>        ArrayList&lt;Fragment&gt; pages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        pages.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewModelFragmentA</span>());<br>        pages.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewModelFragmentB</span>());<br>        PagerAdapter adapter=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewAdapter</span>(getSupportFragmentManager(), pages);<br>       binding.viewPager.setAdapter(adapter);<br>    <br>    &#125;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FragmentPagerAdapter</span> &#123;<br>        <span class="hljs-keyword">private</span> ArrayList&lt;Fragment&gt; list;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ViewAdapter</span><span class="hljs-params">(FragmentManager fm,ArrayList&lt;Fragment&gt; list)</span> &#123;<br>            <span class="hljs-built_in">super</span>(fm);<br>            <span class="hljs-built_in">this</span>.list=list;<br>        &#125;<br>    <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Fragment <span class="hljs-title function_">getItem</span><span class="hljs-params">(<span class="hljs-type">int</span> arg0)</span> &#123;<br>            <span class="hljs-keyword">return</span> list.get(arg0);<br>        &#125;<br>    <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> list.size();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>FragmentA和FragmentB是一样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewModelFragmentA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fragment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br><br>    <span class="hljs-keyword">private</span> EditText name;<br>    <span class="hljs-keyword">private</span> EditText age;<br>    <span class="hljs-keyword">private</span> EditText sex;<br>    <br>    <span class="hljs-keyword">private</span> UserViewModel user;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ViewModelFragmentA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Required empty public constructor</span><br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>    <br>        user = ViewModelProviders.of(getActivity()).get(UserViewModel.class);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(LayoutInflater inflater, ViewGroup container,</span><br><span class="hljs-params">                             Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-comment">// Inflate the layout for this fragment</span><br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> inflater.inflate(R.layout.fragment_view_model, container, <span class="hljs-literal">false</span>);<br>        name = view.findViewById(R.id.name);<br>        age = view.findViewById(R.id.age);<br>        sex = view.findViewById(R.id.sex);<br>    <br>        view.findViewById(R.id.save).setOnClickListener(<span class="hljs-built_in">this</span>);<br>        view.findViewById(R.id.reset).setOnClickListener(<span class="hljs-built_in">this</span>);<br>        view.findViewById(R.id.show).setOnClickListener(<span class="hljs-built_in">this</span>);<br>        user.getValueChanged().observeForever(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onChanged</span><span class="hljs-params">(Integer integer)</span> &#123;<br>                show();<br>            &#125;<br>        &#125;);<br>    <br>        show();<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        sex.setText(user.getSex());<br>        age.setText(String.valueOf(user.getAge()));<br>        name.setText(user.getName());<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (v.getId()) &#123;<br>            <span class="hljs-keyword">case</span> R.id.save:<br>                user.setSex(sex.getText().toString());<br>                user.setName(name.getText().toString());<br>                user.setAge(Integer.valueOf(age.getText().toString()));<br>                user.getValueChanged().postValue(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> R.id.reset:<br>                user.setAge(<span class="hljs-number">11</span>);<br>                user.setName(<span class="hljs-string">&quot;aa&quot;</span>);<br>                user.setSex(<span class="hljs-string">&quot;M&quot;</span>);<br>                user.getValueChanged().postValue(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> R.id.show:<br>                show();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Activity中显示名字、年龄、性别。两个按钮save和reset。 在Fragment中多一个show按钮。<br>我们获取ViewModel都是通过<code>ViewModelProviders.of(getActivity()).get(UserViewModel.class)</code>来获取，得到是同一个对象。<br>当我们在任意一个地方修改数据并保存之后，会通过<code>valueChanged</code>属性来通知观察者来刷新界面。前面也提到过，我们可以把每个属性都用<code>MutableLiveData</code><br>包装一下，观察者就可以在每个属性改变的时候得到通知了。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>JetPack中的Room</title>
    <url>/2020/01/08/JetPack-Room/</url>
    <content><![CDATA[<p>2018年谷歌I&#x2F;O 发布了一系列辅助android开发者的实用工具，合称Jetpack，以帮助开发者构建出色的 Android 应用。<br>这次发布的 Android Jetpack 组件覆盖以下 4 个方面：Architecture、Foundation、Behavior 以及 UI。该系列博客介绍一下Jetpack中常用组件，本篇介绍Room，结合ViewModel和LiveData完成上图的结构。最后借助于<a href="https://github.com/android/sunflower">https://github.com/android/sunflower</a> 来写一个完整的应用</p>
<span id="more"></span>

<h4 id="Room简介"><a href="#Room简介" class="headerlink" title="Room简介"></a>Room简介</h4><p>原文地址：<a href="https://developer.android.google.cn/training/data-storage/room/index.html">https://developer.android.google.cn/training/data-storage/room/index.html</a></p>
<p>Room 持久性库在 SQLite 的基础上提供了一个抽象层，让用户能够在充分利用 SQLite 的强大功能的同时，获享更强健的数据库访问机制。<br>Room 包含 3 个主要组件：</p>
<ul>
<li><p>数据库：包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点。</p>
<p>使用 @Database 注释的类应满足以下条件：</p>
<ul>
<li><p>是扩展 RoomDatabase 的抽象类。</p>
</li>
<li><p>在注释中添加与数据库关联的实体列表。</p>
</li>
<li><p>包含具有 0 个参数且返回使用 @Dao 注释的类的抽象方法。</p>
</li>
</ul>
<p> 在运行时，您可以通过调用 Room.databaseBuilder() 或 Room.inMemoryDatabaseBuilder() 获取 Database 的实例。</p>
</li>
<li><p>Entity：表示数据库中的表。</p>
</li>
<li><p>DAO：包含用于访问数据库的方法。</p>
</li>
</ul>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>选择合适的版本</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// Room components</span><br>implementation <span class="hljs-string">&quot;androidx.room:room-runtime:2.2.3&quot;</span><br>annotationProcessor <span class="hljs-string">&quot;androidx.room:room-compiler:2.2.3&quot;</span><br>androidTestImplementation <span class="hljs-string">&quot;androidx.room:room-testing:2.2.3&quot;</span><br><br><span class="hljs-comment">// Lifecycle components</span><br>implementation <span class="hljs-string">&quot;androidx.lifecycle:lifecycle-extensions:2.1.0&quot;</span><br>annotationProcessor <span class="hljs-string">&quot;androidx.lifecycle:lifecycle-compiler:2.1.0&quot;</span><br><br><span class="hljs-comment">// UI</span><br>implementation <span class="hljs-string">&quot;com.google.android.material:material:1.0.0&quot;</span><br></code></pre></td></tr></table></figure>

<h4 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity(tableName = &quot;word_table&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Word</span> &#123;<br><br>   <span class="hljs-meta">@PrimaryKey</span><br>   <span class="hljs-meta">@NonNull</span><br>   <span class="hljs-meta">@ColumnInfo(name = &quot;word&quot;)</span><br>   <span class="hljs-keyword">private</span> String mWord;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Word</span><span class="hljs-params">(String word)</span> &#123;<span class="hljs-built_in">this</span>.mWord = word;&#125;<br><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getWord</span><span class="hljs-params">()</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.mWord;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解释一下常用的注解：</p>
<p><strong>@Entity</strong> :数据表的实体类。<br><strong>@PrimaryKey</strong>: 每一个实体类都需要一个唯一的标识。<br><strong>@ColumnInfo</strong> :数据表中字段名称。<br><strong>@Ignore</strong> :标注不需要添加到数据表中的属性。<br><strong>@Embedded</strong> :实体类中引用其他实体类。<br><strong>@ForeignKey</strong>:外键约束。</p>
<h4 id="创建DAO"><a href="#创建DAO" class="headerlink" title="创建DAO"></a>创建DAO</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Dao</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WordDao</span> &#123;<br><br>   <span class="hljs-comment">// allowing the insert of the same word multiple times by passing a </span><br>   <span class="hljs-comment">// conflict resolution strategy</span><br>   <span class="hljs-meta">@Insert(onConflict = OnConflictStrategy.IGNORE)</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Word word)</span>;<br><br>   <span class="hljs-meta">@Query(&quot;DELETE FROM word_table&quot;)</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-meta">@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br>   List&lt;Word&gt; <span class="hljs-title function_">getAlphabetizedWords</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>@Dao</strong> ：数据库操作的类。<br><strong>@Query</strong> ： 包含所有Sqlite语句操作。<br><strong>@Insert</strong> ： 插入操作。<br><strong>@Delete</strong> ： 删除操作。<br><strong>@Update</strong> ： 更新操作。</p>
<p><strong>冲突条款</strong> :我们在<code>@Insert</code>中添加的属性值。 就是针对出现**约束异常(ROLLBACK, ABORT, FAIL, IGNORE, and REPLACE)**的非标准处理。</p>
<p><strong>ABORT</strong> ：  默认值，不处理约束异常。<br><strong>ROLLBACK</strong>：  与ABORT相似，不常用。<br><strong>FAIL</strong> ：  在批量更新或者修改时，中途出现了约束异常，就会终止后续执行，但会保留已执行的sql语句。<br><strong>IGNORE</strong> ：  忽略约束异常，不做任何处理保留原数据。<br><strong>REPLACE</strong>：  当出现约束异常时，移除原数据 &amp; 将新数据覆盖。</p>
<p>解释一波：</p>
<ul>
<li>被<code>@Dao</code>注解的类一定是接口或者抽象类，</li>
<li><code>void insert(Word word);</code>声明一个插入的方法，不需要我们提供SQL语句，只需要用<code>@Insert</code>标记一下就好</li>
<li><code>@Query(&quot;DELETE FROM word_table&quot;)</code>:<code>@Query</code>需要我们提供一下SQL语句</li>
</ul>
<p>这里的<code>WordDao</code>会在编译时生成<code>WordDAO_Impl</code>类，</p>
<h4 id="Room-database"><a href="#Room-database" class="headerlink" title="Room database"></a>Room database</h4><p>我们自己定义的Room database必须是继承自<code>RoomDatabase</code>的抽象类，通常我们会把该类做成单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Database(entities = &#123;Word.class&#125;, version = 1, exportSchema = false)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordRoomDatabase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RoomDatabase</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> WordDao <span class="hljs-title function_">wordDao</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> WordRoomDatabase INSTANCE;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUMBER_OF_THREADS</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">databaseWriteExecutor</span> <span class="hljs-operator">=</span><br>        Executors.newFixedThreadPool(NUMBER_OF_THREADS);<br><br>   <span class="hljs-keyword">static</span> WordRoomDatabase <span class="hljs-title function_">getDatabase</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Context context)</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (WordRoomDatabase.class) &#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),<br>                            WordRoomDatabase.class, <span class="hljs-string">&quot;word_database&quot;</span>)<br>                            .build();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们使用<code>@Database</code>注解来声明这是一个Room database ，并且使用参数中的entities属性，声明该数据库中的映射表，可以设置多个表，同时设置数据库版本，方便之后进行升级。</p>
<h4 id="创建-Repository"><a href="#创建-Repository" class="headerlink" title="创建 Repository"></a>创建 Repository</h4><p><img src="/image/Android/jetpack/room_repository.png" alt="room_repository"></p>
<p>Repository是一个抽象的数据访问层，数据可以来源于数据库，也可以来源于网络，这一次层并不是必须的，但还是推荐有这么一层。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordRepository</span> &#123;<br><br>    <span class="hljs-keyword">private</span> WordDAO wordDAO;<br>    <span class="hljs-keyword">private</span> LiveData&lt;List&lt;Word&gt;&gt; allWords;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WordRepository</span><span class="hljs-params">(Application application)</span>&#123;<br>        <span class="hljs-type">WordRoomDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> WordRoomDatabase.getDatabase(application);<br>        wordDAO = db.wordDAO();<br>        allWords = wordDAO.getAlphabetizedWords();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> LiveData&lt;List&lt;Word&gt;&gt; <span class="hljs-title function_">getAllWords</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> allWords;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Word word)</span>&#123;<br>        WordRoomDatabase.databaseWriteExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                wordDAO.insert(word);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="创建ViewModel"><a href="#创建ViewModel" class="headerlink" title="创建ViewModel"></a>创建ViewModel</h4><p><img src="/image/Android/jetpack/room_view_model.png" alt="room_view_model"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AndroidViewModel</span> &#123;<br><br>    <span class="hljs-keyword">private</span> WordRepository wordRepository;<br>    <span class="hljs-keyword">private</span> LiveData&lt;List&lt;Word&gt;&gt; allWords;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WordViewModel</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Application application)</span> &#123;<br>        <span class="hljs-built_in">super</span>(application);<br>        wordRepository = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WordRepository</span>(application);<br>        allWords = wordRepository.getAllWords();<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> LiveData&lt;List&lt;Word&gt;&gt; <span class="hljs-title function_">getAllWords</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> allWords;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Word word)</span> &#123;<br>        wordRepository.insert(word);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h4><p>页面包含一个<code>RecyclerView</code>，用于展示数据库保存的内容，一个<code>button</code>,点击后跳转新页面，添加新的<code>Word</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoomWordActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> WordViewModel mWordViewModel;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW_WORD_ACTIVITY_REQUEST_CODE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_room_word);<br>        <span class="hljs-type">RecyclerView</span> <span class="hljs-variable">recyclerView</span> <span class="hljs-operator">=</span> findViewById(R.id.recyclerview);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">WordListAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WordListAdapter</span>(<span class="hljs-built_in">this</span>);<br>        recyclerView.setAdapter(adapter);<br>        recyclerView.setLayoutManager(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearLayoutManager</span>(<span class="hljs-built_in">this</span>));<br><br><br>        mWordViewModel = ViewModelProviders.of (<span class="hljs-built_in">this</span>).get(WordViewModel.class);<br>        mWordViewModel.getAllWords().observe(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;List&lt;Word&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onChanged</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> <span class="hljs-keyword">final</span> List&lt;Word&gt; words)</span> &#123;<br>                <span class="hljs-comment">// Update the cached copy of the words in the adapter.</span><br>                adapter.setWords(words);<br>            &#125;<br>        &#125;);<br><br><br>        <span class="hljs-type">FloatingActionButton</span> <span class="hljs-variable">fab</span> <span class="hljs-operator">=</span> findViewById(R.id.fab);<br>        fab.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View view)</span> &#123;<br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(RoomWordActivity.<span class="hljs-built_in">this</span>, NewWordActivity.class);<br>                startActivityForResult(intent, NEW_WORD_ACTIVITY_REQUEST_CODE);<br>            &#125;<br>        &#125;);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityResult</span><span class="hljs-params">(<span class="hljs-type">int</span> requestCode, <span class="hljs-type">int</span> resultCode, Intent data)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onActivityResult(requestCode, resultCode, data);<br><br>        <span class="hljs-keyword">if</span> (requestCode == NEW_WORD_ACTIVITY_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) &#123;<br>            <span class="hljs-type">Word</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Word</span>(data.getStringExtra(NewWordActivity.EXTRA_REPLY));<br>            mWordViewModel.insert(word);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Toast.makeText(<br>                    getApplicationContext(),<br>                    R.string.empty_not_saved,<br>                    Toast.LENGTH_LONG).show();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们当我们添加完数据之后，会在页面上显示。</p>
<h4 id="Dao编译后的产物"><a href="#Dao编译后的产物" class="headerlink" title="@Dao编译后的产物"></a>@Dao编译后的产物</h4><p>我们在WordDAO中添加了几天无关紧要的方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Insert(onConflict = OnConflictStrategy.IGNORE)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Word word)</span>;<br><br><span class="hljs-meta">@Update</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">updateWord</span><span class="hljs-params">(Word word)</span>;<br><br><span class="hljs-meta">@Query(&quot;DELETE FROM word_table&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">@Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br>LiveData&lt;List&lt;Word&gt;&gt; <span class="hljs-title function_">getAlphabetizedWords</span><span class="hljs-params">()</span>;<br><br><span class="hljs-meta">@Query(&quot;select * from word_table where word=:word&quot;)</span><br>LiveData&lt;Word&gt; <span class="hljs-title function_">getWordByContent</span><span class="hljs-params">(String word)</span>;<br></code></pre></td></tr></table></figure>

<p>我们来看一下编译时生成的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordDAO_Impl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WordDAO</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RoomDatabase __db;<br><br>  <span class="hljs-comment">//对应着 void insert(Word word);方法</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EntityInsertionAdapter&lt;Word&gt; __insertionAdapterOfWord;<br>	<span class="hljs-comment">//对应着  void updateWord(Word word);方法</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EntityDeletionOrUpdateAdapter&lt;Word&gt; __updateAdapterOfWord;<br>	<span class="hljs-comment">//对应着 void deleteAll();方法</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SharedSQLiteStatement __preparedStmtOfDeleteAll;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">WordDAO_Impl</span><span class="hljs-params">(RoomDatabase __db)</span> &#123;<br>    <span class="hljs-built_in">this</span>.__db = __db;<br>    <span class="hljs-comment">//和JDBC中PreparedStatement很像，差不多是一致的</span><br>    <span class="hljs-built_in">this</span>.__insertionAdapterOfWord = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntityInsertionAdapter</span>&lt;Word&gt;(__db) &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createQuery</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;INSERT OR IGNORE INTO `word_table` (`word`) VALUES (?)&quot;</span>;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(SupportSQLiteStatement stmt, Word value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (value.getWord() == <span class="hljs-literal">null</span>) &#123;<br>          stmt.bindNull(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          stmt.bindString(<span class="hljs-number">1</span>, value.getWord());<br>        &#125;<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">//这里也是进行预编译</span><br>    <span class="hljs-built_in">this</span>.__updateAdapterOfWord = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntityDeletionOrUpdateAdapter</span>&lt;Word&gt;(__db) &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createQuery</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UPDATE OR ABORT `word_table` SET `word` = ? WHERE `word` = ?&quot;</span>;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(SupportSQLiteStatement stmt, Word value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (value.getWord() == <span class="hljs-literal">null</span>) &#123;<br>          stmt.bindNull(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          stmt.bindString(<span class="hljs-number">1</span>, value.getWord());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (value.getWord() == <span class="hljs-literal">null</span>) &#123;<br>          stmt.bindNull(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          stmt.bindString(<span class="hljs-number">2</span>, value.getWord());<br>        &#125;<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">//这里是删除所有，并没有参数，所以没有预编译语句</span><br>    <span class="hljs-built_in">this</span>.__preparedStmtOfDeleteAll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedSQLiteStatement</span>(__db) &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createQuery</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">_query</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DELETE FROM word_table&quot;</span>;<br>        <span class="hljs-keyword">return</span> _query;<br>      &#125;<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">//这里是复写WordDAO中的方法，调用上面的预编译好的语句进行sql操作，没啥好说的；篇幅原因，</span><br>  <span class="hljs-comment">//public LiveData&lt;List&lt;Word&gt;&gt; getAlphabetizedWords() </span><br>  <span class="hljs-comment">//public LiveData&lt;Word&gt; getWordByContent(final String word)</span><br>  <span class="hljs-comment">//没有抄过来</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Word word)</span> &#123;<br>    __db.assertNotSuspendingTransaction();<br>    __db.beginTransaction();<br>    <span class="hljs-keyword">try</span> &#123;<br>      __insertionAdapterOfWord.insert(word);<br>      __db.setTransactionSuccessful();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      __db.endTransaction();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateWord</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Word word)</span> &#123;<br>    __db.assertNotSuspendingTransaction();<br>    __db.beginTransaction();<br>    <span class="hljs-keyword">try</span> &#123;<br>      __updateAdapterOfWord.handle(word);<br>      __db.setTransactionSuccessful();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      __db.endTransaction();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span><span class="hljs-params">()</span> &#123;<br>    __db.assertNotSuspendingTransaction();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SupportSQLiteStatement</span> <span class="hljs-variable">_stmt</span> <span class="hljs-operator">=</span> __preparedStmtOfDeleteAll.acquire();<br>    __db.beginTransaction();<br>    <span class="hljs-keyword">try</span> &#123;<br>      _stmt.executeUpdateDelete();<br>      __db.setTransactionSuccessful();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      __db.endTransaction();<br>      __preparedStmtOfDeleteAll.release(_stmt);<br>    &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="Database编译后生成的类"><a href="#Database编译后生成的类" class="headerlink" title="@Database编译后生成的类"></a>@Database编译后生成的类</h4><p>我们定义的<code>WordRoomDatabase</code>类在编译后生成了<code>WordRoomDatabase_Impl</code>类，我们来看一下类的内容,删除了方法的实现，只保留了方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordRoomDatabase_Impl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WordRoomDatabase</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WordDAO _wordDAO;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ManDAO _manDAO;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> SupportSQLiteOpenHelper <span class="hljs-title function_">createOpenHelper</span><span class="hljs-params">(DatabaseConfiguration configuration)</span> &#123;<br>   <br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> RoomOpenHelper.ValidationResult <span class="hljs-title function_">onValidateSchema</span><span class="hljs-params">(SupportSQLiteDatabase _db)</span> &#123;<br>        <br>    <span class="hljs-keyword">final</span> SupportSQLiteOpenHelper.<span class="hljs-type">Configuration</span> <span class="hljs-variable">_sqliteConfig</span> <span class="hljs-operator">=</span> SupportSQLiteOpenHelper.Configuration.builder(configuration.context)<br>        .name(configuration.name)<br>        .callback(_openCallback)<br>        .build();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SupportSQLiteOpenHelper</span> <span class="hljs-variable">_helper</span> <span class="hljs-operator">=</span> configuration.sqliteOpenHelperFactory.create(_sqliteConfig);<br>    <span class="hljs-keyword">return</span> _helper;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> InvalidationTracker <span class="hljs-title function_">createInvalidationTracker</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> HashMap&lt;String, String&gt; _shadowTablesMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;(<span class="hljs-number">0</span>);<br>    HashMap&lt;String, Set&lt;String&gt;&gt; _viewTables = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Set&lt;String&gt;&gt;(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidationTracker</span>(<span class="hljs-built_in">this</span>, _shadowTablesMap, _viewTables, <span class="hljs-string">&quot;word_table&quot;</span>,<span class="hljs-string">&quot;man&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearAllTables</span><span class="hljs-params">()</span> &#123;<br>    <br>  &#125;<br><br> <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> WordDAO <span class="hljs-title function_">wordDAO</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (_wordDAO != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> _wordDAO;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span>(_wordDAO == <span class="hljs-literal">null</span>) &#123;<br>          _wordDAO = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WordDAO_Impl</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> _wordDAO;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ManDAO <span class="hljs-title function_">ManDAO</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (_manDAO != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> _manDAO;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span>(_manDAO == <span class="hljs-literal">null</span>) &#123;<br>          _manDAO = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ManDAO_Impl</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> _manDAO;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里面我们发现了获取我们定义的两个<code>DAO</code>的方法，返回了<code>DAO_Impl</code>的实现类。</p>
<p><code>createInvalidationTracker</code>是在创建RoomDatabase时调用的 ，代码在<code>RoomDatabase</code>类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">RoomDatabase</span><span class="hljs-params">()</span> &#123;<br>       mInvalidationTracker = createInvalidationTracker();<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><code>createOpenHelper</code>是在我们自己定义的RoomDatabase中调用<code>Room.databaseBuilder().build()</code>方法时，这个方法内部调用的。</p>
<h4 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h4><p>上面简单说明了调用过程中所涉及到的类，下面简单捋一下调用过程：</p>
<ol>
<li>我们的<code>WordRoomDatabase</code>继承自<code>RoomDatabase</code>,并且在<code>getDatabase</code>方法中调用了<code>Room.databaseBuilder().build()</code>方法。这里的<code>Room.databaseBuilder()</code>方法返回的是<code>RoomDatabase.Builder</code>类型，这调用<code>build()</code>方法</li>
<li>在<code>RoomDatabase.Builder.build</code>方法中，只看最后几行，前面是对数据库进行的配置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> Room.getGeneratedImplementation(mDatabaseClass, DB_IMPL_SUFFIX);<br>db.init(configuration);<br><span class="hljs-keyword">return</span> db;<br></code></pre></td></tr></table></figure>

<p>这里的<code>DB_IMPL_SUFFIX</code>是一个全局静态变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DB_IMPL_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;_Impl&quot;</span>;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>在返回数据库实例之前，调用了<code>db.init</code>方法，在<code>init</code>方法中调用了<code>createOpenHelper</code>方法，也就是上面</li>
</ol>
<p>提到的<code>WordRoomDatabase_Impl</code>中实现的<code>createOpenHelper</code>方法。</p>
<p>至此，我们就可以调用DAO中的方法对数据库进行操作了</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>JetPack-sunflower</title>
    <url>/2020/03/12/JetPack-sunflower/</url>
    <content><![CDATA[<p>2018年谷歌I&#x2F;O 发布了一系列辅助android开发者的实用工具，合称Jetpack，以帮助开发者构建出色的 Android 应用。<br>sunflower with java，A gardening app illustrating Android development best practices with Android Jetpack.<br>sunflower的java版本：园艺应用程序，说明了使用Android Jetpack进行Android开发的最佳做法。<br>源码地址 <a href="https://github.com/huangyuanlove/sunflower_java">https://github.com/huangyuanlove/sunflower_java</a> 本项目完全来自于kotlin版本的<strong>代码翻译</strong><br>kotlin版本 <a href="https://github.com/android/sunflower">https://github.com/android/sunflower</a></p>
<span id="more"></span>

<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ol>
<li>主页分为两个tab，默认tab展示已经栽种的植物，另外一个tab展示所有可栽种植物；</li>
<li>点击每个植物进入到植物详情</li>
<li>单Activity</li>
<li>ViewModel从数据库中读取数据，返回LiveData对象，并将对象绑定到视图中</li>
<li>展示了创建数据库、数据对象以及ViewModel、Repository过程<h4 id="JetPack组件"><a href="#JetPack组件" class="headerlink" title="JetPack组件"></a>JetPack组件</h4></li>
<li>lifecycle</li>
<li>navigation</li>
<li>room</li>
<li>work</li>
<li>liveData</li>
<li>databinding</li>
</ol>
<h4 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h4><ol>
<li>主页：MainActivity -&gt; HomeViewPagerFragment</li>
<li>我的花园：GardenFragment</li>
<li>植物目录：PlantListFragment</li>
<li>植物详情：PlantDetailFragment</li>
<li>数据来源：assets中的plants.json</li>
</ol>
<h4 id="结构简介"><a href="#结构简介" class="headerlink" title="结构简介"></a>结构简介</h4><ol>
<li>adapter:包含DatabindingAdapter,ListViewAdapter</li>
<li>data:数据库、实体类、DAO</li>
<li>utilities:常量字段</li>
<li>viewmodels:各个视图所需的ViewModel</li>
<li>widget:自定义控件</li>
<li>workers:初始化数据库</li>
<li>*Fragment:视图UI</li>
</ol>
<h4 id="流程简介"><a href="#流程简介" class="headerlink" title="流程简介"></a>流程简介</h4><ol>
<li>AppDatabase单例模式，在GardenFragment中会进行初始化，这时会将plants.json写入数据库；</li>
<li>在PlantListFragment中，读取数据库中植物信息并展示在页面上；点击右上角按钮，会筛选植物</li>
<li>点击植物进入详情</li>
<li>在详情页点击加号添加植物，则会出现在GardenFragment中，同时加号隐藏</li>
</ol>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>JetPack中的Navigation</title>
    <url>/2020/02/25/JetPack%E4%B8%AD%E7%9A%84Navigation/</url>
    <content><![CDATA[<p>2018年谷歌I&#x2F;O 发布了一系列辅助android开发者的实用工具，合称Jetpack，以帮助开发者构建出色的 Android 应用。<br>这次发布的 Android Jetpack 组件覆盖以下 4 个方面：Architecture、Foundation、Behavior 以及 UI。<br>该系列博客介绍一下Jetpack中常用组件，本篇介绍LiveData、ViewModel、LifeCycle。最后借助于<a href="https://github.com/android/sunflower">https://github.com/android/sunflower</a> 来写一个完整的应用</p>
<span id="more"></span>

<p>原文<a href="https://developer.android.com/guide/navigation/?hl=zh-cn%EF%BC%8C%E5%B0%B1%E5%83%8F%E5%AE%83%E7%9A%84%E5%90%8D%E5%AD%97%E4%B8%80%E6%A0%B7%EF%BC%8C%E7%94%A8%E6%9D%A5%E5%81%9A%E5%AF%BC%E8%88%AA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8(%E4%B8%80%E4%B8%AAActivity%E4%B8%AD%E5%A4%9A%E4%B8%AAFragment%E8%BF%9B%E8%A1%8C%E5%88%87%E6%8D%A2)">https://developer.android.com/guide/navigation/?hl=zh-cn，就像它的名字一样，用来做导航，可以用来做单页面应用(一个Activity中多个Fragment进行切换)</a></p>
<p>导航组件由以下三个关键部分组成：</p>
<ul>
<li>导航图：在一个集中位置包含所有导航相关信息的 XML 资源。这包括应用内所有单个内容区域（称为<em>目标</em>）以及用户可以通过应用获取的可能路径。</li>
<li><code>NavHost</code>：显示导航图中目标的空白容器。导航组件包含一个默认 <code>NavHost</code> 实现 (<a href="https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment?hl=zh-cn"><code>NavHostFragment</code></a>)，可显示 Fragment 目标</li>
<li><code>NavController</code>：在 <code>NavHost</code> 中管理应用导航的对象。当用户在整个应用中移动时，<code>NavController</code> 会安排 <code>NavHost</code> 中目标内容的交换。</li>
</ul>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>      <span class="hljs-keyword">def</span> nav_version = <span class="hljs-string">&quot;2.3.0-alpha01&quot;</span><br><br>      <span class="hljs-comment">// Java language implementation</span><br>      implementation <span class="hljs-string">&quot;androidx.navigation:navigation-fragment:$nav_version&quot;</span><br>      implementation <span class="hljs-string">&quot;androidx.navigation:navigation-ui:$nav_version&quot;</span><br><br>      <span class="hljs-comment">// Kotlin</span><br>      implementation <span class="hljs-string">&quot;androidx.navigation:navigation-fragment-ktx:$nav_version&quot;</span><br>      implementation <span class="hljs-string">&quot;androidx.navigation:navigation-ui-ktx:$nav_version&quot;</span><br><br>      <span class="hljs-comment">// Dynamic Feature Module Support</span><br>      implementation <span class="hljs-string">&quot;androidx.navigation:navigation-dynamic-features-fragment:$nav_version&quot;</span><br><br>      <span class="hljs-comment">// Testing Navigation</span><br>      androidTestImplementation <span class="hljs-string">&quot;androidx.navigation:navigation-testing:$nav_version&quot;</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="创建导航图"><a href="#创建导航图" class="headerlink" title="创建导航图"></a>创建导航图</h4><p>在<code>res/navigation</code>下创建一个<code>Navigation source file</code>，根节点如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/test_navigation&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="向-Activity-添加-NavHost"><a href="#向-Activity-添加-NavHost" class="headerlink" title="向 Activity 添加 NavHost"></a>向 Activity 添加 NavHost</h4><p>导航宿主是 Navigation 组件的核心部分之一。导航宿主是一个空容器，用户在您的应用中导航时，目的地会在该容器中交换进出。</p>
<p>导航宿主必须派生于 <a href="https://developer.android.com/reference/androidx/navigation/NavHost?hl=zh-cn"><code>NavHost</code></a>。Navigation 组件的默认 <code>NavHost</code> 实现 (<a href="https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment?hl=zh-cn"><code>NavHostFragment</code></a>) 负责处理 Fragment 目的地的交换。</p>
<p>在Activit的布局文件中添加如下控件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/fragment_first&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;androidx.navigation.fragment.NavHostFragment&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:defaultNavHost</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:navGraph</span>=<span class="hljs-string">&quot;@navigation/test_navi&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>请注意以下几点：</p>
<ul>
<li><code>android:name</code> 属性包含 <code>NavHost</code> 实现的类名称。</li>
<li><code>app:navGraph</code> 属性将 <code>NavHostFragment</code> 与导航图相关联。导航图会在此 <code>NavHostFragment</code> 中指定用户可以导航到的所有目的地。</li>
<li><code>app:defaultNavHost=&quot;true&quot;</code> 属性确保您的 <code>NavHostFragment</code> 会拦截系统返回按钮。请注意，只能有一个默认 <code>NavHost</code>。如果同一布局（例如，双窗格布局）中有多个主机，请务必仅指定一个默认 <code>NavHost</code>。</li>
</ul>
<p>在Activit中设置支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>       <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>       setContentView(R.layout.activity_navigation);<br>   &#125;<br><br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onSupportNavigateUp</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> Navigation.findNavController(<span class="hljs-built_in">this</span>, R.id.fragment_first).navigateUp();<br>   &#125;<br></code></pre></td></tr></table></figure>

<h4 id="添加Fragment"><a href="#添加Fragment" class="headerlink" title="添加Fragment"></a>添加Fragment</h4><p>我们添加FragmentA，FragmentB，FragmentC，每个Fragment中只有一个文本按钮</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FragmentA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fragment</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FragmentA</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> View <span class="hljs-title function_">onCreateView</span><span class="hljs-params">(LayoutInflater inflater, ViewGroup container,</span><br><span class="hljs-params">                             Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span><br>                inflater.inflate(R.layout.fragment_a, container, <span class="hljs-literal">false</span>);<br>        view.findViewById(R.id.jump).setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                FragmentBArgs.Builder builder= <span class="hljs-keyword">new</span>  <span class="hljs-title class_">FragmentBArgs</span>.Builder();<br>                builder.setNum(<span class="hljs-number">11111</span>);<br>                builder.setTitle(<span class="hljs-string">&quot;FragmentB&quot;</span>);<br>                Navigation.findNavController(v).navigate(R.id.action_fragmentA_to_fragmentB,builder.build().toBundle());<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="添加导航"><a href="#添加导航" class="headerlink" title="添加导航"></a>添加导航</h4><p>在我们前面步骤创建的Navigation Resource文件中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/test_navi&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:startDestination</span>=<span class="hljs-string">&quot;@id/fragmentA&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/fragmentA&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.huangyuanlove.androidjetpack.architecture.navigation.FragmentA&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;fragmentA&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/fragment_a&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/action_fragmentA_to_fragmentB&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:destination</span>=<span class="hljs-string">&quot;@id/fragmentB&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:exitAnim</span>=<span class="hljs-string">&quot;@android:anim/slide_out_right&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/fragmentB&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.huangyuanlove.androidjetpack.architecture.navigation.FragmentB&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;fragmentB&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/fragment_b&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">argument</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;title&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:defaultValue</span>=<span class="hljs-string">&quot;test&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:argType</span>=<span class="hljs-string">&quot;string&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">argument</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;num&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:defaultValue</span>=<span class="hljs-string">&quot;100&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:argType</span>=<span class="hljs-string">&quot;integer&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/action_fragmentB_to_fragmentC&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:destination</span>=<span class="hljs-string">&quot;@id/fragmentC&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:exitAnim</span>=<span class="hljs-string">&quot;@android:anim/slide_out_right&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/fragmentC&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.huangyuanlove.androidjetpack.architecture.navigation.FragmentC&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;fragmentC&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/fragment_c&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/action_fragmentC_to_fragmentA&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:destination</span>=<span class="hljs-string">&quot;@id/fragmentA&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:exitAnim</span>=<span class="hljs-string">&quot;@android:anim/slide_out_right&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>Type</strong> 字段指示在您的源代码中，该目的地是作为 Fragment、Activity 还是其他自定义类实现的。</li>
<li><strong>Label</strong> 字段包含该目的地的 XML 布局文件的名称。</li>
<li><strong>ID</strong> 字段包含该目的地的 ID，它用于在代码中引用该目的地。</li>
<li><strong>Class</strong> 下拉列表显示与该目的地相关联的类的名称。您可以点击此下拉列表，将相关联的类更改为其他目的地类型。</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>导航到目的地是使用 <a href="https://developer.android.com/reference/androidx/navigation/NavController?hl=zh-cn"><code>NavController</code></a> 完成的，后者是一个在 <code>NavHost</code> 中管理应用导航的对象。每个 <code>NavHost</code> 均有自己的相应 <code>NavController</code>。可以使用以下方法之一检索 <code>NavController</code>：</p>
<ul>
<li><a href="https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment?hl=zh-cn#findNavController(android.support.v4.app.Fragment)">NavHostFragment.findNavController(Fragment)</a></li>
<li>[Navigation.findNavController(Activity, @IdRes int viewId)](<a href="https://developer.android.com/reference/androidx/navigation/Navigation?hl=zh-cn#findNavController">https://developer.android.com/reference/androidx/navigation/Navigation?hl=zh-cn#findNavController</a>(android.app.Activity, int))</li>
<li><a href="https://developer.android.com/reference/androidx/navigation/Navigation?hl=zh-cn#findNavController(android.view.View)">Navigation.findNavController(View)</a></li>
</ul>
<p>比如我们打算在FragmentA中导航到FragmentB，则</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">tv.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                Navigation.findNavController(v)<br>                        .navigate(R.id.action_fragmentA_to_fragmentB);<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure>

<p>如果我们需要传递参数，可以使用 Safe Args 来确保类型安全。</p>
<p>在顶级<code>build.gradle</code>中添加classPath:<code>classpath &quot;androidx.navigation:navigation-safe-args-gradle-plugin:2.3.0-alpha02&quot;</code></p>
<p>在对应module的<code>build.gradle</code>中添加plugin:<code>apply plugin: &#39;androidx.navigation.safeargs&#39;</code></p>
<p>我们在上面的Navigation Resource中的<code>fragmentB</code>中添加了三个<code>argument</code>节点，插件会帮我们自动生成<code>FragmentBArgs</code>类，我们可以这么使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">view.findViewById(R.id.jump).setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        FragmentBArgs.Builder builder= <span class="hljs-keyword">new</span>  <span class="hljs-title class_">FragmentBArgs</span>.Builder();<br>        builder.setNum(<span class="hljs-number">11111</span>);<br>        builder.setTitle(<span class="hljs-string">&quot;FragmentB&quot;</span>);<br>        Navigation.findNavController(v).navigate(R.id.action_fragmentA_to_fragmentB,builder.build().toBundle());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h4 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h4><p>尽管通过Navigation方式管理Fragment的代码简洁而且直观，但是有一个非常致命的问题，就是同一个Fragment会被重复创建，比如A到B，B再到C，然后点击返回键返回到B，这时B会被重建，再点击返回键返回到A，A也会被重建，目前还找不到解决方案，或许是我的使用方式不对</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>JetPack中的WorkManager</title>
    <url>/2020/02/25/JetPack%E4%B8%AD%E7%9A%84WorkManager/</url>
    <content><![CDATA[<p>2018年谷歌I&#x2F;O 发布了一系列辅助android开发者的实用工具，合称Jetpack，以帮助开发者构建出色的 Android 应用。<br>这次发布的 Android Jetpack 组件覆盖以下 4 个方面：Architecture、Foundation、Behavior 以及 UI。<br>该系列博客介绍一下Jetpack中常用组件，本篇介绍LiveData、ViewModel、LifeCycle。最后借助于<a href="https://github.com/android/sunflower">https://github.com/android/sunflower</a> 来写一个完整的应用</p>
<span id="more"></span>

<p>原文 <a href="https://developer.android.com/topic/libraries/architecture/workmanager?hl=zh-cn">https://developer.android.com/topic/libraries/architecture/workmanager?hl=zh-cn</a></p>
<p>使用 WorkManager API 可以轻松地调度即使在应用退出或设备重启时仍应运行的可延迟异步任务。</p>
<p><strong>主要功能</strong>：</p>
<ul>
<li>最高向后兼容到 API 14<ul>
<li>在运行 API 23 及以上级别的设备上使用 JobScheduler</li>
<li>在运行 API 14-22 的设备上结合使用 BroadcastReceiver 和 AlarmManager</li>
</ul>
</li>
<li>添加网络可用性或充电状态等工作约束</li>
<li>调度一次性或周期性异步任务</li>
<li>监控和管理计划任务</li>
<li>将任务链接起来</li>
<li>确保任务执行，即使应用或设备重启也同样执行任务</li>
<li>遵循低电耗模式等省电功能</li>
</ul>
<p>WorkManager 旨在用于<strong>可延迟</strong>运行（即不需要立即运行）并且在应用退出或设备重启时必须能够可靠运行的任务。例如：</p>
<ul>
<li>向后端服务发送日志或分析数据</li>
<li>定期将应用数据与服务器同步</li>
</ul>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>相关类：</p>
<ul>
<li><p>Worker<br> 任务的执行者，是一个抽象类，需要继承它实现要执行的任务。</p>
</li>
<li><p>WorkRequest<br> 指定让哪个 Woker 执行任务，指定执行的环境，执行的顺序等。<br> 要使用它的子类 OneTimeWorkRequest 或 PeriodicWorkRequest。</p>
</li>
<li><p>WorkManager<br> 管理任务请求和任务队列，发起的 WorkRequest 会进入它的任务队列。</p>
</li>
<li><p>WorkStatus<br> 包含有任务的状态和任务的信息，以 LiveData 的形式提供给观察者。</p>
</li>
</ul>
<h3 id="入门指南"><a href="#入门指南" class="headerlink" title="入门指南"></a>入门指南</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p><code>implementation &quot;androidx.work:work-runtime:2.3.2&quot;</code></p>
<h4 id="创建后台任务"><a href="#创建后台任务" class="headerlink" title="创建后台任务"></a>创建后台任务</h4><p>创建一个类，继承自<code>androidx.work.Worker</code>，并覆写其<code>public Result doWork()</code>方法，从 <code>doWork()</code> 返回的 <code>Result</code>会通知 WorkManager 任务是否：</p>
<ul>
<li>已成功完成：<code>Result.success()</code></li>
<li>已失败：<code>Result.failure()</code></li>
<li>需要稍后重试：<code>Result.retry()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Worker</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UploadWorker</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@NonNull</span> WorkerParameters workerParams)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, workerParams);<br>    &#125;<br><br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>        Log.e(<span class="hljs-string">&quot;UploadWorker input&quot;</span>,getInputData().getString(<span class="hljs-string">&quot;time&quot;</span>));<br>				<span class="hljs-comment">//do something</span><br>  	    <span class="hljs-keyword">return</span> Result.success();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="配置运行任务的方式和时间"><a href="#配置运行任务的方式和时间" class="headerlink" title="配置运行任务的方式和时间"></a>配置运行任务的方式和时间</h4><p><code>Worker</code> 定义工作单元，<a href="https://developer.android.com/reference/androidx/work/WorkRequest?hl=zh-cn"><code>WorkRequest</code></a> 则定义工作的运行方式和时间。任务可以是一次性的，也可以是周期性的。对于一次性 <code>WorkRequest</code>，请使用 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest?hl=zh-cn"><code>OneTimeWorkRequest</code></a>，对于周期性工作，请使用 <a href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest?hl=zh-cn"><code>PeriodicWorkRequest</code></a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">uploadWorkRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(UploadWorker.class)<br>            .build()<br>    <br></code></pre></td></tr></table></figure>

<h4 id="将任务提交给系统"><a href="#将任务提交给系统" class="headerlink" title="将任务提交给系统"></a>将任务提交给系统</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">WorkManager.getInstance(myContext).enqueue(uploadWorkRequest);<br></code></pre></td></tr></table></figure>

<p>执行 Worker 的确切时间取决于 <code>WorkRequest</code> 中使用的约束以及系统优化。</p>
<h3 id="定义工作请求"><a href="#定义工作请求" class="headerlink" title="定义工作请求"></a>定义工作请求</h3><h4 id="工作约束"><a href="#工作约束" class="headerlink" title="工作约束"></a>工作约束</h4><p>可以向工作添加 <code>Constraints</code>，以指明工作何时可以运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Constraints constraints=    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Constraints</span>.Builder()<br>  .setRequiredNetworkType(NetworkType.CONNECTED)  <span class="hljs-comment">// 网络状态</span><br>  .setRequiresBatteryNotLow(<span class="hljs-literal">true</span>)                 <span class="hljs-comment">// 不在电量不足时执行</span><br>  .setRequiresCharging(<span class="hljs-literal">true</span>)                      <span class="hljs-comment">// 在充电时执行</span><br>  .setRequiresStorageNotLow(<span class="hljs-literal">true</span>)                 <span class="hljs-comment">// 不在存储容量不足时执行</span><br>  <span class="hljs-comment">//.setRequiresDeviceIdle(true)                    // 在待机状态下执行，需要 API 23</span><br>  .build();<br><span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">compressionWork</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(UploadWorker.class)<br>  .setConstraints(constraints)<br>  .build();<br></code></pre></td></tr></table></figure>

<p>如果指定了多个约束，任务将仅在满足所有约束时才会运行。</p>
<p>如果在任务运行期间某个约束不再得到满足，则 WorkManager 将停止工作器。当约束继续得到满足时，系统将重新尝试执行该任务。</p>
<h4 id="初始延迟"><a href="#初始延迟" class="headerlink" title="初始延迟"></a>初始延迟</h4><p>如果Worker没有约束，或者工作加入队列时所有约束均已得到满足，则系统可能会选择立即运行任务。如果不希望任务立即运行，则可以将工作指定为在经过最短的初始延迟后启动。</p>
<p>下面的示例展示了如何将任务设置为在加入队列后至少经过 10 分钟再运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">uploadWorkRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(UploadWorker.class)<br>  .setInitialDelay(<span class="hljs-number">10</span>, TimeUnit.MINUTES)<br>  .build();<br></code></pre></td></tr></table></figure>

<h4 id="重试和退避政策"><a href="#重试和退避政策" class="headerlink" title="重试和退避政策"></a>重试和退避政策</h4><p>如果需要让 WorkManager 重新尝试执行任务，可以从工作器返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result?hl=zh-cn#retry()"><code>Result.retry()</code></a>。</p>
<p>然后，系统会根据默认的退避延迟时间和政策重新调度工作。退避延迟时间指定重试工作前的最短等待时间。<a href="https://developer.android.com/reference/androidx/work/BackoffPolicy?hl=zh-cn">退避政策</a>定义了在后续重试的尝试过程中，退避延迟时间随时间以怎样的方式增长；默认情况下按 <a href="https://developer.android.com/reference/androidx/work/BackoffPolicy?hl=zh-cn"><code>EXPONENTIAL</code></a> 延长。</p>
<p>以下是自定义退避延迟时间和政策的示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">uploadWorkRequest</span> <span class="hljs-operator">=</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(UploadWorker.class)<br>  .setBackoffCriteria(BackoffPolicy.LINEAR,<br>  OneTimeWorkRequest.MIN_BACKOFF_MILLIS,<br>  TimeUnit.MILLISECONDS)<br>  .build();<br></code></pre></td></tr></table></figure>

<h4 id="定义任务的输入-x2F-输出"><a href="#定义任务的输入-x2F-输出" class="headerlink" title="定义任务的输入&#x2F;输出"></a>定义任务的输入&#x2F;输出</h4><p>可以通过使用<code>androidx.work.Data</code>来定义输入或者输出</p>
<p>在<code>UploadWorker</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>  Log.e(<span class="hljs-string">&quot;UploadWorker input&quot;</span>,getInputData().getString(<span class="hljs-string">&quot;time&quot;</span>));<br>  <span class="hljs-type">Data</span> <span class="hljs-variable">outputData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>.Builder()<br>    .putLong(<span class="hljs-string">&quot;timestamp&quot;</span>,System.currentTimeMillis())<br>    .build();<br>  <span class="hljs-keyword">return</span> Result.success(outputData); <br>&#125;<br></code></pre></td></tr></table></figure>

<p>在调用时 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Data</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>.Builder()<br>  .putString(<span class="hljs-string">&quot;time&quot;</span>,simpleDateFormat.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()))<br>  .build();<br><br><span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">uploadWorkRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(UploadWorker.class)<br>  .setConstraints(constraints)<br>  .setInputData(data) <span class="hljs-comment">//定义输入</span><br>  .build();<br>WorkManager.getInstance(<span class="hljs-built_in">this</span>).enqueue(uploadWorkRequest);<br>        WorkManager.getInstance(<span class="hljs-built_in">this</span>).getWorkInfoByIdLiveData(uploadWorkRequest.getId()).observe(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;WorkInfo&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onChanged</span><span class="hljs-params">(WorkInfo workInfo)</span> &#123;<br><br>                 <span class="hljs-type">long</span> <span class="hljs-variable">timeStamp</span> <span class="hljs-operator">=</span> workInfo.getOutputData().getLong(<span class="hljs-string">&quot;timestamp&quot;</span>,<span class="hljs-number">0</span>);<br>                Log.e(<span class="hljs-string">&quot;UploadWorker output&quot;</span>,simpleDateFormat.format(timeStamp) +<span class="hljs-string">&quot;---&gt;&quot;</span>+workInfo.getState());<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure>

<p>非常重要的一点：</p>
<p><strong>按照设计，<code>Data</code> 对象应该很小，值可以是字符串、基元类型或数组变体。如果需要将更多数据传入和传出工作器，应该将数据放在其他位置，例如 Room 数据库。Data 对象的大小上限为 10KB。</strong></p>
<h4 id="标记工作"><a href="#标记工作" class="headerlink" title="标记工作"></a>标记工作</h4><p>可以通过为任意 <a href="https://developer.android.com/reference/androidx/work/WorkRequest?hl=zh-cn"><code>WorkRequest</code></a> 对象分配标记字符串，按逻辑对任务进行分组。这样就可以对使用特定标记的所有任务执行操作。</p>
<p>例如，<a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#cancelAllWorkByTag(java.lang.String)"><code>WorkManager.cancelAllWorkByTag(String)</code></a> 会取消使用特定标记的所有任务，而 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#getWorkInfosByTagLiveData(java.lang.String)"><code>WorkManager.getWorkInfosByTagLiveData(String)</code></a> 会返回 <a href="https://developer.android.com/reference/androidx/lifecycle/LiveData?hl=zh-cn"><code>LiveData</code></a> 和具有该标记的所有任务的状态列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">cacheCleanupTask</span> <span class="hljs-operator">=</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(CacheCleanupWorker.class)<br>  .setConstraints(constraints)<br>  .addTag(<span class="hljs-string">&quot;cleanup&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure>

<h4 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h4><ul>
<li>如果有尚未完成的<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/chain-work?hl=zh-cn">前提性工作</a>，则工作处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn#BLOCKED"><code>BLOCKED</code></a> <code>State</code>。</li>
<li>如果工作能够在满足 <a href="https://developer.android.com/reference/androidx/work/Constraints?hl=zh-cn"><code>Constraints</code></a> 和时机条件后立即运行，则被视为处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn#ENQUEUED"><code>ENQUEUED</code></a> 状态。</li>
<li>当工作器在活跃地执行时，其处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn#RUNNING"><code>RUNNING</code></a> <code>State</code>。</li>
<li>如果工作器返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result?hl=zh-cn#success()"><code>Result.success()</code></a>，则被视为处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn#SUCCEEDED"><code>SUCCEEDED</code></a> 状态。这是一种终止 <code>State</code>；只有 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest?hl=zh-cn"><code>OneTimeWorkRequest</code></a> 可以进入这种 <code>State</code>。</li>
<li>相反，如果工作器返回 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker.Result?hl=zh-cn#failure()"><code>Result.failure()</code></a>，则被视为处于 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn#FAILED"><code>FAILED</code></a> 状态。这也是一个终止 <code>State</code>；只有 <a href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest?hl=zh-cn"><code>OneTimeWorkRequest</code></a> 可以进入这种 <code>State</code>。所有依赖工作也会被标记为 <code>FAILED</code>，并且不会运行。</li>
<li>当明确<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/cancel-stop-work?hl=zh-cn">取消</a>尚未终止的 <code>WorkRequest</code> 时，它会进入 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn#CANCELLED"><code>CANCELLED</code></a> <code>State</code>。所有依赖工作也会被标记为 <code>CANCELLED</code>，并且不会运行。</li>
</ul>
<h4 id="观察工作"><a href="#观察工作" class="headerlink" title="观察工作"></a>观察工作</h4><p>将工作加入队列后，可以通过 WorkManager 检查其状态。相关信息在 <a href="https://developer.android.com/reference/androidx/work/WorkInfo?hl=zh-cn"><code>WorkInfo</code></a> 对象中提供，包括工作的 <code>id</code>、标签、当前 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn"><code>State</code></a> 和任何输出数据。</p>
<p>可以通过以下三种方式之一来获取 <code>WorkInfo</code>：</p>
<ul>
<li>对于特定的 <a href="https://developer.android.com/reference/androidx/work/WorkRequest?hl=zh-cn"><code>WorkRequest</code></a>，可以利用 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#getWorkInfoById(java.util.UUID)"><code>WorkManager.getWorkInfoById(UUID)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#getWorkInfoByIdLiveData(java.util.UUID)"><code>WorkManager.getWorkInfoByIdLiveData(UUID)</code></a> 来通过 <code>WorkRequest</code> <code>id</code> 检索其 <code>WorkInfo</code>。</li>
<li>对于指定的<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work?hl=zh-cn#tag">标记</a>，可以利用 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#getWorkInfosByTag(java.lang.String)"><code>WorkManager.getWorkInfosByTag(String)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#getWorkInfosByTagLiveData(java.lang.String)"><code>WorkManager.getWorkInfosByTagLiveData(String)</code></a> 检索所有匹配的 <code>WorkRequest</code> 的 <code>WorkInfo</code> 对象。</li>
<li>对于<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/unique-work?hl=zh-cn">唯一工作名称</a>，可以利用 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#getWorkInfosForUniqueWork(java.lang.String)"><code>WorkManager.getWorkInfosForUniqueWork(String)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#getWorkInfosForUniqueWorkLiveData(java.lang.String)"><code>WorkManager.getWorkInfosForUniqueWorkLiveData(String)</code></a> 检索所有匹配的 <code>WorkRequest</code> 的 <code>WorkInfo</code> 对象。</li>
</ul>
<p>利用每个方法的 <a href="https://developer.android.com/topic/libraries/architecture/livedata?hl=zh-cn"><code>LiveData</code></a> 变量，可以通过注册监听器来观察 <code>WorkInfo</code> 的变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">WorkManager.getInstance(myContext).getWorkInfoByIdLiveData(uploadWorkRequest.getId())<br>  .observe(lifecycleOwner, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;WorkInfo&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onChanged</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> WorkInfo workInfo)</span> &#123;<br>      <span class="hljs-keyword">if</span> (workInfo != <span class="hljs-literal">null</span> &amp;&amp; workInfo.state == WorkInfo.State.SUCCEEDED) &#123;<br>        displayMessage(<span class="hljs-string">&quot;Work finished!&quot;</span>)<br>      &#125;<br>    &#125;<br>  &#125;);<br></code></pre></td></tr></table></figure>

<h4 id="更新进度"><a href="#更新进度" class="headerlink" title="更新进度"></a>更新进度</h4><p>对于使用 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker?hl=zh-cn"><code>ListenableWorker</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/Worker?hl=zh-cn"><code>Worker</code></a> 的 Java 开发者，<a href="https://developer.android.com/reference/androidx/work/ListenableWorker?hl=zh-cn#setProgressAsync(androidx.work.Data)"><code>setProgressAsync()</code></a> API 会返回 <code>ListenableFuture</code>；更新进度是异步过程，因为更新过程包括将进度信息存储在数据库中。</p>
<p>此示例展示了一个简单的 <code>ProgressWorker</code>。该 <code>Worker</code> 启动时将进度设置为 0，完成时将进度值更新为 100。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProgressWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Worker</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PROGRESS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;PROGRESS&quot;</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">DELAY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProgressWorker</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> Context context,</span><br><span class="hljs-params">    <span class="hljs-meta">@NonNull</span> WorkerParameters parameters)</span> &#123;<br>    <span class="hljs-built_in">super</span>(context, parameters);<br>    <span class="hljs-comment">// Set initial progress to 0</span><br>    setProgressAsync(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>.Builder().putInt(PROGRESS, <span class="hljs-number">0</span>).build());<br>  &#125;<br><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// Doing work.</span><br>      Thread.sleep(DELAY);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException exception) &#123;<br>      <span class="hljs-comment">// ... handle exception</span><br>    &#125;<br>    <span class="hljs-comment">// Set progress to 100 after you are done doing your work.</span><br>    setProgressAsync(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>.Builder().putInt(PROGRESS, <span class="hljs-number">100</span>).build());<br>    <span class="hljs-keyword">return</span> Result.success();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="观察进度"><a href="#观察进度" class="headerlink" title="观察进度"></a>观察进度</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">WorkManager.getInstance(getApplicationContext())<br>  .getWorkInfoByIdLiveData(uploadWorkRequest.getId())<br>  .observe(lifecycleOwner, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>&lt;WorkInfo&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onChanged</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> WorkInfo workInfo)</span> &#123;<br>      <span class="hljs-keyword">if</span> (workInfo != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">progress</span> <span class="hljs-operator">=</span> workInfo.getProgress();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> progress.getInt(PROGRESS, <span class="hljs-number">0</span>)<br>          <span class="hljs-comment">// Do something with progress</span><br>      &#125;<br>    &#125;<br>  &#125;);<br>    <br></code></pre></td></tr></table></figure>

<h3 id="链接工作"><a href="#链接工作" class="headerlink" title="链接工作"></a>链接工作</h3><p>就像动画的执行可以确定顺序、依赖一样，Worker的执行也可以这么操作</p>
<p>可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn">WorkManager</a> 创建工作链并为其排队。工作链用于指定多个关联任务并定义这些任务的运行顺序。当需要以特定的顺序运行多个任务时，这尤其有用。</p>
<p>要创建工作链，可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#beginWith(androidx.work.OneTimeWorkRequest)"><code>WorkManager.beginWith(OneTimeWorkRequest)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#beginWith(java.util.List)"><code>WorkManager.beginWith(List)</code></a>，这会返回 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation?hl=zh-cn"><code>WorkContinuation</code></a> 实例。</p>
<p>然后，可以通过 <code>WorkContinuation</code> 使用 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation?hl=zh-cn#then(androidx.work.OneTimeWorkRequest)"><code>WorkContinuation.then(OneTimeWorkRequest)</code></a> 或 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation?hl=zh-cn#then(java.util.List)"><code>WorkContinuation.then(List)</code></a> 来添加从属 <code>OneTimeWorkRequest</code>。</p>
<p>每次调用 <code>WorkContinuation.then(...)</code> 都会返回一个新的 <code>WorkContinuation</code> 实例。如果添加了 <code>OneTimeWorkRequest</code> 的 <code>List</code>，这些请求可能会并行运行。</p>
<p>最后，可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkContinuation?hl=zh-cn#enqueue()"><code>WorkContinuation.enqueue()</code></a> 方法为 <code>WorkContinuation</code> 链排队。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">WorkManager.getInstance(myContext)<br>  .beginWith(Arrays.asList(filter1, filter2, filter3)) <br>  .then(compress)<br>  .then(upload)<br>  .enqueue();<br></code></pre></td></tr></table></figure>

<p>这里的filter是OneTimeWorkRequest实例对象</p>
<h4 id="Input-Merger"><a href="#Input-Merger" class="headerlink" title="Input Merger"></a>Input Merger</h4><p>在使用 <code>OneTimeWorkRequest</code> 链时，父级 <code>OneTimeWorkRequest</code> 的输出将作为输入传递给子级。因此在上面的示例中，<code>filter1</code>、<code>filter2</code> 和 <code>filter3</code> 的输出将作为输入传递给 <code>compress</code> 请求。</p>
<p>为了管理来自多个父级 <code>OneTimeWorkRequest</code> 的输入，WorkManager 使用 <a href="https://developer.android.com/reference/androidx/work/InputMerger?hl=zh-cn"><code>InputMerger</code></a>。</p>
<p>WorkManager 提供两种不同类型的 <code>InputMerger</code>：</p>
<ul>
<li><a href="https://developer.android.com/reference/androidx/work/OverwritingInputMerger?hl=zh-cn"><code>OverwritingInputMerger</code></a> 会尝试将所有输入中的所有键添加到输出中。如果发生冲突，它会覆盖先前设置的键。</li>
<li><a href="https://developer.android.com/reference/androidx/work/ArrayCreatingInputMerger?hl=zh-cn"><code>ArrayCreatingInputMerger</code></a> 会尝试合并输入，并在必要时创建数组。</li>
</ul>
<p>对于上面的示例，假设我们要保留所有图像滤镜的输出，则应使用 <code>ArrayCreatingInputMerger</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">compress</span> <span class="hljs-operator">=</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(CompressWorker.class)<br>  .setInputMerger(ArrayCreatingInputMerger.class)<br>  .setConstraints(constraints)<br>  .build();<br></code></pre></td></tr></table></figure>

<h4 id="链接和工作状态"><a href="#链接和工作状态" class="headerlink" title="链接和工作状态"></a>链接和工作状态</h4><p>创建 <code>OneTimeWorkRequest</code> 链时，需要注意以下几点：</p>
<ul>
<li>从属 <code>OneTimeWorkRequest</code> 仅在其所有父级 <code>OneTimeWorkRequest</code> 都成功完成（即返回 <code>Result.success()</code>）时才会被解除阻塞（变为 <code>ENQUEUED</code> 状态）。</li>
<li>如果有任何父级 <code>OneTimeWorkRequest</code> 失败（返回 <code>Result.failure()</code>），则所有从属 <code>OneTimeWorkRequest</code> 也会被标记为 <code>FAILED</code>。</li>
<li>如果有任何父级 <code>OneTimeWorkRequest</code> 被取消，则所有从属 <code>OneTimeWorkRequest</code> 也会被标记为 <code>CANCELLED</code></li>
</ul>
<h3 id="取消和停止工作"><a href="#取消和停止工作" class="headerlink" title="取消和停止工作"></a>取消和停止工作</h3><p>如果不再需要运行先前加入队列的作业，则可以申请取消。最简单的方法是使用其 <code>id</code> 并调用 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#cancelWorkById(java.util.UUID)"><code>WorkManager.cancelWorkById(UUID)</code></a> 来取消单个 WorkRequest：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">WorkManager.cancelWorkById(workRequest.getId());<br></code></pre></td></tr></table></figure>

<p>在后台，WorkManager 会检查工作的 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn"><code>State</code></a>。如果工作已经<a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn#isFinished()">完成</a>，则不会发生任何变化。否则，其状态将更改为 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn#CANCELLED"><code>CANCELLED</code></a>，之后就不会运行这个工作。任何<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/chain-work?hl=zh-cn">依赖于这项工作</a>的 <a href="https://developer.android.com/reference/androidx/work/WorkRequest?hl=zh-cn"><code>WorkRequests</code></a> 的状态也将变为 <code>CANCELLED</code>。</p>
<p>此外，如果工作当前的状态为 <a href="https://developer.android.com/reference/androidx/work/WorkInfo.State?hl=zh-cn#RUNNING"><code>RUNNING</code></a>，则工作器也会收到对 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker?hl=zh-cn#onStopped()"><code>ListenableWorker.onStopped()</code></a> 的调用。替换此方法以处理任何可能的清理操作。</p>
<p>也可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#cancelAllWorkByTag(java.lang.String)"><code>WorkManager.cancelAllWorkByTag(String)</code></a> 按标记取消 WorkRequest。请注意，此方法会取消所有具有此标记的工作。此外，还可以使用 <a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#cancelUniqueWork(java.lang.String)"><code>WorkManager.cancelUniqueWork(String)</code></a> 取消具有唯一名称的所有工作。</p>
<h4 id="停止正在运行的工作器"><a href="#停止正在运行的工作器" class="headerlink" title="停止正在运行的工作器"></a>停止正在运行的工作器</h4><p>WorkManager 停止正在运行的工作器可能有几种不同的原因：</p>
<ul>
<li>明确要求取消它（例如，通过调用 <code>WorkManager.cancelWorkById(UUID)</code> 取消）。</li>
<li>如果是<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/unique-work?hl=zh-cn">唯一工作</a>，使用 <a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy?hl=zh-cn"><code>ExistingWorkPolicy</code></a> <a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/'reference/androidx/work/ExistingWorkPolicy#REPLACE"><code>REPLACE</code></a> 明确地将新的 <code>WorkRequest</code> 加入队列。旧的 <code>WorkRequest</code> 会立即被视为已终止。</li>
<li>工作约束已不再得到满足。</li>
<li>系统出于某种原因指示您的应用停止工作。如果超过 10 分钟的执行期限，可能会发生这种情况。系统将工作安排在稍后重试。</li>
</ul>
<p>在这些情况下，会收到对 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker?hl=zh-cn#onStopped()"><code>ListenableWorker.onStopped()</code></a> 的调用。如果操作系统决定关闭应用，应执行清理工作并以协作方式完成工作器。例如，应该在此时或者尽早关闭数据库和文件的打开句柄。此外，如果想要确认系统是否已经停止你应用，都可以调用 <a href="https://developer.android.com/reference/androidx/work/ListenableWorker?hl=zh-cn#isStopped()"><code>ListenableWorker.isStopped()</code></a>。即使通过在调用 <code>onStopped()</code> 后返回 <a href="https://developer.android.com/reference/androidx/work/Result?hl=zh-cn"><code>Result</code></a> 来指示工作已完成，WorkManager 都会忽略该 <code>Result</code>，因为工作器已经被视为停止。</p>
<h3 id="重复性工作"><a href="#重复性工作" class="headerlink" title="重复性工作"></a>重复性工作</h3><p>应用有时可能需要定期运行某些任务。例如，您可能要定期备份数据、下载应用中的新鲜内容，或者上传日志到服务器。 <a href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest?hl=zh-cn"><code>PeriodicWorkRequest</code></a> 用于这种需要定期执行的任务。需要注意的是<code>PeriodicWorkRequest</code> 无法和其他任务进行链接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Constraints</span> <span class="hljs-variable">constraints</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Constraints</span>.Builder().setRequiresCharging(<span class="hljs-literal">true</span>).build();<br><br><span class="hljs-type">PeriodicWorkRequest</span> <span class="hljs-variable">saveRequest</span> <span class="hljs-operator">=</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeriodicWorkRequest</span>.Builder(SaveImageFileWorker.class, <span class="hljs-number">1</span>, TimeUnit.HOURS)<br>  .setConstraints(constraints)<br>  .build();<br><br>WorkManager.getInstance(myContext)<br>  .enqueue(saveRequest);<br></code></pre></td></tr></table></figure>

<h3 id="唯一工作"><a href="#唯一工作" class="headerlink" title="唯一工作"></a>唯一工作</h3><p>唯一工作是一个概念性非常强的术语，可确保一次只有一个具有特定名称的工作链。与 <code>id</code> 不同的是，唯一名称是人类可读的，由开发者指定，而不是由 WorkManager 自动生成。与<a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/define-work?hl=zh-cn#tag">标记</a>不同，唯一名称仅与“一个”工作链关联。</p>
<p>可以通过调用 [<code>WorkManager.enqueueUniqueWork(String, ExistingWorkPolicy, OneTimeWorkRequest)</code>](<a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#enqueueUniqueWork">https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#enqueueUniqueWork</a>(java.lang.String, androidx.work.ExistingWorkPolicy, androidx.work.OneTimeWorkRequest)) 或 [<code>WorkManager.enqueueUniquePeriodicWork(String, ExistingPeriodicWorkPolicy, PeriodicWorkRequest)</code>](<a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#enqueueUniquePeriodicWork">https://developer.android.com/reference/androidx/work/WorkManager?hl=zh-cn#enqueueUniquePeriodicWork</a>(java.lang.String, androidx.work.ExistingPeriodicWorkPolicy, androidx.work.PeriodicWorkRequest)) 创建唯一工作序列。第一个参数是唯一名称 - 这是我们用来标识 <code>WorkRequest</code> 的键。第二个参数是冲突解决策略，它指定了如果已经存在一个具有该唯一名称的未完成工作链，WorkManager 应该如何处理：</p>
<ul>
<li>取消现有工作链，并将其 <a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy?hl=zh-cn#REPLACE"><code>REPLACE</code></a> 为新工作链。</li>
<li><a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy?hl=zh-cn#KEEP"><code>KEEP</code></a> 现有序列并忽略您的新请求。</li>
<li>将新序列 <a href="https://developer.android.com/reference/androidx/work/ExistingWorkPolicy?hl=zh-cn#APPEND"><code>APPEND</code></a> 到现有序列，在现有序列的最后一个任务完成后运行新序列的第一个任务。您不能将 <code>APPEND</code> 与 <code>PeriodicWorkRequest</code> 一起使用。</li>
</ul>
<p>当有不能够多次排队的任务时，唯一工作将非常有用。例如，如果应用需要将其数据同步到网络，可能需要对一个名为“sync”的序列进行排队，并指定当已经存在具有该名称的序列时，应该忽略新的任务。当需要逐步构建一个长任务链时，也可以利用唯一工作序列。例如，照片编辑应用可能允许用户撤消一长串操作。其中的每一项撤消操作可能都需要一些时间来完成，但必须按正确的顺序执行。在这种情况下，应用可以创建一个“撤消”链，并根据需要将每个撤消操作附加到该链上。</p>
<p>最后，如果需要创建一个唯一工作链，可以使用 [<code>WorkManager.beginUniqueWork(String, ExistingWorkPolicy, OneTimeWorkRequest)</code>](<a href="https://developer.android.com/reference/androidx/work/WorkManager?hl=en#beginUniqueWork">https://developer.android.com/reference/androidx/work/WorkManager?hl=en#beginUniqueWork</a>(java.lang.String, androidx.work.ExistingWorkPolicy, androidx.work.OneTimeWorkRequest)) 代替 <code>beginWith()</code>。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><a href="https://developer.android.com/topic/libraries/architecture/workmanager/how-to/testing?hl=zh-cn">https://developer.android.com/topic/libraries/architecture/workmanager/how-to/testing?hl=zh-cn</a></p>
<h4 id="简介与设置"><a href="#简介与设置" class="headerlink" title="简介与设置"></a>简介与设置</h4><p><a href="https://developer.android.com/topic/libraries/architecture/workmanager?hl=zh-cn">WorkManager</a> 提供了一个 <code>work-testing</code> 工件，可以协助进行 Android 插桩测试中的工作器单元测试。</p>
<p>要使用 <code>work-testing</code> 工件，您应该将它作为 <code>androidTestImplementation</code> 依赖项添加到 <code>build.gradle</code> 中。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>work-testing</code> 为测试模式提供了一种特殊的 WorkManager 实现，它通过使用 <a href="https://developer.android.com/reference/androidx/work/testing/WorkManagerTestInitHelper?hl=zh-cn"><code>WorkManagerTestInitHelper</code></a> 来初始化。</p>
<p><code>work-testing</code> 工件还提供了 <a href="https://developer.android.com/reference/androidx/work/testing/SynchronousExecutor?hl=zh-cn"><code>SynchronousExecutor</code></a>，让您可以更加轻松地以同步方式编写测试，而无需处理多个线程、锁定或锁存。</p>
<p>以下示例展示了如何将所有这些类一起使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(AndroidJUnit4.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicInstrumentationTest</span> &#123;<br>  <span class="hljs-meta">@Before</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> InstrumentationRegistry.getTargetContext();<br>    <span class="hljs-type">Configuration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>.Builder()<br>      <span class="hljs-comment">// Set log level to Log.DEBUG to</span><br>      <span class="hljs-comment">// make it easier to see why tests failed</span><br>      .setMinimumLoggingLevel(Log.DEBUG)<br>      <span class="hljs-comment">// Use a SynchronousExecutor to make it easier to write tests</span><br>      .setExecutor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousExecutor</span>())<br>      .build();<br><br>    <span class="hljs-comment">// Initialize WorkManager for instrumentation tests.</span><br>    WorkManagerTestInitHelper.initializeTestWorkManager(<br>      context, config);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="构造测试"><a href="#构造测试" class="headerlink" title="构造测试"></a>构造测试</h4><p>现在 WorkManager 已在测试模式中初始化，您可以测试您的工作器了。</p>
<p>假设您有一个 <code>EchoWorker</code>，它需要一些 <code>inputData</code> 并简单地将其输入复制（回显）到其 <code>outputData</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Worker</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">EchoWorker</span><span class="hljs-params">(Context context, WorkerParameters parameters)</span> &#123;<br>    <span class="hljs-built_in">super</span>(context, parameters);<br>  &#125;<br><br>  <span class="hljs-meta">@NonNull</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Data</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> getInputData();<br>    <span class="hljs-keyword">if</span> (input.size() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> Result.failure();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> Result.success(input);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="基本测试"><a href="#基本测试" class="headerlink" title="基本测试"></a>基本测试</h4><p>以下是一个对 <code>EchoWorker</code> 进行测试的 Android 插桩测试。这里的要点是，在测试模式中测试 <code>EchoWorker</code> 与在真实应用中使用 <code>EchoWorker</code> 非常相似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSimpleEchoWorker</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// Define input data</span><br>  <span class="hljs-type">Data</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>.Builder()<br>    .put(KEY_1, <span class="hljs-number">1</span>)<br>    .put(KEY_2, <span class="hljs-number">2</span>)<br>    .build();<br><br>  <span class="hljs-comment">// Create request</span><br>  <span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(EchoWorker.class)<br>    .setInputData(input)<br>    .build();<br><br>  <span class="hljs-type">WorkManager</span> <span class="hljs-variable">workManager</span> <span class="hljs-operator">=</span> WorkManager.getInstance(getApplicationContext());<br>  <span class="hljs-comment">// Enqueue and wait for result. This also runs the Worker synchronously</span><br>  <span class="hljs-comment">// because we are using a SynchronousExecutor.</span><br>  workManager.enqueue(request).getResult().get();<br>  <span class="hljs-comment">// Get WorkInfo and outputData</span><br>  <span class="hljs-type">WorkInfo</span> <span class="hljs-variable">workInfo</span> <span class="hljs-operator">=</span> workManager.getWorkInfoById(request.getId()).get();<br>  <span class="hljs-type">Data</span> <span class="hljs-variable">outputData</span> <span class="hljs-operator">=</span> workInfo.getOutputData();<br>  <span class="hljs-comment">// Assert</span><br>  assertThat(workInfo.getState(), is(WorkInfo.State.SUCCEEDED));<br>  assertThat(outputData, is(input));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们来编写另一个测试，它将确保在 <code>EchoWorker</code> 没有获得任何输入数据时，其预期的 <code>Result</code> 为 <code>Result.failure()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testEchoWorkerNoInput</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// Create request</span><br>  <span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(EchoWorker.class)<br>    .build();<br><br>  <span class="hljs-type">WorkManager</span> <span class="hljs-variable">workManager</span> <span class="hljs-operator">=</span> WorkManager.getInstance(getApplicationContext());<br>  <span class="hljs-comment">// Enqueue and wait for result. This also runs the Worker synchronously</span><br>  <span class="hljs-comment">// because we are using a SynchronousExecutor.</span><br>  workManager.enqueue(request).getResult().get();<br>  <span class="hljs-comment">// Get WorkInfo</span><br>  <span class="hljs-type">WorkInfo</span> <span class="hljs-variable">workInfo</span> <span class="hljs-operator">=</span> workManager.getWorkInfoById(request.getId()).get();<br>  <span class="hljs-comment">// Assert</span><br>  assertThat(workInfo.getState(), is(WorkInfo.State.FAILED));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="模拟约束、延迟和定期工作"><a href="#模拟约束、延迟和定期工作" class="headerlink" title="模拟约束、延迟和定期工作"></a>模拟约束、延迟和定期工作</h4><p><code>WorkManagerTestInitHelper</code> 为您提供了一个 <a href="https://developer.android.com/reference/androidx/work/testing/TestDriver?hl=zh-cn"><code>TestDriver</code></a> 实例，可用于模拟 <code>initialDelay</code>、<code>ListenableWorker</code> 满足 <code>Constraint</code> 的条件，以及 <code>PeriodicWorkRequest</code> 的间隔。</p>
<p>测试初始延迟</p>
<p><code>Worker</code> 可以具有初始延迟。要测试含有 <code>EchoWorker</code> 的 <code>initialDelay</code>，而不必在测试中等待 <code>initialDelay</code>，您可以使用 <code>TestDriver</code> 将 <code>WorkRequest</code> 初始延迟标记为已满足条件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWithInitialDelay</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// Define input data</span><br>  <span class="hljs-type">Data</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>.Builder()<br>    .put(KEY_1, <span class="hljs-number">1</span>)<br>    .put(KEY_2, <span class="hljs-number">2</span>)<br>    .build();<br><br>  <span class="hljs-comment">// Create request</span><br>  <span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(EchoWorker.class)<br>    .setInputData(input)<br>    .setInitialDelay(<span class="hljs-number">10</span>, TimeUnit.SECONDS)<br>    .build();<br><br>  <span class="hljs-type">WorkManager</span> <span class="hljs-variable">workManager</span> <span class="hljs-operator">=</span> WorkManager.getInstance(myContext);<br>  <span class="hljs-comment">// Get the TestDriver</span><br>  <span class="hljs-type">TestDriver</span> <span class="hljs-variable">testDriver</span> <span class="hljs-operator">=</span> WorkManagerTestInitHelper.getTestDriver();<br>  <span class="hljs-comment">// Enqueue</span><br>  workManager.enqueue(request).getResult().get();<br>  <span class="hljs-comment">// Tells the WorkManager test framework that initial delays are now met.</span><br>  testDriver.setInitialDelayMet(request.getId());<br>  <span class="hljs-comment">// Get WorkInfo and outputData</span><br>  <span class="hljs-type">WorkInfo</span> <span class="hljs-variable">workInfo</span> <span class="hljs-operator">=</span> workManager.getWorkInfoById(request.getId()).get();<br>  <span class="hljs-type">Data</span> <span class="hljs-variable">outputData</span> <span class="hljs-operator">=</span> workInfo.getOutputData();<br>  <span class="hljs-comment">// Assert</span><br>  assertThat(workInfo.getState(), is(WorkInfo.State.SUCCEEDED));<br>  assertThat(outputData, is(input));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="测试约束"><a href="#测试约束" class="headerlink" title="测试约束"></a>测试约束</h4><p><code>TestDriver</code> 也可用于利用 <code>setAllConstraintsMet</code> 将约束标记为已满足条件。以下示例展示了如何测试含有约束的 <code>Worker</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWithConstraints</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// Define input data</span><br>  <span class="hljs-type">Data</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>.Builder()<br>    .put(KEY_1, <span class="hljs-number">1</span>)<br>    .put(KEY_2, <span class="hljs-number">2</span>)<br>    .build();<br><br>  <span class="hljs-comment">// Define constraints</span><br>  <span class="hljs-type">Constraints</span> <span class="hljs-variable">constraints</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Constraints</span>.Builder()<br>    .setRequiresDeviceIdle(<span class="hljs-literal">true</span>)<br>    .build();<br><br>  <span class="hljs-comment">// Create request</span><br>  <span class="hljs-type">OneTimeWorkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OneTimeWorkRequest</span>.Builder(EchoWorker.class)<br>    .setInputData(input)<br>    .setConstraints(constraints)<br>    .build();<br><br>  <span class="hljs-type">WorkManager</span> <span class="hljs-variable">workManager</span> <span class="hljs-operator">=</span> WorkManager.getInstance(myContext);<br>  <span class="hljs-type">TestDriver</span> <span class="hljs-variable">testDriver</span> <span class="hljs-operator">=</span> WorkManagerTestInitHelper.getTestDriver();<br>  <span class="hljs-comment">// Enqueue</span><br>  workManager.enqueue(request).getResult().get();<br>  <span class="hljs-comment">// Tells the testing framework that all constraints are met.</span><br>  testDriver.setAllConstraintsMet(request.getId());<br>  <span class="hljs-comment">// Get WorkInfo and outputData</span><br>  <span class="hljs-type">WorkInfo</span> <span class="hljs-variable">workInfo</span> <span class="hljs-operator">=</span> workManager.getWorkInfoById(request.getId()).get();<br>  <span class="hljs-type">Data</span> <span class="hljs-variable">outputData</span> <span class="hljs-operator">=</span> workInfo.getOutputData();<br>  <span class="hljs-comment">// Assert</span><br>  assertThat(workInfo.getState(), is(WorkInfo.State.SUCCEEDED));<br>  assertThat(outputData, is(input));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="测试定期工作"><a href="#测试定期工作" class="headerlink" title="测试定期工作"></a>测试定期工作</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPeriodicWork</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// Define input data</span><br>  <span class="hljs-type">Data</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>.Builder()<br>    .put(KEY_1, <span class="hljs-number">1</span>)<br>    .put(KEY_2, <span class="hljs-number">2</span>)<br>    .build();<br><br>  <span class="hljs-comment">// Create request</span><br>  <span class="hljs-type">PeriodicWorkRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">PeriodicWorkRequest</span>.Builder(EchoWorker.class, <span class="hljs-number">15</span>, MINUTES)<br>    .setInputData(input)<br>    .build();<br><br>  <span class="hljs-type">WorkManager</span> <span class="hljs-variable">workManager</span> <span class="hljs-operator">=</span> WorkManager.getInstance(myContext);<br>  <span class="hljs-type">TestDriver</span> <span class="hljs-variable">testDriver</span> <span class="hljs-operator">=</span> WorkManagerTestInitHelper.getTestDriver();<br>  <span class="hljs-comment">// Enqueue</span><br>  workManager.enqueue(request).getResult().get();<br>  <span class="hljs-comment">// Tells the testing framework the period delay is met</span><br>  testDriver.setPeriodDelayMet(request.getId());<br>  <span class="hljs-comment">// Get WorkInfo and outputData</span><br>  <span class="hljs-type">WorkInfo</span> <span class="hljs-variable">workInfo</span> <span class="hljs-operator">=</span> workManager.getWorkInfoById(request.getId()).get();<br>  <span class="hljs-comment">// Assert</span><br>  assertThat(workInfo.getState(), is(WorkInfo.State.ENQUEUED));<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin中的函数类型及 Lambda 表达式</title>
    <url>/2024/04/23/Kotlin%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8F%8A-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>继续上次在扩展函数中遗留下的问题：函数类型。总所周知，在Kotlin 中函数是一等公民。那么什么是高阶函数嘞？到处翻了翻，发现差不多是这么个意思：<strong>接受一个或多个函数作为参数，或者返回一个函数。</strong>在 Kotlin 协程中的 launch、async函数以及各种各样的框架中到处都是高阶函数的影子，称高阶函数是 Kotlin函数式编程、各大框架的基石也不过分。</p>
<span id="more"></span>

<p>不得不说，这里面概念挺多的，有的时候我们会用，但并不知道叫什么名字。有的知道名字但不知道是什么东西。</p>
<ul>
<li>高阶函数</li>
<li>扩展函数</li>
<li>Lambda</li>
<li>SAM转换</li>
<li>带接收者的函数类型</li>
<li>带有接收者的函数字面值</li>
</ul>
<p>问题不大，慢慢整，慢慢理解，多读几遍文档，参考一下别人的看法，也就熟悉了。</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>这里想表达的并不是说kotlin 中的函数分类，比如什么内联函数、扩展函数、标准函数、高阶函数等等这种分类，而是说在函数作为返回值或者参数的时候，我们怎么确认这个函数就是我们想要的类型，或者说如何使用编程语言来描述一个函数。比如我们在调用函数的时候传入的参数，我们会讲这个函数需要一个 Int 类型的参数，那如果我们调用的函数需要另外一个函数作为参数我们应该怎么表示嘞？这里就引出了函数类型。<br>举个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionA</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Unit</span>&#123;<br>    println(<span class="hljs-string">&quot;functionA&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionA1</span><span class="hljs-params">(name:<span class="hljs-type">String</span>)</span></span>:<span class="hljs-built_in">Unit</span>&#123;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionA11</span><span class="hljs-params">(name:<span class="hljs-type">String</span>)</span></span>:String&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi <span class="hljs-variable">$name</span>&quot;</span><br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们应该如何描述上面的三个方法嘞？</p>
<blockquote>
<p>functionA,不需要参数，返回值为 Unit<br>functionA1, 需要一个String 类型的参数，返回值为 Unit<br>functionA11,需要一个String 类型的参数，返回值为 String</p>
</blockquote>
<p>那么在 kotlin 编程语言中又是如何描述的？<br><img src="/image/kotlin/kotlin_function0%3CUnit%3E.png"><br><img src="/image/kotlin/kotlin_function1%3CString,Unit%3E.png"><br><img src="/image/kotlin/kotlin_function1%3CString,String%3E.png"></p>
<p>上面的图是将鼠标悬停在变量上就会出现，当然也可以选中变量或者表达式，按 ctrl+shift+p来显示类型</p>
<p>可以看到在<code>kotlin</code>中是用<code>KFunction0&lt;Unit&gt;</code>、<code>KFunction1&lt;String, Unit&gt;</code>、<code>KFunction1&lt;String, String&gt;</code>这种形式来描述一个函数。这里的 KFunction 后面的数字表示这个函数的参数个数，尖括号中的类型表示参数的类型，最后一个类型表示函数的返回值类型。比如<code>KFunction1&lt;String, Unit&gt;</code>表示这个函数需要<code>1</code>个<code>String</code>类型的参数，返回值类型为<code>Unit</code>。而<code>KFunction1&lt;String, String&gt;</code>表示这个函数需要<code>1</code>个<code>String</code>类型的参数，返回值为<code>String</code>。<br>如果函数是挂起函数(被suspend修饰)，则对应的类型为<code> KSuspendFunction0&lt;Unit&gt;</code>,以此类推。<br>那么如果是高阶函数嘞？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">functionC</span><span class="hljs-params">(method:()-&gt;<span class="hljs-type">String</span>)</span></span>:String&#123;<br>    <span class="hljs-keyword">return</span> method()<br>&#125;<br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span>  <span class="hljs-title">suspendFunctionC</span><span class="hljs-params">(method: () -&gt; <span class="hljs-type">String</span>)</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> method()<br>&#125;<br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span>  <span class="hljs-title">suspendFunctionC1</span><span class="hljs-params">(method:<span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">String</span>)</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> method()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样的方法，我们可以看到</p>
<blockquote>
<p><code>functionC</code>对应的描述是<code>KFunction1&lt;() -&gt; String, String&gt;</code><br><code>suspendFunctionC</code>对应的描述是<code> KSuspendFunction1&lt;() -&gt; String, String&gt;</code><br><code>suspendFunctionC1</code>对应的描述是<code> KSuspendFunction1&lt;suspend () -&gt; String, String&gt;</code>。</p>
</blockquote>
<p>对于扩展函数也一样</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">A1</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-keyword">this</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">A11</span><span class="hljs-params">()</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;    <br><span class="hljs-keyword">val</span> stringA1 = String::A1 <span class="hljs-comment">// KFunction1&lt;String, Unit&gt;</span><br><span class="hljs-keyword">val</span> stringA11 = String::A11 <span class="hljs-comment">// KFunction1&lt;String, String&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>注意</strong>，我们还可以使用<code>typealias</code>给函数类型取一个别名<br><code>typealias ClickHandler = (Button, ClickEvent) -&gt; Unit</code></p>
<h3 id="带接收者的函数类型"><a href="#带接收者的函数类型" class="headerlink" title="带接收者的函数类型"></a>带接收者的函数类型</h3><p>一种特殊的函数类型，它允许您在函数类型中指定一个接收者对象，使得在函数体内可以直接访问该接收者对象的成员函数和属性。这种函数类型的语法是在函数类型声明之前添加接收者类型。<br>带接收者的函数类型的语法如下：</p>
<blockquote>
<p>接收者类型.() -&gt; 返回类型</p>
</blockquote>
<p>通过使用带接收者的函数类型，我们可以创建具有接收者的函数变量、函数参数或函数返回类型，以便在调用函数时可以直接操作接收者对象。这样可以实现一种类似扩展函数的效果。举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String)<br><br><span class="hljs-comment">// 带接收者的函数类型</span><br><span class="hljs-keyword">val</span> greeting: Person.() -&gt; String = &#123;<br>    <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>!&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 扩展函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Person.<span class="hljs-title">greet</span><span class="hljs-params">()</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, <span class="hljs-variable">$name</span>!&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person: Person = Person(<span class="hljs-string">&quot;huang&quot;</span>)<br><br>    <span class="hljs-comment">// 使用带接收者的函数类型调用函数</span><br>    <span class="hljs-keyword">val</span> message1 = person.greeting()<br><br>    <span class="hljs-comment">// 使用扩展函数调用函数</span><br>    <span class="hljs-keyword">val</span> message2 = person.greet()<br><br>    println(message1) <span class="hljs-comment">// 输出: Hello, huang!</span><br>    println(message2) <span class="hljs-comment">// 输出: Hello, huang!</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结起来，带接收者的函数类型更适合在函数类型的声明和传递中使用，以提供特定上下文的函数操作。而扩展函数则更适合在已有类上添加新的函数，使得在调用该类时可以使用这些额外的函数。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>先小小的总结一下：</p>
<ul>
<li>所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型：(A, B) -&gt; C 表示接受类型分别为 A 与 B 两个参数并返回一个 C 类型值的函数类型。 参数类型列表可以为空，如 () -&gt; A。Unit 返回类型不可省略。</li>
<li>函数类型可以有一个额外的接收者类型，它在表示法中的点之前指定： 类型 A.(B) -&gt; C 表示可以在 A 的接收者对象上以一个 B 类型参数来调用并返回一个 C 类型值的函数。 <code>带有接收者的函数字面值</code>通常与这些类型一起使用。</li>
<li>挂起函数属于函数类型的特殊种类，它的表示法中有一个 suspend 修饰符 ，例如 suspend () -&gt; Unit 或者 suspend A.(B) -&gt; C。</li>
<li>如需将函数类型指定为可空，请使用圆括号，如下所示： ((Int, Int) -&gt; Int)?。</li>
</ul>
<p>这样我们在看其他框架的时候就知道框架中的高阶函数怎么调用了：</p>
<blockquote>
<p>当参数类型为<code>() -&gt; String</code>时，我们需要传入一个没有参数且返回值为String类型的函数，对应的类型是<code>KFunction0&lt;String&gt;</code></p>
</blockquote>
<h3 id="函数实例化"><a href="#函数实例化" class="headerlink" title="函数实例化"></a>函数实例化</h3><p>既然函数也是对象，那么理所当然的可以被实例化。我们可以使用以下几种方式获取函数类型的实例</p>
<ul>
<li>使用函数字面值的代码块<ul>
<li>lambda 表达式: { a, b -&gt; a + b },</li>
<li>匿名函数: fun(s: String): Int { return s.toIntOrNull() ?: 0 }</li>
</ul>
</li>
<li>使用已有声明的可调用引用<ul>
<li>顶层、局部、成员、扩展函数：::isOdd、 String::toInt，</li>
<li>顶层、成员、扩展属性：List<Int>::size，</li>
<li>构造函数：::Regex</li>
</ul>
</li>
<li>使用实现函数类型接口的自定义类的实例：<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntTransformer</span>: <span class="hljs-type"></span></span>(<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = TODO()<br>&#125;<br><span class="hljs-keyword">val</span> intFunction: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = IntTransformer()<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="有无Receiver的函数相互转化"><a href="#有无Receiver的函数相互转化" class="headerlink" title="有无Receiver的函数相互转化"></a>有无Receiver的函数相互转化</h3><p>带与不带接收者的函数类型非字面值可以互换，其中接收者可以替代第一个参数，反之亦然。例如，(A, B) -&gt; C 类型的值可以传给或赋值给期待 A.(B) -&gt; C 类型值的地方，反之亦然。这也是为什么<code>String.A1()</code>明明没有声明需要参数，为啥和上面的<code>functionA1</code>方法是相同的类型嘞？可以这么认为:Kotlin中的扩展函数将接收者本身当做第一个参数传入，要不然为啥在<code>String.A1()</code>里面可以使用<code>this</code>来代替调用者本身嘞？<br>那既然这样的话，也就是说这两者是可以互换的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">d</span><span class="hljs-params">(block :(<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>   block(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br>d(String::A1)<br>d(::functionA1)<br></code></pre></td></tr></table></figure>
<p>需要注意的是，这里仅针对在引用和调用时可以互相转换，比如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sayHi: (String) -&gt; <span class="hljs-built_in">Unit</span> = &#123; name:String-&gt;  println(<span class="hljs-string">&quot;hi <span class="hljs-variable">$name</span>&quot;</span>) &#125;<br>sayHi.invoke(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br>sayHi(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br><br><span class="hljs-keyword">val</span> sayHello: String.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; println(<span class="hljs-string">&quot;hello <span class="hljs-variable">$this</span>&quot;</span>) &#125;<br>sayHello.invoke(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br>sayHello(<span class="hljs-string">&quot;huangyuan&quot;</span>)<br><span class="hljs-string">&quot;huangyuan&quot;</span>.sayHello()<br><br><span class="hljs-keyword">val</span> sayHiRef:(String)-&gt;<span class="hljs-built_in">Unit</span> =sayHi<br><span class="hljs-keyword">val</span> sayHiRef1: String.() -&gt; <span class="hljs-built_in">Unit</span> = sayHi<br></code></pre></td></tr></table></figure>
<p>但是如果将 sayHello 和sayHi这两个函数等号右边互换一下则会报错。</p>
<p>需要注意的是这里还有一个概念：<code>带接收者的函数字面值</code>（Function Literals with Receiver），也称为带接收者的 Lambda 表达式，是一种特殊的 Lambda 表达式。它允许在 Lambda 表达式中访问特定类型的对象的成员，就像在该对象的成员函数中一样。通过使用带接收者的函数字面值，可以在 Lambda 表达式中以更简洁的方式操作特定类型的对象。上面对<code>sayHello</code>的定义就属于这种形式。<br>也就是说：带有接收者的函数类型，例如 A.(B) -&gt; C，可以用特殊形式的函数字面值实例化—-带有接收者的函数字面值。<br>这里解释一下：所谓的字面量，就是不用变量名称直接用相对应的值写出来。比如“hello world”就是一个字符串字面量、12.23是一个 Double 的字面量、4是一个 Int 的字面量。</p>
<h3 id="函数类型实例调用"><a href="#函数类型实例调用" class="headerlink" title="函数类型实例调用"></a>函数类型实例调用</h3><p>既然能获取到函数类型的实例，那么肯定就可以调用了。<br>这里调用方式有两种，一种是通过<code>invoke()</code>，比如<code>func.invoke()</code>,或者直接在引用后面加上括号<code>func()</code>:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> functionOne: <span class="hljs-built_in">Int</span>.() -&gt; <span class="hljs-built_in">Unit</span> = &#123; println(<span class="hljs-string">&quot;aaFunRefRec <span class="hljs-variable">$this</span>  &quot;</span>) &#125;<br>functionOne.invoke(<span class="hljs-number">10001</span>)<br>functionOne(<span class="hljs-number">10001</span>)<br><br><span class="hljs-keyword">val</span> functionTwo: <span class="hljs-built_in">Int</span>.(String) -&gt; <span class="hljs-built_in">Unit</span> = &#123; println(<span class="hljs-string">&quot;other <span class="hljs-variable">$this</span>  &quot;</span>) &#125;<br>functionTwo.invoke(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;other&quot;</span>)<br>functionTwo(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;other&quot;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>我们在使用Java语言开发Android 应用的时候可能已经体验过 Lambda 表达式了，最常见的就是给 View 设置点击监听的时候<br><img src="/image/kotlin/replace_with_lambda_tip.png" alt="replace_with_lambda_tip"><br>当我们点击了之后，代码就成了这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java">llShowMoreDialog.setOnClickListener(v -&gt; showToast(<span class="hljs-string">&quot;点击了&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>目前在 java 中只能简化成这样的，kotlin 中还可以进一步简化，后面再说。这里先看看Lambda表达式语法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>lambda 表达式总是括在花括号中。</li>
<li>完整语法形式的参数声明放在花括号内，并有可选的类型标注。</li>
<li>函数体跟在一个 -&gt; 之后。</li>
<li>如果推断出的该 lambda 的返回类型不是 Unit，那么该 lambda 主体中的最后一个（或可能是单个）表达式会视为返回值。</li>
</ul>
<p>如果Lambda 表达式的参数可以推断出来，我们可以省略一些类型，比如上面的 sum 函数可以省略为</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> sum1 = &#123; x: <span class="hljs-built_in">Int</span>, y: <span class="hljs-built_in">Int</span> -&gt; x + y &#125;<br><span class="hljs-keyword">val</span> sum2: (<span class="hljs-built_in">Int</span>, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Int</span> = &#123; x, y -&gt; x + y &#125;<br></code></pre></td></tr></table></figure>
<p>我们在写 Android 时经常会用到给某个控件设置点击事件，就像上面的例子一样</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener(<span class="hljs-keyword">object</span> :View.OnClickListener&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;view?.id&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;)<br>view.setOnClickListener &#123; println(<span class="hljs-string">&quot;click <span class="hljs-variable">$it</span> &quot;</span>) &#125;<br></code></pre></td></tr></table></figure>
<h4 id="SAM转换"><a href="#SAM转换" class="headerlink" title="SAM转换"></a>SAM转换</h4><p>那么它是怎么从上面使用匿名内部类变成下面样子的？这里就要提一下<code>SAM转换</code>了：SAM是Single Abstract Method的缩写，意思就是只有一个抽象方法的类或者接口。但在Kotlin和Java 8里，SAM代表着只有一个抽象方法的接口。只要是符合SAM要求的接口，编译器就能进行SAM转换，也就是我们可以使用Lambda表达式，来简写接口类的参数。<br>需要注意的是，Java 8中的SAM有明确的名称，叫做<code>函数式接口(FunctionalInterface)</code>。FunctionalInterface的限制如下，缺一不可：</p>
<ul>
<li>必须是接口，抽象类不行；</li>
<li>该接口有且仅有一个抽象的方法，抽象方法个数必须是1，默认实现的方法可以有多个。</li>
</ul>
<p>同样的，在kotlin中也有限制：</p>
<ul>
<li>必须是函数接口，也就是声明为<code>fun interface</code></li>
<li>只能包含一个抽象方法，并且不能包含默认方法</li>
</ul>
<p>因此,kotlin 编译器会将该方法自动转化为<code>fun setOnClickListener(l: ((View!) -&gt; Unit)?)</code>，我们才得以使用 Lambda表达式来简化代码。可以将代码写成这样</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener(&#123;view:View?-&gt; println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;view?.id&#125;</span>&quot;</span>)&#125;)<br></code></pre></td></tr></table></figure>
<p>这种情况下，由于 kotlin 支持类型推导，所以我们可以将<code>View?</code>也省略掉，接着还会触发一个被称之为<code>单个参数的隐式名称</code>的东西，原话是这么说的</p>
<blockquote>
<p>If the compiler can parse the signature without any parameters, the parameter does not need to be declared and -&gt; can be omitted. 该参数会隐式声明为 it<br>因此，我们得到了这样子的代码</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener(&#123;println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;it?.id&#125;</span>&quot;</span>)&#125;)<br></code></pre></td></tr></table></figure>
<p>按照 Kotlin 惯例，如果函数的最后一个参数是函数，那么作为相应参数传入的 lambda 表达式可以放在圆括号之外：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener()&#123;println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;it?.id&#125;</span>&quot;</span>)&#125;<br></code></pre></td></tr></table></figure>
<p>这种语法也称为<code>拖尾lambda(trailing lambda)</code>表达式。<br>如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以完全省略：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">view.setOnClickListener&#123;println(<span class="hljs-string">&quot;click <span class="hljs-subst">$&#123;it?.id&#125;</span>&quot;</span>)&#125;<br></code></pre></td></tr></table></figure>
<p>这就是我们最终得到的代码样子</p>
<h4 id="从lambda表达式中返回一个值"><a href="#从lambda表达式中返回一个值" class="headerlink" title="从lambda表达式中返回一个值"></a>从lambda表达式中返回一个值</h4><p>这里有两种方式，一种是隐式返回：如果我们什么都不做，将返回最后一个表达式的值。<br>另外一种就是使用限定的返回语法从lambda显式返回一个值</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">ints.filter &#123;<br>    <span class="hljs-keyword">val</span> shouldFilter = it &gt; <span class="hljs-number">0</span><br>    shouldFilter<br>&#125;<br><br>ints.filter &#123;<br>    <span class="hljs-keyword">val</span> shouldFilter = it &gt; <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span><span class="hljs-symbol">@filter</span> shouldFilter<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这两种方式是等价的。<br>那么这个标签 <strong>@filter</strong>是怎么来的呢？<br>在 Kotlin 中任何表达式都可以用标签来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@。 要为一个表达式加标签，我们只要在其前加标签即可.<br>比如我们在嵌套函数中，标签限定的 return 允许我们从外层函数返回，比如从 Lambda 表达式中返回</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-comment">// 非局部直接返回到 foo() 的调用者</span><br>        print(it)<br>    &#125;<br>    println(<span class="hljs-string">&quot;this point is unreachable&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach <span class="hljs-symbol">lit@</span>&#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@lit</span> <span class="hljs-comment">// 局部返回到该 lambda 表达式的调用者——forEach 循环</span><br>        print(it)<br>    &#125;<br>    print(<span class="hljs-string">&quot; done with explicit label&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通常情况下使用<strong>隐式标签</strong>更方便，因为该标签与接受该 lambda 的函数同名。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span> &#123;<br>    listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).forEach &#123;<br>        <span class="hljs-keyword">if</span> (it == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@forEach</span> <span class="hljs-comment">// 局部返回到该 lambda 表达式的调用者——forEach 循环</span><br>        print(it)<br>    &#125;<br>    print(<span class="hljs-string">&quot; done with implicit label&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>官方这里也给了一个提示：<strong>注意，这种非局部的返回只支持传给内联函数的 lambda 表达式</strong>，这个问题后面再说把，就是<code>inline</code>、<code>noinline</code>、<code>crossinline</code>这三个关键字带来的优化以及滥用的坏处。<br>另外这里还有一个小 tip：如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">map.forEach &#123; (_, value) -&gt; println(<span class="hljs-string">&quot;<span class="hljs-variable">$value</span>!&quot;</span>) &#125;<br></code></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>上文中的 Lambda 表达式缺少指定返回类型的能力，虽然大部分情况下返回值类型可以推导出来，但如果确实需要指定，我们可以使用<strong>匿名函数</strong>，<br>它看起来非常像一个常规函数声明，除了其名称省略了。其函数体既可以是表达式也可以是代码块：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> = x + y<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果参数类型可以推断出来，则参数类型可以省略</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">ints.filter(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(item)</span></span> = item &gt; <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<hr>
<p>对于上面的内容<br>函数式（SAM）接口 英文版: <a href="https://kotlinlang.org/docs/fun-interfaces.html">Functional (SAM) interfaces</a><br>函数式（SAM）接口 中文版: <a href="https://book.kotlincn.net/text/fun-interfaces.html">函数式（SAM）接口</a><br>高阶函数和Lambda 英文版: <a href="https://kotlinlang.org/docs/lambdas.html">Higher-order functions and lambdas</a><br>高阶函数和Lambda 中文版: <a href="https://book.kotlincn.net/text/lambdas.html">高阶函数与 lambda 表达式</a><br>返回与跳转 中文版: <a href="https://book.kotlincn.net/text/returns.html">返回与跳转</a><br>返回与跳转 英文版: <a href="https://kotlinlang.org/docs/returns.html">Returns and jumps</a></p>
<hr>
<p>已学习：</p>
<ul>
<li><p>扩展</p>
<ul>
<li><input type='checkbox' disabled='true' checked>扩展函数</input></li>
<li><input type='checkbox' disabled='true' checked>扩展属性</input></li>
<li><input type='checkbox' disabled='true' checked>作用域</input></li>
</ul>
</li>
<li><p>函数类型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li>
<li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li>
<li><input type='checkbox' disabled='true' checked>SAM 转换</input></li>
</ul>
</li>
</ul>
<p>未学习：</p>
<ul>
<li><p>关键字</p>
<ul>
<li>object</li>
<li>Unit</li>
<li>Nothing</li>
<li>with、let、run、apply、also</li>
<li>inline,noinline,crossinline</li>
</ul>
</li>
<li><p>泛型</p>
<ul>
<li>逆变</li>
<li>协变</li>
</ul>
</li>
<li><p>委托</p>
<ul>
<li>委托类</li>
<li>委托属性</li>
<li>自定义委托</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li>启动</li>
<li>挂起</li>
<li>Job</li>
<li>Context</li>
<li>Channel</li>
<li>Flow</li>
<li>select</li>
<li>并发、异常</li>
<li>launch</li>
<li>Dispatchers</li>
<li>CoroutineScope</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX笔记(一)(准备工作)</title>
    <url>/2018/01/18/LaTeX%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<p>如果学习不是为了装逼，那一切都将毫无意义。<br>没错，我又想学<strong>LaTeX</strong>了，作为世界上最好的排版系统(没有之一)，我也只是在写简历的时候用过(装上编译器，改模板而已)，没有怎么了解过。最近妹子有提到过说些毕业论文的时候可能要用，这就需要系统的学习一下了。</p>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>本着实用至上的原则，LaTeX的历史以及光辉事迹就不在提了，想看的自己去搜</p>
<ol>
<li><strong>TexLive2017套装</strong>：下载地址<a href="http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/texlive2017-20170524.iso">http://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/texlive2017-20170524.iso</a> 这个是清华镜像站点。<a href="http://mirror.ctan.org/systems/texlive/Images/texlive2017.iso">http://mirror.ctan.org/systems/texlive/Images/texlive2017.iso</a> 这个是官方的镜像下载地址。<br>不推荐使用<strong>CTex</strong></li>
<li><strong>TexWorks</strong>：Tex文件编辑器，你也可以使用其他编辑器+插件：比如 VisualStudioCode，Sublime，Notepad++等。</li>
<li><strong>JabRef</strong>：下载地址 <a href="https://www.fosshub.com/JabRef.html">https://www.fosshub.com/JabRef.html</a> 大部分用在写论文的引用文献上，只有使用LaTeX撰写科技论文的研究人员才能完全领略到JabRef的妙不可言。</li>
<li><strong>学习资料</strong>：LaTeX实在太庞大了，加上各种package，网上各种博客资料不是很全面，只照顾到一部分，推荐<em>刘海洋</em>的<em>LaTeX入门</em>。</li>
<li><strong>建议</strong>：多练习，就像学编程一样，把书上的例子都自己敲一遍。</li>
</ol>
<span id="more"></span>
<h4 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h4><p>将<code>TexLive2017套装</code>加载到光驱，</p>
<ul>
<li>Windows 用户双击 install-tl-advanced.bat；</li>
<li>*nix 用户执行 install-tl。<br>然后按照提示来安装就好了，最后将<code>texlive\2017\bin\win32</code>加入环境变量，*nix用户自己找执行文件所在的路径加到环境变量里面。<br>其他的东西可以参考这个网站 <a href="http://www.latexstudio.net/archives/10208">http://www.latexstudio.net/archives/10208</a></li>
</ul>
<h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>老规矩，先跑个<code>Hello World</code>。</p>
<ol>
<li>打开<code>TexWork</code>,在编辑区输入以下代码：<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs Tex"><span class="hljs-keyword">\documentclass</span>&#123;article&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br>Hello World!<br><br><span class="hljs-keyword">\LaTeX</span><br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>
然后保存一下文件，注意一定要使用UTF-8编码(默认)，Tex文件的后缀名为<code>.tex</code>，编译过程会多出好多临时文件。</li>
<li>在下图红框处(界面左上角)选择<code>pafLaTeX</code>,然后点击绿色按钮进行编译，编译过程中绿色按钮会变成红叉，编译成功后又变成绿色按钮。你会在弹出的窗口看到”Hello World LaTeX”，并且在<code>tex</code>文件同级的文件夹下看到生成的<code>pdf</code>文件。<br>如果没有编译成功，可以尝试选择不同的编译类型，也可以搜索控制台报错信息来解决。<br><img src="/image/latex/latex_note_one_1.png" alt="TexWorks界面"></li>
<li>如果你觉得编辑窗口的字体看着不舒服，可以在<code>编辑</code>–&gt;<code>首选项</code>–&gt;<code>编辑器</code>或者<code>格式</code>–&gt;<code>字体</code>里面调整。</li>
<li>多说一句，<code>TexWorks</code>支持代码补全</li>
</ol>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>\documentclass[UTF-8]&#123;article&#125;</code> 声明文档类型是一篇文章。<br><code>\begin&#123;document&#125;</code> 和 <code>\end&#123;document&#125;</code> 标识出正文的范围<br><code>\LaTeX</code> 看结果就知道是表示结果中高低不平的LaTeX<br>但是，当你把内容替换为汉字的时候，发现汉字并不能在pdf文件中展示，这是因为LaTeX原本是面向西文写作的，默认没有加载中文字体。我们可以通过替换文档类型来显示中文，将 <code>\documentclass&#123;article&#125;</code> 替换为 <code>\documentclass[UTF-8]&#123;ctexart&#125;</code> 就可以显示中文了。</p>
<h4 id="下一个目标"><a href="#下一个目标" class="headerlink" title="下一个目标"></a>下一个目标</h4><p>如下图，接下来我们来慢慢写出来图片所示的样式。<br><img src="/image/latex/latex_note_one_2.png" alt="目标"></p>
<hr>
<p>以上。</p>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin中的函数类型及扩展函数</title>
    <url>/2024/04/22/Kotlin%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E5%8F%8A%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>继续kotlin 的学习，之前只是学了点皮毛中的皮毛，会了一些简单语法而已。最后面列了一个大纲，认真的学习一下。<br>今天的内容是<strong>扩展</strong>。gradle：8.5，插件：id ‘org.jetbrains.kotlin.jvm’ version ‘1.9.23’</p>
<span id="more"></span>


<h3 id="简介和使用"><a href="#简介和使用" class="headerlink" title="简介和使用"></a>简介和使用</h3><p>kotlin 中扩展可以给已有的类添加额外的方法和属性，看起来就像是修改了类的源码一样，而不是像 java 一样需要继承该类然后添加自己的方法。扩展又分为扩展函数和扩展属性。<br>那么如何使用嘞？其实和声明普通函数几乎一致，只是多了一个叫做”接收者”的东西，也就是文档中的Receiver，说白了，其实就是限制这个接收者类型才能使用这个方法，也就是我们要对这个类型 <strong>“添加”</strong> 一个方法。<br>比如我们想要给字符串类型添加一个获取最后一个元素的方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">lastChar</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Char</span>?&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.isEmpty())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(length - <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的方法声明表示：对<code>String</code>类型定义一个无参的<code>lastChar</code>方法，返回值是<code>Char?</code>，使用的时候就像使用 String 类中的方法一样使用就好了：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;kotlin&quot;</span><br>    println(s.lastChar())<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么扩展属性怎么使用嘞？和扩展函数差不多：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> String.firstChar:<span class="hljs-built_in">Char</span>?<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.isEmpty()) <span class="hljs-literal">null</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>
<p>可以简单的认为上面的声明是这样:对<code>String</code>类型顶一个<code>firstChar</code>属性，类型是<code>Char?</code>,使用时和使用 String 类中的属性一样就好了:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s = <span class="hljs-string">&quot;kotlin&quot;</span><br>    println(s.lastChar())<br>    println(s.firstChar)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="思考：Java中如何使用？"><a href="#思考：Java中如何使用？" class="headerlink" title="思考：Java中如何使用？"></a>思考：Java中如何使用？</h3><p>接下来思考一下在 java 中如何调用嘞？得先看看 kotlin 是如何实现扩展的。最简单的方法，看反编译后的字节码文件：<br>顶部菜单中 tools–&gt;kotlin–&gt;Show Kotlin Bytecode，然后点Decompile就可以看到了<br><img src="/image/kotlin/show_kotlin_bytecode.png" alt="decompile kotlin bytecode"><br>代码大致如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainKt</span> &#123;<br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Character <span class="hljs-title function_">lastChar</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String $<span class="hljs-built_in">this</span>$lastChar)</span> &#123;<br>      Intrinsics.checkNotNullParameter($<span class="hljs-built_in">this</span>$lastChar, <span class="hljs-string">&quot;&lt;this&gt;&quot;</span>);<br>      <span class="hljs-keyword">return</span> ((CharSequence)$<span class="hljs-built_in">this</span>$lastChar).length() == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : $<span class="hljs-built_in">this</span>$lastChar.charAt($<span class="hljs-built_in">this</span>$lastChar.length() - <span class="hljs-number">1</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Nullable</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Character <span class="hljs-title function_">getFirstChar</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String $<span class="hljs-built_in">this</span>$firstChar)</span> &#123;<br>      Intrinsics.checkNotNullParameter($<span class="hljs-built_in">this</span>$firstChar, <span class="hljs-string">&quot;&lt;this&gt;&quot;</span>);<br>      <span class="hljs-keyword">return</span> ((CharSequence)$<span class="hljs-built_in">this</span>$firstChar).length() == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : $<span class="hljs-built_in">this</span>$firstChar.charAt(<span class="hljs-number">0</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;kotlin&quot;</span>;<br>      <span class="hljs-type">Character</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> lastChar(s);<br>      System.out.println(var1);<br>      var1 = getFirstChar(s);<br>      System.out.println(var1);<br>   &#125;<br><br>   <span class="hljs-comment">// $FF: synthetic method</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      main();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到反编译之后的代码只是添加了两个静态方法而已，这样的话，在 Java 中我们就可以这么使用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMain</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>        System.out.println( MainKt.lastChar(s));<br>        System.out.println( MainKt.getFirstChar(s));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="思考：作用域，继承与重载"><a href="#思考：作用域，继承与重载" class="headerlink" title="思考：作用域，继承与重载"></a>思考：作用域，继承与重载</h3><p>接下来思考另外一个问题：作用域，或者说我们可以在哪里声明、在哪里调用扩展函数？<br>上面的例子中都是声明为了顶级函数(top level),我们可以在任意地方使用对应的类型进行调用，如果声明在类里面会怎么样？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">isEmail</span><span class="hljs-params">()</span></span>:<span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.contains(<span class="hljs-string">&quot;@&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">val</span> email = <span class="hljs-string">&quot;a@a.com&quot;</span><br>        println(email.isEmail())<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> email = <span class="hljs-string">&quot;a@a.com&quot;</span><br>    println(email.isEmail())<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到在类里面定义的扩展函数，只能在类里面调用，在类外是无法使用的。但是，我们可以在继承Example的类中使用，比如这样</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubExample</span> :<span class="hljs-type">Example</span></span>()&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subTest</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">val</span> email = <span class="hljs-string">&quot;a@a&quot;</span><br>        println(email.isEmail())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么问题来了，如果对<code>Example</code>定义一个扩展函数，那么在子类SubExample中能调用么？答案是可以的，但是不能覆写，因为kotlin中的函数默认是<code>final</code>不能被覆写的，同时定义扩展函数时又不能被<code>open</code>修饰，从语法上讲，这是扩展函数不能被覆写的原因。看反编译之后的代码，定义为顶级函数的扩展函数是 static 的，因此也不能被覆写。<br>那么在 Java 中能不能用嘞？遇事不决先看反编译后的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmail</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> String $<span class="hljs-built_in">this</span>$isEmail)</span> &#123;<br>      Intrinsics.checkNotNullParameter($<span class="hljs-built_in">this</span>$isEmail, <span class="hljs-string">&quot;&lt;this&gt;&quot;</span>);<br>      <span class="hljs-keyword">return</span> StringsKt.contains$<span class="hljs-keyword">default</span>((CharSequence)$<span class="hljs-built_in">this</span>$isEmail, (CharSequence)<span class="hljs-string">&quot;@&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">2</span>, (Object)<span class="hljs-literal">null</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">email</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a@a.com&quot;</span>;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.isEmail(email);<br>      System.out.println(var2);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样的话就可以通过<code>Example</code>实例来调用了。同样注意到在<code>Example</code>类中定义的扩展函数<code>isEmail</code>被 final 修饰了，因此也无法通过继承来覆写该方法。</p>
<h3 id="思考：扩展函数如何引用？"><a href="#思考：扩展函数如何引用？" class="headerlink" title="思考：扩展函数如何引用？"></a>思考：扩展函数如何引用？</h3><p>嘿嘿嘿,我们知道函数是可以通过双冒号引用的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHi</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hi <span class="hljs-variable">$name</span>&quot;</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">referenceMethod</span><span class="hljs-params">(method: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    method(<span class="hljs-string">&quot;xuan&quot;</span>)<br>    method.invoke(<span class="hljs-string">&quot;yuan&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    referenceMethod(::sayHi)<br>    referenceMethod &#123; name -&gt; println(<span class="hljs-string">&quot;hello <span class="hljs-variable">$name</span>&quot;</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么扩展函数应该如何引用嘞？这里先学怎么用，后面再学函数类型吧<br>如果我们将扩展函数定义为顶级函数，那么在应用的时候和引用这个类本身的成员函数没啥区别,比如在一开始我们对 String 定义的扩展函数 lastChar,我们可以这么引用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">val</span> lastCharFun1 = String::lastChar<br></code></pre></td></tr></table></figure>
<p>但是，如果我们将扩展函数定义在类里面又该如何应对？应对不了，没法引用。<br>为什么？思考一个问题，扩展函数属于哪个类？实际上可以认为扩展函数谁都不属于，只是加了一个限定，限定哪个类型的对象可以调用这个函数。<br>另外一个问题，语法上引用类的成员函数是类名双冒号函数名，那引用扩展函数也是这样，但是把扩展函数定义在其他类中，我们应该用哪个类名？干脆不能引用就好了。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>了解了扩展函数、扩展属性 及其作用域。了解了在 Java 层面如何实现的以及 Java 中如何使用。翻看 kotlin 源码，有很多都是基于扩展来实现的，比如 String、比如一些数字类型 Float、Double 等。</p>
<p>到此，扩展就差不多了，应该还会有一些小细节上的问题，但问题应该不大。接下来应该会学习一下遗留下来的问题：函数类型以及lambda 表达式</p>
<hr>
<p>已学习：</p>
<ul>
<li>扩展<ul>
<li><input type='checkbox' disabled='true' checked>扩展函数</input></li>
<li><input type='checkbox' disabled='true' checked>扩展属性</input></li>
<li><input type='checkbox' disabled='true' checked>作用域</input></li>
</ul>
</li>
</ul>
<p>未学习：</p>
<ul>
<li><p>Lambda表达式</p>
<ul>
<li>SAM 转换</li>
<li>函数类型</li>
</ul>
</li>
<li><p>函数类型</p>
<ul>
<li>带有接收者的函数类型</li>
</ul>
</li>
<li><p>关键字</p>
<ul>
<li>object</li>
<li>Unit</li>
<li>Nothing</li>
<li>with、let、run、apply、also</li>
</ul>
</li>
<li><p>泛型</p>
<ul>
<li>逆变</li>
<li>协变</li>
</ul>
</li>
<li><p>委托</p>
<ul>
<li>委托类</li>
<li>委托属性</li>
<li>自定义委托</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li>启动</li>
<li>挂起</li>
<li>Job</li>
<li>Context</li>
<li>Channel</li>
<li>Flow</li>
<li>select</li>
<li>并发、异常</li>
<li>launch</li>
<li>Dispatchers</li>
<li>CoroutineScope</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX笔记(二)(开篇)</title>
    <url>/2018/01/27/LaTeX%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    <content><![CDATA[<p>接上篇，写好的tex文件在这 <a href="https://github.com/huangyuanlove/latex_practice/blob/master/latex(1)/chapter_one.tex">https://github.com/huangyuanlove/latex_practice/blob/master/latex(1)/chapter_one.tex</a></p>
<h5 id="写个框架"><a href="#写个框架" class="headerlink" title="写个框架"></a>写个框架</h5><p>既然有目标了，我们先写个大概的框架，然后往里面填充内容</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-comment">% coding:UTF-8</span><br><br><br><span class="hljs-keyword">\documentclass</span>[UTF8]&#123;ctexart&#125;<br><br><span class="hljs-keyword">\title</span>&#123;杂谈勾股定理&#125;<br><span class="hljs-keyword">\author</span>&#123;xuan&#125;<br><span class="hljs-keyword">\date</span>&#123;<span class="hljs-keyword">\today</span>&#125;<br><br><span class="hljs-keyword">\bibliographystyle</span>&#123;plain&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><br><span class="hljs-keyword">\maketitle</span><br><span class="hljs-keyword">\tableofcontents</span><br><span class="hljs-keyword">\section</span>&#123;勾股定理在古代&#125;<br><span class="hljs-keyword">\section</span>&#123;勾股定理的近代形式&#125;<br><span class="hljs-keyword">\bibliography</span>&#123;math&#125;<br><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li>以 <code>%</code>开头的行是注释，源文件一行中百分号后面的内容都会被忽略。</li>
<li>第<strong>4</strong>行是文档类，因为是中文的短文，所以用的是<code>ctexart</code>，并用[UTF8]选项说明编码方式。</li>
<li>第<strong>6-8</strong>行声明了文章的标题、作者、日期。其中的<code>\today</code>是当前日期。但是这些信息是通过<strong>14</strong>行的<code>\maketitle</code>排版的。</li>
<li>第<strong>10</strong>行的<code>\bibliographystyle</code>声明参考文献的格式。<br>以上在<code>\begin&#123;document&#125;</code>之前的部分称为<code>导言区(preamble)</code>，导言区通常用来对文档的性质做一些设置，或自定义一些命令。</li>
<li>第<strong>12-20</strong>行以<code>\begin&#123;document&#125;</code>和<code>\end&#123;socument&#125;</code>声明了一个document环境，里面是论文的正文部分，也就是直接输出的部分。</li>
<li>第<strong>14</strong>行的<code>\maketitle</code>输出论文标题。</li>
<li>第<strong>15</strong>行的<code>\tableofcontents</code>输出目录。</li>
<li>第<strong>16-17</strong>行两个<code>\section</code>开始新的一节。</li>
<li>第<strong>18</strong>行的<code>\bibliography&#123;math&#125;</code>则是从文献数据库math(这里的math文献数据库是我们自己编辑的一个文件)中获取文献信息，打印参考文献列表。<blockquote>
<p>为了格式清晰，源文件使用了一些空行作为分隔，在正文外的部分，空行不代表任何意义</p>
</blockquote>
</li>
</ul>
<h5 id="填写正文"><a href="#填写正文" class="headerlink" title="填写正文"></a>填写正文</h5><p>自己把大段的文字先写上再说，自己试试查看排版之后格式。</p>
<ul>
<li>使用空行分段，</li>
<li>段落的第一行缩进不需要自己打空格<h5 id="命令与环境"><a href="#命令与环境" class="headerlink" title="命令与环境"></a>命令与环境</h5><h6 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h6>脚注是在正文<strong>欧几里得</strong>的后面用脚注命令<code>\footnote</code>得到的。<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">该定理的严格表述和证明则见于欧几里得<br><span class="hljs-keyword">\footnote</span>&#123;欧几里得，约公元前330--275年。&#125;<br></code></pre></td></tr></table></figure>
在这里，<code>\footnote</code>后面花括号内的部分是命令的参数，也就是脚注的内容。<br>注意一个细节，在表示起止年份时，用两个减号(–)，通常用来表示数字的范围。<br>文中还使用<code>\emph</code>命令改变字体的形状，表示强调的内容：<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">的整数称为<span class="hljs-keyword">\emph</span>&#123;勾股数&#125;<br></code></pre></td></tr></table></figure>
一个LaTeX命令(宏)的格式为：<br>无参数：<code>\command</code><br>有n个参数:<code>\command&lt;arg1&gt;&lt;arg2&gt;&lt;arg3&gt;</code><br>有可选参数:<code>\command&lt;arg——opt&gt;&lt;arg2&gt;&lt;arg3&gt;</code><br>命令都一反斜线<code>\</code>开头，后接命令名，可以带一些参数，必选参数使用花括号括起来，可选参数使用方括号括起来。<br>引用的内容这是在正文中使用<code>quote</code>环境得到的。<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">我国《周髀算经》载商高（约公元前12世纪）答周公问：<br><span class="hljs-keyword">\begin</span>&#123;quote&#125;<br>勾广三，股修四，经隅五。<br><span class="hljs-keyword">\end</span>&#123;quote&#125;<br></code></pre></td></tr></table></figure>
quote环境即以<code>\begin&#123;quote&#125;</code>和<code>\end&#123;quote&#125;</code>为起止位置的部分，突出引用部分。但是quote环境不能改变引用内容的字体，因此还需要再使用改变字体的命令<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;quote&#125;<br><span class="hljs-keyword">\kaishu</span><span class="hljs-keyword">\zihao</span>&#123;-5&#125; 引用的内容<br><span class="hljs-keyword">\end</span>&#123;quote&#125;<br></code></pre></td></tr></table></figure>
这里<code>\zihao</code>是一个有参数的命令，选择字号(-5就是小五号)，而<code>\kaishu</code>则是没有参数的命令，把字体切换为楷书，注意用空格把命令和后面的文字分开。<br>文章的摘要也是在<code>\maketitle</code>之后用<code>abstract</code>环境生成的：<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;abstract&#125;<br>刚开始学<span class="hljs-keyword">\LaTeX</span>,如果学习不是为了装逼，那一切将毫无意义。<br><span class="hljs-keyword">\end</span>&#123;abstract&#125;<br></code></pre></td></tr></table></figure>
当然我们也可以自定义环境，比如上面的突出引用的环境：<br>在导言区<code>\maketitle</code>之后<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\newenvironment</span>&#123;myquote&#125;&#123;<span class="hljs-keyword">\begin</span>&#123;quote&#125;<span class="hljs-keyword">\kaishu</span><span class="hljs-keyword">\zihao</span>&#123;-5&#125;&#125;&#123;<span class="hljs-keyword">\end</span>&#123;quote&#125;&#125;<br></code></pre></td></tr></table></figure>
之后我们在突出引用的时候就可以这么写：<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">我国《周髀算经》载商高（约公元前12世纪）答周公问：<br><span class="hljs-keyword">\begin</span>&#123;myquote&#125;<br>勾广三，股修四，经隅五。<br><span class="hljs-keyword">\end</span>&#123;myquote&#125;<br></code></pre></td></tr></table></figure>
文章第二节的定理，是用一类定理环境输出的，定理环境是一类环境，在使用前需要先在导言区做定义：<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;<br></code></pre></td></tr></table></figure>
这就定义了一个<code>thm</code>环境，定理环境可以有一个可选参数，就是定理的名字，所以文章中的勾股定义就可以由新定义的<code>thm</code>环境得到：<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;thm&#125;[勾股定理]<br>直角三角形斜边的平方等于两腰的平方和。<br><span class="hljs-keyword">\end</span>&#123;thm&#125;<br></code></pre></td></tr></table></figure>
<h6 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h6>最简单的方式就是把公式用<code>$</code>符号括起来，比如<code>$a+b$</code>就可以得到斜体的<em>a+b</em>，这种夹在行文中的公式称为”正文公式(in-text formula)”或”行内公式(inline formula)”。为了方便引用，经常会给公式编号，这种公式被称为”显式公式”或”列表公式(display formula)”,使用<code>equation</code>环境就可以方便地输入这种公式。<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>a(a+b) = ab + ac<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure>
 键盘上没有的符号，就需要使用命令来输入，”角”符号”∠”,就可以用<code>\angle</code>输入(虽然有的输入法也提供了数学符号的选项，但是不建议这么做，可以自己试试有什么区别)。<br> 数学公式还有上线标、分式、根式等，在勾股定理的表达中，就用到了上标表示乘方：<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>AB<span class="hljs-built_in">^</span>2 = BC<span class="hljs-built_in">^</span>2 + AC<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure>
 符号<code>^</code>用来引入一个上标，<code>_</code>医用一个下标，如果上下标识多个字符，则需要使用花括号分组：<code>2^&#123;10&#125;</code>。<br> 所以90°怎么输入，在latex默认的字体中，并没有专用于表示角度的符号，输入角度的时候是通过上标输入的:<code>^\circ</code>，其中<code>\circ</code>通常用来表示函数符号的二元运算符<code>○</code>，我们把它的上标借用来表示角度。</li>
</ul>
<h6 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h6><p> 使用图片有两种途径：一个是插入事先准备好的图片，二是使用latex代码直接在文档中画图。<br> 插图功能不是由latex内核直接提供，而是有<strong>graphicx</strong>宏包提供的，要使用<strong>graphicx</strong>宏包的插图功能呢个，需要在导言区使用<code>\usepackage</code>命令引入宏包：<br> <figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>&#123;ctexart&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;graphicx&#125;<br></code></pre></td></tr></table></figure><br> 引入<strong>graphicx</strong>宏包后，就可以使用<code>\includegraphics</code>命令插图了：<br> <figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\includegraphic</span>[width=3cm]&#123;gougu.png&#125;<br></code></pre></td></tr></table></figure></p>
<p>这里<code>\includegraphic</code>有两个参数，方括号中可选参数<code>width=3cm</code>设置图形在文档中显示的宽度为3cm，第二个参数则是图片的文件名(和源文件同级)，还有一些类似的参数如scale(缩放)、height等。<br>除了一些很小的图标，我们很少进行图文混排，而是使用单独的环境列出，而且很大的图形如果位置是固定，会给分页造成困难，因此，通常都把图像放在一个可以变动相对位置的环境中，称为浮动体。在浮动体中还可以给图片加入说明性标题。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;figure&#125;[ht]<br>  <span class="hljs-keyword">\centering</span><br>  <span class="hljs-keyword">\includegraphics</span>[width=3cm]&#123;gougu.png&#125;<br>  <span class="hljs-keyword">\caption</span> &#123;<span class="hljs-keyword">\kaishu</span><span class="hljs-keyword">\zihao</span>&#123;-5&#125; 宋赵爽在《周髀算经》注中做的弦图（仿制），该图给出了勾股定理的一个极具对称美德证明。&#125;<br>  <span class="hljs-keyword">\label</span>&#123;fig:gougu&#125;<br><span class="hljs-keyword">\end</span>&#123;figure&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，第1行和第6行使用了<code>figure</code>环境，就是插图使用的浮动体环境，<code>figure</code>环境有可选参数<code>[ht]</code>，表示浮动体可以出现在环境周围的文本所在处和一页的顶部。<code>figure</code>环境内部相当于普通的段落(默认没有缩进)；第二行用生命<code>\centering</code>表示后面的内容居中；第3行插入图片；第4行使用<code>\caption</code>命令给插图加上自动编号和标题；第5行的<code>\lable</code>命令则给图形定义一个标签，这个标签就可以在文章的其他地方引用<code>\caption</code>产生的编号。</p>
<h6 id="使用表格"><a href="#使用表格" class="headerlink" title="使用表格"></a>使用表格</h6><p>制作表格，需要确定是表格的行、列、对齐模式和表格线，这是由<code>tabular</code>环境完成的：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;table&#125;[h]<br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;|lcr|&#125;<br><span class="hljs-keyword">\hline</span><br>直角边 <span class="hljs-built_in">$</span>a<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 直角边 <span class="hljs-built_in">$</span>b<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 斜边 <span class="hljs-built_in">$</span>c<span class="hljs-built_in">$</span><span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br>3 <span class="hljs-built_in">&amp;</span>  4 <span class="hljs-built_in">&amp;</span> 5<span class="hljs-keyword">\\</span><br>5 <span class="hljs-built_in">&amp;</span>  12<span class="hljs-built_in">&amp;</span>  13<span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<span class="hljs-comment">%</span><br><span class="hljs-keyword">\qquad</span><br>(<span class="hljs-built_in">$</span>a<span class="hljs-built_in">^</span>2 + b<span class="hljs-built_in">^</span>2 = c<span class="hljs-built_in">^</span>2<span class="hljs-built_in">$</span>)<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure>
<p>表格和插图一样，一般也放在浮动环境中，即<code>table</code>环境中，参数大致和<code>figure</code>差不多；<br><code>tabular</code>环境有一个参数，里面声明了表格中列的模式，在上面的表格中<code>|lcr|</code>表示第一列的内容左对齐，第二类居中对齐，第三列居中对齐，在第一列前面和第三列后面各有一条垂直的表格线。<br>在<code>tabular</code>环境中，行与行之间用命令<code>\\</code>隔开，每一行内的表项使用符号<code>$</code>隔开，表格中的横线是用命令<code>\hline</code>生成。<br>这里并没有给表格加标题，也没有把内容居中，而是把表格个一个公式并排排开，中间使用一个<code>\qquad</code>分割，这个命令产生长为2em(大约两个’M’的宽度)的空白。因为已经使用<code>\qquad</code>生成足够长度的空格了，所以再用<code>\end&#123;tabular&#125;</code>后的注释符取消换行产生的一个多余空格。又因为表格是和正文连在一起的，不允许再浮动了，所以在<code>table</code>环境中的表示位置参数处使用了<code>[H]</code>，但是这个参数是由<strong>float</strong>宏包提供的，所以还要在导言区使用<code>\usepackage&#123;float&#125;</code>。</p>
<h6 id="文献引用"><a href="#文献引用" class="headerlink" title="文献引用"></a>文献引用</h6><p>上面提到了引用文献，是在<code>math.bib</code>这个文件中指定的，下面是<code>math.bib</code>文件的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs bib">% Encoding: UTF-8<br><br>@Book&#123;Shiye,<br>  title  = &#123;几何的有名定理&#125;,<br>  year   = &#123;1986&#125;,<br>  author = &#123;矢野健太郎&#125;,<br>&#125;<br><br>@Book&#123;Kline,<br>  title  = &#123;古今数学思想&#125;,<br>  year   = &#123;2002&#125;,<br>  author = &#123;克莱因&#125;,<br>&#125;<br><br>@Book&#123;quanjing,<br>  title   = &#123;商高、赵爽与刘徽关于勾股定理的证明&#125;,<br>  year    = &#123;1998&#125;,<br>  author  = &#123;曲安京&#125;,<br>  volume  = &#123;20&#125;,<br>  number  = &#123;3&#125;,<br>  journal = &#123;数学传播&#125;,<br>&#125;<br><br>@Comment&#123;jabref-meta: databaseType:bibtex;&#125;<br></code></pre></td></tr></table></figure>
<p>一个文献数据文件的格式并不复杂，每一个条目包括类型、引用标签、标题、年限、作者等信息，可以手工输入，也可以通过jabref制作。<br>在实际应用中，BIBTEX数据并不需要我们自己录入，可以从相关的学科网站直接现在或是从其他类型的文献数据库转换得到。<br>BIBTEX是一个专门用于处理LATEX文档文献列表的程序，使用BIBTEX处理文献时，编译源文件需要增加为四次运行程序(在TexWorks中点击四次按钮)<br><code>pdflatex ***.tex</code><br><code>bibtex ***.aux</code><br><code>pdflatex ***.tex</code><br><code>pdflatex ***.tex</code><br>第一次运行为BIBTEX准备好辅助文件，确定数据库中的哪些文献将被列出来，然后bibtex处理辅助文件aux，从文献数据库中选取文件，按指定的格式生成文献列表的latex代码，后面两次再读入文献列表代码并生成正确的引用信息。<br>latex只选择被引用的文献，引用文献的方法是在正文中使用<code>\cite</code>命令，如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">将勾股定理的发现归功于公元前 6 世纪的毕达哥拉斯学派<span class="hljs-keyword">\cite</span>&#123;Kline&#125;。该学派得到了一个法则...<br>...是我国古代对勾股定理的一种证明<span class="hljs-keyword">\cite</span>&#123;quanjing&#125;。 <br></code></pre></td></tr></table></figure>
<p><code>\cite</code>命令的参数<code>Kline</code>和<code>quanjing</code>分别是其中两篇的引用标签，也就是在<code>math.bib</code>中每个条目第一行出现的星系，使用<code>\cite</code>命令会在引用的文字显示文献在列表中的标号(它在第3次pdflatex编译后才能确定)，同时在辅助文件中说明某文献将被引用。如果要在列表中显示并不直接引用的文献，可以使用<code>\nocite</code>命令，一般是把它放在<code>\bibliography</code>之前：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\nocite</span>&#123;Shiye&#125;<br><span class="hljs-keyword">\bibliography</span>&#123;math&#125;<br></code></pre></td></tr></table></figure>
<p>目录也是自动从章节命令中提取并写入目录文件中的，在文章中我们就使用了<code>\tableofcontents</code>命令，它将在第二次编译时生效。<br>引用并不仅限于参考文献，图表、公式的编号，只要事先设定了标签，同样可以引用。基本的交叉引用命令是<code>\ref</code>，它以标签问参数，得到被引用标号。比如在这篇文章中，在插入图片时是引用<code>\label</code>命令为弦图定义了标签<code>\label&#123;fig:gougu&#125;</code>，这样在正文中就可以使用</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">图<span class="hljs-keyword">\ref</span>&#123;fig:gougu&#125;是我国古代对勾股定理的一种证明<span class="hljs-keyword">\cite</span>&#123;quanjing&#125;。<br></code></pre></td></tr></table></figure>
<p>公式编号的引用也可照此做法，不过需要先在公式中定义标签：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;equation&#125; <span class="hljs-keyword">\label</span>&#123;eq:gougu&#125;<br>AB<span class="hljs-built_in">^</span>2 = BC<span class="hljs-built_in">^</span>2 + AC<span class="hljs-built_in">^</span>2<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure>
<p>引用数学公式的时候一般使用数学宏包<code>amsmath</code>就定义了<code>\eqref</code>命令，专门用于公式的引用，并能产生括号：<br>导言区引入包</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;amsmath&#125;<br></code></pre></td></tr></table></figure>
<p>正文中引用公式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">满足式<span class="hljs-keyword">\eqref</span>&#123;eq:gougu&#125;的整数称为<span class="hljs-keyword">\emph</span>&#123;勾股数&#125;。<br></code></pre></td></tr></table></figure>

<hr>
<p>以上。</p>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX笔记(三)(杂)</title>
    <url>/2018/02/11/LaTeX%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    <content><![CDATA[<p>前两篇笔记记录下了写一篇小文章所需要的东西，这一片就记录下一些零零散散的东西，计算机专业的嘛，只关心中文和英文，像什么德语、法语之类的东西就不在考虑范围内了，用的时候再去查也是可以的。</p>
<span id="more"></span>
<h5 id="标点"><a href="#标点" class="headerlink" title="标点"></a>标点</h5><ul>
<li>在LaTeX中遇到单引号与双引号连续出现的情形，在中间使用<code>\,</code>命令分开：<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">``<span class="hljs-keyword">\,</span>`A&#x27; or `B&#x27;<span class="hljs-keyword">\,</span>&#x27;&#x27; he asked.<br>``It&#x27;s Knuth&#x27;s book。&#x27;&#x27;, he said。<br></code></pre></td></tr></table></figure>
这里<code>\,</code>命令产生很小的间距，但是LaTex并不会忽略以符号命名的宏前后的空格，所以在它的前后都不要加多余的空格。符号<code>&#39;</code>同时也是表示所有格和省字的撇好。</li>
<li>除了在数学模式中表示减号，符号<code>-</code>在LaTeX正文中也有多种用途：单独使用它是连字符(hyphen);两个连用<code>--</code>是en dash,用来表示数字范围;三个连用<code>---</code>是 em dash，即破折号。不过在中文书写中，表示数学范围也常使用符号<code>~</code>(数学模式的符号$\sim$)。</li>
<li>西文的省略号(ellipsis)使用<code>\ldots</code>或<code>\dots</code>命令产生，相比直接输入三个句号，拉开的间距要合理的多。<h4 id="水平间距"><a href="#水平间距" class="headerlink" title="水平间距"></a>水平间距</h4>在正文中可以使用下面的命令表示不可换行的水平间距<br>不可换行的水平间距</li>
</ul>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">间距</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\thinspace</code> 或<code>\,</code></td>
<td align="center">0.1667em</td>
</tr>
<tr>
<td align="center"><code>\negthinspace</code> 或<code>\!</code></td>
<td align="center">-0.1667em</td>
</tr>
<tr>
<td align="center"><code>\enspace</code></td>
<td align="center">0.5em</td>
</tr>
<tr>
<td align="center"><code>\nobreakspace</code> 或<code>~</code></td>
<td align="center">空格</td>
</tr>
</tbody></table>
<p>可换行的水平间距</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">间距</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\quad</code></td>
<td align="center">1em</td>
</tr>
<tr>
<td align="center"><code>\qquad</code> 或<code>\!</code></td>
<td align="center">2em</td>
</tr>
<tr>
<td align="center"><code>\enskip</code></td>
<td align="center">0.5em</td>
</tr>
<tr>
<td align="center"><code>\空格</code></td>
<td align="center">空格</td>
</tr>
</tbody></table>
<p>当上面的命令中没有合适的距离时，可以用<code>\hspace&#123;距离&#125;</code>命令来产生指定的水平间距(这里的<code>\,</code>用来分隔数字和单位)</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">Space<span class="hljs-keyword">\hspace</span>&#123;1cm&#125;1<span class="hljs-keyword">\,</span>cm<br></code></pre></td></tr></table></figure>
<p><code>\hspace</code>命令产生的距离是可断行的，但是在某些情况下(强制断行的行首)，改命令产生的距离会被忽略，此时可以用带星号的命令<code>\hspace*&#123;距离&#125;</code>阻止距离被忽略。</p>
<h4 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h4><p>盒子(box)是TeX中的基本处理单位。<br>最简单的命令是<code>\mbox&#123;内容&#125;</code>,它产生一个格子，内容以左右模式排列，可以用它表示不允许断行的内容。<br><code>\makebox</code>与<code>\mbox</code>类似，但可以带两个可选参数，指定盒子的宽度和对齐方式：<br><code>\makebox[&lt;宽度&gt;][&lt;位置&gt;]&#123;&lt;内容&gt;&#125;</code><br>对齐参数可以取c(居中)、l、r、s(分散),默认居中。<br><code>\fbox</code> 和 <code>\framebox</code>产生带边框的盒子，语法和<code>\mbox</code>、<code>\makebox</code>类似</p>
<h4 id="列表环境"><a href="#列表环境" class="headerlink" title="列表环境"></a>列表环境</h4><p>列表是常用的文本格式，LaTeX标准文档类提供了三种列表环境：带编号的<code>enumerate</code>环境、不编号的<code>itemize</code>环境和使用关键字的<code>description</code>环境。在列表内部使用<code>\item</code>命令开始一个列表项，它可以带一个可选参数表示手动编号或关键字</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;enumerate&#125;<br><span class="hljs-keyword">\item</span> 中文<br><span class="hljs-keyword">\item</span> English<br><span class="hljs-keyword">\end</span>&#123;enumerate&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;itemize&#125;<br><span class="hljs-keyword">\item</span> 中文<br><span class="hljs-keyword">\item</span> English<br><span class="hljs-keyword">\end</span>&#123;itemize&#125;<br></code></pre></td></tr></table></figure>
<p>description环境总是使用<code>\item</code>命令的可选参数，把它作为条目的关键字加粗。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;description&#125;<br><span class="hljs-keyword">\item</span>[中文] 中文<br><span class="hljs-keyword">\item</span>[英文] English<br><span class="hljs-keyword">\end</span>&#123;description&#125;<br></code></pre></td></tr></table></figure>
<p>上面三种列表环境可以嵌套使用(最多四层)</p>
<h4 id="抄录和代码环境"><a href="#抄录和代码环境" class="headerlink" title="抄录和代码环境"></a>抄录和代码环境</h4><p><code>\verb</code>命令可用来表示杭温中的抄录，语法格式如下：<br><code>\verb&lt;符号&gt;&lt;抄录内容&gt;&lt;符号&gt;</code><br>在<code>\verb</code>后，两个符号相同，表示起始符号和末尾符号，两个符号之间的内容会原样输出。<br>使用带星号的命令<code>\verb*</code>则可以使输出的空格为可见的。<br>大段的抄录可以使用<code>verbatim</code>环境：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;verbatim&#125;<span class="hljs-string"></span><br><span class="hljs-string">#! user/bin /env perl</span><br><span class="hljs-string">$name = &#x27;&#x27;guy&#x27;&#x27;;</span><br><span class="hljs-string">print &#x27;&#x27;Hello,$name!\n&#x27;&#x27;</span><br><span class="hljs-string"></span><span class="hljs-keyword">\end</span>&#123;verbatim&#125;<br></code></pre></td></tr></table></figure>
<p>同样可以使用带星号的<code>verbatim*</code>环境输出可见空格。<br>如果想在程序代码中增加语法高亮功能，可以使用<strong>listings</strong>宏包</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;lstlisting&#125;[language=java]<br>class Test&#123;<br>	public static void main(String ... args)&#123;<br>		System.out.println(&#x27;&#x27;Hello Java&#x27;&#x27;);<br>	&#125;<br>&#125;<br><span class="hljs-keyword">\end</span>&#123;lstlisting&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX笔记-五(自动化工具)</title>
    <url>/2018/02/27/LaTeX%E7%AC%94%E8%AE%B0-%E4%BA%94/</url>
    <content><![CDATA[<p>记录一下某些自动化的工具，比如添加超链接(hyperref)、索引(makeindex)等</p>
<span id="more"></span>
<h4 id="电子文档与超链接"><a href="#电子文档与超链接" class="headerlink" title="电子文档与超链接"></a>电子文档与超链接</h4><p><code>hyperref</code>宏包可算是LaTeX最为复杂的宏包之一，它提供了大量的选项和命令，完成各种设置和功能，这里主要记录以PDF格式输出时，<code>hyperref</code>有关标签和超链接的一些最基本的功能和设置。<br><code>hyperref</code>最基本的用法非常简单，就是直接调用此宏包：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;hyperef&#125;<br></code></pre></td></tr></table></figure>
<p>如果使用ctex宏包或文档类，则可以加<code>hyperef</code>选项，这样啊ctex宏包会自动根据编码和编译方式选择合适的选项，避免出现乱码：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>[hyperref,UTF8]&#123;ctexart&#125;<br></code></pre></td></tr></table></figure>
<p>引入hyperref后再编译文档时，会根据章节结构，自动生成目录结构的PDF文档标签。同时，正文中的目录和所有交叉引用，都会自动成为超链接，可以用鼠标点击跳转到引用位置。要得到正确的PDF标签，也应至少表一两遍文档。<br>除了直接加在<code>\usepackage</code>，也可以使用<code>\hypersetup</code>命令单独设置。hyperref的选项大多使用&lt;选项&gt;&#x3D;&lt;值&gt;的方式设置，如果是布尔类型的真假值选项(true或false),通常可以省略为真的值，常见选项如下：</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="center">类型</th>
<th align="center">默认值</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">colorlinks</td>
<td align="center">布尔</td>
<td align="center">false</td>
<td align="center">超链接用彩色显示</td>
</tr>
<tr>
<td align="left">bookmarks</td>
<td align="center">布尔</td>
<td align="center">true</td>
<td align="center">生成PDF目录书签</td>
</tr>
<tr>
<td align="left">bookmarksopen</td>
<td align="center">布尔</td>
<td align="center">false</td>
<td align="center">在PDF阅读器中自动打开书签</td>
</tr>
<tr>
<td align="left">bookmarksnumbered</td>
<td align="center">布尔</td>
<td align="center">false</td>
<td align="center">目录书签带编号</td>
</tr>
<tr>
<td align="left">pdfborder</td>
<td align="center">数 数 数</td>
<td align="center">0 0 1</td>
<td align="center">当colorlink为假时，超链接由彩色边框包围(不会被打印)。默认值表示1pt宽的边框，可以设置为0 0 0 表示没有边框。</td>
</tr>
<tr>
<td align="left">pdfpagemode</td>
<td align="center">文本</td>
<td align="center"></td>
<td align="center">在PDF阅读器中的页面显示方式，常用值是FullScreen，表示全屏显示</td>
</tr>
<tr>
<td align="left">pdfstartview</td>
<td align="center">文本</td>
<td align="center">Fit</td>
<td align="center">在PDF阅读器中的页面缩放大小，默认值Fit表示“适合页面”；常用取值有适合宽度FitH，适合高度FitV</td>
</tr>
<tr>
<td align="left">pdftitle</td>
<td align="center">文本</td>
<td align="center"></td>
<td align="center">文档标题，会在PDF文档属性中显示</td>
</tr>
<tr>
<td align="left">pdfauthor</td>
<td align="center">文本</td>
<td align="center"></td>
<td align="center">文档作者，会在PDF文档属性中显示</td>
</tr>
<tr>
<td align="left">pdfsubject</td>
<td align="center">文本</td>
<td align="center"></td>
<td align="center">文档主题，会在PDF文档属性中显示</td>
</tr>
<tr>
<td align="left">pdfkeywords</td>
<td align="center">文本</td>
<td align="center"></td>
<td align="center">文档关键字，会在PDF文档属性中显示</td>
</tr>
<tr>
<td align="left">除此之外，可以用<code>\url</code>命令输出URL地址，同时也具有超链接的功能。与排版纯文本不同，找<code>\url</code>命令的参数中，网址允许使用合法符号直接输入，并且默认以打字机字体输出，如果URL地址不需要超链接的效果，可以改用<code>\nolinkurl</code>命令。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><code>\href&#123;&lt;URL&gt;&#125;&#123;文字&#125;</code>命令可以用来使文字产生指向URL地址的超链接效果。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><code>\hyperref[&lt;标签&gt;]&#123;&lt;文字&gt;&#125;</code>命令可以用来产生使文字执行标签的超链接效果，这里方括号中的标签与<code>\ref</code>使用的标签相同，不能省略。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><code>\hypertarget&#123;&lt;名称&gt;&#125;&#123;&lt;文字&gt;&#125;</code>用来给文字定义带有名称的链接点，在文档的其他地方，则可以使用命令<code>\hyperlink&#123;&lt;名称&gt;&#125;&#123;&lt;文字&gt;&#125;</code>让另一段文字链接到指定名称的连接点。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="制作索引"><a href="#制作索引" class="headerlink" title="制作索引"></a>制作索引</h4><p>在LaTeX中制作索引，需要.tex源文件和外部索引程序的共同协作。在.tex源文件中，我们需要做一下几件事：</p>
<ol>
<li>在导言区使用<code>\makeindex</code>命令，开启索引文件输出</li>
<li>在导言区调用<code>makeidx</code>宏包，开启索引列表排版功能</li>
<li>在正文中需要索引的关键字处使用<code>\index</code>命令，生成索引项</li>
<li>在需要生成索引的地方(通常是文档的末尾)，使用<code>\printindex</code>命令，实际输出处理好的索引列表</li>
</ol>
<p>例子如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>[hyperref,UTF8]&#123;ctexart&#125;<br><span class="hljs-keyword">\usepackage</span>&#123;makeidx&#125;<br><span class="hljs-keyword">\makeindex</span><br><span class="hljs-comment">% ...</span><br>西方称勾股定理为毕达哥拉斯定理，<br><span class="hljs-keyword">\index</span>&#123;毕达哥拉斯定理&#125;<br>将勾股定理的发现归功于公元前 6 <br><span class="hljs-comment">%...</span><br>勾股定理可以用现代语言表述如下<span class="hljs-keyword">\index</span>&#123;勾股定理&#125;：<br><span class="hljs-comment">%...</span><br><span class="hljs-keyword">\printindex</span><br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>
<p>与参考文献类似，要生成索引需要多次编译和外部工具<code>Makeindex</code>的配合，编译带索引的文档需要使用如下命令：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">pdflatex ***<br>makeindex ***<br>pdflatex ***<br></code></pre></td></tr></table></figure>
<p>以上命令可以在IDE的编译选项中找到<br>在<code>\index</code>的参数中可以使用符号<code>!</code>来分隔不同层次的索引项，这样将得到分级的索引项。默认支持三级列表，例如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\index</span>&#123;language&#125;<br><span class="hljs-keyword">\index</span>&#123;language!Chinese&#125;<br><span class="hljs-keyword">\index</span>&#123;language!Chinese!dialect&#125;<br><span class="hljs-keyword">\index</span>&#123;language!English&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>\index</code>的参数后面使用符号<code>|</code>则可以使用几个特殊的功能，基本的用法是使用<code>|see&#123;&lt;条目&gt;&#125;</code>与<code>|seealse&#123;条目&#125;</code>表示参考条目。例如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\index</span>&#123;beta&#125;<br><span class="hljs-keyword">\index</span>&#123;Beta|see&#123;beta&#125;&#125;<br><span class="hljs-keyword">\index</span>&#123;gamma|seealso&#123;beta&#125;&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX笔记-六(数学公式)</title>
    <url>/2018/02/27/LaTeX%E7%AC%94%E8%AE%B0-%E5%85%AD/</url>
    <content><![CDATA[<p>TeX有两种数学公式，一种是夹杂在行文段落中的公式，如$\int f(x) \text{d}x&#x3D;1$,一般称为<strong>行内(inline)<strong>数学公式，或</strong>正文(in-text)<strong>数学公式;另一种就是像下面这样单独占据郑航居中展示出来，称为</strong>显示</strong>数学公式<br>$$\sum_{i&#x3D;0}^N \int_a^bg(t,i)\text{d}$$</p>
<p>在TeX中，行内公式一般在前后单个美元符号\$…\$表示，显示公式用连续的两个美元符号\$\$…\$\$表示</p>
<span id="more"></span>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>在数学模式下，符号会使用单独的字体，字母通常是倾斜的意大利体，数字和符号则是自立体，仔细看的话，数学符号之间的距离也与一般的水平模式不同：<br>$a + b &#x3D; b + a$,如$ 1 + 2 &#x3D; 2 + 1$<br>正常模式<br>a + b &#x3D; b + a，如 1 + 2 &#x3D; 2 + 1<br>因此，在排版数学公式时，即使是没有任何特殊符号的算式$1+1$也要进入数学模式，使用$1+1$而不是普通文字的1+1<br>c除了使用单个美元符号，在LaTeX中还额外定义了命令格式与环境格式的方式输入行内公式，即使用命令<code>\(</code>和<code>\)</code>环境括起来一个行内数学公式，如<code>$a+b$</code>也可以写成<code>\(a+b\)</code>或是<code>\begin&#123;math&#125;a+b\end&#123;math&#125;</code>。这两种形式提供了更好的错误检查，并且可以更明确地看出公式的开始于结束，也不容易混淆。<br>同样的，LaTeX中也定义了命令形式和环境形式的输入方法，即使用<code>\[</code>和<code>\]</code>命令或是<code>displaymath</code>环境括起一个显示数学公式，例如：<code>\[a+b=b+a\]</code>,虽然并非必须，但最好在源代码中就把单独占据一行的显示公式放在单独的行内，使代码更清晰，推荐使用的方式是<code>\[...\]</code>，<code>$$...$$</code>会产生不良的间距，缺少错误检查，并且不能正确处理fleqn等文档选项，应该避免使用，而<code>displaymath</code>环境可能显得冗长。<br>LaTeX还提供了带自动编号的数学公式，可以用<code>equation</code>环境表示，公式后还可以带引用的标签，例如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br>  a+b=b+a <span class="hljs-keyword">\label</span>&#123;eq:commutative&#125;<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br></code></pre></td></tr></table></figure>
<h4 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h4><p>上标和下标是两种最常见的数学结构，它们的形式也很朴素：上标一般在原符号的右上方，下标一般在原符号的右下方，有时也在正上方和正下方，例如：</p>
<p>$$\sum_{i&#x3D;1}^{n}\max_a10^na_i\int_Da^2_i$$</p>
<p>在TeX中，上标用特殊字符<code>^</code>表示，下标用特殊字符<code>_</code>表示。在数学模式中，符号<code>^</code>和<code>_</code>的用法差不多相当于带一个参数的命令，如<strong>$10^n$<strong>可以得到 $10^n$ ,而</strong>$a_i$<strong>可以得到 <strong>$a_i$</strong> 当上标和下标多余一个字符时，需要使用分组确定上下标范围，如</strong>$A_{ij}&#x3D;2^{i+j}$<strong>得到</strong>$A_{ij}&#x3D;2^{i+j}$</strong><br>上标和下标可以同时使用，也可以嵌套使用。同时使用上标和下标，上下标的先后次序并不重要，二者互不影响，嵌套使用上下标时，则外层一定要使用分组。数学公式中空格是不起实际作用的，适当的空格可以将代码分隔得好看一些。<br>数学公式中单引号是一种特殊的上标，表示用符号<code>\prime</code>(即’)做上标，可以与下标混用，也可以连续使用，但不能与上标直接混用，如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-built_in">$</span>a=a&#x27;<span class="hljs-built_in">$</span>,<span class="hljs-built_in">$</span>b<span class="hljs-built_in">_</span>0&#x27;=b<span class="hljs-built_in">_</span>0&#x27;&#x27;<span class="hljs-built_in">$</span>,<br><span class="hljs-built_in">$</span>&#123;c&#x27;&#125;<span class="hljs-built_in">^</span>2=(c&#x27;)<span class="hljs-built_in">^</span>2<span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure>
<p>得到<br>$a&#x3D;a’$,$b_0’&#x3D;b_0’’$,${c’}^2&#x3D;(c’)^2$</p>
<h4 id="上下画线与花括号"><a href="#上下画线与花括号" class="headerlink" title="上下画线与花括号"></a>上下画线与花括号</h4><p><code>\overline</code> 和 <code>\underline</code>命令可用来在公式的上方和下方划横线，<code>overbrace</code> 和 <code>underbrace</code>命令可以在公式上方和下方带上花括号如：</p>
<table>
<thead>
<tr>
<th align="center">代码</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>$\overleftarrow&#123;a+b&#125;$</code></td>
<td align="center">$\overleftarrow{a+b}$</td>
</tr>
<tr>
<td align="center"><code>$\overrightarrow&#123;a+b&#125;$</code></td>
<td align="center">$\overrightarrow{a+b}$</td>
</tr>
<tr>
<td align="center"><code>$\overleftrightarrow&#123;a+b&#125;$</code></td>
<td align="center">$\overleftrightarrow{a+b}$</td>
</tr>
<tr>
<td align="center"><code>$\underleftarrow&#123;a-b&#125;$</code></td>
<td align="center">$\underleftarrow{a-b}$</td>
</tr>
<tr>
<td align="center"><code>$\underrightarrow&#123;a-b&#125;$</code></td>
<td align="center">$\underrightarrow{a-b}$</td>
</tr>
<tr>
<td align="center"><code>$\underleftrightarrow&#123;a-b&#125;$</code></td>
<td align="center">$\underleftrightarrow{a-b}$</td>
</tr>
<tr>
<td align="center"><code>$\vec x = \overrightarrow&#123;AB&#125;$</code></td>
<td align="center">$\vec x &#x3D; \overrightarrow{AB}$</td>
</tr>
<tr>
<td align="center"><code>$\overbrace&#123;a+b+c&#125; = \underbrace&#123;1+2+3&#125;$</code></td>
<td align="center">$\overbrace{a+b+c} &#x3D; \underbrace{1+2+3}$</td>
</tr>
</tbody></table>
<p>还可以使用上下标在花括号上做标注</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> (<span class="hljs-keyword">\overbrace</span>&#123;a<span class="hljs-built_in">_</span>0,a<span class="hljs-built_in">_</span>1,...,a<span class="hljs-built_in">_</span>n&#125;<span class="hljs-built_in">^</span>&#123;<span class="hljs-keyword">\text</span>&#123;共 <span class="hljs-built_in">$</span>n+1<span class="hljs-built_in">$</span> 项&#125;&#125;) = (<span class="hljs-keyword">\underbrace</span>&#123;0,0,...,0&#125;<span class="hljs-built_in">_</span>n,1) <span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure>
<p>$$ (\overbrace{a_0,a_1,…,a_n}^{\text{共 $n+1$ 项}}) &#x3D; (\underbrace{0,0,…,0}_n,1) $$</p>
<h4 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h4><p>在LaTeX中分式用<code>\frace&lt;分子&gt;&lt;分母&gt;</code>得到，如：<br><code>$$ \frac 12 + \frac 1a = \frac&#123;2+a&#125;&#123;2a&#125; $$</code>  $ \frac 12 + \frac 1a &#x3D; \frac{2+a}{2a} $<br>在行内公式和显示公式中，分式的大小是不同的。行内分式中分子分母都用较小的字号排版，以免超出文本行的高度。<br>连分式是一种特殊的分式，amsmath提供的<code>\cfrac</code>专用于输入连分式。这个命令可以带一个可选的参数l、c、r，表示左、中、右，默认是居中，如：<br><code>$$ \cfrac&#123;1&#125;&#123;1+\cfrac&#123;2&#125;&#123;1+\cfrac&#123;3&#125;&#123;1+x&#125;&#125;&#125; = \cfrac[r]&#123;1&#125;&#123;1+\cfrac&#123;2&#125;&#123;1+\cfrac[l]&#123;3&#125;&#123;1+x&#125;&#125;&#125; $$</code></p>
<p>得到  $$ \cfrac{1}{1+\cfrac{2}{1+\cfrac{3}{1+x}}} &#x3D; \cfrac[r]{1}{1+\cfrac{2}{1+\cfrac[l]{3}{1+x}}} $$<br> <img src="/image/latex/latex_note_six_1.png" alt="结果">,<code>markdown</code>对这个支持不是很好，结果用图片代替了。<br>还有一些类似分数分成上下两半,如二项式系数$\binom nk$，<code>amsmath</code>提供了<code>\binom</code>来输入二项式系数，其用法与<code>\frac</code>类似:</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">`<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> (a+b)<span class="hljs-built_in">^</span>2 = <span class="hljs-keyword">\binom</span> &#123;20&#125;&#123;02&#125; a<span class="hljs-built_in">^</span>2 + <span class="hljs-keyword">\binom</span> 21 ab + <span class="hljs-keyword">\binom</span> 22 b<span class="hljs-built_in">^</span>2 <span class="hljs-built_in">$</span><span class="hljs-built_in">$</span>`<br></code></pre></td></tr></table></figure>
<p>$$ (a+b)^2 &#x3D; \binom {20}{02} a^2 + \binom 21 ab + \binom 22 b^2 $$</p>
<h4 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h4><p>根式在LaTeX用单参数的命令<code>\sqrt</code>得到，同时可以带一个可选参数，表示开方得次数，如：<br><code>$\sqrt 4 = \sqrt[3]&#123;8&#125; = 2$</code> 得到 $\sqrt 4 &#x3D; \sqrt[3]{8} &#x3D; 2$<br>嵌套使用根式或与其他数学结构结合也很常见：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> <span class="hljs-keyword">\sqrt</span>[n]&#123;<span class="hljs-keyword">\frac</span>&#123;x<span class="hljs-built_in">^</span>2 + <span class="hljs-keyword">\sqrt</span> 2&#125;&#123;x+y&#125;&#125;<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure>
<p>$$ \sqrt[n]{\frac{x^2 + \sqrt 2}{x+y}}$$<br>如果开方得次数不是简单的整数，或者被开方得内容过长，通常改用等价的指数形式：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> (x<span class="hljs-built_in">^</span>p+y<span class="hljs-built_in">^</span>q)<span class="hljs-built_in">^</span>&#123;<span class="hljs-keyword">\frac</span>&#123;1&#125;&#123;1/p+1/q&#125;&#125;<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure>
<p>$$ (x^p+y^q)^{\frac{1}{1&#x2F;p+1&#x2F;q}}$$<br>有时可能对开方次数的排版位置不满意，可以用<code>amsmath</code>提供的<code>\uproot</code>和<code>\leftroot</code>命令调整，命令参数是整数，移动的单位是很小的一段距离，如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span> <span class="hljs-keyword">\sqrt</span>[<span class="hljs-keyword">\uproot</span>&#123;16&#125;<span class="hljs-keyword">\leftroot</span>&#123;-2&#125;n] &#123;<span class="hljs-keyword">\frac</span>&#123;x<span class="hljs-built_in">^</span>2 + <span class="hljs-keyword">\sqrt</span> 2&#125;&#123;x+y&#125;&#125; <span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure>

<h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p>在基本的LaTeX中，矩阵是用PlainTeX一样的命令<code>\matrix</code>和<code>\pmatrix</code>,各类矩阵环境的区别在于外面的括号不同：</p>
<table>
<thead>
<tr>
<th align="center">环境</th>
<th align="center">代码</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">matrix</td>
<td align="center"><code>$$\begin&#123;matrix&#125; 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end&#123;matrix&#125;$$</code></td>
<td align="center">$$\begin{matrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{matrix}$$</td>
</tr>
<tr>
<td align="center">bmatrix</td>
<td align="center"><code>$$\begin&#123;bmatrix&#125; 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end&#123;bmatrix&#125;$$</code></td>
<td align="center">$$\begin{bmatrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{bmatrix}$$</td>
</tr>
<tr>
<td align="center">vmatrix</td>
<td align="center"><code>$$\begin&#123;vmatrix&#125; 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end&#123;vmatrix&#125;$$</code></td>
<td align="center">$$\begin{vmatrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{vmatrix}$$</td>
</tr>
<tr>
<td align="center">pmatrix</td>
<td align="center"><code>$$\begin&#123;pmatrix&#125; 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end&#123;pmatrix&#125;$$</code></td>
<td align="center">$$\begin{pmatrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{pmatrix}$$</td>
</tr>
<tr>
<td align="center">Bmatrix</td>
<td align="center"><code>$$\begin&#123;Bmatrix&#125; 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end&#123;Bmatrix&#125;$$</code></td>
<td align="center">$$\begin{Bmatrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{Bmatrix}$$</td>
</tr>
<tr>
<td align="center">Vmatrix</td>
<td align="center"><code>$$\begin&#123;Vmatrix&#125; 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end&#123;Vmatrix&#125;$$</code></td>
<td align="center">$$\begin{Vmatrix} 1&amp;0&amp;0\\ 0&amp;1&amp;0\\ 0&amp;0&amp;1\\ \end{Vmatrix}$$</td>
</tr>
</tbody></table>
<p>在矩阵环境中，不同的列用符号<code>&amp;</code>分隔，行用<code>\\</code>分隔，矩阵中每列元素居中对齐，例如：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><span class="hljs-keyword">\begin</span>&#123;Vmatrix&#125; <br> A<span class="hljs-built_in">_</span>1 <span class="hljs-built_in">&amp;</span> A<span class="hljs-built_in">_</span>2 <span class="hljs-built_in">&amp;</span> A<span class="hljs-built_in">_</span>3 <span class="hljs-keyword">\\</span> <br> B<span class="hljs-built_in">_</span>1 <span class="hljs-built_in">&amp;</span> B<span class="hljs-built_in">_</span>2 <span class="hljs-built_in">&amp;</span> B<span class="hljs-built_in">_</span>3 <span class="hljs-keyword">\\</span> <br> C<span class="hljs-built_in">_</span>1 <span class="hljs-built_in">&amp;</span> C<span class="hljs-built_in">_</span>2 <span class="hljs-built_in">&amp;</span> C<span class="hljs-built_in">_</span>3 <span class="hljs-keyword">\\</span> <br> <span class="hljs-keyword">\end</span>&#123;Vmatrix&#125;<span class="hljs-built_in">$</span><span class="hljs-built_in">$</span><br></code></pre></td></tr></table></figure>

<p>$$\begin{Vmatrix}  A_1&amp;A_2&amp;A_3\\  B_1&amp;B_2&amp;B_3\\  C_1&amp;C_2&amp;C_3\\  \end{Vmatrix}$$</p>
<p>在矩阵中经常使用各种省略号即<code>\dots</code>、<code>\vdots</code>、<code>\ddots</code>、<code>\iddots</code>,amsmath还提供了可以跨多列的省略号<code>\hdotsfor&#123;&lt;列数&gt;&#125;</code>，在行公式中，有时需要使用很小的矩阵，这可以由amsmath提供的<code>smallmatrix</code>环境得到.</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX笔记(四)--文档结构层次</title>
    <url>/2018/02/11/LaTeX%E7%AC%94%E8%AE%B0-%E5%9B%9B/</url>
    <content><![CDATA[<p>下面是介绍文档的层次结构</p>
<span id="more"></span>
<h4 id="标题和标题页"><a href="#标题和标题页" class="headerlink" title="标题和标题页"></a>标题和标题页</h4><p>在LaTeX中，使用标题通常分为两个部分：声明标题内容和实际输出标题。每个标题则由标题、作者、日期等部分组成。<br>声明标题、作者和日期分别使用<code>\title</code>，<code>\author</code>，<code>\date</code>命令。它们都带有一个参数，里面可以使用<code>\\</code>进行换行。标题的声明通常放在导言区，也可以放在标题输出之前的任何位置：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>[UTF8,titlepage]&#123;ctexart&#125;<br><span class="hljs-keyword">\title</span> &#123;语言<span class="hljs-keyword">\thanks</span>&#123;本文由XX基金会赞助&#125;&#125;<br><span class="hljs-keyword">\author</span>&#123;huangyuan<span class="hljs-keyword">\thanks</span>&#123;sdut&#125;<span class="hljs-keyword">\\</span>sdut <span class="hljs-keyword">\and</span> xuan<span class="hljs-keyword">\thanks</span>&#123;sdut&#125;<span class="hljs-keyword">\\</span>sdut&#125;<br><span class="hljs-keyword">\date</span>&#123;戊戌初春&#125;<br></code></pre></td></tr></table></figure>
<p><code>\author</code>定义的参数可以分行，一般第一行是作者姓名，后面是作者的单位、联系方式等，如果文档有多个作者，则多个作者之间用<code>\and</code>分隔。<br>在声明标题和作者时，可以使用<code>\thanks</code>命令产生一种特殊的脚注，它默认使用特殊符号和编号，通常用来表示文章的致谢、文档的版本、作者的详细信息等。<br>使用<code>\maketitle</code>命令可以输出前面声明的标题，通常<code>\maketitle</code>是文档中document环境后面的第一个命令。整个标题的格式是预设好的，在<code>article</code>或<code>ctexart</code>中，标题不单独成页，可以使用文档类的选项<code>titlepage</code>和<code>notitlepage</code>来设置标题是否单独成页。</p>
<h4 id="划分章节"><a href="#划分章节" class="headerlink" title="划分章节"></a>划分章节</h4><p>LaTeX的标准文档类可以划分多层章节，可以使用6到7个层次的章节。</p>
<table>
<thead>
<tr>
<th align="center">层次</th>
<th align="center">名称</th>
<th align="center">命令</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-1</td>
<td align="center">part(部分)</td>
<td align="center"><code>\part</code></td>
<td align="center">可选的最高层</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">chapter(章)</td>
<td align="center"><code>\chapter</code></td>
<td align="center">report,book或ctexrep,ctexbook文档类的最高层</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">section(节)</td>
<td align="center"><code>\section</code></td>
<td align="center">article或ctexart类的最高层</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">subsection(小节)</td>
<td align="center"><code>\subsection</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">subsubsection(小小节)</td>
<td align="center"><code>\subsubsection</code></td>
<td align="center">report,book或ctexrep,ctexbook文档类默认不编号，不编目录</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">paragraph(段)</td>
<td align="center"><code>\paragraph</code></td>
<td align="center">默认不编号，不编目录</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">subparagraph(小段)</td>
<td align="center"><code>\subparagraph</code></td>
<td align="center">默认不编号，不编目录</td>
</tr>
<tr>
<td align="center">一个文档的最高层章节可以是<code>\part</code>，也可以不用<code>\part</code>直接使用<code>\chapter</code>(对book和report等)或<code>\section</code>(对article)。除<code>\part</code>外，只有在上一层章节存在时才能使用下一章节，否则编号会出现错误。在<code>\part</code>下面，<code>\chapter</code>或<code>\section</code>是连续编号的；在其他情况下，下一级的章节随上一节的编号增加会清零重新编号。可以使用带星号的章节命令(如<code>\chapter*</code>)来表示不编号、不编目录的章节。</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h4><p>对于一篇只有几页的文章，把所有的内容都放进一个tex源文件就足够了，但是如果要排版更长的内容，单一文件编译的方式就不那么方便可，可以按照文档的逻辑层次，把整个文档分成多个tex源文件，这样文档的内容更便于检索和管理，也适合大型文档的多人协同编写。<br>LaTeX提供<code>\include&#123;&lt;文件名&gt;&#125;</code>命令可以用来导入两一个文件的内容作为一个章节，文件名不用带<code>.tex</code>扩展名，<code>\include</code>命令会在之前和之后使用<code>\clearpage</code>或<code>\cleardoublepage</code>另起新页，同时将这个文件的内容贴到<code>\include</code>命令所在的文字。所以我们可以这样来组织一篇较长的文章：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>[UTF8,titlepage]&#123;ctexart&#125;<br><span class="hljs-keyword">\title</span> &#123;语言&#125;<br><span class="hljs-keyword">\author</span>&#123;huangyuan<span class="hljs-keyword">\thanks</span>&#123;sdut&#125;<span class="hljs-keyword">\\</span>SDUT <span class="hljs-keyword">\and</span> xuan<span class="hljs-keyword">\thanks</span>&#123;sdut&#125;<span class="hljs-keyword">\\</span>SDUT&#125;<br><span class="hljs-keyword">\date</span>&#123;戊戌初春&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\maketitle</span><br><span class="hljs-keyword">\tableofcontents</span><br><span class="hljs-keyword">\include</span>&#123;lang-natural&#125;<br><span class="hljs-keyword">\include</span>&#123;lang-computer&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-comment">%lang-natural.tex 不能单独编译</span><br><span class="hljs-keyword">\chapter</span>&#123;自然语言&#125;<br>这是自然语言章节<br></code></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-comment">% lang-computer.tex 不能单独编译</span><br><span class="hljs-keyword">\chapter</span>&#123;计算机语言&#125;<br>这是计算机语言章节<br></code></pre></td></tr></table></figure>
<p>划分文档后，可以通过主文件来控制编译整个文档的一章或者某几章。当然可以把不要的章节注释掉，更好的办法是通过<code>\includeonly&#123;&lt;文件列表&gt;&#125;</code>命令，其中&lt;文件列表&gt;是用英文都好隔开的若干文件名。在导言区使用<code>\includeonly</code>命令以后，只有在文件列表中的文件才会被实际的引入主文件。更好的是，如果以前曾经完整的编译过整个文档，那么在使用<code>\includeonly</code>选择编译时，原来的章节编号、页码、交叉引用等仍然会保留为前一次编译的效果：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\documentclass</span>[UTF8,titlepage]&#123;ctexart&#125;<br><span class="hljs-keyword">\title</span> &#123;语言&#125;<br><span class="hljs-keyword">\author</span>&#123;huangyuan<span class="hljs-keyword">\thanks</span>&#123;sdut&#125;<span class="hljs-keyword">\\</span>SDUT <span class="hljs-keyword">\and</span> xuan<span class="hljs-keyword">\thanks</span>&#123;sdut&#125;<span class="hljs-keyword">\\</span>SDUT&#125;<br><span class="hljs-keyword">\includeonly</span>&#123;lang-natural&#125;<br><span class="hljs-keyword">\date</span>&#123;戊戌初春&#125;<br><span class="hljs-keyword">\begin</span>&#123;document&#125;<br><span class="hljs-keyword">\maketitle</span><br><span class="hljs-keyword">\tableofcontents</span><br><span class="hljs-keyword">\include</span>&#123;lang-natural&#125;<br><span class="hljs-keyword">\include</span>&#123;lang-computer&#125;<br><span class="hljs-keyword">\end</span>&#123;document&#125;<br></code></pre></td></tr></table></figure>
<p>值得注意的是，在使用<code>\include</code>命令时，最好不要在子文件中新定义计数器、声明新字体，否则在使用<code>\includeonly</code>时，会因为找不到出现在辅助文件中而在源文件中缺失的计数器而出错。<br>比<code>\include</code>命令更一般的是<code>\input</code>命令，它直接把文件的内容复制到<code>\input</code>命令所在的文字，不做其他多余的操作。<code>\input</code>命令接受一个文件名参数，文件名可以带扩展名，也可以不带扩展名(此时认为扩展名是.tex)。<br>一般可以把导言区、复杂图标代码放在一个单独文件中，然后在主文件中使用<code>\input</code>插入。在<strong>被引入的文件</strong>末尾，可以使用<code>\endinput</code>命令显式的结束文件的读入，在<code>\endinput</code>命令的后面，就可以直接写一些注释性的文字，而不必再加入注释符号。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>MMKV与SharedPreference</title>
    <url>/2020/08/23/MMKV%E4%B8%8ESharedPreference/</url>
    <content><![CDATA[<p>鉴于SP的”种种问题”,萌发了想要使用写文件的方式替换掉sp的想法，发现腾讯开源MMKV是个不错的选择。</p>
<span id="more"></span>

<h5 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h5><ol>
<li>SharedPreferences</li>
<li>ContentProvider</li>
<li>文件</li>
<li>数据库</li>
</ol>
<h5 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h5><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>时间开销</td>
<td>这里说的时间开销包括了CPU时间和&#x2F;0时间，在I&#x2F;O优化中我就多次提到相比CPU和内存，I&#x2F;0存储的速度是非常慢的。但是如果存储方法中比如编解码或者加密&#x2F;解密等设计的比较复杂，整个数据存储过程也会出现CPU时间变得更长的情况</td>
</tr>
<tr>
<td>正确性</td>
<td>选择存储方案的时候，第一个需要判断它是否靠谱。这套存储方案设计是否完备，有没有支持多线程或者跨进程同步操作。内部是否健壮，有没有考虑异常情况下数据的校验和恢复，比如采用双写或者备份文件策略，即使主文件因为系统底层导致损坏，也可以一定程度 上恢复大部分数据</td>
</tr>
<tr>
<td>空间开销</td>
<td>即使相同的数据如果使用不同的编码方式，最后占用的存储空间也会有所不同。举一个简单的例子，相同的数据所占的空间大小是XML&gt;JSON&gt;ProtocolBuffer。除了编码方式的差异，在一些场景我们可能还需要引入压缩策略来进-步减少存储空间，例如zip、lzma等。数据存储的空间开销还需要考虑内存空间的占用量，整个存储过程会不会导致应用出现大量GC、OOM等</td>
</tr>
<tr>
<td>安全</td>
<td>应用中可能会有一些非常敏感的数据,即使它们存储在&#x2F;data&#x2F;data中，我们依然必须将它们加密。例如微信的聊天数据是存储在加密的数据库中，一些些账号相关的数据我们也要单独做加密落地。根据加密强度的不同，可以选择RSA、AES、chacha20、 TEA这些常用的加密算法</td>
</tr>
<tr>
<td>开发成本</td>
<td>有些存储方案看起来非常高大上，但是需要业务做很大改造才能接入。这里我们当然希望能无缝的接入到业务中，在整个开发过程越简单越好</td>
</tr>
<tr>
<td>兼容性</td>
<td>业务不停地向前演进，我们的存储字段或者格式有时候也会不得不有所变化。兼容性首先要考虑的是向前、向后的兼容性，老的数据在升级时能否迁移过来，新的数据在老版本能否降级使用。兼容性另外一个需要考虑的可能是多语言的问题，不同的语言是否支持转换</td>
</tr>
</tbody></table>
<h4 id="sp的N宗罪"><a href="#sp的N宗罪" class="headerlink" title="sp的N宗罪"></a>sp的N宗罪</h4><ol>
<li>跨进程不安全</li>
<li>加载缓慢：异步加载，但是异步加载线程没有设置优先级，如果这时候主线程读取数据需要等待加载线程执行完毕(也就是主线程等待低优先级线程锁的问题)</li>
<li>全量写入：无论是commit还是apply，即使改动一个条目，也会把全部内容写到文件</li>
<li>卡顿：异步落盘机制在应用崩溃时会导致数据丢失</li>
</ol>
<p>下面是SP操作源码的简介图，来源：<a href="https://juejin.im/entry/6844903488271417351">https://juejin.im/entry/6844903488271417351</a></p>
<p><img src="/image/Android/MMKV/apply.png" alt="linux-io"></p>
<p><img src="/image/Android/MMKV/commit.png" alt="linux-io"></p>
<h4 id="SP优化"><a href="#SP优化" class="headerlink" title="SP优化"></a>SP优化</h4><p>可以在Application中重写getSharedPreference方法，返回自己实现的sp。我们可以自己将多次读写进行合并</p>
<h4 id="MMKV与SP"><a href="#MMKV与SP" class="headerlink" title="MMKV与SP"></a>MMKV与SP</h4><table>
<thead>
<tr>
<th>关键要素</th>
<th>SP</th>
<th>MMKV</th>
</tr>
</thead>
<tbody><tr>
<td>正确性</td>
<td>差<br>跨进程和apply机制导致数据丢失</td>
<td>优<br>使用mmap和文件 锁保证数据完整</td>
</tr>
<tr>
<td>时间开销</td>
<td>差<br>全量写入、卡顿</td>
<td>优<br>1.使用mmap<br/>2.修改插入文件尾部，无需全量写入</td>
</tr>
<tr>
<td>空间开销</td>
<td>差<br>使用XML，格式比较冗余</td>
<td>良<br/>使用Protocol Buffer,但是增量更新可能会导致部分冗余</td>
</tr>
<tr>
<td>安全</td>
<td>差<br/>完全明文存储，没有支持加密与权限校验，不适合存放敏感数据</td>
<td>良<br/>使用Protocol Buffer,不是完全明文。没有支持加密与权限校验，不适合存放敏感数据</td>
</tr>
<tr>
<td>开发成本</td>
<td>优<br/>系统支持，非常简单</td>
<td>良<br/>需要引入单独库，有一定的改造成本</td>
</tr>
<tr>
<td>兼容性</td>
<td>优<br/>支持前后兼容</td>
<td>优<br/>支持前后兼容，支持导入<br/>SharedPreferences历史数据，但注意<br/>转换后版本无法回退</td>
</tr>
</tbody></table>
<h4 id="MMKV原理：来源https-github-com-Tencent-MMKV"><a href="#MMKV原理：来源https-github-com-Tencent-MMKV" class="headerlink" title="MMKV原理：来源https://github.com/Tencent/MMKV"></a>MMKV原理：来源<a href="https://github.com/Tencent/MMKV">https://github.com/Tencent/MMKV</a></h4><ol>
<li><p>内存准备</p>
<p>通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。</p>
<p><img src="/image/Android/MMKV/Linux-storage-stack.png" alt="Linux-storage-stack"></p>
</li>
</ol>
<p>简化版<br>   <img src="/image/Android/MMKV/linux-io.png" alt="linux-io"></p>
<ol start="2">
<li><p>数据组织</p>
<p>数据序列化方面我们选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现。考虑到我们要提供的是通用 kv 组件，key 可以限定是 string 字符串类型，value 则多种多样（int&#x2F;bool&#x2F;double 等）。要做到通用的话，考虑将 value 通过 protobuf 协议序列化成统一的内存块（buffer），然后就可以将这些 KV 对象序列化到内存中。</p>
</li>
<li><p>写入优化</p>
<p>标准 protobuf 不提供增量更新的能力，每次写入都必须全量写入。考虑到主要使用场景是频繁地进行写入更新，我们需要有增量更新的能力：将增量 kv 对象序列化后，直接 append 到内存末尾；这样同一个 key 会有新旧若干份数据，最新的数据在最后；那么只需在程序启动第一次打开 mmkv 时，不断用后读入的 value 替换之前的值，就可以保证数据是最新有效的。</p>
</li>
<li><p>空间增长</p>
<p>使用 append 实现增量更新带来了一个新的问题，就是不断 append 的话，文件大小会增长得不可控。例如同一个 key 不断更新的话，是可能耗尽几百 M 甚至上 G 空间，而事实上整个 kv 文件就这一个 key，不到 1k 空间就存得下。这明显是不可取的。我们需要在性能和空间上做个折中：以内存 pagesize 为单位申请空间，在空间用尽之前都是 append 模式；当 append 到文件末尾时，进行文件重整、key 排重，尝试序列化保存排重结果；排重后空间还是不够用的话，将文件扩大一倍，直到空间足够。</p>
</li>
<li><p>数据有效性</p>
<p>考虑到文件系统、操作系统都有一定的不稳定性，我们另外增加了 crc 校验，对无效数据进行甄别。在 iOS 微信现网环境上，我们观察到有平均约 70万日次的数据校验不通过。</p>
</li>
</ol>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p><a href="https://github.com/Tencent/MMKV">https://github.com/Tencent/MMKV</a> github上有对应的示例</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.0xffffff.org/2017/05/01/41-linux-io/">聊聊 Linux IO</a><br><a href="https://tech.meituan.com/2017/05/19/about-desk-io.html">磁盘I&#x2F;O那些事</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cache/index.html">Linux 内核的文件 Cache 管理机制介绍</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-directio/index.html">Linux 中直接 I&#x2F;O 机制的介绍</a><br><a href="https://developer.android.com/reference/android/os/MemoryFile">MemoryFile</a><br><a href="https://developer.android.com/reference/java/nio/MappedByteBuffer">MappedByteBuffer</a><br><a href="https://juejin.im/entry/6844903488271417351">彻底搞懂 SharedPreferences</a><br><a href="https://developer.ibm.com/zh/articles/j-5things1/">Java 对象序列化</a></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentry搭建及Android接入</title>
    <url>/2021/05/22/Sentry%E6%90%AD%E5%BB%BA%E5%8F%8AAndroid%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<p>因为sentry可以私有化部署，相比起bugly，我们可以做跟多的单独定制功能，所以决定将需要即时上报的日志放在sentry上。</p>
<p>搭建环境：</p>
<ol>
<li>Ubuntu18.04 64位</li>
<li>sentry版本21.5.1</li>
</ol>
<p>环境要求：</p>
<ul>
<li>Docker 19.03.6+</li>
<li>Compose 1.24.1+</li>
<li>4 CPU Cores</li>
<li>8 GB RAM</li>
<li>20 GB Free Disk Space</li>
</ul>
<p>由于sentry需要使用redis、postgreSQL，所以选在了在新的虚拟机上进行部署</p>
<span id="more"></span>





<h4 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h4><p>目前是在Ubuntu18.04上使用deb文件安装的。官方指导在这里<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p>
<p>在 <a href="https://download.docker.com/linux/ubuntu/dists/">https://download.docker.com/linux/ubuntu/dists/</a> 这里选择一下自己ubuntu的系统对应的文件夹(也就是系统版本代号)，比如18.04对应<code>bionic</code>，然后进入<code>pool/stable</code>文件夹，选择对应的系统环境，比如ubuntu 18.04 64位，对应的地址应该是<code>https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/</code>,然后下载最新版本的软件，我现在下载的是</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">containerd</span>.io_1.<span class="hljs-number">4</span>.<span class="hljs-number">4</span>-<span class="hljs-number">1</span>_amd64.deb <br><span class="hljs-attribute">docker</span>-ce-cli_20.<span class="hljs-number">10</span>.<span class="hljs-number">6</span>~<span class="hljs-number">3</span>-<span class="hljs-number">0</span>~ubuntu-bionic_amd64.deb <br><span class="hljs-attribute">docker</span>-ce_20.<span class="hljs-number">10</span>.<span class="hljs-number">6</span>~<span class="hljs-number">3</span>-<span class="hljs-number">0</span>~ubuntu-bionic_amd64.deb<br></code></pre></td></tr></table></figure>

<p>然后按照顺序安装，安装完成后确认是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo docker run hello-world<br></code></pre></td></tr></table></figure>

<p>这条命令会下载测试镜像并运行，如果安装成功，则会在终端打印对应信息</p>
<p>如果上面的下载地址无法访问的话，可以使用国内的清华大学镜像源，地址是 <code>https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu/dists/bionic/pool/stable/amd64/</code></p>
<h4 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h4><p>访问 <a href="https://github.com/docker/compose/releases/tag/1.29.2">https://github.com/docker/compose/releases/tag/1.29.2</a> 下载linux版本，文件名字改成<code>docker-compose</code>，添加执行权限，并复制到<code> /usr/local/bin/</code>文件夹下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mv docker-compose-Linux-x86_64 docker-compose<br>chmox +x docker-compose<br>sudo cp docker-compose  /usr/local/bin/<br></code></pre></td></tr></table></figure>

<p>执行 <code>docker-compose -v</code>命令，能打印出版本信息证明安装程国平</p>
<h4 id="安装sentry"><a href="#安装sentry" class="headerlink" title="安装sentry"></a>安装sentry</h4><p>访问 <a href="https://github.com/getsentry/onpremise">https://github.com/getsentry/onpremise</a> 并克隆下来该仓库，仓库地址为：<code>git@github.com:getsentry/onpremise.git</code> 或者<code> https://github.com/getsentry/onpremise.git</code>,执行文件夹中的<code>install.sh</code>。过程会比较漫长，在这个过程中会让你创建sentry的用户，输入邮箱和密码。这个用户也就是你之后登陆sentry网页使用的账号密码。</p>
<p>安装过程中需要拉取docker镜像，众所周知的原因，有很大可能会失败，我们可以将docker的镜像源替换为国内的，比如中科大。ubuntu下替换方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">vi /etc/docker/daemon.json<br><span class="hljs-meta prompt_">#</span><span class="language-bash">文件内容</span><br>&#123;<br>    &quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]<br>&#125;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">保存后执行</span><br>systemctl restart docker.service<br></code></pre></td></tr></table></figure>

<h4 id="启动及使用"><a href="#启动及使用" class="headerlink" title="启动及使用"></a>启动及使用</h4><p>在上一步安装完成后的控制台会告诉你启动sentry服务的命令<code>docker-compose up -d</code>，</p>
<p>在浏览器中访问sentry服务器的ip:9000， 输入上一步创建的邮箱和密码就可以登录了。接下来可以跟着引导查看一下基本功能的使用。</p>
<p>现在我们创建一个Android应用，创建好了之后会有对应的引导提示如何在Android中使用sentry。</p>
<ol>
<li><p>添加仓库</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">repositories &#123;<br>  mavenCentral()<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>添加依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;io.sentry:sentry-android:4.3.0&#x27;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>在Androidmanifest.xml中添加应用信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;io.sentry.dsn&quot;</span> <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;http://b3a3844e753f4734b7ca1d6b154e6e06@192.168.102.181:9000/2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里的value值可以在sentry项目设置中找到。</p>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.sentry.Breadcrumb;<br><span class="hljs-keyword">import</span> io.sentry.Sentry;<br><span class="hljs-keyword">import</span> io.sentry.SentryEvent;<br><span class="hljs-keyword">import</span> io.sentry.SentryLevel;<br><span class="hljs-keyword">import</span> io.sentry.protocol.Message;<br><span class="hljs-keyword">import</span> io.sentry.protocol.User;<br><br>Sentry.captureMessage(<span class="hljs-string">&quot;captureMessage INFO&quot;</span>, SentryLevel.INFO);<br>Sentry.captureException(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;exception&quot;</span>));<br>Sentry.captureEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SentryEvent</span>());<br><span class="hljs-comment">//设置全局用户信息</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>user.setEmail(<span class="hljs-string">&quot;a@a.com&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>user.setId(userId);<br>Sentry.setUser(user);<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="关于混淆"><a href="#关于混淆" class="headerlink" title="关于混淆"></a>关于混淆</h4><p>如果应用经过混淆，我们需要将mapping文件上传到sentry平台，才能定位到错误代码所在位置。</p>
<p>首先在<code>app/build.gradle</code>中添加plugin：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;io.sentry.android.gradle&#x27;</span><br></code></pre></td></tr></table></figure>

<p>然后在工程根目录下的<code>build.gradle</code>文件中添加</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>        classpath <span class="hljs-string">&#x27;io.sentry:sentry-android-gradle-plugin:1.7.36&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们还需要在项目根目录下添加一个<code>sentry.properties</code>文件，用来配置我们的mapping文件上传到哪个项目中</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">defaults.project</span>=<span class="hljs-string">your-project</span><br><span class="hljs-attr">defaults.org</span>=<span class="hljs-string">your-org</span><br><span class="hljs-attr">auth.token</span>=<span class="hljs-string">YOUR_AUTH_TOKEN</span><br><span class="hljs-attr">defaults.url</span>=<span class="hljs-string">your sentry service address</span><br></code></pre></td></tr></table></figure>

<p>这里的org的值在<code>Organization Settings</code>中查看，是<code>Organization Slug</code>的值，而不是<code>Display Name</code>的值</p>
<p><img src="/image/sentry_upload_mapping.png" alt="sentry_upload_mapping"></p>
<p>token值在上图中的 <code>API keys</code>里面，没有的话创建一个新的就好，权限我是用的默认。</p>
<p>然后我们打个release包，上传成功后会在控制台打印出对应信息。我们可以在项目设置 <code>ProGuard</code>中找到上传的mapping文件。</p>
<p>如果不希望自动上传mapping，我们可以将其关闭，使用<code>sentry-cli</code>进行手动上传</p>
<p>在<code>app/build.gradle</code>中添加如下配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">sentry &#123;<br>    <span class="hljs-comment">// Disables or enables the automatic configuration of ProGuard</span><br>    <span class="hljs-comment">// for Sentry.  This injects a default config for ProGuard so</span><br>    <span class="hljs-comment">// you don&#x27;t need to do it manually.</span><br><br>    <span class="hljs-comment">// Only enable it if you are using sentry-android &lt;= v1.7,</span><br>    <span class="hljs-comment">// sentry-android &gt;= v2.0 already does it automatically.</span><br>    autoProguardConfig <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">// Enables or disables the automatic upload of mapping files</span><br>    <span class="hljs-comment">// during a build.  If you disable this, you&#x27;ll need to manually</span><br>    <span class="hljs-comment">// upload the mapping files with sentry-cli when you do a release.</span><br>    autoUpload <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// Disables or enables the automatic configuration of Native Symbols</span><br>    <span class="hljs-comment">// for Sentry. This executes sentry-cli automatically so</span><br>    <span class="hljs-comment">// you don&#x27;t need to do it manually.</span><br>    <span class="hljs-comment">// Default is disabled.</span><br>    uploadNativeSymbols <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment">// Does or doesn&#x27;t include the source code of native code for Sentry.</span><br>    <span class="hljs-comment">// This executes sentry-cli with the --include-sources param. automatically so</span><br>    <span class="hljs-comment">// you don&#x27;t need to do it manually.</span><br>    <span class="hljs-comment">// Default is disabled.</span><br>    includeNativeSources <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>sentry-cli的安装在这里 <a href="https://docs.sentry.io/product/cli/installation/">https://docs.sentry.io/product/cli/installation/</a></p>
<p>sentry-cli的配置 <a href="https://docs.sentry.io/product/cli/configuration/">https://docs.sentry.io/product/cli/configuration/</a></p>
<p>sentry-cli 的使用 <a href="https://docs.sentry.io/product/cli/dif/#proguard-mapping-upload">https://docs.sentry.io/product/cli/dif/#proguard-mapping-upload</a></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>运维</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>PMS及apk安装过程</title>
    <url>/2021/04/05/PMS%E5%8F%8Aapk%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>先从如何使用代码安装一个apk开始。</p>
<p>在7.0之前，我们可以直接指定apk的路径进行安装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.Action_View);<br><span class="hljs-type">String</span> <span class="hljs-variable">filepath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/sdcard/a.apk&quot;</span>;<br>intent.setDataAndType(Uri.parse(<span class="hljs-string">&quot;file://&quot;</span> + filepath),<span class="hljs-string">&quot;application/vnd.android.package-archive&quot;</span>);<br>startActivity(intent);<br></code></pre></td></tr></table></figure>

<p>在7.0及以后，需要使用FileProvider进行安装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">apk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(...);<br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_VIEW);<br>intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);<br>intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);<br><span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> FileProvider.getUriForFile(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;com.example.demo.fileprovider&quot;</span>, apk);<br>intent.setDataAndType(uri, <span class="hljs-string">&quot;application/vnd.android.package-archive&quot;</span>);<br>startActivity(intent);<br></code></pre></td></tr></table></figure>

<p>不管是哪个版本，我们都需要调用<code>intent.setDataAndType</code>方法，我们在aosp源码中找到了对应的Activity：在<code>packages/apps/PackageInstaller</code>文件夹下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.InstallStart&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">android:excludeFromRecents</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span> <span class="hljs-attr">android:priority</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.INSTALL_PACKAGE&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;content&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:mimeType</span>=<span class="hljs-string">&quot;application/vnd.android.package-archive&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span> <span class="hljs-attr">android:priority</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.INSTALL_PACKAGE&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;package&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;content&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span> <span class="hljs-attr">android:priority</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="PackageInstaller准备工作"><a href="#PackageInstaller准备工作" class="headerlink" title="PackageInstaller准备工作"></a>PackageInstaller准备工作</h3><h4 id="com-android-packageinstaller-InstallStart"><a href="#com-android-packageinstaller-InstallStart" class="headerlink" title="com.android.packageinstaller.InstallStart"></a>com.android.packageinstaller.InstallStart</h4><p><code>InstallStart</code>继承自Activity，先看注释：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Select which activity is the first visible activity of the installation and forward the intent to</span><br><span class="hljs-comment"> * it.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p>很清楚了，判断需要打开哪个页面。</p>
<p>我们来看<code>onCreate</code>方法中的关键地方</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">nextActivity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(intent);<br>nextActivity.setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);<br><br><span class="hljs-comment">// The the installation source as the nextActivity thinks this activity is the source, hence</span><br><span class="hljs-comment">// set the originating UID and sourceInfo explicitly</span><br>nextActivity.putExtra(PackageInstallerActivity.EXTRA_CALLING_PACKAGE, callingPackage);<br>nextActivity.putExtra(PackageInstallerActivity.EXTRA_ORIGINAL_SOURCE_INFO, sourceInfo);<br>nextActivity.putExtra(Intent.EXTRA_ORIGINATING_UID, originatingUid);<br><br><span class="hljs-keyword">if</span> (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) &#123;<br>    nextActivity.setClass(<span class="hljs-built_in">this</span>, PackageInstallerActivity.class);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">Uri</span> <span class="hljs-variable">packageUri</span> <span class="hljs-operator">=</span> intent.getData();<br><br>    <span class="hljs-keyword">if</span> (packageUri != <span class="hljs-literal">null</span> &amp;&amp; (packageUri.getScheme().equals(ContentResolver.SCHEME_FILE)<br>                               || packageUri.getScheme().equals(ContentResolver.SCHEME_CONTENT))) &#123;<br>        <span class="hljs-comment">// Copy file to prevent it from being changed underneath this process</span><br>        nextActivity.setClass(<span class="hljs-built_in">this</span>, InstallStaging.class);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (packageUri != <span class="hljs-literal">null</span> &amp;&amp; packageUri.getScheme().equals(<br>        PackageInstallerActivity.SCHEME_PACKAGE)) &#123;<br>        nextActivity.setClass(<span class="hljs-built_in">this</span>, PackageInstallerActivity.class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        result.putExtra(Intent.EXTRA_INSTALL_RESULT,<br>                        PackageManager.INSTALL_FAILED_INVALID_URI);<br>        setResult(RESULT_FIRST_USER, result);<br><br>        nextActivity = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (nextActivity != <span class="hljs-literal">null</span>) &#123;<br>    startActivity(nextActivity);<br>&#125;<br>finish();<br></code></pre></td></tr></table></figure>

<p>在7.0之后的版本上，由于使用FIleProvider，会隐藏共享文件的真实路径，并将路径转换成:Uri路径，这样就会跳转到<code>InstallStaging</code>这个类</p>
<h4 id="com-android-packageinstaller-InstallStaging"><a href="#com-android-packageinstaller-InstallStaging" class="headerlink" title="com.android.packageinstaller.InstallStaging"></a>com.android.packageinstaller.InstallStaging</h4><p>同样先看顶部注释</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">/**<br> * If a package gets installed <span class="hljs-keyword">from</span> an content URI this step loads <span class="hljs-keyword">the</span> package <span class="hljs-keyword">and</span> turns <span class="hljs-keyword">it</span> <span class="hljs-keyword">into</span><br> * <span class="hljs-keyword">and</span> installation <span class="hljs-keyword">from</span> a <span class="hljs-built_in">file</span>. Then <span class="hljs-keyword">it</span> re-starts <span class="hljs-keyword">the</span> installation <span class="hljs-keyword">as</span> usual.<br> */<br></code></pre></td></tr></table></figure>

<p>如果是从Uri安装的，会先转化成文件，然后再进行安装</p>
<p>我们找到对应的方法，是在onResume中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResume</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.onResume();<br><br>    <span class="hljs-comment">// This is the first onResume in a single life of the activity</span><br>    <span class="hljs-keyword">if</span> (mStagingTask == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// File does not exist, or became invalid</span><br>        <span class="hljs-keyword">if</span> (mStagedFile == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Create file delayed to be able to show error</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                mStagedFile = TemporaryFileManager.getStagedFile(<span class="hljs-built_in">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                showError();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>        mStagingTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StagingAsyncTask</span>();<br>        mStagingTask.execute(getIntent().getData());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StagingAsyncTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AsyncTask</span>&lt;Uri, Void, Boolean&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Boolean <span class="hljs-title function_">doInBackground</span><span class="hljs-params">(Uri... params)</span> &#123;<br>        <span class="hljs-keyword">if</span> (params == <span class="hljs-literal">null</span> || params.length &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Uri</span> <span class="hljs-variable">packageUri</span> <span class="hljs-operator">=</span> params[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> getContentResolver().openInputStream(packageUri)) &#123;<br>            <span class="hljs-comment">// Despite the comments in ContentResolver#openInputStream the returned stream can</span><br>            <span class="hljs-comment">// be null.</span><br>            <span class="hljs-keyword">if</span> (in == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(mStagedFile)) &#123;<br>                <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>                <span class="hljs-type">int</span> bytesRead;<br>                <span class="hljs-keyword">while</span> ((bytesRead = in.read(buffer)) &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// Be nice and respond to a cancellation</span><br>                    <span class="hljs-keyword">if</span> (isCancelled()) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    out.write(buffer, <span class="hljs-number">0</span>, bytesRead);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | SecurityException | IllegalStateException e) &#123;<br>            Log.w(LOG_TAG, <span class="hljs-string">&quot;Error staging apk from content URI&quot;</span>, e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPostExecute</span><span class="hljs-params">(Boolean success)</span> &#123;<br>        <span class="hljs-keyword">if</span> (success) &#123;<br>            <span class="hljs-comment">// Now start the installation again from a file</span><br>            <span class="hljs-type">Intent</span> <span class="hljs-variable">installIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(getIntent());<br>            installIntent.setClass(InstallStaging.<span class="hljs-built_in">this</span>, DeleteStagedFileOnResult.class);<br>            installIntent.setData(Uri.fromFile(mStagedFile));<br><br>            <span class="hljs-keyword">if</span> (installIntent.getBooleanExtra(Intent.EXTRA_RETURN_RESULT, <span class="hljs-literal">false</span>)) &#123;<br>                installIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);<br>            &#125;<br><br>            installIntent.addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);<br>            startActivity(installIntent);<br><br>            InstallStaging.<span class="hljs-built_in">this</span>.finish();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            showError();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里创建了<code>StagingAsyncTask</code>, 将uri(最开始传入的apk文件的uri，也是task中的packageUri)中的内容写入到mStagedFile中；如果写入成功，则跳转到<code>DeleteStagedFileOnResult</code>页面</p>
<h4 id="com-android-packageinstaller-DeleteStagedFileOnResult"><a href="#com-android-packageinstaller-DeleteStagedFileOnResult" class="headerlink" title="com.android.packageinstaller.DeleteStagedFileOnResult"></a>com.android.packageinstaller.DeleteStagedFileOnResult</h4><p>先看顶部注释</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Trampoline activity. Calls PackageInstallerActivity and deletes staged install file onResult.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p>作为中间层的页面，打开PackageInstallerActivity，并且在返回的时候删除暂存文件。没啥好说的，直接到PackageInstallerActivity</p>
<h4 id="com-android-packageinstaller-PackageInstallerActivity"><a href="#com-android-packageinstaller-PackageInstallerActivity" class="headerlink" title="com.android.packageinstaller.PackageInstallerActivity"></a>com.android.packageinstaller.PackageInstallerActivity</h4><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This activity is launched when a new application is installed via side loading</span><br><span class="hljs-comment"> * The package is first parsed and the user is notified of parse errors via a dialog.</span><br><span class="hljs-comment"> * If the package is successfully parsed, the user is notified to turn on the install unknown</span><br><span class="hljs-comment"> * applications setting. A memory check is made at this point and the user is notified of out</span><br><span class="hljs-comment"> * of memory conditions if any. If the package is already existing on the device,</span><br><span class="hljs-comment"> * a confirmation dialog (to replace the existing package) is presented to the user.</span><br><span class="hljs-comment"> * Based on the user response the package is then installed by launching InstallAppConfirm</span><br><span class="hljs-comment"> * sub activity. All state transitions are handled in this activity</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p>粗略的描述了应用程序的安装过程：先对安装包进行解析，解析失败则弹窗通知；解析成功后，通知用户打开”安装未知应用程序”设置，进行内容检查，如果内存不足，则通知用户；如果设备上已经存在该应用，则通知用户进行替换，然后根据用户响应，通过启动InstallAppConfirm来安装软件包。</p>
<p>我们来看onCreate方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle icicle)</span> &#123;<br>      <span class="hljs-built_in">super</span>.onCreate(<span class="hljs-literal">null</span>);<br><br>      <span class="hljs-keyword">if</span> (icicle != <span class="hljs-literal">null</span>) &#123;<br>          mAllowUnknownSources = icicle.getBoolean(ALLOW_UNKNOWN_SOURCES_KEY);<br>      &#125;<br><br>      mPm = getPackageManager();<br>      mIpm = AppGlobals.getPackageManager();<br>      mAppOpsManager = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);<br>      mInstaller = mPm.getPackageInstaller();<br>      mUserManager = (UserManager) getSystemService(Context.USER_SERVICE);<br>。<br>      。<br>      。<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">wasSetUp</span> <span class="hljs-operator">=</span> processPackageUri(packageUri);<br>      <span class="hljs-keyword">if</span> (!wasSetUp) &#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// load dummy layout with OK button disabled until we override this layout in</span><br>      <span class="hljs-comment">// startInstallConfirm</span><br>      bindUi(R.layout.install_confirm, <span class="hljs-literal">false</span>);<br>      checkIfAllowedAndInitiateInstall();<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>一开始初始化需要的各种对象，PackageManager、IPackageManager、IPackageManager、UserManager、PackageInstaller等；</p>
<p>瞄一眼<code>processPackageUri</code>方法：根据Uri拿到scheme,然后根据scheme类型拿到packageInfo;如果scheme既不是<code>package</code>也不是<code>file</code>，则抛出<code>IllegalArgumentException</code>异常。</p>
<p><code>bindUi</code>是设置页面按钮的点击事件。</p>
<p>看下<code>checkIfAllowedAndInitiateInstall</code>方法：如果允许安装未知来源或者该应用不是未知来源，则调用<code>initiateInstall</code>方法进行安装；在<code>initiateInstall</code>方法中，获取包名信息，进入判断设备上是否已经安装该应用流程，最后调用<code>startInstallConfirm</code>初始化确认安装界面，列出应用所需权限信息</p>
<p>总结一下这些步骤：</p>
<ul>
<li>根据Uri中的scheme不同，跳转到不同页面</li>
<li>InstallStart将content协议转化为file协议，跳转到InstallStaging，然后跳转到PackageInstallerActivity</li>
<li>在PackageInstallerActivity，对协议进行处理，解析文件得到PackageInfo</li>
<li>对未知来源apk进行处理，初始化页面</li>
</ul>
<h3 id="PackageInstaller安装apk"><a href="#PackageInstaller安装apk" class="headerlink" title="PackageInstaller安装apk"></a>PackageInstaller安装apk</h3><p>当我们点击安装页面中确认按钮时，调用<code>onClick</code>方法，接着调用<code>startInstall</code>打开<code>InstallInstalling</code>页面进行安装。老规矩，先看顶部注释</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">/**<br> * Send <span class="hljs-keyword">package</span> to the <span class="hljs-keyword">package</span> manager <span class="hljs-keyword">and</span> handle results from <span class="hljs-keyword">package</span> manager. Once the<br> * installation succeeds, start &#123;@link InstallSuccess&#125; <span class="hljs-keyword">or</span> &#123;@link InstallFailed&#125;.<br> * &lt;p&gt;This has two phases: First <span class="hljs-keyword">send</span> the data to the <span class="hljs-keyword">package</span> manager, then <span class="hljs-keyword">wait</span> <span class="hljs-keyword">until</span> the <span class="hljs-keyword">package</span><br> * manager processed the result.&lt;<span class="hljs-regexp">/p&gt;</span><br><span class="hljs-regexp"> */</span><br></code></pre></td></tr></table></figure>

<p>主要用于向包管理器发送包的信息，并处理回调，安装成功则打开<code>InstallSuccess</code>,失败则打开<code>InstallFailed</code></p>
<h4 id="com-android-packageinstaller-InstallInstalling"><a href="#com-android-packageinstaller-InstallInstalling" class="headerlink" title="com.android.packageinstaller.InstallInstalling"></a>com.android.packageinstaller.InstallInstalling</h4><p>看下onCreate做了啥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Bundle savedInstanceState)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br><br>    setContentView(R.layout.install_installing);<br><br>    <span class="hljs-type">ApplicationInfo</span> <span class="hljs-variable">appInfo</span> <span class="hljs-operator">=</span> getIntent()<br>            .getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO);<br>    mPackageURI = getIntent().getData();<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;package&quot;</span>.equals(mPackageURI.getScheme())) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            getPackageManager().installExistingPackage(appInfo.packageName);<br>            launchSuccess();<br>        &#125; <span class="hljs-keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;<br>            launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">sourceFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(mPackageURI.getPath());<br>        PackageUtil.initSnippetForNewApp(<span class="hljs-built_in">this</span>, PackageUtil.getAppSnippet(<span class="hljs-built_in">this</span>, appInfo,<br>                sourceFile), R.id.app_snippet);<br><br>        <span class="hljs-keyword">if</span> (savedInstanceState != <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//----1------</span><br>            mSessionId = savedInstanceState.getInt(SESSION_ID);<br>            mInstallId = savedInstanceState.getInt(INSTALL_ID);<br><br>            <span class="hljs-comment">// Reregister for result; might instantly call back if result was delivered while</span><br>            <span class="hljs-comment">// activity was destroyed</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                InstallEventReceiver.addObserver(<span class="hljs-built_in">this</span>, mInstallId,<br>                        <span class="hljs-built_in">this</span>::launchFinishBasedOnResult);<br>            &#125; <span class="hljs-keyword">catch</span> (EventResultPersister.OutOfIdsException e) &#123;<br>                <span class="hljs-comment">// Does not happen</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            PackageInstaller.<span class="hljs-type">SessionParams</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageInstaller</span>.SessionParams(<br>                    PackageInstaller.SessionParams.MODE_FULL_INSTALL);<br>            params.installFlags = PackageManager.INSTALL_FULL_APP;<br>            params.referrerUri = getIntent().getParcelableExtra(Intent.EXTRA_REFERRER);<br>            params.originatingUri = getIntent()<br>                    .getParcelableExtra(Intent.EXTRA_ORIGINATING_URI);<br>            params.originatingUid = getIntent().getIntExtra(Intent.EXTRA_ORIGINATING_UID,<br>                    UID_UNKNOWN);<br>            params.installerPackageName =<br>                    getIntent().getStringExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME);<br><br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(mPackageURI.getPath());<br>            <span class="hljs-keyword">try</span> &#123;<br>                PackageParser.<span class="hljs-type">PackageLite</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> PackageParser.parsePackageLite(file, <span class="hljs-number">0</span>);<br>                params.setAppPackageName(pkg.packageName);<br>                params.setInstallLocation(pkg.installLocation);<br>                params.setSize(<br>                        PackageHelper.calculateInstalledSize(pkg, <span class="hljs-literal">false</span>, params.abiOverride));<br>            &#125; <span class="hljs-keyword">catch</span> (PackageParser.PackageParserException e) &#123;<br>                Log.e(LOG_TAG, <span class="hljs-string">&quot;Cannot parse package &quot;</span> + file + <span class="hljs-string">&quot;. Assuming defaults.&quot;</span>);<br>                Log.e(LOG_TAG,<br>                        <span class="hljs-string">&quot;Cannot calculate installed size &quot;</span> + file + <span class="hljs-string">&quot;. Try only apk size.&quot;</span>);<br>                params.setSize(file.length());<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                Log.e(LOG_TAG,<br>                        <span class="hljs-string">&quot;Cannot calculate installed size &quot;</span> + file + <span class="hljs-string">&quot;. Try only apk size.&quot;</span>);<br>                params.setSize(file.length());<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//-------2-------</span><br>                mInstallId = InstallEventReceiver<br>                        .addObserver(<span class="hljs-built_in">this</span>, EventResultPersister.GENERATE_NEW_ID,<br>                                <span class="hljs-built_in">this</span>::launchFinishBasedOnResult);<br>            &#125; <span class="hljs-keyword">catch</span> (EventResultPersister.OutOfIdsException e) &#123;<br>                launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, <span class="hljs-literal">null</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//-------3-------</span><br>                mSessionId = getPackageManager().getPackageInstaller().createSession(params);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                launchFailure(PackageManager.INSTALL_FAILED_INTERNAL_ERROR, <span class="hljs-literal">null</span>);<br>            &#125;<br>        &#125;<br><br>        mSessionCallback = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstallSessionCallback</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在onCreate方法中会对<code>package</code>和<code>content</code>协议的Uri进袭姑娘处理，我们关注一下content协议的uri处理部分:</p>
<p>首先判断savedInstanceState是否为空，不为空则从中获取mSessionId和mInstallId，然后向InstallEventReceiver注册一个观察者。</p>
<p>如果为空，则构建一个 PackageInstaller.SessionParams对象，在注释2处同样注册了一个观察者，然后在注释3处创建并返回sessionId</p>
<ul>
<li><p>这里创建mSessionId时，在createSession方法内部会通过<code>IPackageInstaller</code>与<code>PackageInstallerService</code>进行进程间通信，最终调用的是<code>PackageInstaller</code>的<code>createSession</code>方法来创建并返回的sessionId</p>
</li>
<li><p>这里注册的观察者是<code>launchFinishBasedOnResult</code>方法，根据安装结果不同，跳转到不同的页面(安装成功、安装失败)</p>
</li>
<li><p>这里的InstallEventReceiver是继承自BroadcastReceiver的广播接收器，可以看作是一个中间层，真正保存观察者的类是EventResultPersister，对于<code>EventResultPersister</code>注释是这样的：<strong>Persists results of events and calls back observers when a matching result arrives.</strong></p>
</li>
</ul>
<p>我们接着看InstallInstalling的onResume方法</p>
<h4 id="com-android-packageinstaller-InstallInstalling-1"><a href="#com-android-packageinstaller-InstallInstalling-1" class="headerlink" title="com.android.packageinstaller.InstallInstalling"></a>com.android.packageinstaller.InstallInstalling</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResume</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.onResume();<br><br>    <span class="hljs-comment">// This is the first onResume in a single life of the activity</span><br>    <span class="hljs-keyword">if</span> (mInstallingTask == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">PackageInstaller</span> <span class="hljs-variable">installer</span> <span class="hljs-operator">=</span> getPackageManager().getPackageInstaller();<br>        PackageInstaller.<span class="hljs-type">SessionInfo</span> <span class="hljs-variable">sessionInfo</span> <span class="hljs-operator">=</span> installer.getSessionInfo(mSessionId);<br><br>        <span class="hljs-keyword">if</span> (sessionInfo != <span class="hljs-literal">null</span> &amp;&amp; !sessionInfo.isActive()) &#123;<br>            mInstallingTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstallingAsyncTask</span>();<br>            mInstallingTask.execute();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// we will receive a broadcast when the install is finished</span><br>            mCancelButton.setEnabled(<span class="hljs-literal">false</span>);<br>            setFinishOnTouchOutside(<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>&#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Send the package to the package installer and then register a event result observer that</span><br><span class="hljs-comment">     * will call &#123;<span class="hljs-doctag">@link</span> #launchFinishBasedOnResult(int, int, String)&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstallingAsyncTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AsyncTask</span>&lt;Void, Void,<br>            PackageInstaller.Session&gt; &#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> isDone;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> PackageInstaller.Session <span class="hljs-title function_">doInBackground</span><span class="hljs-params">(Void... params)</span> &#123;<br>            PackageInstaller.Session session;<br>            <span class="hljs-keyword">try</span> &#123;<br>                session = getPackageManager().getPackageInstaller().openSession(mSessionId);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            session.setStagingProgress(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(mPackageURI.getPath());<br><br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file)) &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">sizeBytes</span> <span class="hljs-operator">=</span> file.length();<br>                    <span class="hljs-keyword">try</span> (<span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> session<br>                            .openWrite(<span class="hljs-string">&quot;PackageInstaller&quot;</span>, <span class="hljs-number">0</span>, sizeBytes)) &#123;<br>                        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>                        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">numRead</span> <span class="hljs-operator">=</span> in.read(buffer);<br><br>                            <span class="hljs-keyword">if</span> (numRead == -<span class="hljs-number">1</span>) &#123;<br>                                session.fsync(out);<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br><br>                            <span class="hljs-keyword">if</span> (isCancelled()) &#123;<br>                                session.close();<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br><br>                            out.write(buffer, <span class="hljs-number">0</span>, numRead);<br>                            <span class="hljs-keyword">if</span> (sizeBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-type">float</span> <span class="hljs-variable">fraction</span> <span class="hljs-operator">=</span> ((<span class="hljs-type">float</span>) numRead / (<span class="hljs-type">float</span>) sizeBytes);<br>                                session.addProgress(fraction);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> session;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException | SecurityException e) &#123;<br>                Log.e(LOG_TAG, <span class="hljs-string">&quot;Could not write package&quot;</span>, e);<br><br>                session.close();<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    isDone = <span class="hljs-literal">true</span>;<br>                    notifyAll();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPostExecute</span><span class="hljs-params">(PackageInstaller.Session session)</span> &#123;<br>            <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">broadcastIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(BROADCAST_ACTION);<br>                broadcastIntent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);<br>                broadcastIntent.setPackage(<br>                        getPackageManager().getPermissionControllerPackageName());<br>                broadcastIntent.putExtra(EventResultPersister.EXTRA_ID, mInstallId);<br><br>                <span class="hljs-type">PendingIntent</span> <span class="hljs-variable">pendingIntent</span> <span class="hljs-operator">=</span> PendingIntent.getBroadcast(<br>                        InstallInstalling.<span class="hljs-built_in">this</span>,<br>                        mInstallId,<br>                        broadcastIntent,<br>                        PendingIntent.FLAG_UPDATE_CURRENT);<br><br>                session.commit(pendingIntent.getIntentSender());<br>                mCancelButton.setEnabled(<span class="hljs-literal">false</span>);<br>                setFinishOnTouchOutside(<span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                getPackageManager().getPackageInstaller().abandonSession(mSessionId);<br><br>                <span class="hljs-keyword">if</span> (!isCancelled()) &#123;<br>                    launchFailure(PackageManager.INSTALL_FAILED_INVALID_APK, <span class="hljs-literal">null</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这里根据mSessionId获取到安装会话的详细信息，如果sessionInfo不空并且是活动的，接着会创建<code>InstallingAsyncTask</code>任务并立即执行。该任务将APK信息通过IO流的形式写入 PackageInstaller.Session中。</p>
<p>之后，在onPostExecute方法中创建一个PendingIntent，并通过 PackageInstaller.Session 的commit方法将IntentSender发送出去。这里的 <code>PackageInstaller.Session.commit</code>方法，调用的是<code>IPackageInstallerSession</code>的commit方法，进行进程间通信，最终会调用PackageInstallerSession的commit方法。</p>
<h4 id="com-android-server-pm-PackageInstallerSession"><a href="#com-android-server-pm-PackageInstallerSession" class="headerlink" title="com.android.server.pm.PackageInstallerSession"></a>com.android.server.pm.PackageInstallerSession</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IntentSender statusReceiver, <span class="hljs-type">boolean</span> forTransfer)</span> &#123;<br>     Preconditions.checkNotNull(statusReceiver);<br><br>     <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> wasSealed;<br>     <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        <br>         <span class="hljs-keyword">final</span> <span class="hljs-type">PackageInstallObserverAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageInstallObserverAdapter</span>(<br>                 mContext, statusReceiver, sessionId,<br>                 isInstallerDeviceOwnerOrAffiliatedProfileOwnerLocked(), userId);<br>         mRemoteObserver = adapter.getBinder();<br><span class="hljs-comment">//·······省略一些代码·······//</span><br>         <span class="hljs-comment">// Client staging is fully done at this point</span><br>         mClientProgress = <span class="hljs-number">1f</span>;<br>         computeProgressLocked(<span class="hljs-literal">true</span>);<br><br>         <span class="hljs-comment">// This ongoing commit should keep session active, even though client</span><br>         <span class="hljs-comment">// will probably close their end.</span><br>         mActiveCount.incrementAndGet();<br><br>         mCommitted = <span class="hljs-literal">true</span>;<br>         mHandler.obtainMessage(MSG_COMMIT).sendToTarget();<br>     &#125;<br><br>     <span class="hljs-keyword">if</span> (!wasSealed) &#123;<br>         <span class="hljs-comment">// Persist the fact that we&#x27;ve sealed ourselves to prevent</span><br>         <span class="hljs-comment">// mutations of any hard links we create. We do this without holding</span><br>         <span class="hljs-comment">// the session lock, since otherwise it&#x27;s a lock inversion.</span><br>         mCallback.onSessionSealedBlocking(<span class="hljs-built_in">this</span>);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<p>在这里将相关信息封装为PackageInstallObserverAdapter对象，然后再向mHandler发送一个<code>MSG_COMMIT</code>的消息，在这个handler的callback中是这么处理的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Handler.<span class="hljs-type">Callback</span> <span class="hljs-variable">mHandlerCallback</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>.Callback() &#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>           <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>         <br>               <span class="hljs-keyword">case</span> MSG_COMMIT:<br>                   <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>                       <span class="hljs-keyword">try</span> &#123;<br>                           commitLocked();<span class="hljs-comment">//-------1-------</span><br>                       &#125; <span class="hljs-keyword">catch</span> (PackageManagerException e) &#123;<br>                           <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">completeMsg</span> <span class="hljs-operator">=</span> ExceptionUtils.getCompleteMessage(e);<br>                           Slog.e(TAG,<br>                                   <span class="hljs-string">&quot;Commit of session &quot;</span> + sessionId + <span class="hljs-string">&quot; failed: &quot;</span> + completeMsg);<br>                           destroyInternal();<br>                           dispatchSessionFinished(e.error, completeMsg, <span class="hljs-literal">null</span>);<br>                       &#125;<br>                   &#125;<br>                   <span class="hljs-keyword">break</span>;<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br>   &#125;;<br></code></pre></td></tr></table></figure>

<p>在注释1处调用了commitLocked，在该方法中调用了PackageManagerService对象的installStage方法</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey">mPm.installStage(mPackageName, stageDir, localObserver, params,<br><span class="hljs-built_in">        mInstallerPackageName,</span> mInstallerUid, user, mSigningDetails)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>在commitLocked方法中如果抛出了PackageManagerException，则会调用<code>dispatchSessionFinished</code>方法，向mHandler发送一个<code>MSG_ON_PACKAGE_INSTALLED</code>消息，调用<code>observer.onPackageInstalled(packageName, returnCode, message, extras);</code>这里的<code>observer</code>对象是<code>.PackageInstallerSession.commit</code>方法通过<code>adapter.getBinder()</code>方法获取到的<code>IPackageInstallObserver2</code>对象。</p>
<p>简单来讲，也就两个步骤：</p>
<ul>
<li>将APK信息通过IO流写入到PackageInstaller.Session中</li>
<li>调用PackageInstaller.Session的commit方法，发送消息到handler，最终交给PMS处理。</li>
</ul>
<h3 id="PMS介入安装过程"><a href="#PMS介入安装过程" class="headerlink" title="PMS介入安装过程"></a>PMS介入安装过程</h3><p>上面提到在commitLocked方法中，调用了<code>PackageManagerService</code>对象的installStage方法。老规矩，先看下<code>PackageManagerService</code>类的顶部注释，挺长的不贴了，主要介绍了两个锁对象以及这两个锁对象的使用方法注意事项。看下installStage方法</p>
<h4 id="com-android-server-pm-PackageManagerService"><a href="#com-android-server-pm-PackageManagerService" class="headerlink" title="com.android.server.pm.PackageManagerService"></a>com.android.server.pm.PackageManagerService</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">installStage</span><span class="hljs-params">(String packageName, File stagedDir,</span><br><span class="hljs-params">                  IPackageInstallObserver2 observer, PackageInstaller.SessionParams sessionParams,</span><br><span class="hljs-params">                  String installerPackageName, <span class="hljs-type">int</span> installerUid, UserHandle user,</span><br><span class="hljs-params">                  PackageParser.SigningDetails signingDetails)</span> &#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_INSTANT) &#123;<br>        <span class="hljs-keyword">if</span> ((sessionParams.installFlags &amp; PackageManager.INSTALL_INSTANT_APP) != <span class="hljs-number">0</span>) &#123;<br>            Slog.d(TAG, <span class="hljs-string">&quot;Ephemeral install of &quot;</span> + packageName);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">VerificationInfo</span> <span class="hljs-variable">verificationInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VerificationInfo</span>(<br>        sessionParams.originatingUri, sessionParams.referrerUri,<br>        sessionParams.originatingUid, installerUid);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">OriginInfo</span> <span class="hljs-variable">origin</span> <span class="hljs-operator">=</span> OriginInfo.fromStagedFile(stagedDir);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mHandler.obtainMessage(INIT_COPY);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">installReason</span> <span class="hljs-operator">=</span> fixUpInstallReason(installerPackageName, installerUid,<br>                                                 sessionParams.installReason);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">InstallParams</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstallParams</span>(origin, <span class="hljs-literal">null</span>, observer,<br>                                                   sessionParams.installFlags, installerPackageName, sessionParams.volumeUuid,<br>                                                   verificationInfo, user, sessionParams.abiOverride,<br>                                                   sessionParams.grantedRuntimePermissions, signingDetails, installReason);<br>    params.setTraceMethod(<span class="hljs-string">&quot;installStage&quot;</span>).setTraceCookie(System.identityHashCode(params));<br>    msg.obj = params;<span class="hljs-comment">//-------1-------</span><br><br>    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="hljs-string">&quot;installStage&quot;</span>,<br>                          System.identityHashCode(msg.obj));<br>    Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="hljs-string">&quot;queueInstall&quot;</span>,<br>                          System.identityHashCode(msg.obj));<br><br>    mHandler.sendMessage(msg);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要是创建了一个类型为<code>INIT_COPY</code>的Message对象，然后通过发送到mHandler。注意注释1处的msg.obj的值，是一个<code>InstallParams</code>对象(继承自HandlerParams)，后面会用到。我们接着看mHanlder的处理</p>
<h4 id="com-android-server-pm-PackageManagerService-1"><a href="#com-android-server-pm-PackageManagerService-1" class="headerlink" title="com.android.server.pm.PackageManagerService"></a>com.android.server.pm.PackageManagerService</h4><p>这里的mHandler是继承自Handler的<code>PackageHandler</code>对象，是PMS的内部类，我们看下具体的处理逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>           <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>               <span class="hljs-keyword">case</span> INIT_COPY: &#123;<br>                   <span class="hljs-type">HandlerParams</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> (HandlerParams) msg.obj;<br>                   <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> mPendingInstalls.size();<br>                   <span class="hljs-keyword">if</span> (DEBUG_INSTALL) Slog.i(TAG, <span class="hljs-string">&quot;init_copy idx=&quot;</span> + idx + <span class="hljs-string">&quot;: &quot;</span> + params);<br>                   <span class="hljs-comment">// If a bind was already initiated we dont really</span><br>                   <span class="hljs-comment">// need to do anything. The pending install</span><br>                   <span class="hljs-comment">// will be processed later on.</span><br>                   <span class="hljs-keyword">if</span> (!mBound) &#123;<br>                       Trace.asyncTraceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="hljs-string">&quot;bindingMCS&quot;</span>,<br>                               System.identityHashCode(mHandler));<br>                       <span class="hljs-comment">// If this is the only one pending we might</span><br>                       <span class="hljs-comment">// have to bind to the service again.</span><br>                       <span class="hljs-keyword">if</span> (!connectToService()) &#123;<br>                           Slog.e(TAG, <span class="hljs-string">&quot;Failed to bind to media container service&quot;</span>);<br>                           params.serviceError();<br>                           Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, <span class="hljs-string">&quot;bindingMCS&quot;</span>,<br>                                   System.identityHashCode(mHandler));<br>                           <span class="hljs-keyword">if</span> (params.traceMethod != <span class="hljs-literal">null</span>) &#123;<br>                               Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, params.traceMethod,<br>                                       params.traceCookie);<br>                           &#125;<br>                           <span class="hljs-keyword">return</span>;<br>                       &#125; <span class="hljs-keyword">else</span> &#123;<br>                           <span class="hljs-comment">// Once we bind to the service, the first</span><br>                           <span class="hljs-comment">// pending request will be processed.</span><br>                           mPendingInstalls.add(idx, params);<br>                       &#125;<br>                   &#125; <span class="hljs-keyword">else</span> &#123;<br>                       mPendingInstalls.add(idx, params);<br>                       <span class="hljs-comment">// Already bound to the service. Just make</span><br>                       <span class="hljs-comment">// sure we trigger off processing the first request.</span><br>                       <span class="hljs-keyword">if</span> (idx == <span class="hljs-number">0</span>) &#123;<br>                           mHandler.sendEmptyMessage(MCS_BOUND);<br>                       &#125;<br>                   &#125;<br>                   <span class="hljs-keyword">break</span>;<br>               &#125;<br>           &#125;<br></code></pre></td></tr></table></figure>

<p>mBound表示是否绑定了<code>DefaultContainerService</code>服务，没有绑定的话则重新绑定，绑定成功后则将参数添加到<code>mPendingInstalls</code>中等待处理；</p>
<p>绑定服务的代码在这里:<code>DefaultContainerConnection</code>也是PMS的内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">private</span> <span class="hljs-type">DefaultContainerConnection</span> <span class="hljs-variable">mDefContainerConn</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultContainerConnection</span>();<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultContainerConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServiceConnection</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG, <span class="hljs-string">&quot;onServiceConnected&quot;</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">IMediaContainerService</span> <span class="hljs-variable">imcs</span> <span class="hljs-operator">=</span> IMediaContainerService.Stub<br>                .asInterface(Binder.allowBlocking(service));<br>        mHandler.sendMessage(mHandler.obtainMessage(MCS_BOUND, imcs));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG, <span class="hljs-string">&quot;onServiceDisconnected&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，绑定成功后会发送一个类型为<code>MCS_BOUND</code>的Message对象到mHandler。当然这里发送的消息是带有Object参数，而上面<code>INIT_COPY</code>中的最后发送的消息是不带有Object参数的。</p>
<p>这里我们直接探讨正常流程，也就是服务已经绑定，并且mPendingInstalls中有待处理的数据，也就是走<code>INIT_COPY</code>中的最后一条分支。</p>
<p>这时候在PackageHandler里面会走这个分支：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mPendingInstalls.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-type">HandlerParams</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> mPendingInstalls.get(<span class="hljs-number">0</span>);<br>                        <span class="hljs-keyword">if</span> (params != <span class="hljs-literal">null</span>) &#123;<br>                            Trace.asyncTraceEnd(TRACE_TAG_PACKAGE_MANAGER, <span class="hljs-string">&quot;queueInstall&quot;</span>,<br>                                    System.identityHashCode(params));<br>                            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, <span class="hljs-string">&quot;startCopy&quot;</span>);<br>                            <span class="hljs-keyword">if</span> (params.startCopy()) &#123;<br>                                <span class="hljs-comment">// We are done...  look for more work or to</span><br>                                <span class="hljs-comment">// go idle.</span><br>                                <span class="hljs-keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG,<br>                                        <span class="hljs-string">&quot;Checking for more work or unbind...&quot;</span>);<br>                                <span class="hljs-comment">// Delete pending install</span><br>                                <span class="hljs-keyword">if</span> (mPendingInstalls.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                                    mPendingInstalls.remove(<span class="hljs-number">0</span>);<br>                                &#125;<br>                                <span class="hljs-keyword">if</span> (mPendingInstalls.size() == <span class="hljs-number">0</span>) &#123;<br>                                    <span class="hljs-keyword">if</span> (mBound) &#123;<br>                                        <span class="hljs-keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG,<br>                                                <span class="hljs-string">&quot;Posting delayed MCS_UNBIND&quot;</span>);<br>                                        removeMessages(MCS_UNBIND);<br>                                        <span class="hljs-type">Message</span> <span class="hljs-variable">ubmsg</span> <span class="hljs-operator">=</span> obtainMessage(MCS_UNBIND);<br>                                        <span class="hljs-comment">// Unbind after a little delay, to avoid</span><br>                                        <span class="hljs-comment">// continual thrashing.</span><br>                                        sendMessageDelayed(ubmsg, <span class="hljs-number">10000</span>);<br>                                    &#125;<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    <span class="hljs-comment">// There are more pending requests in queue.</span><br>                                    <span class="hljs-comment">// Just post MCS_BOUND message to trigger processing</span><br>                                    <span class="hljs-comment">// of next pending install.</span><br>                                    <span class="hljs-keyword">if</span> (DEBUG_SD_INSTALL) Log.i(TAG,<br>                                            <span class="hljs-string">&quot;Posting MCS_BOUND for next work&quot;</span>);<br>                                    mHandler.sendEmptyMessage(MCS_BOUND);<br>                                &#125;<br>                            &#125;<br>                            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);<br>                        &#125;<br>                    &#125;<br></code></pre></td></tr></table></figure>

<p>调用<code>params.startCopy()</code>之后，会将当前安装任务从列表中移除，接着处理下一个安装任务；这里的params是上面说到的<code>InstallParams</code>实例。</p>
<p>看下<code>HandlerParams.startCopy</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">startCopy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> res;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG_INSTALL) Slog.i(TAG, <span class="hljs-string">&quot;startCopy &quot;</span> + mUser + <span class="hljs-string">&quot;: &quot;</span> + <span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-keyword">if</span> (++mRetries &gt; MAX_RETRIES) &#123;<br>            Slog.w(TAG, <span class="hljs-string">&quot;Failed to invoke remote methods on default container service. Giving up&quot;</span>);<br>            mHandler.sendEmptyMessage(MCS_GIVE_UP);<br>            handleServiceError();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            handleStartCopy();<br>            res = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        <span class="hljs-keyword">if</span> (DEBUG_INSTALL) Slog.i(TAG, <span class="hljs-string">&quot;Posting install MCS_RECONNECT&quot;</span>);<br>        mHandler.sendEmptyMessage(MCS_RECONNECT);<br>        res = <span class="hljs-literal">false</span>;<br>    &#125;<br>    handleReturnCode();<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的MAX_RETRIES值被定义为4，尝试次数超过4次，则放弃这个安装请求。如果没有超过，则执行<code>handleStartCopy</code>方法，该方法的具体实现在<code>InstallParams</code>中。该方法的具体实现代码很长，这里抄一下注释</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Invoke remote method to get package information and install</span><br><span class="hljs-comment"> * location values. Override install location based on default</span><br><span class="hljs-comment"> * policy if needed and then create install arguments based</span><br><span class="hljs-comment"> * on the install location.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p>通过IMediaContainerService跨进程调用DefaultContainerService的getMinimalPackageInfo方法，轻量级解析apk并获取到apk的少量信息，封装到PackageInfoLite对象中。然后确认安装未知，创建InstallArgs对象。这里的InstallArgs是个抽象类，在PMS有三个对应的子类：</p>
<ul>
<li>FileInstallArgs:处理安装到非ASEC存储空间的APK，也就是内部存储空间(Data分区)</li>
<li>AsecInstallArgs:处理安装到ASEC中(mnt&#x2F;asec，也就是存储卡)中的apk</li>
<li>MoveInstallArgs:处理已安装的APK在存储中移动的逻辑</li>
</ul>
<p>复制完成后，会接着调用<code>handleReturnCode</code>方法，该方法中只是调用了<code>processPendingInstall</code>方法，看下这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">mHandler.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>               mHandler.removeCallbacks(<span class="hljs-built_in">this</span>);<br>                <span class="hljs-comment">// Result object to be returned</span><br>               <span class="hljs-type">PackageInstalledInfo</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageInstalledInfo</span>();<br>               res.setReturnCode(currentStatus);<br>               res.uid = -<span class="hljs-number">1</span>;<br>               res.pkg = <span class="hljs-literal">null</span>;<br>               res.removedInfo = <span class="hljs-literal">null</span>;<br>               <span class="hljs-keyword">if</span> (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123;<br>                   args.doPreInstall(res.returnCode);<span class="hljs-comment">//-------1-------</span><br>                   <span class="hljs-keyword">synchronized</span> (mInstallLock) &#123;<br>                       installPackageTracedLI(args, res);<span class="hljs-comment">//-------2-------</span><br>                   &#125;<br>                   args.doPostInstall(res.returnCode, res.uid);<span class="hljs-comment">//-------3-------</span><br>               &#125;<br>               ......<br>           &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>注释1处会检查apk状态，确保安装环境可靠，否则清除复制的apk文件，在注释3处进行安装后的收尾工作；</p>
<p>主要看下注释2处的方法，该方法内部会调用PMS的installPackageLI方法，这个方法也挺长的，简单说下这个方法做了什么：</p>
<ul>
<li>创建PackageParser，解析apk</li>
<li>检查APK是否已经安装</li>
<li>如果PackageSetting中存在要安装的apk信息，则表示要替换安装，需要进行签名校验，确保替换安装是安全的</li>
<li>如果是替换安装，则调用replacePackageLIF方法，如果是安装新的apk，调用installNewPackageLIF方法。</li>
</ul>
<p>我们以安装新的apk为例</p>
<ol>
<li>扫描APK，将apk信息存储在PackageParser.Package类型的newPackage中，一个Package的信息包含了一个base apk和N个split APK</li>
<li>更新该APK对应的PackageSetting信息</li>
<li>如果安装成功，则为新应用准备数据；如果安装失败，则删除APK</li>
</ol>
<p>总结一下</p>
<ol>
<li>PackageINstaller安装APK时会将APK的信息交由PMS处理，PMS则通过PackageHandler发送消息来驱动APK的复制和安装工作</li>
<li>PMS发送INIT_COPY和MCS_BOUND类型的消息，驱动PackageHandler来绑定DefaultContainerService，完成APK的复制等工作</li>
<li>进行APK的安装前检查，安装APK及安装后的收尾工作</li>
</ol>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit流程分析</title>
    <url>/2024/04/07/Retrofit%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在之前的文章中介绍了《在kotlin协程中使用自定义CallAdapter处理错误》，既然选择了它，当然得先全面了解一下。<br>先下载一下源码，搭建一下环境，也没啥好说的，我下载的是2.11.0 版本的代码，使用的 IDEA2023.3.6。这都是小事情，只要能有代码跳转功能就好。首次配置需要下载相应依赖，时间会长一些，这不重要。等配置完成后，找到 simple module，有各种各样的示例代码。是可以直接运行的。</p>
<span id="more"></span>
<h2 id="创建Retrofit对象"><a href="#创建Retrofit对象" class="headerlink" title="创建Retrofit对象"></a>创建Retrofit对象</h2><p>我们先从如何创建的<code>Retrofit</code>对象开始<br>先看一下我们可以设置哪些参数，撸一下源码，找一下<code>Retrofit.Builder</code>类</p>
<h3 id="设置OkHttpClient"><a href="#设置OkHttpClient" class="headerlink" title="设置OkHttpClient"></a>设置<code>OkHttpClient</code></h3><p>这里的<code>OkHttpClient</code>实现了<code>Call.Factory</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">client</span><span class="hljs-params">(OkHttpClient client)</span> &#123;<br>  <span class="hljs-keyword">return</span> callFactory(Objects.requireNonNull(client, <span class="hljs-string">&quot;client == null&quot;</span>));<br>&#125;<br><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">callFactory</span><span class="hljs-params">(okhttp3.Call.Factory factory)</span> &#123;<br>  <span class="hljs-built_in">this</span>.callFactory = Objects.requireNonNull(factory, <span class="hljs-string">&quot;factory == null&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="设置-baseUrl"><a href="#设置-baseUrl" class="headerlink" title="设置 baseUrl"></a>设置 baseUrl</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">baseUrl</span><span class="hljs-params">(URL baseUrl)</span> &#123;<br>  Objects.requireNonNull(baseUrl, <span class="hljs-string">&quot;baseUrl == null&quot;</span>);<br>  <span class="hljs-keyword">return</span> baseUrl(HttpUrl.get(baseUrl.toString()));<br>&#125;<br><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">baseUrl</span><span class="hljs-params">(String baseUrl)</span> &#123;<br>  Objects.requireNonNull(baseUrl, <span class="hljs-string">&quot;baseUrl == null&quot;</span>);<br>  <span class="hljs-keyword">return</span> baseUrl(HttpUrl.get(baseUrl));<br>&#125;<br><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">baseUrl</span><span class="hljs-params">(HttpUrl baseUrl)</span> &#123;<br>  Objects.requireNonNull(baseUrl, <span class="hljs-string">&quot;baseUrl == null&quot;</span>);<br>  List&lt;String&gt; pathSegments = baseUrl.pathSegments();<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;&quot;</span>.equals(pathSegments.get(pathSegments.size() - <span class="hljs-number">1</span>))) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;baseUrl must end in /: &quot;</span> + baseUrl);<br>  &#125;<br>  <span class="hljs-built_in">this</span>.baseUrl = baseUrl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">addConverterFactory</span><span class="hljs-params">(Converter.Factory factory)</span> &#123;<br>  converterFactories.add(Objects.requireNonNull(factory, <span class="hljs-string">&quot;factory == null&quot;</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="支持’Call’对象之外的返回类型"><a href="#支持’Call’对象之外的返回类型" class="headerlink" title="支持’Call’对象之外的返回类型"></a>支持’Call’对象之外的返回类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">addCallAdapterFactory</span><span class="hljs-params">(CallAdapter.Factory factory)</span> &#123;<br>  callAdapterFactories.add(Objects.requireNonNull(factory, <span class="hljs-string">&quot;factory == null&quot;</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="调用-callBack-时使用的Executor"><a href="#调用-callBack-时使用的Executor" class="headerlink" title="调用 callBack 时使用的Executor"></a>调用 callBack 时使用的Executor</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">callbackExecutor</span><span class="hljs-params">(Executor executor)</span> &#123;<br>  <span class="hljs-built_in">this</span>.callbackExecutor = Objects.requireNonNull(executor, <span class="hljs-string">&quot;executor == null&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="是否提前验证接口中定义的方法"><a href="#是否提前验证接口中定义的方法" class="headerlink" title="是否提前验证接口中定义的方法"></a>是否提前验证接口中定义的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">validateEagerly</span><span class="hljs-params">(<span class="hljs-type">boolean</span> validateEagerly)</span> &#123;<br>  <span class="hljs-built_in">this</span>.validateEagerly = validateEagerly;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="调用-build-方法创建-Retrofit-对象"><a href="#调用-build-方法创建-Retrofit-对象" class="headerlink" title="调用 build()方法创建 Retrofit 对象"></a>调用 build()方法创建 Retrofit 对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> Retrofit <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (baseUrl == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Base URL required.&quot;</span>);<br>  &#125;<br><br>  okhttp3.Call.<span class="hljs-type">Factory</span> <span class="hljs-variable">callFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.callFactory;<br>  <span class="hljs-keyword">if</span> (callFactory == <span class="hljs-literal">null</span>) &#123;<br>      callFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>();<br>  &#125;<br><br>  <span class="hljs-type">Executor</span> <span class="hljs-variable">callbackExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.callbackExecutor;<br>  <span class="hljs-keyword">if</span> (callbackExecutor == <span class="hljs-literal">null</span>) &#123;<br>      callbackExecutor = Platform.callbackExecutor;<br>  &#125;<br><br>  <span class="hljs-type">BuiltInFactories</span> <span class="hljs-variable">builtInFactories</span> <span class="hljs-operator">=</span> Platform.builtInFactories;<br><br>  <span class="hljs-comment">// Make a defensive copy of the adapters and add the default Call adapter.</span><br>  List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.callAdapterFactories);<br>  List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CallAdapter</span>.Factory&gt; defaultCallAdapterFactories =<br>  builtInFactories.createDefaultCallAdapterFactories(callbackExecutor);<br>  callAdapterFactories.addAll(defaultCallAdapterFactories);<br><br>  <span class="hljs-comment">// Make a defensive copy of the converters.</span><br>  List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Converter</span>.Factory&gt; defaultConverterFactories =<br>  builtInFactories.createDefaultConverterFactories();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">defaultConverterFactoriesSize</span> <span class="hljs-operator">=</span> defaultConverterFactories.size();<br>  List&lt;Converter.Factory&gt; converterFactories =<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">1</span> + <span class="hljs-built_in">this</span>.converterFactories.size() + defaultConverterFactoriesSize);<br><br>  <span class="hljs-comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span><br>  <span class="hljs-comment">// ensures correct behavior when using converters that consume all types.</span><br>  converterFactories.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BuiltInConverters</span>());<br>  converterFactories.addAll(<span class="hljs-built_in">this</span>.converterFactories);<br>  converterFactories.addAll(defaultConverterFactories);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Retrofit</span>(<br>      callFactory,<br>      baseUrl,<br>      unmodifiableList(converterFactories),<br>      defaultConverterFactoriesSize,<br>      unmodifiableList(callAdapterFactories),<br>      defaultCallAdapterFactories.size(),<br>      callbackExecutor,<br>      validateEagerly);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>首先检查是否设置了 baseUrl，没设置直接抛异常</li>
<li>设置callFactory，默认为OkHttpClient</li>
<li>设置callbackExecutor默认为platform.defaultCallbackExecutor()，Android平台为MainThreadExecutor，其他平台为 null。这里的 AndroidMainExecutor 只是简单的使用 handler 转发到主线程<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AndroidMainExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(Looper.getMainLooper());<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> &#123;<br>      handler.post(r);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>callAdapterFactories 默认添加 platform.defaultCallAdapterFactories,返回值为DefaultCallAdapterFactory，之后在 kotlin 中使用密闭类代替 callback 时就是抄的这个类中的方法</li>
<li>converterFactories<br>  ○ 先添加 new BuiltInConverters()<br>  ○ 再添加自定义的<br>  ○ 最后添加platform.defaultConverterFactories() 默认是空的<br>这样就配置好的 Retrofit 对象</li>
</ol>
<h2 id="如何发送请求"><a href="#如何发送请求" class="headerlink" title="如何发送请求"></a>如何发送请求</h2><p>我们在定义网络请求时是这么写的</p>
<h3 id="定义网络请求"><a href="#定义网络请求" class="headerlink" title="定义网络请求"></a>定义网络请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GitHub</span> &#123;<br>  <span class="hljs-meta">@GET(&quot;/repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span><br>  Call&lt;List&lt;Contributor&gt;&gt; <span class="hljs-title function_">contributors</span><span class="hljs-params">(<span class="hljs-meta">@Path(&quot;owner&quot;)</span> String owner, <span class="hljs-meta">@Path(&quot;repo&quot;)</span> String repo)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="创建GitHub对象-和发送请求"><a href="#创建GitHub对象-和发送请求" class="headerlink" title="创建GitHub对象 和发送请求"></a>创建<strong>GitHub对象</strong> 和发送请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// Create an instance of our GitHub API interface.</span><br><span class="hljs-type">GitHub</span> <span class="hljs-variable">github</span> <span class="hljs-operator">=</span> retrofit.create(GitHub.class);<br><span class="hljs-comment">// Create a call instance for looking up Retrofit contributors.</span><br>Call&lt;List&lt;Contributor&gt;&gt; call = github.contributors(<span class="hljs-string">&quot;square&quot;</span>, <span class="hljs-string">&quot;retrofit&quot;</span>);<br><span class="hljs-comment">// Fetch and print a list of the contributors to the library.</span><br>List&lt;Contributor&gt; contributors = call.execute().body();<br></code></pre></td></tr></table></figure>

<p>重点在我们调用<code>retrofit.create</code>方法时用到的动态代理商</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;T&gt; service)</span> &#123;<br>  validateServiceInterface(service);<br>  <span class="hljs-keyword">return</span> (T)<br>      Proxy.newProxyInstance(<br>          service.getClassLoader(),<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123;service&#125;,<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] emptyArgs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>];<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>                <span class="hljs-keyword">throws</span> Throwable &#123;<br>              <span class="hljs-comment">// If the method is a method from Object then defer to normal invocation.</span><br>              <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;<br>                <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>, args);<br>              &#125;<br>              args = args != <span class="hljs-literal">null</span> ? args : emptyArgs;<br>              <span class="hljs-type">Reflection</span> <span class="hljs-variable">reflection</span> <span class="hljs-operator">=</span> Platform.reflection;<br>              <span class="hljs-keyword">return</span> reflection.isDefaultMethod(method)<br>                  ? reflection.invokeDefaultMethod(method, service, proxy, args)<br>                  : loadServiceMethod(service, method).invoke(proxy, args);<br>            &#125;<br>          &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="validateServiceInterface"><a href="#validateServiceInterface" class="headerlink" title="validateServiceInterface"></a>validateServiceInterface</h3><p>创建 Github 对象时使用了动态代理，不过在创建之前，先调用了<code>validateServiceInterface(service);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateServiceInterface</span><span class="hljs-params">(Class&lt;?&gt; service)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!service.isInterface()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;API declarations must be interfaces.&quot;</span>);<br>    &#125;<br><br>    Deque&lt;Class&lt;?&gt;&gt; check = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>    check.add(service);<br>    <span class="hljs-keyword">while</span> (!check.isEmpty()) &#123;<br>      Class&lt;?&gt; candidate = check.removeFirst();<br>      <span class="hljs-keyword">if</span> (candidate.getTypeParameters().length != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;Type parameters are unsupported on &quot;</span>).append(candidate.getName());<br>        <span class="hljs-keyword">if</span> (candidate != service) &#123;<br>          message.append(<span class="hljs-string">&quot; which is an interface of &quot;</span>).append(service.getName());<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(message.toString());<br>      &#125;<br>      Collections.addAll(check, candidate.getInterfaces());<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (validateEagerly) &#123;<br>      <span class="hljs-type">Reflection</span> <span class="hljs-variable">reflection</span> <span class="hljs-operator">=</span> Platform.reflection;<br>      <span class="hljs-keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;<br>        <span class="hljs-keyword">if</span> (!reflection.isDefaultMethod(method)<br>            &amp;&amp; !Modifier.isStatic(method.getModifiers())<br>            &amp;&amp; !method.isSynthetic()) &#123;<br>          loadServiceMethod(service, method);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>先检查 Github 类是不是 Interface，接着定义一个双端队列，对当前接口及其父接口进行递归检查，这里是不支持泛型参数的。<br>在接下来判断一下在创建 Retrofit 时传入的validateEagerly参数，如果是 true，并且声明的方法不是默认、不是静态、不是合成方法，则调用loadServiceMethod方法解析接口中声明的方法。</p>
<h3 id="loadServiceMethod"><a href="#loadServiceMethod" class="headerlink" title="loadServiceMethod"></a>loadServiceMethod</h3><p>首先调用<code>ServiceMethod.parseAnnotations(this, service, method);</code>，先从缓存的map中获取有没有已经解析好的ServiceMethod。如果没有则调用ServiceMethod.parseAnnotations(this, method)方法进行解析。</p>
<h4 id="第一步创建requestFactory对象"><a href="#第一步创建requestFactory对象" class="headerlink" title="第一步创建requestFactory对象"></a>第一步创建requestFactory对象</h4><p>调用了 <code>RequestFactory requestFactory = RequestFactory.parseAnnotations(retrofit, service, method); </code>，解析了例如请求方式（即 POST 还是 GET 等请求），请求头，contentType 等等参数并返回了一个<code>RequestFactory</code>对象</p>
<h4 id="第二步创建HttpServiceMethod子类CallAdapted"><a href="#第二步创建HttpServiceMethod子类CallAdapted" class="headerlink" title="第二步创建HttpServiceMethod子类CallAdapted"></a>第二步创建HttpServiceMethod子类CallAdapted</h4><p>接着通过<code>HttpServiceMethod</code>的静态方法<code>parseAnnotations</code>进一步解析，入参有<code>Retrofit</code>对象，<code>Method</code>对象和刚才创建的<code>RequestFactory </code>对象。<code>HttpServiceMethod</code>继承自<code>ServiceMethod</code>，但也是个抽象类，这个类提供的<code>parseAnnotations</code>方法的主要内容是进一步解析，并通过<code>createCallAdapter</code>创建适配器、通过<code>createResponseConverter</code>创建转换器，最后利用<code>RequestFactory</code>对象，<code>OkHttp</code>对象，<code>转换器</code>对象，<code>适配器</code>对象创建了一个<code>CallAdapted</code>类型的对象并返回。</p>
<h5 id="创建适配器"><a href="#创建适配器" class="headerlink" title="创建适配器"></a>创建适配器</h5><p>如果我们前面没有调用<code>addCallAdapterFactory(CallAdapter.Factory factory)</code>添加自定义的Factory的话，这里返回的是默认的<code>DefaultCallAdapterFactory</code>对象。<br>在该类的<code>adapt</code>方法中返回的<code>CallAdapter</code>对象中，先判断了<code>executor</code>是不是空，这里的<code>executor</code>就是在创建<code>Retrofit</code>时调用<code>public Builder callbackExecutor(Executor executor)</code>方法时传入的对象，前面也说过，在**Android(Dalvik)**平台上默认是<code>AndroidMainExecutor</code>,其他平台默认为空。</p>
<p>简单讲，<code>DefaultCallAdapterFactory</code>大致如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultCallAdapterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CallAdapter</span>.Factory &#123;<br>    <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span><br>        Utils.isAnnotationPresent(annotations, SkipCallbackExecutor.class)<br>            ? <span class="hljs-literal">null</span><br>            : callbackExecutor;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallAdapter</span>&lt;Object, Call&lt;?&gt;&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> Type <span class="hljs-title function_">responseType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> responseType;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> Call&lt;Object&gt; <span class="hljs-title function_">adapt</span><span class="hljs-params">(Call&lt;Object&gt; call)</span> &#123;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> ? call : <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorCallbackCall</span>&lt;&gt;(executor, call);<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecutorCallbackCall</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Call</span>&lt;T&gt; &#123;<br>   ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;<br>      <span class="hljs-built_in">this</span>.callbackExecutor = callbackExecutor;<br>      <span class="hljs-built_in">this</span>.delegate = delegate;<br>    &#125;<br>    <span class="hljs-comment">//。。。。一系列的方法，除了enqueue(final Callback&lt;T&gt; callback)方法外，都是调用delegate中对应的方法</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="创建转换器"><a href="#创建转换器" class="headerlink" title="创建转换器"></a>创建转换器</h5><p>我们在使用的时候一般会传入一个ConverterFactory对象，比如MoshiConverterFactory、GsonConverterFactory等。最主要的就两个方法<br><code>responseBodyConverter</code> and <code>requestBodyConverter</code>.在调用<code>HttpServiceMethod.createResponseConverter</code>时，兜兜转转最终还是调用了 <code>Retrofit.nextCallAdapter</code>方法，从我们一开始构建的 Retrofit 对象中查找对应的转换器</p>
<h5 id="创建CallAdapted对象"><a href="#创建CallAdapted对象" class="headerlink" title="创建CallAdapted对象"></a>创建CallAdapted对象</h5><p>这里直接调用的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallAdapted</span>&lt;&gt;(requestFactory, callFactory, responseConverter, callAdapter);<br></code></pre></td></tr></table></figure>
<p>注意这里传入的<code>callAdapter</code>对象就是前面提到的调用<code>createCallAdapter</code>返回的默认<code>DefaultCallAdapterFactory</code>示例。<br><code>CallAdapted</code>类是<code>HttpServiceMethod</code>的子类，实现了父类的抽象方法<code>adapt</code>。而<code>HttpServiceMethod</code>又实现了<code>ServiceMethod</code>的抽象方法<code>invoke</code>，在<code>invoke</code>方法里调用了<code>adapt</code>方法。</p>
<h4 id="loadServiceMethod过程总结"><a href="#loadServiceMethod过程总结" class="headerlink" title="loadServiceMethod过程总结"></a>loadServiceMethod过程总结</h4><p>所以前面说到的加载过程(loadServiceMethod)，最终就是返回了一个<code>CallAdapted</code>类型的对象，并存到缓存中。接下去就是调用了<code>CallAdapted</code>对象的<code>invoke</code>方法，显然最终调用了<code>CallAdapted</code>自身的<code>adapt</code>方法。<code>CallAdapted</code>提供的<code>adapt</code>方法里就一句，那就是调用适配器的<code>adapt</code>方法，并返回一个值。这个值就是我们定义的接口类型的代理对象.之后调用调用定义的接口方法获取到Call对象，调用enqueue异步执行；调用execute同步执行；</p>
<h3 id="invoke过程"><a href="#invoke过程" class="headerlink" title="invoke过程"></a>invoke过程</h3><p>前面知道了<code>loadServiceMethod</code>返回的是一个<code>CallAdapted</code>对象，然后紧接着调用了<code>invoke</code>方法。但<code>CallAdapted</code>并没有重写该方法，所以实际上还是调用的<code>HttpServiceMethod</code>类中的<code>invoke</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> ReturnT <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object instance, Object[] args)</span> &#123;<br>  Call&lt;ResponseT&gt; call =<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpCall</span>&lt;&gt;(requestFactory, instance, args, callFactory, responseConverter);<br>  <span class="hljs-keyword">return</span> adapt(call, args);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/image/Android/retrofit/NewOkHttpCall.png"><br><img src="/image/Android/retrofit/NewOkhttpCallArgs.png"></p>
<p>接着调用了<code>adapt(call, args)</code>方法，这个方法就需要子类实现了，这里的子类是<code>CallAdapted</code>,在<code>CallAdapted</code>中接着调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ReturnT <span class="hljs-title function_">adapt</span><span class="hljs-params">(Call&lt;ResponseT&gt; call, Object[] args)</span> &#123;<br>  <span class="hljs-keyword">return</span> callAdapter.adapt(call);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该方法中的<code>callAdapter</code>对象就是前面提到的<code>DefaultCallAdapterFactory.get</code>方法中返回的<code>CallAdapter</code>,调用了该对应的<code>adapt</code>方法。在上面的介绍的<strong>创建适配器</strong>小结中提到，在**Android(Dalvik)**平台上默认有<code>AndroidMainExecutor</code>,其他平台默认为空。所以在没有额外添加<code>callbackExecutor</code>的情况下，Android 平台上返回的是<code>ExecutorCallbackCall</code>,在其他平台上默认返回的就是参数中的<code>call</code>对象，也就是<code>retrofit2.OkHttpCall</code>。 这个对象也就是我们调用接口中的方法返回的对象。</p>
<h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><p>上面提到在 Android 平台上会返回<code>ExecutorCallbackCall</code>对象，其他平台返回<code>retrofit2.OkHttpCall</code>对象。但在创建<code>ExecutorCallbackCall</code><br>对象的时候也会将<code>retrofit2.OkHttpCall</code>传进去，在调用各种方法的时候还是调用的<code>retrofit2.OkHttpCall</code>对象的方法，只不过在调用<code>void enqueue(Callback&lt;T&gt; callback);</code>方法的<code>callback</code>回调中使用<code>callbackExecutor</code>将回调切换回主线程而已。</p>
<p>在调用<code>retrofit2.OkHttpCall</code>的<code>enqueue</code>或者<code>execute</code>方法时，会调用<code>createRawCall</code>方法创建一个<code>okhttp3.Call</code>对象，实际上的网络请求还是 okhttp 发出的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> okhttp3.Call <span class="hljs-title function_">createRawCall</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  okhttp3.<span class="hljs-type">Call</span> <span class="hljs-variable">call</span> <span class="hljs-operator">=</span> callFactory.newCall(requestFactory.create(instance, args));<br>  <span class="hljs-keyword">if</span> (call == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;Call.Factory returned null.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> call;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的<code>requestFactory</code>是上面提到的<code>parseAnnotations</code>时创建的<code>RequestFactory</code>对象，包含了部分请求信息。这里又用它创建了<code>okhttp3.Request</code>对象。创建好之后接着就创建了<code>okhttp3.Call</code>对象，接下来就是调用<code>enqueue</code>或者<code>execute</code>方法发送请求。<br>当请求数据返回时，会调用<code>parseResponse(okhttp3.Response rawResponse)</code>方法，最终调用的是<code>responseConverter.convert(catchingBody)</code>方法，这里的<code>responseConverter</code>就是我们在创建<code>Retrofit</code>对象调用<code>addConverterFactory</code>时传入的解析方法.<br>至此，完成了一次网络请求。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title>Tinker初探</title>
    <url>/2018/03/10/Tinker%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>前两天想试一下热修复的功能，对比各大平台的热修复功能，看到tinker的<a href="http://www.tinkerpatch.com/Docs/intro">文档介绍</a>，最终决定先拿Tinker试一下。</p>
<blockquote>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">Tinker</td>
<td align="center">QZone</td>
<td align="center">AndFix</td>
<td align="center">Robust</td>
</tr>
<tr>
<td align="center">类替换</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">So替换</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">资源替换</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">全平台支持</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">即时生效</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">性能损耗</td>
<td align="center">较小</td>
<td align="center">较大</td>
<td align="center">较小</td>
<td align="center">较小</td>
</tr>
<tr>
<td align="center">补丁包大小</td>
<td align="center">较小</td>
<td align="center">较大</td>
<td align="center">一般</td>
<td align="center">一般</td>
</tr>
<tr>
<td align="center">开发透明</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">复杂度</td>
<td align="center">较低</td>
<td align="center">较低</td>
<td align="center">复杂</td>
<td align="center">复杂</td>
</tr>
<tr>
<td align="center">Rom体积</td>
<td align="center">Dalvik较大</td>
<td align="center">较小</td>
<td align="center">较小</td>
<td align="center">较小</td>
</tr>
<tr>
<td align="center">成功率</td>
<td align="center">较高</td>
<td align="center">较高</td>
<td align="center">一般</td>
<td align="center">最高</td>
</tr>
</tbody></table>
<blockquote>
<p>Tinker热补丁方案不仅支持类、So 以及资源的替换，它还是2.X－7.X的全平台支持。利用Tinker我们不仅可以用做 bugfix,甚至可以替代功能的发布。Tinker 已运行在微信的数亿 Android 设备上，那么为什么你不使用 Tinker 呢？</p>
</blockquote>
<p>不得不说，我真的低估了跟着腾讯文档走的难度。</p>
<span id="more"></span>

<h3 id="注册-TinkerPatch-平台"><a href="#注册-TinkerPatch-平台" class="headerlink" title="注册 TinkerPatch 平台"></a>注册 TinkerPatch 平台</h3><p>因为需要下发补丁，直接使用TinkerPatch平台就好，在这里注册<a href="http://www.tinkerpatch.com/Index/reg">http://www.tinkerpatch.com/Index/reg</a>,注册完成后创建一个应用，拿到<code>appKey</code><br>然后添加一个APP版本</p>
<h3 id="SDK接入"><a href="#SDK接入" class="headerlink" title="SDK接入"></a>SDK接入</h3><p>测试成功的工程全部文件在这里<a href="https://github.com/huangyuanlove/TestTinker">https://github.com/huangyuanlove/TestTinker</a>,包含构建成功之后的apk文件以及一些辅助文件。</p>
<h5 id="添加Gradle插件依赖"><a href="#添加Gradle插件依赖" class="headerlink" title="添加Gradle插件依赖"></a>添加Gradle插件依赖</h5><p>AndroidStudio创建一个工程，定义使用的SDK版本，我是放在了<code>gradle.properties</code> 这个文件中，</p>
<blockquote>
<p>TINKER_VERSION&#x3D;1.9.2<br>TINKERPATCH_VERSION&#x3D;1.2.2</p>
</blockquote>
<p>然后在工程的<code>build.gradle</code>文件中添加插件依赖</p>
<blockquote>
<p>classpath “com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:${TINKERPATCH_VERSION}”</p>
</blockquote>
<p>然后添加一些其他配置，整个文件内容如下</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    repositories &#123;<br>        google()<br>        jcenter()<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&#x27;com.android.tools.build:gradle:3.0.1&#x27;</span><br>        classpath <span class="hljs-string">&quot;com.tinkerpatch.sdk:tinkerpatch-gradle-plugin:$&#123;TINKERPATCH_VERSION&#125;&quot;</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (JavaVersion.current().isJava8Compatible()) &#123;<br>    allprojects &#123;<br>        tasks.withType(Javadoc) &#123;<br>            options.addStringOption(<span class="hljs-string">&#x27;Xdoclint:none&#x27;</span>, <span class="hljs-string">&#x27;-quiet&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br>subprojects &#123;<br>    tasks.withType(JavaCompile) &#123;<br>        sourceCompatibility = JavaVersion.VERSION_1_7<br>        targetCompatibility = JavaVersion.VERSION_1_7<br>    &#125;<br>&#125;<br>allprojects &#123;<br>    repositories &#123;<br>        google()<br>        jcenter()<br>    &#125;<br>&#125;<br>task clean(<span class="hljs-attr">type:</span> Delete) &#123;<br>    delete rootProject.buildDir<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h5 id="集成-TinkerPatch-SDK"><a href="#集成-TinkerPatch-SDK" class="headerlink" title="集成 TinkerPatch SDK"></a>集成 TinkerPatch SDK</h5><p>在<code>app/build.gradle</code>里面添加依赖</p>
<blockquote>
</blockquote>
<pre><code class="hljs">annotationProcessor(&quot;com.tinkerpatch.tinker:tinker-android-anno:$&#123;TINKER_VERSION&#125;&quot;) &#123; changing = true &#125;
compileOnly(&quot;com.tinkerpatch.tinker:tinker-android-anno:$&#123;TINKER_VERSION&#125;&quot;) &#123; changing = true &#125;
implementation(&quot;com.tinkerpatch.sdk:tinkerpatch-android-sdk:$&#123;TINKERPATCH_VERSION&#125;&quot;) &#123; changing = true &#125;
</code></pre>
<p>为了配置方便，我们把TinkerPatchSupport相关的配置放在一个单独的gradle文件中，在app下创建一个<code>tinkerpatch.gradle</code>，我们需要在<code>app/build.grale</code>文件中引用</p>
<blockquote>
<p>apply from: ‘tinkerpatch.gradle’</p>
</blockquote>
<h5 id="配置-tinkerpatchSupport-参数"><a href="#配置-tinkerpatchSupport-参数" class="headerlink" title="配置 tinkerpatchSupport 参数"></a>配置 tinkerpatchSupport 参数</h5><p>编辑 <code>app/tinkerpatch.gralde</code>文件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;tinkerpatch-support&#x27;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">TODO:</span> 请按自己的需求修改为适应自己工程的参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">def</span> bakPath = file(<span class="hljs-string">&quot;$&#123;buildDir&#125;/bakApk/&quot;</span>)<br><span class="hljs-keyword">def</span> baseInfo = <span class="hljs-string">&quot;app-1.0.0-0309-21-30-56&quot;</span> <span class="hljs-comment">//构建差异文件时使用</span><br><span class="hljs-keyword">def</span> variantName = <span class="hljs-string">&quot;debug&quot;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对于插件各参数的详细解析请参考</span><br><span class="hljs-comment"> * http://tinkerpatch.com/Docs/SDK</span><br><span class="hljs-comment"> */</span><br>tinkerpatchSupport &#123;<br>    <span class="hljs-comment">/** 可以在debug的时候关闭 tinkerPatch **/</span><br>    <span class="hljs-comment">/** 当disable tinker的时候需要添加multiDexKeepProguard和proguardFiles,</span><br><span class="hljs-comment">        这些配置文件本身由tinkerPatch的插件自动添加，当你disable后需要手动添加</span><br><span class="hljs-comment">        你可以copy本示例中的proguardRules.pro和tinkerMultidexKeep.pro,</span><br><span class="hljs-comment">        需要你手动修改&#x27;tinker.sample.android.app&#x27;本示例的包名为你自己的包名, com.xxx前缀的包名不用修改</span><br><span class="hljs-comment">     **/</span><br>    tinkerEnable = <span class="hljs-literal">true</span><br>    reflectApplication = <span class="hljs-literal">false</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否开启加固模式，只能在APK将要进行加固时使用，否则会patch失败。</span><br><span class="hljs-comment">     * 如果只在某个渠道使用了加固，可使用多flavors配置</span><br><span class="hljs-comment">     **/</span><br>    protectedApp = <span class="hljs-literal">false</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实验功能</span><br><span class="hljs-comment">     * 补丁是否支持新增 Activity (新增Activity的exported属性必须为false)</span><br><span class="hljs-comment">     **/</span><br>    supportComponent = <span class="hljs-literal">true</span><br><br>    autoBackupApkPath = <span class="hljs-string">&quot;$&#123;bakPath&#125;&quot;</span><br><br>    appKey = <span class="hljs-string">&quot;2b662623551153ee&quot;</span><br><br>    <span class="hljs-comment">/** 注意: 若发布新的全量包, appVersion一定要更新 **/</span><br>    appVersion = <span class="hljs-string">&quot;1.0.0&quot;</span><br><br>    <span class="hljs-keyword">def</span> pathPrefix = <span class="hljs-string">&quot;$&#123;bakPath&#125;/$&#123;baseInfo&#125;/$&#123;variantName&#125;/&quot;</span><br>    <span class="hljs-keyword">def</span> name = <span class="hljs-string">&quot;$&#123;project.name&#125;-$&#123;variantName&#125;&quot;</span><br><br>    baseApkFile = <span class="hljs-string">&quot;$&#123;pathPrefix&#125;/$&#123;name&#125;.apk&quot;</span><br>    baseProguardMappingFile = <span class="hljs-string">&quot;$&#123;pathPrefix&#125;/$&#123;name&#125;-mapping.txt&quot;</span><br>    baseResourceRFile = <span class="hljs-string">&quot;$&#123;pathPrefix&#125;/$&#123;name&#125;-R.txt&quot;</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  若有编译多flavors需求, 可以参照： https://github.com/TinkerPatch/tinkerpatch-flavors-sample</span><br><span class="hljs-comment">     *  注意: 除非你不同的flavor代码是不一样的,不然建议采用zip comment或者文件方式生成渠道信息（相关工具：walle 或者 packer-ng）</span><br><span class="hljs-comment">     **/</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于用户在代码中判断tinkerPatch是否被使能</span><br><span class="hljs-comment"> */</span><br>android &#123;<br>    defaultConfig &#123;<br>        buildConfigField <span class="hljs-string">&quot;boolean&quot;</span>, <span class="hljs-string">&quot;TINKER_ENABLE&quot;</span>, <span class="hljs-string">&quot;$&#123;tinkerpatchSupport.tinkerEnable&#125;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一般来说,我们无需对下面的参数做任何的修改</span><br><span class="hljs-comment"> * 对于各参数的详细介绍请参考:</span><br><span class="hljs-comment"> * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97</span><br><span class="hljs-comment"> */</span><br>tinkerPatch &#123;<br>    ignoreWarning = <span class="hljs-literal">false</span><br>    useSign = <span class="hljs-literal">true</span><br>    dex &#123;<br>        dexMode = <span class="hljs-string">&quot;jar&quot;</span><br>        pattern = [<span class="hljs-string">&quot;classes*.dex&quot;</span>]<br>        loader = []<br>    &#125;<br>    lib &#123;<br>        pattern = [<span class="hljs-string">&quot;lib/*/*.so&quot;</span>]<br>    &#125;<br><br>    res &#123;<br>        pattern = [<span class="hljs-string">&quot;res/*&quot;</span>, <span class="hljs-string">&quot;r/*&quot;</span>, <span class="hljs-string">&quot;assets/*&quot;</span>, <span class="hljs-string">&quot;resources.arsc&quot;</span>, <span class="hljs-string">&quot;AndroidManifest.xml&quot;</span>]<br>        ignoreChange = []<br>        largeModSize = <span class="hljs-number">100</span><br>    &#125;<br><br>    packageConfig &#123;<br>    &#125;<br>    sevenZip &#123;<br>        zipArtifact = <span class="hljs-string">&quot;com.tencent.mm:SevenZip:1.1.10&quot;</span><br>    &#125;<br>    buildConfig &#123;<br>        keepDexApply = <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>每个参数的含义如下</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">默认值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tinkerEnable</td>
<td align="center">true</td>
<td align="center">是否开启 tinkerpatchSupport 插件功能</td>
</tr>
<tr>
<td align="center">appKey</td>
<td align="center">“”</td>
<td align="center">在 TinkerPatch 平台 申请的 appkey</td>
</tr>
<tr>
<td align="center">appVersion</td>
<td align="center">“”</td>
<td align="center">在 TinkerPatch 平台 输入的版本号,注意，我们使用 appVersion 作为 TinkerId, 我们需要保证每个发布出去的基础安装包的 appVersion 都不一样。</td>
</tr>
<tr>
<td align="center">reflectApplication</td>
<td align="center">false</td>
<td align="center">是否反射 Application 实现一键接入；一般来说，接入 Tinker 我们需要改造我们</td>
</tr>
<tr>
<td align="center">autoBackupApkPath</td>
<td align="center">“”</td>
<td align="center">将每次编译产生的 apk&#x2F;mapping.txt&#x2F;R.txt 归档存储的位置</td>
</tr>
<tr>
<td align="center">baseApkFile</td>
<td align="center">“”</td>
<td align="center">基准包的文件路径, 对应 tinker 插件中的 oldApk 参数;编译补丁包时，必需指定基准版本的 apk，默认值为空，则表示不是进行补丁包的编译。</td>
</tr>
<tr>
<td align="center">baseProguardMappingFile</td>
<td align="center">“”</td>
<td align="center">基准包的 Proguard mapping.txt 文件路径, 对应 tinker 插件 applyMapping 参数；在编译新的 apk 时候，我们希望通过保持基准 apk 的 proguard 混淆方式，从而减少补丁包的大小。这是强烈推荐的，编译补丁包时，我们推荐输入基准 apk 生成的 mapping.txt 文件。</td>
</tr>
<tr>
<td align="center">baseResourceRFile</td>
<td align="center">“”</td>
<td align="center">基准包的资源 R.txt 文件路径, 对应 tinker 插件 applyResourceMapping 参数；在编译新的apk时候，我们希望通基准 apk 的 R.txt 文件来保持 Resource Id 的分配，这样不仅可以减少补丁包的大小，同时也避免由于 Resource Id 改变导致 remote view 异常。</td>
</tr>
<tr>
<td align="center">protectedApp</td>
<td align="center">false</td>
<td align="center">是否开启支持加固，注意：只有在使用加固时才能开启此开关</td>
</tr>
<tr>
<td align="center">supportComponent</td>
<td align="center">false</td>
<td align="center">是否开启支持在补丁包中动态增加Activity 注意：新增Activity的Exported属性必须为false</td>
</tr>
<tr>
<td align="center">backupFileNameFormat</td>
<td align="center">‘${appName}-${variantName}’</td>
<td align="center">格式化命名备份文件 这里请使用单引号</td>
</tr>
</tbody></table>
<h5 id="初始化-TinkerPatch-SDK"><a href="#初始化-TinkerPatch-SDK" class="headerlink" title="初始化 TinkerPatch SDK"></a>初始化 TinkerPatch SDK</h5><p>这里推荐使用改造之后的ApplicationLike，对应<code>tinkerpatch.gradle</code>文件中的<code>reflectApplication = false</code>,这里给出了完整的ApplicationLike类，可以在这里查看<a href="https://github.com/huangyuanlove/TestTinker/blob/master/app/src/main/java/com/huangyuan/testtinker/SampleApplicationLike.java">https://github.com/huangyuanlove/TestTinker/blob/master/app/src/main/java/com/huangyuan/testtinker/SampleApplicationLike.java</a><br>其中对于类的注解中的 <code>application</code> 的值，就是我们应用的Application类，需要在<code>AndroidManifest.xml</code>中的<code>application</code>标签中配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DefaultLifeCycle(application = &quot;com.huangyuanlove.testtinker.SampleApplication&quot;,</span><br><span class="hljs-meta">                  flags = ShareConstants.TINKER_ENABLE_ALL,</span><br><span class="hljs-meta">                  loadVerifyFlag = false)</span>`<br></code></pre></td></tr></table></figure>

<p><strong>注意：初始化的代码建议紧跟 super.onCreate(),并且所有进程都需要初始化，已达到所有进程都可以被 patch 的目的<br>如果你确定只想在主进程中初始化 tinkerPatch，那也请至少在 :patch 进程中初始化，否则会有造成 :patch 进程crash，无法使补丁生效</strong><br>我们在实际应用过程中，可以在登陆等关键地方去调用<code>TinkerPatch.with().fetchPatchUpdate(true)</code>来检测有没有新的补丁包，若有，则去下载。下载完成补丁包后，sdk会自动去合成新的安装包，并且在息屏的时候自动重启主线程去加载新的文件，或者调用<code> ShareTinkerInternals.killAllOtherProcess(getApplicationContext());                 android.os.Process.killProcess(android.os.Process.myPid());</code>来完成杀死主线程的目的。</p>
<h5 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h5><p>首先构建基础包，模拟用户当前使用的版本。<br>在gradle中找到下图所示的 <code>assembleRelease</code>或者<code>assembleDebug</code>task，需要注意的是，如果构建基础包使用的是<code>debug</code>,那么在构建patch包的时候也要选择<code>debug</code>，还有就是尽量把<code>app/tinkerpatch.gradle</code>中定义的<code>variantName</code>改成一致的。<br>基础包构建成功后，会在<code>app/build/bakApk</code>文件夹下生成对应的文件，找到和你构建时间一致的包。<br>现在修改代码或者布局文件(模拟修复bug),修改清单文件<code>AndroidManifest.xml</code>中的versionName和versionCode。<br>修改<code>app/tinkerpatch.gradle</code>文件，将其中定义的<code>baseInfo</code>修改为上面提到的路径。这时候<strong>不需要修改</strong>该文件中的<code>appVersion</code>。<br>在gradle中找到tinker任务包，找到<code>tinkerPatchDebug</code>或者<code>tinkerPatchRelease</code>，构建差异包(补丁文件)。构建成功后会在<code>app/build/outputs/apk/tinkerPatch</code>文件夹中<br><img src="/image/hotfix/tinker_task.png" alt="tinkerTaskResult"> <img src="/image/hotfix/tinker_task_result.png" alt="tinkerTaskResult"><br>现在我们已经成功构建的差异包<code>patch-signed-7zip.apk</code>,现在只需要将差异包上传到<code>tinker-patch</code>平台就可以了。</p>
<h5 id="在tinker-patch平台发布差异包"><a href="#在tinker-patch平台发布差异包" class="headerlink" title="在tinker-patch平台发布差异包"></a>在tinker-patch平台发布差异包</h5><p>我们登陆tinker-patch平台，找到在刚开始创建的项目，在该项目里面添加一个App版本，注意这里的App版本号要和<code>tinkerpatch.gradle</code>里面定义的<code>appVersion</code>一致，在官方文档中也提到过这一点：</p>
<blockquote>
<p>每一个 APP 版本对应一个已经发布的 base apk, 这里我们可以使用 APP 版本作为 TinkerID。我们需要保证每个发布的 APK 都采用不用的 APP 版本。</p>
</blockquote>
<p>创建好app版本之后，点击<code>发布新补丁</code>，选择补丁文件<code>patch-signed-7zip.apk</code>,填写一下备注就好了，这里有四种补丁的下发方式<a href="http://www.tinkerpatch.com/Docs/dev">开发预览</a> 、<code>全量下发</code> 、<a href="http://www.tinkerpatch.com/Docs/rule">条件下发</a> 、<a href="http://www.tinkerpatch.com/Docs/rule">灰度下发</a>、具体差异可以点击去查看。<br>同时我们也可以在平台对应的软件版本中的实时监控里面看到补丁的下载以及合成应用次数。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>热修复</tag>
        <tag>tinker</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议的简单理解</title>
    <url>/2017/07/03/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>尽管TCP和UDP都使用相同的网络层(IP)，TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。这里的面向连接是指：两个使用TCP的应用（通常是一个客户一个服务器）在彼此交换数据之前必须先建立一个TCP连接。</p>
<span id="more"></span>
<h4 id="TCP的主要特点"><a href="#TCP的主要特点" class="headerlink" title="TCP的主要特点"></a>TCP的主要特点</h4><ul>
<li>TCP是面向连接的运输层协议</li>
<li>每一条TCP连接只能两个短点，每一条TCP都是点对点的</li>
<li>提供可靠交付服务</li>
<li>提供全双工服务</li>
<li>面向字节流<h4 id="TCP通过下列方式来提供可靠性"><a href="#TCP通过下列方式来提供可靠性" class="headerlink" title="TCP通过下列方式来提供可靠性"></a>TCP通过下列方式来提供可靠性</h4></li>
<li>应用数据被分割成TCP认为最合适发送的数据块。这个UDP完全不同，应用程序产生的数据报长度将保持不变。由TCP传递给IP的信息单位称为报文段或段(segment)</li>
<li>当TCP发出一个段之后，它将启动一个定时器，等待目的端确认收到这个报文段，如果目的端不能及时确认接收，将重发这个报文段</li>
<li>当TCP收到发至TCP连接的另一端的数据，它将发送一个确认。</li>
<li>TCP保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果检验和有差错，TCP将丢弃这个报文段和不确认接收此报文段，并希望另一端重传此报文段。</li>
<li>既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</li>
<li>既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。</li>
<li>TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机缓冲区溢出。<h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4>停止等待协议用下面的图来说明：图片来源于《计算机网络第六版》谢希仁编著<br>在全双工通信的情况下，每一端既是接收方也是发送方，为方便，简化为A向B发送数据.</li>
</ul>
<ol>
<li>在无差错的情况下，A向B发送数据分组M1，发送完了就等待B的确认。B确认接收M1之后向A发送确认收到M1的数据。A收到B发送的”确认收到M1”的消息后，再向B发送下一组数据分组。</li>
<li>在有差错的情况下，B收到的数据分组可能是内容不对，B就把数据直接丢弃；也可能是数据分组在 传输过程中丢失了，B什么也没有接收到。这两种情况下，B什么也不操作（不通知A数据有错或者没收到数据。等到过一段时间，A没有收到B的确认消息，就认为刚刚发送的数据丢失了，然后重新传输刚才发送的分组。这要求A在每次发送一个数据分组时，都要设计一个超时计数器。<br> 但是要注意<ol>
<li>A在发送完一个分组后，必须暂时保留已发送的分组的副本（超时重传）。只有等到分组确认后才能清除暂时保留的副本</li>
<li>分组和确认分组必须都进行编号</li>
<li>超时及时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。<br><img src="/image/tcp/tcp1.png" alt="无差错左/有差错右"></li>
</ol>
</li>
<li>确认丢失和确认迟到<br>下图左边的情况是B向A发送的确认收到M1的消息丢失了。A在设定的超时重传时间内没有收到确认，但并无法知道是自己发送的分组出错、丢失，或者是B发送的确认丢失了，因此A在超时计时器到期后就要重传M1。假定B又收到了重传的分组M1.这时应采取两个行动：<ol>
<li>丢弃这个重复的分组M1，不向上层交付。</li>
<li>向A发送确认，不能认为已经发送过确认就不再发送，因为A之所以重传M1就表示A没有收到M1的确认。<br>下图右边的情况是传输过程中没有出现差错，但是B对分组M1的确认迟到了，A会收到重复确认，然后丢弃掉，但是这时A已经重发数据分组M1了，B收到重复的分组M1胡同样丢弃重复的分组M1，并重传确认分组。<br><img src="/image/tcp/tcp2.png" alt="确认丢失左/确认迟到右"><h4 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h4>　　滑动窗口协议比较复杂。图片来源于《计算机网络第六版》谢希仁编著<br>下图a表示发送发维持的发送窗口，它的意义是：位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方确认。<br>连续ARQ协议规定，发送方每收到一个确认，就把窗口向前滑动一个分组的位置，b表示发送发收到了对第一个分组的确认，于是把发送的分组向前移动一个分组的位置。<br>接收方一般都是采用<strong>累计确认</strong>的方式。这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的的最后一个分组发送确认，这就表示：到这个分组为止的所有分组都已经正确收到了。<br><img src="/image/tcp/tcp3.png" alt="发送窗口"><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4>　　TCP的滑动窗口是以字节为单位的。现在假定A收到了B发来的确认报文段，其中窗口是20，而确认号是31(这表明B期望收到的下一个序号是31,到序号30为止的数据已经收到了)。根据这两个数据，A就构造出自己的发送窗口，如下图所示<br><img src="/image/tcp/tcp4.png" alt="滑动窗口"><br>　　发送窗口表示：在没有收到B的确认情况下，A可以把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。<br>发送窗口里面的序号表示允许发送的序号。显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。但是接收方必须来得及处理这些收到的数据。<br>发送窗口后延的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间。<br>　　发送窗口的位置由窗口前沿和后延的位置共同确定。发送窗口后沿的变换情况有两种可能，即不懂(没有收到新的确认)和前移(收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况：一时没有收到信的确认，对方通知的窗口大小也不变；二是收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。发送窗口前沿也可能向后收缩，但是TCP的标准强烈不赞成这么做。<h4 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h4>假定主机A运行的是TCP客户程序，而B运行TCP服务器程序。最初两端的TCP进程都处于CLOSED(关闭)状态。如下图所示。现在A主动打开连接，而B是被动打开连接。<br><img src="/image/tcp/tcp5.png" alt="三次握手"><br>　　B的TCP服务器先创建传输控制块TCB，准备接受客户程序的连接请求，然后服务器进场就处于LISTEN(监听)状态，等待客户端的连接请求。如果有，即作出响应。<br>　　A的TCP客户进程也是首先创建传输控制模块TCB，然后向B发出连接请求报文段，这时首部中的同部位SYN&#x3D;1，同时选择一个初始序号 seq&#x3D;x 。TCP规定，SYN报文段(即SYN&#x3D;1的报文段)不能携带数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT(同步已发送)状态。<br>　　B收到连接请求报文段后，如果同意建立连接，则向A发送确认。在确认报文段中应把SYN位和ACK位都置1，确认号是ack&#x3D;x+1 ,同时也为自己选择一个初始序号seq&#x3D;y。这个报文段也不能携带数据，但同样要消耗掉一个序号。这时TCP服务器进程进入SYN-RCVD(同步收到)状态。<br>　　TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack&#x3D;y+1，而自己的序号seq&#x3D;x+1。TCP的标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍然是seq&#x3D;x+1。这时TCP连接已经建立，A进入ESTABLISHED(已建立连接)状态。<br>　　当B收到A的确认后，也进入ESTABLISHED状态<br>　　A最后发送一次确认主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。<h4 id="TCP连接的释放"><a href="#TCP连接的释放" class="headerlink" title="TCP连接的释放"></a>TCP连接的释放</h4>数据传输结束后，通信的双方都可释放连接。<br><img src="/image/tcp/tcp6.png" alt="四次挥手"><br>　　现在A和B都处于ESTABLISHED状态，A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接，A把连接释放报文段首部的宗旨控制位FIN置1，其序号seq&#x3D;u，它等于前面已传送过的数据的最后一个直接的序号加1.这时A进入FIN-WAIT-1(终止等待1)状态，等待B的确认。TCP规定，FIN报文段即使不携带数据，它也消耗掉一个序号。<br>　　B收到连接释放报文段后即发出确认，确认号是ack&#x3D;u+1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT(关闭等待)状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭(half-close)状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收，就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一些时间。<br>　　A收到来自B的确认后，就进图FIN-WAIT-2(终止等待2)状态，等待B发出的连接释放报文段。<br>　　若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。这时B发出的连接释放报文段必须使用FIN&#x3D;1.现在假定B的序号为w(在半关闭状态B可能又发送了一些数据)，B还必须重复上次已发送过的确认号ack&#x3D;u+1。这时B就进入LAST-ACK(最后确认)状态，等待A的确认。<br>　　A在收到B的连接释放报文段后，必须对此发出确认。在确认报文段中把ACK置1，确认号ack&#x3D;w+1，而自己的序号是seq&#x3D;u+1，TCP规定，前面发送的FIN报文段要消耗一个序号。然后进入到TIME-WAIT(时间等待)状态。现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间2MSL后，A才进入到CLOSED状态，时间MSL叫做最长报文段寿命。<br>　　B只要收到了A发出的确认，就进入CLOSED状态。同样，B在撤销相应的出书控制块TCB后，就结束了这次的TCP连接。B结束TCP连接的时间要比A早一些。<h4 id="TCP有限状态机"><a href="#TCP有限状态机" class="headerlink" title="TCP有限状态机"></a>TCP有限状态机</h4><img src="/image/tcp/tcp7.png" alt="有限状态机"><br>粗实线箭头表示对客户进程的正常变迁、粗虚线箭头表示对服务器进程的正常变迁、另一种细线箭头表示异常变迁。</li>
</ol>
</li>
</ol>
<hr>
<p>以上文字和图片均来自于《计算机网络第6版》谢希仁著</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>tcp协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Toast显示过程</title>
    <url>/2018/08/03/Toast%E6%98%BE%E7%A4%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>抄书抄的有点烦，自己也学着分析一下源码，挑了个在我看来比较简单的Toast显示过程来玩一玩。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Toast.makeText(context, text, duration).show();<br></code></pre></td></tr></table></figure>
<p>先了解一下makeText过程，该过程最终都会调用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Make a standard toast to display using the specified looper.</span><br><span class="hljs-comment">     * If looper is null, Looper.myLooper() is used.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@hide</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Toast <span class="hljs-title function_">makeText</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> Looper looper,</span><br><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> CharSequence text, <span class="hljs-meta">@Duration</span> <span class="hljs-type">int</span> duration)</span> &#123;<br>        <span class="hljs-type">Toast</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Toast</span>(context, looper);<br><br>        <span class="hljs-type">LayoutInflater</span> <span class="hljs-variable">inflate</span> <span class="hljs-operator">=</span> (LayoutInflater)<br>                context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);<br>        <span class="hljs-type">View</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> inflate.inflate(com.android.internal.R.layout.transient_notification, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">TextView</span> <span class="hljs-variable">tv</span> <span class="hljs-operator">=</span> (TextView)v.findViewById(com.android.internal.R.id.message);<br>        tv.setText(text);<br><br>        result.mNextView = v;<br>        result.mDuration = duration;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>创建一个新的Toast对象，在Toast的构造方法中有一个TN类型的mTN对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">mTN = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TN</span>(context.getPackageName(), looper);<br></code></pre></td></tr></table></figure>
<p><code>TN</code>是<code>ITransientNotification.Stub</code>的子类，注意一下这个对象，这对后面的过程很重要。</p>
<span id="more"></span>
<p>得到Toast对象后接着调用<code>show</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Show the view for the specified duration.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (mNextView == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;setView must have been called&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">INotificationManager</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> getService();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> mContext.getOpPackageName();<br>        <span class="hljs-type">TN</span> <span class="hljs-variable">tn</span> <span class="hljs-operator">=</span> mTN;<br>        tn.mNextView = mNextView;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            service.enqueueToast(pkg, tn, mDuration);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            <span class="hljs-comment">// Empty</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>重点在<code>service</code>上，它是<code>INotificationManager</code>的实例对象，是个用于Binder机制IPC通信的接口，实际上getService返回了一个以”notification”为标记的远程服务对象的代理。这个远程服务对象就是NotificationManagerService，以下简称NMS。NMS中的enqueueToast方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueueToast</span><span class="hljs-params">(String pkg, ITransientNotification callback, <span class="hljs-type">int</span> duration)</span><br>&#123;<br>    ......<br>    <span class="hljs-keyword">synchronized</span> (mToastQueue) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">callingPid</span> <span class="hljs-operator">=</span> Binder.getCallingPid();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">callingId</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ToastRecord record;<br>            <span class="hljs-type">int</span> index;<br>            <span class="hljs-comment">// All packages aside from the android package can enqueue one toast at a time</span><br>            <span class="hljs-keyword">if</span> (!isSystemToast) &#123;<br>                index = indexOfToastPackageLocked(pkg);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                index = indexOfToastLocked(pkg, callback);<br>            &#125;<br><br>            <span class="hljs-comment">// If the package already has a toast, we update its toast</span><br>            <span class="hljs-comment">// in the queue, we don&#x27;t move it to the end of the queue.</span><br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                record = mToastQueue.get(index);<br>                record.update(duration);<br>                record.update(callback);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">Binder</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Binder</span>();<br>                mWindowManagerInternal.addWindowToken(token, TYPE_TOAST, DEFAULT_DISPLAY);<br>                record = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ToastRecord</span>(callingPid, pkg, callback, duration, token);<br>                mToastQueue.add(record);<br>                index = mToastQueue.size() - <span class="hljs-number">1</span>;<br>            &#125;<br>            keepProcessAliveIfNeededLocked(callingPid);<br>            <span class="hljs-comment">// If it&#x27;s at index 0, it&#x27;s the current toast.  It doesn&#x27;t matter if it&#x27;s</span><br>            <span class="hljs-comment">// new or just been updated.  Call back and tell it to show itself.</span><br>            <span class="hljs-comment">// If the callback fails, this will remove it from the list, so don&#x27;t</span><br>            <span class="hljs-comment">// assume that it&#x27;s valid after this.</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>                showNextToastLocked();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            Binder.restoreCallingIdentity(callingId);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法中的第二个参数callBack就是上面的TN对象，关键在于下面的index的判断：<br>mToastQueue是个list，如果是非系统tost，并且该taost存在于list中(根据pkg判断)，就取出该ToastRecord并且更新，如果不存在，则新建一个ToastRecord存入list中。<br>如果ToastRecord是在list的第一个位置，接着调用<code>showNextToastLocaked</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GuardedBy(&quot;mToastQueue&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">showNextToastLocked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ToastRecord</span> <span class="hljs-variable">record</span> <span class="hljs-operator">=</span> mToastQueue.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (record != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (DBG) Slog.d(TAG, <span class="hljs-string">&quot;Show pkg=&quot;</span> + record.pkg + <span class="hljs-string">&quot; callback=&quot;</span> + record.callback);<br>        <span class="hljs-keyword">try</span> &#123;<br>            record.callback.show(record.token);<br>            scheduleTimeoutLocked(record);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            Slog.w(TAG, <span class="hljs-string">&quot;Object died trying to show notification &quot;</span> + record.callback<br>                    + <span class="hljs-string">&quot; in package &quot;</span> + record.pkg);<br>            <span class="hljs-comment">// remove it from the list and let the process die</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> mToastQueue.indexOf(record);<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                mToastQueue.remove(index);<br>            &#125;<br>            keepProcessAliveIfNeededLocked(record.pid);<br>            <span class="hljs-keyword">if</span> (mToastQueue.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                record = mToastQueue.get(<span class="hljs-number">0</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                record = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键的两行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">record.callback.show(record.token);<br>scheduleTimeoutLocked(record);<br></code></pre></td></tr></table></figure>
<p>第一行负责显示，第二行负责超时关闭并显示队列中的下一个Toast。<br>在第一行中，callBack就是我们上面提到的TN对象的实例mTN：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* schedule handleShow into the right thread</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(IBinder windowToken)</span> &#123;<br>    <span class="hljs-keyword">if</span> (localLOGV) Log.v(TAG, <span class="hljs-string">&quot;SHOW: &quot;</span> + <span class="hljs-built_in">this</span>);<br>    mHandler.obtainMessage(SHOW, windowToken).sendToTarget();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>mHandler</code>中调用了<code>handleShow</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleShow</span><span class="hljs-params">(IBinder windowToken)</span> &#123;<br>            <span class="hljs-keyword">if</span> (localLOGV) Log.v(TAG, <span class="hljs-string">&quot;HANDLE SHOW: &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; mView=&quot;</span> + mView<br>                    + <span class="hljs-string">&quot; mNextView=&quot;</span> + mNextView);<br>            <span class="hljs-comment">// If a cancel/hide is pending - no need to show - at this point</span><br>            <span class="hljs-comment">// the window token is already invalid and no need to do any work.</span><br>            <span class="hljs-keyword">if</span> (mHandler.hasMessages(CANCEL) || mHandler.hasMessages(HIDE)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mView != mNextView) &#123;<br>                <span class="hljs-comment">// remove the old view if necessary</span><br>                handleHide();<br>                mView = mNextView;<br>                <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> mView.getContext().getApplicationContext();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">packageName</span> <span class="hljs-operator">=</span> mView.getContext().getOpPackageName();<br>                <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>                    context = mView.getContext();<br>                &#125;<br>                mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);<br>                <span class="hljs-comment">// We can resolve the Gravity here by using the Locale for getting</span><br>                <span class="hljs-comment">// the layout direction</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Configuration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> mView.getContext().getResources().getConfiguration();<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">gravity</span> <span class="hljs-operator">=</span> Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection());<br>                mParams.gravity = gravity;<br>                <span class="hljs-keyword">if</span> ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) &#123;<br>                    mParams.horizontalWeight = <span class="hljs-number">1.0f</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) &#123;<br>                    mParams.verticalWeight = <span class="hljs-number">1.0f</span>;<br>                &#125;<br>                mParams.x = mX;<br>                mParams.y = mY;<br>                mParams.verticalMargin = mVerticalMargin;<br>                mParams.horizontalMargin = mHorizontalMargin;<br>                mParams.packageName = packageName;<br>                mParams.hideTimeoutMilliseconds = mDuration ==<br>                    Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;<br>                mParams.token = windowToken;<br>                <span class="hljs-keyword">if</span> (mView.getParent() != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (localLOGV) Log.v(TAG, <span class="hljs-string">&quot;REMOVE! &quot;</span> + mView + <span class="hljs-string">&quot; in &quot;</span> + <span class="hljs-built_in">this</span>);<br>                    mWM.removeView(mView);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (localLOGV) Log.v(TAG, <span class="hljs-string">&quot;ADD! &quot;</span> + mView + <span class="hljs-string">&quot; in &quot;</span> + <span class="hljs-built_in">this</span>);<br>                <span class="hljs-comment">// Since the notification manager service cancels the token right</span><br>                <span class="hljs-comment">// after it notifies us to cancel the toast there is an inherent</span><br>                <span class="hljs-comment">// race and we may attempt to add a window after the token has been</span><br>                <span class="hljs-comment">// invalidated. Let us hedge against that.</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    mWM.addView(mView, mParams);<br>                    trySendAccessibilityEvent();<br>                &#125; <span class="hljs-keyword">catch</span> (WindowManager.BadTokenException e) &#123;<br>                    <span class="hljs-comment">/* ignore */</span><br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>上面的一坨是获取到<code>WindowManager</code>然后通过<code>mWM.addView</code>将Toast显示到窗口上。<br>至于<code>WindowManager</code>如何添加view的，可以看这个：<a href="http://blog.huangyuanlove.com/2017/03/21/Window%E5%92%8CCWindowManager/">http://blog.huangyuanlove.com/2017/03/21/Window和CWindowManager/</a><br>接下来看一下怎么取消Toast弹窗，上面提到了调用了<code>scheduleTimeoutLocked</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GuardedBy(&quot;mToastQueue&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduleTimeoutLocked</span><span class="hljs-params">(ToastRecord r)</span>&#123;<br>    mHandler.removeCallbacksAndMessages(r);<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> Message.obtain(mHandler, MESSAGE_TIMEOUT, r);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;<br>    mHandler.sendMessageDelayed(m, delay);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用mHandler发送了一个延时消息去调用<code>handleTimeout</code>方法，延迟时间就是根据duration来判断的。这里的<code>mHandler</code>是<code>WorkerHandler</code>继承自<code>Handler</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleTimeout</span><span class="hljs-params">(ToastRecord record)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (DBG) Slog.d(TAG, <span class="hljs-string">&quot;Timeout pkg=&quot;</span> + record.pkg + <span class="hljs-string">&quot; callback=&quot;</span> + record.callback);<br>        <span class="hljs-keyword">synchronized</span> (mToastQueue) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> indexOfToastLocked(record.pkg, record.callback);<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                cancelToastLocked(index);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>接着调用了<code>cancelToastLocked</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GuardedBy(&quot;mToastQueue&quot;)</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelToastLocked</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">ToastRecord</span> <span class="hljs-variable">record</span> <span class="hljs-operator">=</span> mToastQueue.get(index);<br>        <span class="hljs-keyword">try</span> &#123;<br>            record.callback.hide();<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            Slog.w(TAG, <span class="hljs-string">&quot;Object died trying to hide notification &quot;</span> + record.callback<br>                    + <span class="hljs-string">&quot; in package &quot;</span> + record.pkg);<br>            <span class="hljs-comment">// don&#x27;t worry about this, we&#x27;re about to remove it from</span><br>            <span class="hljs-comment">// the list anyway</span><br>        &#125;<br><br>        <span class="hljs-type">ToastRecord</span> <span class="hljs-variable">lastToast</span> <span class="hljs-operator">=</span> mToastQueue.remove(index);<br>        mWindowManagerInternal.removeWindowToken(lastToast.token, <span class="hljs-literal">true</span>, DEFAULT_DISPLAY);<br><br>        keepProcessAliveIfNeededLocked(record.pid);<br>        <span class="hljs-keyword">if</span> (mToastQueue.size() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Show the next one. If the callback fails, this will remove</span><br>            <span class="hljs-comment">// it from the list, so don&#x27;t assume that the list hasn&#x27;t changed</span><br>            <span class="hljs-comment">// after this point.</span><br>            showNextToastLocked();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在该方法中调用了<code>callback.hide()</code>方法移除toast的显示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleHide</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (localLOGV) Log.v(TAG, <span class="hljs-string">&quot;HANDLE HIDE: &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; mView=&quot;</span> + mView);<br>    <span class="hljs-keyword">if</span> (mView != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// note: checking parent() just to make sure the view has</span><br>        <span class="hljs-comment">// been added...  i have seen cases where we get here when</span><br>        <span class="hljs-comment">// the view isn&#x27;t yet added, so let&#x27;s try not to crash.</span><br>        <span class="hljs-keyword">if</span> (mView.getParent() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (localLOGV) Log.v(TAG, <span class="hljs-string">&quot;REMOVE! &quot;</span> + mView + <span class="hljs-string">&quot; in &quot;</span> + <span class="hljs-built_in">this</span>);<br>            mWM.removeViewImmediate(mView);<br>        &#125;<br><br>        mView = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果这时候mToastQueue中还有ToastRecord，则调用<code>showNextToastLocked</code>方法显示下一个。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX/linux的find命令细节</title>
    <url>/2015/02/11/UNIX-linux%E7%9A%84find%E5%91%BD%E4%BB%A4%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<p>find 命令的工作方式如下:</p>
<p>沿着文件层次结构向下遍历,匹配符合条件的文件,并执行相应的操作.</p>
<span id="more"></span>

<h4 id="根据文件名或者正则表达式匹配搜索"><a href="#根据文件名或者正则表达式匹配搜索" class="headerlink" title="根据文件名或者正则表达式匹配搜索"></a>根据文件名或者正则表达式匹配搜索</h4><p>选项-name的参数指定了文件名所必须匹配的字符串,我们可以将通配符作为参数使用.”*.txt” 可以匹配所有的以”.txt”结尾的文件.选项-print 在终端中打印出符合条件的文件名或者文件路径,这些匹配条件作为find 的参数给出</p>
<p>find &#x2F;home&#x2F;huangyuan -name “*.txt” -print</p>
<p>find 有一个选项-iname 可以忽略文件名的大小写</p>
<p>如果想匹配多个条件中的一个,可以使用 OR 条件操作</p>
<p>find . (-name “<em>.txt” -o -name “</em>.pdf”) -print</p>
<p>上面的代码会打印出所有的 “.txt” 和 “.pdf” 文件,是因为这个find 命令可以匹配所有的这两类文件</p>
<p>其中, “(“ 和 “)“ 用于将 -name “<em>.txt” -o -name “</em>.pdf” 视为一个整体</p>
<p>选项 -path 可以使用通配符来匹配文件路径或者文件名</p>
<p>选项 -regex 是基于正则表达式来匹配文件路径货文件.正则表达式是通配符的高级形式,例如,可以使用正则表达式来匹配Email ,一个 Email 的形式通常是 <a href="mailto:&#110;&#97;&#109;&#x65;&#x40;&#x68;&#x6f;&#115;&#116;&#x2e;&#x72;&#111;&#111;&#116;">&#110;&#97;&#109;&#x65;&#x40;&#x68;&#x6f;&#115;&#116;&#x2e;&#x72;&#111;&#111;&#116;</a></p>
<p>所以可以将其一般化为 [0-9a-zA-A]+@[0-9a-zA-A]+.[0-9a-zA-A] +</p>
<p> “+” 指明在它之前的字符类中字符可以出现一次或者多次</p>
<h4 id="否定参数"><a href="#否定参数" class="headerlink" title="否定参数 !"></a>否定参数 !</h4><p>find 也可以用 “!” 来否定参数的含义</p>
<p>find . ! -name “*.txt” -print</p>
<p>上面的命令可以用来 匹配所有不以 “.txt” 结尾的文件</p>
<h4 id="基于目录深度的搜索"><a href="#基于目录深度的搜索" class="headerlink" title="基于目录深度的搜索"></a>基于目录深度的搜索</h4><p>find 命令在使用时会遍历所有的子目录,我们可以使用 -mindepth 和 -maxdepth 来限制搜索子目录的深度</p>
<p>find . -maxdeoth 1 -print </p>
<p>这条目录只会打印当前目录中的所有文件,而不会打印子目录中的文件</p>
<p>find . -mindepth 2 -print</p>
<p>这条目录打印目录深度至少为2 的文件</p>
<h4 id="根据文件类型搜索"><a href="#根据文件类型搜索" class="headerlink" title="根据文件类型搜索"></a>根据文件类型搜索</h4><p>find . -type d -print</p>
<p>上面的命令只会打印出目录</p>
<p>文件类型                类型参数</p>
<p>普通文件                f</p>
<p>符号连接                l</p>
<p>目录                       d</p>
<p>字符设备                c</p>
<p>块设备                    b</p>
<p>套接字                    s</p>
<p>Fifo                        p</p>
<h4 id="根据文件时间进行搜索"><a href="#根据文件时间进行搜索" class="headerlink" title="根据文件时间进行搜索"></a>根据文件时间进行搜索</h4><p>unix&#x2F;linux 文件系统中的每一个文件都有三种时间戳(timestamp) ,如下所示</p>
<p>访问时间 (-atime) : 用户最近一次访问文件的时间</p>
<p>修改时间 (-mtime): 文件内同最后一次被修改的时间</p>
<p>变化时间 (-ctime) : 文件元数据(metadata,例如权限或者所有权)最后一次被修改的时间</p>
<p>在unux&#x2F;linux中没有创建时间这个概念</p>
<p>-atime,-mtime,-ctime 可以作为 find 的时间参数,例如</p>
<p>打印出 最近七天内被访问过的文件</p>
<p>find . -atime -7 -print</p>
<p>打印出 刚好七天前访问过的文件</p>
<p>find . -atime 7 -print</p>
<p>打印出 访问时间超过7天的文件</p>
<p>find . -atime +7 -print</p>
<p>还有其他一些基于时间的参数 (以分钟为单位)</p>
<p>-amin</p>
<p>-mmin</p>
<p>-cmin</p>
<h4 id="基于文件大小搜索"><a href="#基于文件大小搜索" class="headerlink" title="基于文件大小搜索"></a>基于文件大小搜索</h4><p>find . -size +2k</p>
<p>大于2k的文件</p>
<p>find . -size -2k</p>
<p>小于2k的文件</p>
<p>find .-size 2k</p>
<p>等于2k的文件</p>
<p>除了K之外,还有其他单元</p>
<p>b——块  512字节</p>
<p>c——字节</p>
<p>w—–字  2字节</p>
<p>k—–千字节</p>
<p>m—-兆字节</p>
<p>G—-吉字节</p>
<h4 id="删除匹配文件"><a href="#删除匹配文件" class="headerlink" title="删除匹配文件"></a>删除匹配文件</h4><p>-delete 可以删除 find 查找到的匹配文件</p>
<p>find . -name “*.flv” -delete ##(删除所有flv文件)</p>
<p>基于文件权限和所有权的匹配</p>
<p>find . -perm 644 -print</p>
<p>find . -user huangyuan -print</p>
<h4 id="结合-find-执行命令或动作"><a href="#结合-find-执行命令或动作" class="headerlink" title="结合 find 执行命令或动作"></a>结合 find 执行命令或动作</h4><p>find 命令可以借助选项 -exec 与其他命令结合</p>
<p>例如  将制定目录中的所有C程序文件拼接起来写入单个文件 all_C_file.txt </p>
<p>find . -name “*.c” -exec cat {} ;&gt; all_C_file.txt</p>
<p>-exec 后面可以接任何命令.{}表示一个匹配.使用 &gt; 而不使用 &gt;&gt;　的原因是 find 命令的输出只是一个单数据流,而只有当多个数据流被追加到单个文件中的时候才有必要用 &gt;&gt; </p>
<h4 id="跳过指定目录"><a href="#跳过指定目录" class="headerlink" title="跳过指定目录"></a>跳过指定目录</h4><p>find .  ( -name “.get” -prune  ) -o  ( -print )</p>
<p>这条命令中  (-name “.git” -prune ) 指明 .git 目录应该排除掉, 而 ( -print ) 指明了执行的动作.这些动作需要放在第二个语句块中.</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu输入密码登陆后回到登录界面</title>
    <url>/2018/12/26/Ubuntu%E8%BE%93%E5%85%A5%E5%AF%86%E7%A0%81%E7%99%BB%E9%99%86%E5%90%8E%E5%9B%9E%E5%88%B0%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>既然推荐更新了，那就更呗，然后更新到了18.04，被小伙伴吐槽不用命令行更新的系统是没有灵魂的。更新之后玩了没几天，昨晚突然间无法登录桌面了。输入密码登录后显示一下桌面背景然后就回到了的登录界面，使用tty登录没问题。这就好办了，盲猜桌面服务挂了。然后猜原因：</p>
<ol>
<li><code>.Xauthority</code>权限不对</li>
<li><code>/tmp</code>权限不对</li>
<li><code>ubuntu-desktop</code>挂了</li>
</ol>
<p>盲猜完了，验证一下</p>
<span id="more"></span>

<h4 id="Xauthority-权限不对"><a href="#Xauthority-权限不对" class="headerlink" title=".Xauthority 权限不对"></a>.Xauthority 权限不对</h4><p><code>Xauthority</code>是<code>startx</code>脚本记录文件。<code>Xserver</code>启动时，读文件<code>~/.Xauthority</code>，读入相应其<code>display</code>的记录。</p>
<p>当一个须要显示的客户程序启动调用<code>XOpenDisplay()</code>也读这个文 件。并把找到的<code>magic code</code> 发送给<code>Xserver</code>。</p>
<p>当<code>Xserver</code>验证这个<code>magic code</code>正确以后，就允许连接啦。</p>
<p>观察<code>startx</code>脚本也能够看到，每次<code>startx</code>执行，都在调用<code>xinit</code>曾经使用了<code>xauth</code>的<code>add</code>命令加入了一个新的记录到<code>~/.Xauthority</code>，用来这次执行X使用认证 。</p>
<p>查看文件权限，没问题，查看<code>/tmp</code>权限没问题。</p>
<p>emmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm</p>
<p>家目录下有个<code>.xsession-errors</code>文件，也没有错误日志。。。</p>
<h4 id="ubuntu-desktop-挂了"><a href="#ubuntu-desktop-挂了" class="headerlink" title="ubuntu-desktop 挂了"></a>ubuntu-desktop 挂了</h4><p>tty登录，删除<code>ubuntu-desktop</code></p>
<blockquote>
<p>sudo apt-get autoremove ubuntu-desktop</p>
</blockquote>
<p>然后 <code>ctrl+alt+f1</code>进入GUI，输入密码登录。成功。</p>
<p>emmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm</p>
<p>只是桌面上的文件不显示了，不急，命令行查看一下文件还在，放心了。</p>
<p>dock(launch)不见了，就是在桌面左边放软件图标的快捷启动，相当于windows的任务栏的那玩意</p>
<p>按下win键，搜索还能用，问题不大。</p>
<p>原来安装的软件还能用，那就更没问题了。</p>
<blockquote>
<p>sudo apt-get install desktop-base<br>sudo apt-get install desktop-profiles<br>sudo apt-get install desklaunch<br>sudo apt-get install gnome-shell-extension-ubuntu-dock</p>
</blockquote>
<p>ok，解决</p>
<p>没必要追求所有软件和依赖都使用最新版的，有时间折腾还好，没时间折腾。。。。没时间折腾的就要么老老实实用windows，要么上mac。</p>
<hr>
<p>操作系统：我们要不要信任用户的操作？</p>
<p>windows：不信任，用户都是傻<del>消音</del>，不信任，只开放部分权限给用户，系统配置更新我们自己搞。</p>
<p>ubuntu：用户安装了操作系统，那就所有东西都放权给用户，我们只在关键地方给出提示。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>View事件分发</title>
    <url>/2018/07/29/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    <content><![CDATA[<p>抄的《Android开发艺术探索》3.4.1 和 3.4.2</p>
<h6 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h6><p>在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种：</p>
<ul>
<li>ACTION_DOWN——手指刚接触屏幕；</li>
<li>ACTION_MOVE——手指在屏幕上移动；</li>
<li>ACTION_UP——手机从屏幕上松开的一瞬间<br>还有其他的事件可以参考<code>MotionEvent.java</code>类</li>
</ul>
<h6 id="TouchSlop"><a href="#TouchSlop" class="headerlink" title="TouchSlop"></a>TouchSlop</h6><p>TouchSlop是系统所能识别出的被认为是滑动的最小距离，换句话说，当手指在屏幕上滑动时，如果两次滑动之间的距离小于这个常量，那么系统就不认为你是在进行滑动操作，这是一个常量，和设备有关，在不同设备上这个值可能是不同的，通过如下方式即可获取这个常量：<code>ViewConfiguration. get(getContext()).getScaledTouchSlop()</code>。当我们在处理滑动时，可以利用这个常量来做一些过滤，比如当两次滑动事件的滑动距离小于这个值，我们就可以认为未达到滑动距离的临界值，因此就可以认为它们不是滑动，这样做可以有更好的用户体验可以在源码中找到这个常量的定义，在<code>frameworks/base/core/res/res/values/config.xml</code>文件中。</p>
<span id="more"></span>
<p>所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent，下面我们先介绍一下这几个方法</p>
<h6 id="public-boolean-dispatchTouchEvent-MotionEvent-ev"><a href="#public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="public boolean dispatchTouchEvent(MotionEvent ev)"></a>public boolean dispatchTouchEvent(MotionEvent ev)</h6><p>用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。</p>
<h6 id="public-boolean-onInterceptTouchEvent-MotionEvent-event"><a href="#public-boolean-onInterceptTouchEvent-MotionEvent-event" class="headerlink" title="public boolean onInterceptTouchEvent(MotionEvent event)"></a>public boolean onInterceptTouchEvent(MotionEvent event)</h6><p>在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</p>
<h6 id="public-boolean-onTouchEvent-MotionEvent-event"><a href="#public-boolean-onTouchEvent-MotionEvent-event" class="headerlink" title="public boolean onTouchEvent(MotionEvent event)"></a>public boolean onTouchEvent(MotionEvent event)</h6><p>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">consume</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (onInterceptTouchEvent(ev)) &#123;<br>        consume = onTouchEvent(ev);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        consume = child.dispatchTouchEvent(ev);<br>    &#125;<br>    <span class="hljs-keyword">return</span> consume;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于一个根<code>ViewGroup</code>来说，点击事件产生后，首先会传递给它，这时它的<code>dispatchTouchEvent</code>就会被调用，如果这个<code>ViewGroup</code>的<code>onInterceptTouchEvent</code>方法返回<code>true</code>就表示它要拦截当前事件，接着事件就会交给这个<code>ViewGroup</code>处理，即它的<code>onTouchEvent</code>方法就会被调用；如果这个<code>ViewGroup</code>的<code>onInterceptTouchEvent</code>方法返回<code>false</code>就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的<code>dispatchTouchEvent</code>方法就会被调用，如此反复直到事件被最终处理。<br>当一个<code>View</code>需要处理事件时，如果它设置了<code>OnTouchListener</code>，那么<code>OnTouchListener</code>中的<code>onTouch</code>方法会被回调。这时事件如何处理还要看<code>onTouch</code>的返回值，如果返回<code>false</code>，则当前<code>View</code>的<code>onTouchEvent</code>方法会被调用；如果返回<code>true</code>，那么<code>onTouchEvent</code>方法将不会被调用。由此可见，给<code>View</code>设置的<code>OnTouchListener</code>，其优先级比<code>onTouchEvent</code>要高。在<code>onTouchEvent</code>方法中，如果当前设置的有<code>OnClickListener</code>，那么它的<code>onClick</code>方法会被调用。可以看出，平时我们常用的<code>OnClickListener</code>，其优先级最低，即处于事件传递的尾端。<br>当一个点击事件产生后，它的传递过程遵循如下顺序：<code>Activity -&gt; Window -&gt; View</code>，即事件总是先传递给<code>Activity</code>，<code>Activity</code>再传递给<code>Window</code>，最后<code>Window</code>再传递给顶级<code>View</code>。顶级<code>View</code>接收到事件后，就会按照事件分发机制去分发事件。考虑一种情况，如果一个<code>View</code>的<code>onTouchEvent</code>返回<code>false</code>，那么它的父容器的<code>onTouchEvent</code>将会被调用，依此类推。如果所有的元素都不处理这个事件，那么这个事件将会最终传递给<code>Activity</code>处理，即<code>Activity</code>的<code>onTouchEvent</code>方法会被调用。</p>
<h6 id="事件传递机制"><a href="#事件传递机制" class="headerlink" title="事件传递机制"></a>事件传递机制</h6><ul>
<li>同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。</li>
<li>正常情况下，一个事件序列只能被一个View拦截且消耗。因为一旦一个元素拦截了某此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过onTouchEvent强行传递给其他View处理。</li>
<li>某个View一旦决定拦截，那么这一个事件序列都只能由它来处理（如果事件序列能够传递给它的话），并且它的onInterceptTouchEvent不会再被调用。这条也很好理解，就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列内的其他方法都直接交给它来处理，因此就不用再调用这个View的onInterceptTouchEvent去询问它是否要拦截了。</li>
<li>某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的onTouchEvent会被调用。意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。</li>
<li>如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。</li>
<li>ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouch-Event方法默认返回false。</li>
<li>View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。</li>
<li>View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable  和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。</li>
<li>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longClickable有一个为true，那么它的onTouchEvent就返回true。</li>
<li>onClick会发生的前提是当前View是可点击的，并且它收到了down和up的事件。</li>
<li>事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</li>
</ul>
<h6 id="事件分发源码"><a href="#事件分发源码" class="headerlink" title="事件分发源码"></a>事件分发源码</h6><p>** Activity对点击事件的分发过程 **<br>点击事件用<code>MotionEvent</code>来表示，当一个点击操作发生时，事件最先传递给当前<code>Activity</code>，由<code>Activity</code>的<code>dispatchTouchEvent</code>来进行事件派发，具体的工作是由<code>Activity</code>内部的<code>Window</code>来完成的。<code>Window</code>会将事件传递给<code>decor view</code>，<code>decor view</code>一般就是当前界面的底层容器（即<code>setContentView</code>所设置的<code>View</code>的父容器），通过<code>Activity.getWindow.getDecorView()</code>可以获得。我们先从<code>Activity</code>的<code>dispatchTouchEvent</code>开始分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Called to process touch screen events.  You can override this to</span><br><span class="hljs-comment">    * intercept all touch screen events before they are dispatched to the</span><br><span class="hljs-comment">    * window.  Be sure to call this implementation for touch screen events</span><br><span class="hljs-comment">    * that should be handled normally.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ev The touch screen event.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> boolean Return true if this event was consumed.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>       <span class="hljs-keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;<br>           onUserInteraction();<br>       &#125;<br>       <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> onTouchEvent(ev);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>在window类的注释中</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">/**<br> * Abstract base class for a top-level window look<span class="hljs-built_in"> and </span>behavior policy.  An<br> *<span class="hljs-built_in"> instance </span>of this class should be used as the top-level view added to the<br> * window manager. It provides standard UI policies such as a background, title<br> * area, default key processing, etc.<br> *<br> * &lt;p&gt;The only existing implementation of this<span class="hljs-keyword"> abstract</span> class is<br> * android.view.PhoneWindow, which you should instantiate when needing a<br> * Window.<br> */<br></code></pre></td></tr></table></figure>

<p>首先事件开始交给<code>Activity</code>所附属的<code>Window</code>进行分发，如果返回<code>true</code>，整个事件循环就结束了，返回<code>false</code>意味着事件没人处理，所有<code>View</code>的<code>onTouchEvent</code>都返回了<code>false</code>，那么<code>Activity</code>的<code>onTouchEvent</code>就会被调用。<br>其中<code>Window</code>是个抽象类，而其中的<code>superDispatchTouchEvent</code>方法也是个抽象方法。在<code>PhoneWindows</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>       <span class="hljs-keyword">return</span> mDecor.superDispatchTouchEvent(event);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>调用了DecorView的superDispatchTouchEvent方法，我们可以看一下DecorView：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecorView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FrameLayout</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RootViewSurfaceTaker</span>, WindowCallbacks &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">superDispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>目前事件传递到了<code>DecorView</code>这里，由于<code>DecorView</code>继承自<code>FrameLayout</code>且是父<code>View</code>，所以最终事件会传递给<code>View</code>。从这里开始，事件已经传递到顶级<code>View</code>了，即在<code>Activity</code>中通过<code>setContentView</code>所设置的<code>View</code>，另外顶级<code>View</code>也叫根<code>View</code>，顶级View一般来说都是<code>ViewGroup</code>。</p>
<p>** 顶级View对点击事件的分发过程 **<br>点击事件达到顶级<code>View</code>（一般是一个ViewGroup）以后，会调用<code>ViewGroup的dispatchTouchEvent</code>方法，然后的逻辑是这样的：如果顶级<code>ViewGroup</code>拦截事件即<code>onInterceptTouchEvent</code>返回<code>true</code>，则事件由<code>ViewGroup</code>处理，这时如果<code>ViewGroup</code>的<code>mOnTouchListener</code>被设置，则<code>onTouch</code>会被调用，否则<code>onTouchEvent</code>会被调用。也就是说，如果都提供的话，<code>onTouch</code>会屏蔽掉<code>onTouchEven</code>t。在<code>onTouchEvent</code>中，如果设置了<code>mOnClickListener</code>，则<code>onClick</code>会被调用。如果顶级<code>ViewGroup</code>不拦截事件，则事件会传递给它所在的点击事件链上的子<code>View</code>，这时子<code>View</code>的<code>dispatchTouchEvent</code>会被调用。到此为止，事件已经从顶级View传递给了下一层<code>View</code>，接下来的传递过程和顶级<code>View</code>是一致的，如此循环，完成整个事件的分发。具体代码可以看一下<code>ViewGroup.dispatchTouchEvent()</code>方法。</p>
<p>** View对点击事件的处理 **<br>View对点击事件的处理过程稍微简单一些，这里的View不包含ViewGroup。<br>View对点击事件的处理过程就比较简单了，因为View（这里不包含ViewGroup）是一个单独的元素，它没有子元素因此无法向下传递事件，所以它只能自己处理事件。从上面的源码可以看出View对点击事件的处理过程，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的onTouch方法返回true，那么onTouchEvent就不会被调用，可见OnTouchListener的优先级高于onTouchEvent，这样做的好处是方便在外界处理点击事件。接着再分析onTouchEvent的实现。先看当View处于不可用状态下点击事件的处理过程，如下所示。很显然，不可用状态下的View照样会消耗点击事件，尽管它看起来不可用。<br>接着再分析onTouchEvent的实现。先看当View处于不可用状态下点击事件的处理过程，如下所示。很显然，不可用状态下的View照样会消耗点击事件，尽管它看起来不可用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;<br>           <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="hljs-number">0</span>) &#123;<br>               setPressed(<span class="hljs-literal">false</span>);<br>           &#125;<br>           mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;<br>           <span class="hljs-comment">// A disabled view that is clickable still consumes the touch</span><br>           <span class="hljs-comment">// events, it just doesn&#x27;t respond to them.</span><br>           <span class="hljs-keyword">return</span> clickable;<br>       &#125;<br></code></pre></td></tr></table></figure>
<p>接下来如果View设置有代理，还会执行代理的onTouchEvent方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mTouchDelegate != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>

<p>接下来就是对事件序列的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;<br>            <span class="hljs-keyword">switch</span> (action) &#123;<br>                <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:<span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<span class="hljs-keyword">break</span>;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上面的代码来看，只要View的<code>CLICKABLE</code>和<code>LONG_CLICKABLE</code>有一个为true，那么它就会消耗这个事件，即<code>onTouchEvent</code>方法返回true，不管它是不是<code>DISABLE</code>状态，然后就是当<code>ACTION_UP</code>事件发生时，会触发<code>performClick</code>方法，如果View设置了<code>OnClickListener</code>，那么<code>performClick</code>方法内部会调用它的<code>onClick</code>方法。<code>View</code>的<code>LONG_CLICKABLE</code>属性默认为<code>false</code>，而<code>CLICKABLE</code>属性是否为<code>false</code>和具体的View有关，确切来说是可点击的View其<code>CLICKABLE为true</code>，不可点击的View其<code>CLICKABLE</code>为<code>false</code>，比如<code>Button</code>是可点击的，<code>TextView</code>是不可点击的。通过<code>setClickable</code>和<code>setLongClickable</code>可以分别改变<code>View</code>的<code>CLICKABLE</code>和<code>LONG_CLICKABLE</code>属性。另外，<code>setOnClickListener</code>会自动将<code>View</code>的<code>CLICKABLE</code>设为<code>true</code>，s<code>etOnLongClickListener</code>则会自动将<code>View</code>的<code>LONG_CLICKABLE</code>设为<code>true</code>。</p>
<h6 id="处理滑动冲突"><a href="#处理滑动冲突" class="headerlink" title="处理滑动冲突"></a>处理滑动冲突</h6><p>了解了点击事件的处理过程，就可以比较好的处理滑动冲突了</p>
<p>** 父容器拦截处理 **<br>击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截。外部拦截法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">intercepted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN: &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>            <span class="hljs-keyword">if</span> (父容器需要当前点击事件) &#123;<br>                intercepted = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                intercepted = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP: &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastXIntercept = x;<br>    mLastYIntercept = y;<br>    <span class="hljs-keyword">return</span> intercepted;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>针对不同的滑动冲突，只需要修改父容器需要当前点击事件这个条件即可，其他均不需做修改并且也不能修改。这里对上述代码再描述一下，在<code>onInterceptTouchEvent</code>方法中，首先是<code>ACTION_DOWN</code>这个事件，父容器必须返回<code>false</code>，即不拦截<code>ACTION_DOWN</code>事件，这是因为一旦父容器拦截了<code>ACTION_DOWN</code>，那么后续的<code>ACTION_MOVE</code>和<code>ACTION_UP</code>事件都会直接交由父容器处理，这个时候事件没法再传递给子元素了；其次是<code>ACTION_MOVE</code>事件，这个事件可以根据需要来决定是否拦截，如果父容器需要拦截就返回<code>true</code>，否则返回<code>false</code>；最后是<code>ACTION_UP</code>事件，这里必须要返回false，因为<code>ACTION_UP</code>事件本身没有太多意义。假设事件交由子元素处理，如果父容器在<code>ACTION_UP</code>时返回了<code>true</code>，就会导致子元素无法接收到<code>ACTION_UP</code>事件，这个时候子元素中的<code>onClick</code>事件就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交给它来处理，而<code>ACTION_UP</code>作为最后一个事件也必定可以传递给父容器，即便父容器的<code>onInterceptTouchEvent</code>方法在<code>ACTION_UP</code>时返回了<code>false</code>。</p>
<p>** 子元素拦截事件 **<br>父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和Android中的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent()</code>方法才能正常工作，使用起来较外部拦截法稍显复杂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN: &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaX</span> <span class="hljs-operator">=</span> x -mLastX;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> y -mLastY;<br>            <span class="hljs-keyword">if</span> (父容器需要此类点击事件)) &#123;<br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">false</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP: &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    mLastX = x;<br>    mLastY = y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>除了子元素需要做处理以外，父元素也要默认拦截除了<code>ACTION_DOWN</code>以外的其他事件，这样当子元素调用<code>parent.requestDisallowInterceptTouchEvent(false)</code>方法时，父元素才能继续拦截所需的事件。因为<code>ACTION_DOWN</code>事件并不受<code>FLAG_DISALLOW_INTERCEPT</code>这个标记位的控制，所以一旦父容器拦截<code>ACTION_DOWN</code>事件，那么所有的事件都无法传递到子元素中去，这样内部拦截就无法起作用了。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>View的滑动</title>
    <url>/2017/03/15/View%E7%9A%84%E6%BB%91%E5%8A%A8/</url>
    <content><![CDATA[<p>　　View的位置主要由它的四个顶点来决定，分别对应于View的四个属性：top,left,right,bottom,其中top是左上角的纵坐标，left是左上角的横坐标，right是右下角的横坐标，bottom是右下角的纵坐标。需要注意的是，这些坐标都是相当于View的父容器来说的，因此它是一种相对坐标，View的坐标和父容器的关系如下所示：<br><img src="/image/location.png" alt="相对位置关系"></p>
<blockquote>
<p>width &#x3D; right - left<br>height &#x3D; bottom - top<br>left &#x3D; getLeft()<br>right &#x3D; getRight()<br>top &#x3D; getTop()<br>bottom &#x3D; getBottom()<br>从Android3.0 开始，View增加了额外的几个参数：x,y,trabslationX和translationY。其中x和y是View左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。这几个参数也是相对于父容器的坐标，并且translationX和translationY的默认值是0，和View的四个基本的位置参数一样，View也为他们提供了get&#x2F;set方法，这几个参数的换算关系如下<br><code>x = left + translationX</code><br>需要注意的是，View在平移过程中，top和left表示的是原始左上角的位置信息，其值并不会发生改变，此时发生改变的是x,y,translationX和translationY。</p>
</blockquote>
<span id="more"></span>
<h4 id="一-VelocityTracker-和-GestureDetector"><a href="#一-VelocityTracker-和-GestureDetector" class="headerlink" title="一 VelocityTracker 和 GestureDetector"></a>一 VelocityTracker 和 GestureDetector</h4><p>速度最终，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。使用方法在View的onTouchEvent方法中追踪当前单击事件的速度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">VelocityTracker</span> <span class="hljs-variable">velocityTracker</span> <span class="hljs-operator">=</span> VelocityTracker.obtain();<br>velocityTracker.addMovement(event);<br></code></pre></td></tr></table></figure>
<p>接着，当我们想知道当前的滑动速度时，这个时候可以采用如下方式来获得当前速度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">velocityTracker.computeCurrentVelocity(<span class="hljs-number">1000</span>);<br><span class="hljs-type">float</span> <span class="hljs-variable">xVelocity</span> <span class="hljs-operator">=</span> velocityTracker.getXVelocity();<br><span class="hljs-type">float</span> <span class="hljs-variable">yVelocity</span> <span class="hljs-operator">=</span> velocityTracker.getYVelocity();<br></code></pre></td></tr></table></figure>
<p>在这一步中有两点需要注意</p>
<ol>
<li>获取速度之前必须先计算速度，即getXVelocity()和getYVelocity()之前必须调用computeCurrentVelocity(1000)</li>
<li>这里的速度时指一段时间内手指所划过的像素数，速度可以是负数，当手指在水平方向从左向右滑动时，速度为正，反之为负数。<br>最后，当不在使用它的时候，需要调用clear方法来重置并回收内存:<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">velocityTracker.clear();<br>velocityTracker.recycle();<br></code></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。<br>首先创建GestureDetector的对象，接着接管View的onTouchEvent方法。做完下面两部，就可以有选择的实现接口中的方法了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">GestureDetector</span> <span class="hljs-variable">gestureDetector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GestureDetector</span>(<span class="hljs-built_in">this</span>,<span class="hljs-built_in">this</span>);<br>      gestureDetector.setIsLongpressEnabled(<span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">return</span> gestureDetector.onTouchEvent(event);<br></code></pre></td></tr></table></figure>
<p>其中<code>gestureDetector.setIsLongpressEnabled(false)</code>是为了解决长按之后无法拖动的现象。</p>
<h4 id="二-使用ScrollTo-x2F-ScrollBy"><a href="#二-使用ScrollTo-x2F-ScrollBy" class="headerlink" title="二 使用ScrollTo&#x2F;ScrollBy"></a>二 使用ScrollTo&#x2F;ScrollBy</h4><p>调用方式 <code>View.scrollTo(int x, int y)</code>,<code>View.scrollBy(int x, int y)</code><br>方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Set the scrolled position of your view. This will cause a call to</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</span><br><span class="hljs-comment">     * invalidated.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x the x position to scroll to</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y the y position to scroll to</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scrollTo</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        <span class="hljs-keyword">if</span> (mScrollX != x || mScrollY != y) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">oldX</span> <span class="hljs-operator">=</span> mScrollX;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">oldY</span> <span class="hljs-operator">=</span> mScrollY;<br>            mScrollX = x;<br>            mScrollY = y;<br>            invalidateParentCaches();<br>            onScrollChanged(mScrollX, mScrollY, oldX, oldY);<br>            <span class="hljs-keyword">if</span> (!awakenScrollBars()) &#123;<br>                postInvalidateOnAnimation();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Move the scrolled position of your view. This will cause a call to</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> #onScrollChanged(int, int, int, int)&#125; and the view will be</span><br><span class="hljs-comment">     * invalidated.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x the amount of pixels to scroll by horizontally</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> y the amount of pixels to scroll by vertically</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scrollBy</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>        scrollTo(mScrollX + x, mScrollY + y);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>　　从源码中可以看出，<code>scrollBy</code>实际上也是调用<code>scrollBy</code>的方法。需要注意的是在<code>View</code>的滑动过程中，<code>mScrollX</code>和<code>mScrollY</code>的改变规则：<br>在滑动过程中，<code>mScrollX</code>的值总是等于View左边缘和View内容左边缘在水平方向的距离，而mScrollY的值总是等于View上边缘和View内容上边缘在竖直方向的距离。其中<code>mScrollX</code>和<code>mScrollY</code>的单位是像素，并且当View左边缘在View内容左边缘的右边时，<code>mScrollX</code>为正值，反之为负值；当View上边缘在View内容上边缘的下边时，<code>mScrollY</code>为正值，反之为负值。换句话说：从左向右滑动，<code>mScrollX</code>为负值，反之为正值；如果从上往下滑动，<code>mScrollY</code>为负值，反之为正值。<br><strong>意思就是说ScrollTo&#x2F;ScrollBy只能滑动View的内容而不能滑动View本身，比如，只能滑动TextView的文字，而不能滑动TextView控件本身</strong></p>
<h4 id="三-使用动画"><a href="#三-使用动画" class="headerlink" title="三 使用动画"></a>三 使用动画</h4><p>这个没什么好介绍的，想要兼容3.0以下的属性动画，建议使用nineoldandroids来实现</p>
<h4 id="四-改变布局参数"><a href="#四-改变布局参数" class="headerlink" title="四 改变布局参数"></a>四 改变布局参数</h4><p>改变布局参数，也就是改变·LayoutParams·</p>
<h4 id="五-使用Scroller进行平滑移动"><a href="#五-使用Scroller进行平滑移动" class="headerlink" title="五 使用Scroller进行平滑移动"></a>五 使用Scroller进行平滑移动</h4><p>自定义一个控件，添加成员变量·Scroller·，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollerTextView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TextView</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Scroller mScroller;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ScrollerTextView</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context);<br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scroller</span>(context);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ScrollerTextView</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs);<br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scroller</span>(context);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ScrollerTextView</span><span class="hljs-params">(Context context, AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);<br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scroller</span>(context);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">smoothScrollBy</span><span class="hljs-params">(<span class="hljs-type">int</span> dx,<span class="hljs-type">int</span> dy)</span>&#123;<br>        mScroller.startScroll(mScroller.getFinalX(),mScroller.getFinalY(),dx,dy,<span class="hljs-number">2000</span>);<br>        invalidate();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">smoothScrollTo</span><span class="hljs-params">(<span class="hljs-type">int</span> fx, <span class="hljs-type">int</span> fy)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> fx - mScroller.getFinalX();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">dy</span> <span class="hljs-operator">=</span> fy - mScroller.getFinalY();<br>        smoothScrollBy(dx,dy);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">computeScroll</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span>(mScroller.computeScrollOffset())&#123;<br>           scrollTo(mScroller.getCurrX(), mScroller.getCurrY());<br>           postInvalidate();<br>       &#125;<br>        <span class="hljs-built_in">super</span>.computeScroll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实<code>Scroller</code>也是通过<code>ScrollTO/ScrollBy</code>实现的，同样只能滑动内容，不能滑动本身。<br>PS：<br>在调用<code>startScroll</code>时，并没有让<code>View</code>进行滑动。而是在调用<code>invalidate()</code>进行重绘的时候，会去调用<code>computeScroll</code>方法，但是<code>computeScroll</code>在<code>View</code>只是个空实现，因此需要我们自己去实现。在<code>computeScroll</code>中进行平移。也就是说当View重绘后在<code>draw</code>方法中调用<code>computeScroll</code>,而<code>computeScroll</code>又会去向<code>Scroller</code>获取当前的<code>scrollX</code>和<code>scrollY</code>,然后通过<code>scrollTo</code>方法实现滑动，接着又调用<code>postInvalidate()</code>方法来进行第二次重绘，这一次重绘过程和第一次一样，还是会去调用<code>computeScroll()</code>方法，如此反复，直到整个滑动过程结束。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>View绘制过程</title>
    <url>/2018/07/29/View%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>抄的《Android开发艺术探索》第四章<br><code>ViewRoot</code>对应于<code>ViewRootImpl</code>类，它是连接<code>WindowManager</code>和<code>DecorView</code>的纽带，<code>View</code>的三大流程均是通过<code>ViewRoot</code>来完成的。在<code>ActivityThread</code>中，当<code>Activity</code>对象被创建完毕后，会将<code>DecorView</code>添加到<code>Window</code>中，同时会创建<code>ViewRootImpl</code>对象，并将<code>ViewRootImpl</code>对象和<code>DecorView</code>建立关联，<code>View</code>的绘制流程是从<code>ViewRoot</code>的<code>performTraversals</code>方法开始的，它经过<code>measure</code>、<code>layout</code>和<code>draw</code>三个过程才能最终将一个<code>View</code>绘制出来，其中<code>measure</code>用来测量View的宽和高，<code>layout</code>用来确定View在父容器中的放置位置，而<code>draw</code>则负责将View绘制在屏幕上。</p>
<span id="more"></span>
<p><code>performTraversals</code>会依次调用<code>performMeasure</code>、p<code>erformLayout</code>和<code>performDraw</code>三个方法，这三个方法分别完成顶级<code>View</code>的<code>measure</code>、<code>layout</code>和<code>draw</code>这三大流程，其中在<code>performMeasure</code>中会调用<code>measure</code>方法，在<code>measure</code>方法中又会调用<code>onMeasure</code>方法，在<code>onMeasure</code>方法中则会对所有的子元素进行<code>measure</code>过程，这个时候<code>measure</code>流程就从父容器传递到子元素中了，这样就完成了一次<code>measure</code>过程。接着子元素会重复父容器的<code>measure</code>过程，如此反复就完成了整个<code>View</code>树的遍历。同理，<code>performLayout</code>和<code>performDraw</code>的传递流程和<code>performMeasure</code>是类似的，唯一不同的是，<code>performDraw</code>的传递过程是在<code>draw</code>方法中通过<code>dispatchDraw</code>来实现的，不过这并没有本质区别。</p>
<p><code>measure</code>过程决定了<code>View</code>的宽&#x2F;高，<code>Measure</code>完成以后，可以通过<code>getMeasuredWidth</code>和<code>getMeasuredHeight</code>方法来获取到<code>View</code>测量后的宽&#x2F;高，在几乎所有的情况下它都等同于<code>View</code>最终的宽&#x2F;高，但是特殊情况除外，这点在本章后面会进行说明。<code>Layout</code>过程决定了<code>View</code>的四个顶点的坐标和实际的View的宽&#x2F;高，完成以后，可以通过<code>getTop</code>、<code>getBottom</code>、<code>getLeft</code>和<code>getRight</code>来拿到<code>View</code>的四个顶点的位置，并可以通过<code>getWidth</code>和<code>getHeight</code>方法来拿到<code>View</code>的最终宽&#x2F;高。<code>Draw</code>过程则决定了<code>View</code>的显示，只有<code>draw</code>方法完成以后<code>View</code>的内容才能呈现在屏幕上。</p>
<p><code>DecorView</code>作为顶级<code>View</code>，一般情况下它内部会包含一个竖直方向的<code>LinearLayout</code>，在这个<code>LinearLayout</code>里面有上下两个部分（具体情况和Android版本及主题有关），上面是标题栏，下面是内容栏。在<code>Activity</code>中我们通过<code>setContentView</code>所设置的布局文件其实就是被加到内容栏之中的，而内容栏的id是<code>content</code>，因此可以理解为Activity指定布局的方法不叫setview而叫<code>setContentView</code>，因为我们的布局的确加到了<code>id</code>为<code>content</code>的<code>FrameLayout</code>中。如何得到<code>content</code>呢？可以这样：<code>ViewGroup  content=  findViewById(R.android.id.content)</code>。如何得到我们设置的<code>View</code>呢？可以这样：<code>content.getChildAt(0)</code>。同时，通过源码我们可以知道，<code>DecorView</code>其实是一个<code>FrameLayout</code>，<code>View</code>层的事件都先经过<code>DecorView</code>，然后才传递给我们的View。</p>
<h4 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h4><p><code>MeasureSpec</code>在很大程度上决定了一个View的尺寸规格，之所以说是很大程度上是因为这个过程还受父容器的影响，因为父容器影响View的<code>MeasureSpec</code>的创建过程。在测量过程中，系统会将View的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>measureSpec</code>来测量出<code>View</code>的宽&#x2F;高。这里的宽&#x2F;高是测量宽&#x2F;高，不一定等于<code>View</code>的最终宽&#x2F;高。<br><code>MeasureSpec</code>代表一个32位int值，高2位代表<code>SpecMode</code>，低30位代表<code>SpecSize</code>，<code>SpecMode</code>是指测量模式，而<code>SpecSize</code>是指在某种测量模式下的规格大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MODE_SHIFT</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MODE_MASK</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x3</span> &lt;&lt; MODE_SHIFT;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNSPECIFIED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; MODE_SHIFT;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXACTLY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; MODE_SHIFT;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">AT_MOST</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> &lt;&lt; MODE_SHIFT;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">makeMeasureSpec</span><span class="hljs-params">(<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> mode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;<br>        <span class="hljs-keyword">return</span> size + mode;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMode</span><span class="hljs-params">(<span class="hljs-type">int</span> measureSpec)</span> &#123;<br>    <span class="hljs-keyword">return</span> (measureSpec &amp; MODE_MASK);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">(<span class="hljs-type">int</span> measureSpec)</span> &#123;<br>    <span class="hljs-keyword">return</span> (measureSpec &amp; ~MODE_MASK);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>MeasureSpec</code>通过将<code>SpecMode</code>和<code>SpecSize</code>打包成一个int值来避免过多的对象内存分配，为了方便操作，其提供了打包和解包方法。<code>SpecMode</code>和<code>SpecSize</code>也是一个int值，一组<code>SpecMode</code>和<code>SpecSize</code>可以打包为一个<code>MeasureSpec</code>，而一个<code>MeasureSpec</code>可以通过解包的形式来得出其原始的<code>SpecMode</code>和<code>SpecSize</code>，需要注意的是这里提到的<code>MeasureSpec</code>是指<code>MeasureSpec</code>所代表的int值，而并非<code>MeasureSpec</code>本身。<br>SpecMode有三类，每一类都表示特殊的含义，如下所示。<br>** UNSPECIFIED **<br>父容器不对View有任何限制，要多大给多大，这种情况一般用于系统内部，表示一种测量的状态。<br>** EXACTLY **<br>父容器已经检测出View所需要的精确大小，这个时候View的最终大小就是SpecSize所指定的值。它对应于LayoutParams中的match_parent和具体的数值这两种模式。<br>** AT_MOST **<br>父容器指定了一个可用大小即SpecSize，View的大小不能大于这个值，具体是什么值要看不同View的具体实现。它对应于LayoutParams中的wrap_content。</p>
<h6 id="MeasureSpec和LayoutParams"><a href="#MeasureSpec和LayoutParams" class="headerlink" title="MeasureSpec和LayoutParams"></a>MeasureSpec和LayoutParams</h6><p>在View测量的时候，系统会将<code>LayoutParams</code>在父容器的约束下转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来确定View测量后的宽&#x2F;高。需要注意的是，<code>MeasureSpec</code>不是唯一由<code>LayoutParams</code>决定的，<code>LayoutParams</code>需要和父容器一起才能决定<code>View</code>的<code>MeasureSpec</code>，从而进一步决定View的宽&#x2F;高。另外，对于<code>顶级View</code>（即DecorView）和<code>普通View</code>来说，<code>MeasureSpec</code>的转换过程略有不同。对于<code>DecorView</code>，其<code>MeasureSpec</code>由窗口的尺寸和其自身的<code>LayoutParams</code>来共同确定；对于普通View，其<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>来共同决定，<code>MeasureSpec</code>一旦确定后，<code>onMeasure</code>中就可以确定<code>View</code>的测量宽&#x2F;高。<br>对于<code>DecorView</code>来说，在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中有如下一段代码，它展示了<code>DecorView</code>的<code>MeasureSpec</code>的创建过程，其中<code>desiredWindowWidth</code>和<code>desiredWindowHeight</code>是屏幕的尺寸:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth,lp.width);<br>childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight,lp.height);<br>performMeasure(childWidthMeasureSpec,childHeightMeasureSpec);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRootMeasureSpec</span><span class="hljs-params">(<span class="hljs-type">int</span> windowSize,<span class="hljs-type">int</span> rootDimension)</span> &#123;<br>    <span class="hljs-type">int</span> measureSpec;<br>    <span class="hljs-keyword">switch</span> (rootDimension) &#123;<br>        <span class="hljs-keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:<br>            <span class="hljs-comment">// Window can&#x27;t resize. Force root view to be windowSize.</span><br>            measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.EXACTLY);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:<br>            <span class="hljs-comment">// Window can resize. Set max size for root view.</span><br>            measureSpec = MeasureSpec.makeMeasureSpec(windowSize,MeasureSpec.AT_MOST);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-comment">// Window wants to be an exact size. Force root view to be that size.</span><br>            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension,Measure-Spec.EXACTLY);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> measureSpec;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过上述代码，<code>DecorView</code>的<code>MeasureSpec</code>的产生过程就很明确了，具体来说其遵守如下规则，根据它的<code>LayoutParams</code>中的宽&#x2F;高的参数来划分。</p>
<ul>
<li>LayoutParams.MATCH_PARENT：精确模式，大小就是窗口的大小；</li>
<li>LayoutParams.WRAP_CONTENT：最大模式，大小不定，但是不能超过窗口的大小；</li>
<li>固定大小（比如100dp）：精确模式，大小为LayoutParams中指定的大小。<br>对于普通<code>View</code>来说，这里是指我们布局中的<code>View</code>，<code>View</code>的<code>measure</code>过程由<code>ViewGroup</code>传递而来，先看一下<code>ViewGroup</code>的<code>measureChildWithMargins</code>方法：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChildWithMargins</span><span class="hljs-params">(View child,<span class="hljs-type">int</span> parentWidthMeasureSpec,<span class="hljs-type">int</span> widthUsed,<span class="hljs-type">int</span> parentHeightMeasureSpec,<span class="hljs-type">int</span> heightUsed)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MarginLayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> (MarginLayoutParams) child.getLayout-Params();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childWidthMeasureSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(parentWidthMeasureSpec,mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin+ widthUsed,lp.width);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childHeightMeasureSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(parentHeight-MeasureSpec,mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin+ heightUsed,lp.height);<br>    child.measure(childWidthMeasureSpec,childHeightMeasureSpec);<br>&#125;<br></code></pre></td></tr></table></figure>
上述方法会对子元素进行<code>measure</code>，在调用子元素的<code>measure</code>方法之前会先通过<code>getChildMeasureSpec</code>方法来得到子元素的<code>MeasureSpec</code>。从代码来看，很显然，子元素的<code>MeasureSpec</code>的创建与父容器的<code>MeasureSpec</code>和子元素本身的<code>LayoutParam</code>s有关，此外还和<code>View</code>的<code>margin</code>及<code>padding</code>有关，具体情况可以看一下<code>ViewGroup</code>的<code>getChildMeasureSpec</code>方法，如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getChildMeasureSpec</span><span class="hljs-params">(<span class="hljs-type">int</span> spec,<span class="hljs-type">int</span> padding,<span class="hljs-type">int</span> child-Dimension)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(spec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(spec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>,specSize -padding);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">resultSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">resultMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>        <span class="hljs-comment">// Parent has imposed an exact size on us</span><br>        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>            <span class="hljs-keyword">if</span> (childDimension =&gt; <span class="hljs-number">0</span>) &#123;<br>                resultSize = childDimension;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>                <span class="hljs-comment">// Child wants to be our size. So be it.</span><br>                resultSize = size;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>                <span class="hljs-comment">// Child wants to determine its own size. It can&#x27;t be</span><br>                <span class="hljs-comment">// bigger than us.</span><br>                resultSize = size;<br>                resultMode = MeasureSpec.AT_MOST;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// Parent has imposed a maximum size on us</span><br>        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>            <span class="hljs-keyword">if</span> (childDimension =&gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// Child wants a specific size... so be it</span><br>                resultSize = childDimension;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>                <span class="hljs-comment">// Child wants to be our size,but our size is not fixed.</span><br>                <span class="hljs-comment">// Constrain child to not be bigger than us.</span><br>                resultSize = size;<br>                resultMode = MeasureSpec.AT_MOST;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>                <span class="hljs-comment">// Child wants to determine its own size. It can&#x27;t be</span><br>                <span class="hljs-comment">// bigger than us.</span><br>                resultSize = size;<br>                resultMode = MeasureSpec.AT_MOST;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">// Parent asked to see how big we want to be</span><br>        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>            <span class="hljs-keyword">if</span> (childDimension =&gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// Child wants a specific size... let him have it</span><br>                resultSize = childDimension;<br>                resultMode = MeasureSpec.EXACTLY;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<br>                <span class="hljs-comment">// Child wants to be our size... find out how big it should</span><br>                <span class="hljs-comment">// be</span><br>                resultSize = <span class="hljs-number">0</span>;<br>                resultMode = MeasureSpec.UNSPECIFIED;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<br>                <span class="hljs-comment">// Child wants to determine its own size.... find out how</span><br>                <span class="hljs-comment">// big it should be</span><br>                resultSize = <span class="hljs-number">0</span>;<br>                resultMode = MeasureSpec.UNSPECIFIED;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize,resultMode);<br>&#125;<br></code></pre></td></tr></table></figure>
它的主要作用是根据父容器的<code>MeasureSpec</code>同时结合View本身的<code>LayoutParams</code>来确定子元素的<code>MeasureSpec</code>，参数中的<code>padding</code>是指父容器中已占用的空间大小，因此子元素可用的大小为父容器的尺寸减去<code>padding</code>，具体代码如下所示:<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">specSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(spec);<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>,specSize -padding);<br></code></pre></td></tr></table></figure>
这里简单说一下，当View采用固定宽&#x2F;高的时候，不管父容器的<code>MeasureSpec</code>是什么，<code>View</code>的<code>MeasureSpec</code>都是精确模式并且其大小遵循<code>Layoutparams</code>中的大小。当<code>View</code>的宽&#x2F;高是<code>match_parent</code>时，如果父容器的模式是精准模式，那么<code>View</code>也是精准模式并且其大小是父容器的剩余空间；如果父容器是最大模式，那么<code>View</code>也是最大模式并且其大小不会超过父容器的剩余空间。当<code>View</code>的宽&#x2F;高是<code>wrap_content</code>时，不管父容器的模式是精准还是最大化，<code>View</code>的模式总是最大化并且大小不能超过父容器的剩余空间。在我们的分析中漏掉了<code>UNSPECIFIED</code>模式，那是因为这个模式主要用于系统内部多次Measure的情形，一般来说，我们不需要关注此模式。</li>
</ul>
<h4 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a>View的工作流程</h4><h5 id="measure过程"><a href="#measure过程" class="headerlink" title="measure过程"></a>measure过程</h5><p>measure过程要分情况来看，如果只是一个原始的<code>View</code>，那么通过<code>measure</code>方法就完成了其测量过程，如果是一个<code>ViewGroup</code>，除了完成自己的测量过程外，还会遍历去调用所有子元素的<code>measure</code>方法，各个子元素再递归去执行这个流程。<br>** View的measure过程 **<br><code>View</code>的<code>measure</code>过程由其<code>measure</code>方法来完成，<code>measure</code>方法是一个<code>final</code>类型的方法，这意味着子类不能重写此方法，在<code>View</code>的<code>measure</code>方法中会去调用<code>View</code>的<code>onMeasure</code>方法，因此只需要看<code>onMeasure</code>的实现即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec,<span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(),widthMeasureSpec),getDefaultSize(getSuggestedMinimumHeight(),heightMeasureSpec));<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDefaultSize</span><span class="hljs-params">(<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> measureSpec)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(measureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(measureSpec);<br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>            result = size;<br>        <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>            result = specSize;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出，<code>getDefaultSize</code>这个方法的逻辑很简单，对于我们来说，我们只需要看<code>AT_MOST</code>和<code>EXACTLY</code>这两种情况。简单地理解，其实<code>getDefaultSize</code>返回的大小就是<code>measureSpec</code>中的<code>specSize</code>，而这个<code>specSize</code>就是<code>View</code>测量后的大小，这里多次提到测量后的大小，是因为<code>View</code>最终的大小是在<code>layout</code>阶段确定的，所以这里必须要加以区分，但是几乎所有情况下<code>View</code>的测量大小和最终大小是相等的。<br>至于<code>UNSPECIFIED</code>这种情况，一般用于系统内部的测量过程，在这种情况下，<code>View</code>的大小为<code>getDefaultSize</code>的第一个参数<code>size</code>，即宽&#x2F;高分别为<code>getSuggestedMinimumWidth</code>和<code>getSuggestedMinimumHeight</code>这两个方法的返回值，看一下它们的源码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSuggestedMinimumWidth</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (mBackground == <span class="hljs-literal">null</span>) ? mMinWidth : max(mMinWidth,mBackground.getMinimumWidth());<br>&#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSuggestedMinimumHeight</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (mBackground == <span class="hljs-literal">null</span>) ? mMinHeight : max(mMinHeight,mBackground.getMinimumHeight());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里只分析<code>getSuggestedMinimumWidth</code>方法的实现，<code>getSuggestedMinimumHeight</code>和它的实现原理是一样的。从<code>getSuggestedMinimumWidth</code>的代码可以看出，如果<code>View</code>没有设置背景，那么<code>View</code>的宽度为<code>mMinWidth</code>，而<code>mMinWidth</code>对应于<code>android:minWidth</code>这个属性所指定的值，因此<code>View</code>的宽度即为<code>android:minWidth</code>属性所指定的值。这个属性如果不指定，那么<code>mMinWidth</code>则默认为0；如果<code>View</code>指定了背景，则<code>View</code>的宽度为<code>max(mMinWidth,mBackground.getMinimumWidth())</code>。<code>mMinWidth</code>的含义我们已经知道了，那么<code>mBackground.getMinimumWidth()</code>是什么呢？我们看一下<code>Drawable</code>的<code>getMinimumWidth</code>方法，如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMinimumWidth</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">intrinsicWidth</span> <span class="hljs-operator">=</span> getIntrinsicWidth();<br>    <span class="hljs-keyword">return</span> intrinsicWidth &gt; <span class="hljs-number">0</span> ? intrinsicWidth : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看出，<code>getMinimumWidth</code>返回的就是<code>Drawable</code>的原始宽度，前提是这个<code>Drawable</code>有原始宽度，否则就返回0。<br>这里再总结一下<code>getSuggestedMinimumWidth</code>的逻辑：如果<code>View</code>没有设置背景，那么返回<code>android:minWidth</code>这个属性所指定的值，这个值可以为0；如果<code>View</code>设置了背景，则返回<code>android:minWidth</code>和背景的最小宽度这两者中的最大值，<code>getSuggestedMinimumWidth</code>和<code>getSuggestedMinimumHeight</code>的返回值就是<code>View</code>在<code>UNSPECIFIED</code>情况下的测量宽&#x2F;高。<br>从<code>getDefaultSize</code>方法的实现来看，<code>View</code>的宽&#x2F;高由<code>specSize</code>决定，所以我们可以得出如下结论：直接继承<code>View</code>的自定义控件需要重写<code>onMeasure</code>方法并设置<code>wrap_content</code>时的自身大小，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。<br>从上述代码中我们知道，如果<code>View</code>在布局中使用<code>wrap_content</code>，那么它的<code>specMode</code>是<code>AT_MOST</code>模式，在这种模式下，它的宽&#x2F;高等于<code>specSize</code>；这种情况下<code>View</code>的<code>specSize</code>是p<code>arentSize</code>，而<code>parentSize</code>是父容器中目前可以使用的大小，也就是父容器当前剩余的空间大小。很显然，<code>View</code>的宽&#x2F;高就等于父容器当前剩余的空间大小，这种效果和在布局中使用<code>match_parent</code>完全一致。如何解决这个问题呢？也很简单，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec,<span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onMeasure(widthMeasureSpec,heightMeasureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">widthSpecMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(widthMeasureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">widthSpecSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(widthMeasureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">heightSpecMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(heightMeasureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">heightSpecSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(heightMeasureSpec);<br>    <span class="hljs-keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123;<br>        setMeasuredDimension(mWidth,mHeight);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (widthSpecMode == MeasureSpec.AT_MOST) &#123;<br>        setMeasuredDimension(mWidth,heightSpecSize);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heightSpecMode == MeasureSpec.AT_MOST) &#123;<br>        setMeasuredDimension(widthSpecSize,mHeight);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，我们只需要给<code>View</code>指定一个默认的内部宽&#x2F;高（<code>mWidth</code>和<code>mHeight</code>），并在<code>wrap_content</code>时设置此宽&#x2F;高即可。对于非<code>wrap_content</code>情形，我们沿用系统的测量值即可，至于这个默认的内部宽&#x2F;高的大小如何指定，这个没有固定的依据，根据需要灵活指定即可。如果查看<code>TextView</code>、<code>ImageView</code>等的源码就可以知道，针对<code>wrap_content</code>情形，它们的<code>onMeasure</code>方法均做了特殊处理。</p>
<p>** ViewGroup的measure过程 **<br>对于<code>ViewGroup</code>来说，除了完成自己的<code>measure</code>过程以外，还会遍历去调用所有子元素的<code>measure</code>方法，各个子元素再递归去执行这个过程。和<code>View</code>不同的是，<code>ViewGroup</code>是一个抽象类，因此它没有重写<code>View</code>的<code>onMeasure</code>方法，但是它提供了一个叫<code>measureChildren</code>的方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChildren</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec,<span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mChildrenCount;<br>    <span class="hljs-keyword">final</span> View[] children = mChildren;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> children[i];<br>        <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;<br>            measureChild(child,widthMeasureSpec,heightMeasureSpec);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上述代码来看，<code>ViewGroup</code>在<code>measure</code>时，会对每一个子元素进行<code>measure</code>，<code>measureChild</code>这个方法的实现也很好理解，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChild</span><span class="hljs-params">(View child,<span class="hljs-type">int</span> parentWidthMeasureSpec,<span class="hljs-type">int</span> parentHeightMeasureSpec)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span> child.getLayoutParams();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childWidthMeasureSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(parentWidth-MeasureSpec,mPaddingLeft + mPaddingRight,lp.width);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childHeightMeasureSpec</span> <span class="hljs-operator">=</span> getChildMeasureSpec(parentHeight-MeasureSpec,mPaddingTop + mPaddingBottom,lp.height);<br>    child.measure(childWidthMeasureSpec,childHeightMeasureSpec);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>很显然，<code>measureChild</code>的思想就是取出子元素的<code>LayoutParams</code>，然后再通过<code>getChildMeasureSpec</code>来创建子元素的<code>MeasureSpec</code>，接着将<code>MeasureSpec</code>直接传递给<code>View</code>的<code>measure</code>方法来进行测量。我们知道，<code>ViewGroup</code>并没有定义其测量的具体过程，这是因为<code>ViewGroup</code>是一个抽象类，其测量过程的<code>onMeasure</code>方法需要各个子类去具体实现，比如<code>LinearLayout</code>、<code>RelativeLayout</code>等。</p>
<h5 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h5><p><code>Layout</code>的作用是<code>ViewGroup</code>用来确定子元素的位置，当<code>ViewGroup</code>的位置被确定后，它在<code>onLayout</code>中会遍历所有的子元素并调用其<code>layout</code>方法，在<code>layout</code>方法中<code>onLayout</code>方法又会被调用。<code>Layout</code>过程和<code>measure</code>过程相比就简单多了，<code>layout</code>方法确定<code>View</code>本身的位置，而<code>onLayout</code>方法则会确定所有子元素的位置，先看<code>View</code>的<code>layout</code>方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">layout</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> t,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="hljs-number">0</span>) &#123;<br>        onMeasure(mOldWidthMeasureSpec,mOldHeightMeasureSpec);<br>        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldL</span> <span class="hljs-operator">=</span> mLeft;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldT</span> <span class="hljs-operator">=</span> mTop;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldB</span> <span class="hljs-operator">=</span> mBottom;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldR</span> <span class="hljs-operator">=</span> mRight;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">changed</span> <span class="hljs-operator">=</span> isLayoutModeOptical(mParent) ?setOpticalFrame(l,t,r,b) : setFrame(l,t,r,b);<br>    <span class="hljs-keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;<br>        onLayout(changed,l,t,r,b);<br>        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;<br>        <span class="hljs-type">ListenerInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> mListenerInfo;<br>        <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="hljs-literal">null</span>) &#123;<br>            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =(ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayout-ChangeListeners.clone();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">numListeners</span> <span class="hljs-operator">=</span> listenersCopy.size();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numListeners; ++i) &#123;<br>                listenersCopy.get(i).onLayoutChange(<span class="hljs-built_in">this</span>,l,t,r,b,oldL,oldT,oldR,oldB);<br>            &#125;<br>        &#125;<br>    &#125;<br>    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;<br>    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>layout</code>方法的大致流程如下：首先会通过<code>setFrame</code>方法来设定<code>View</code>的四个顶点的位置，即初始化<code>mLeft</code>、<code>mRight</code>、<code>mTop</code>和<code>mBottom</code>这四个值，<code>View</code>的四个顶点一旦确定，那么<code>View</code>在父容器中的位置也就确定了；接着会调用<code>onLayout</code>方法，这个方法的用途是父容器确定子元素的位置，和<code>onMeasure</code>方法类似，<code>onLayout</code>的具体实现同样和具体的布局有关，所以<code>View</code>和<code>ViewGroup</code>均没有真正实现<code>onLayout</code>方法。接下来，我们可以看一下<code>LinearLayout</code>的<code>onLayout</code>方法，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLayout</span><span class="hljs-params">(<span class="hljs-type">boolean</span> changed,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> t,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">if</span> (mOrientation == VERTICAL) &#123;<br>        layoutVertical(l,t,r,b);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        layoutHorizontal(l,t,r,b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>LinearLayout</code>中<code>onLayout</code>的实现逻辑和<code>onMeasure</code>的实现逻辑类似，这里选择<code>layoutVertical</code>继续讲解，为了更好地理解其逻辑，这里只给出了主要的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">layoutVertical</span><span class="hljs-params">(<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> top,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> bottom)</span> &#123;<br>    ......<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> getVirtualChildCount();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> getVirtualChildAt(i);<br>        <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span>) &#123;<br>            childTop += measureNullChild(i);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child.getVisibility() != GONE) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childWidth</span> <span class="hljs-operator">=</span> child.getMeasuredWidth();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childHeight</span> <span class="hljs-operator">=</span> child.getMeasuredHeight();<br>            <span class="hljs-keyword">final</span> LinearLayout.<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">lp</span> <span class="hljs-operator">=</span>(LinearLayout.LayoutParams) child.getLayoutParams();<br>            ......<br>            <span class="hljs-keyword">if</span> (hasDividerBeforeChildAt(i)) &#123;<br>                childTop += mDividerHeight;<br>            &#125;<br>            childTop += lp.topMargin;<br>            setChildFrame(child,childLeft,childTop + getLocationOffset(child),childWidth,childHeight);<br>            childTop += childHeight + lp.bottomMargin + getNextLocation-Offset(child);<br>            i += getChildrenSkipCount(child,i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里分析一下<code>layoutVertical</code>的代码逻辑，可以看到，此方法会遍历所有子元素并调用<code>setChildFrame</code>方法来为子元素指定对应的位置，其中<code>childTop</code>会逐渐增大，这就意味着后面的子元素会被放置在靠下的位置，这刚好符合竖直方向的<code>LinearLayout</code>的特性。至于<code>setChildFrame</code>，它仅仅是调用子元素的<code>layout</code>方法而已，这样父元素在<code>layout</code>方法中完成自己的定位以后，就通过<code>onLayout</code>方法去调用子元素的<code>layout</code>方法，子元素又会通过自己的<code>layout</code>方法来确定自己的位置，这样一层一层地传递下去就完成了整个<code>View</code>树的<code>layout</code>过程。<code>setChildFrame</code>方法的实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setChildFrame</span><span class="hljs-params">(View child,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> top,<span class="hljs-type">int</span> width,<span class="hljs-type">int</span> height)</span> &#123;<br>    child.layout(left,top,left + width,top + height);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们注意到，setChildFrame中的width和height实际上就是子元素的测量宽&#x2F;高，从下面的代码可以看出这一点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childWidth</span> <span class="hljs-operator">=</span> child.getMeasuredWidth();<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">childHeight</span> <span class="hljs-operator">=</span> child.getMeasuredHeight();<br>setChildFrame(child,childLeft,childTop + getLocationOffset(child),childWidth,childHeight);<br></code></pre></td></tr></table></figure>

<p>而在<code>layout</code>方法中会通过<code>setFrame</code>去设置子元素的四个顶点的位置，在<code>setFrame</code>中有如下几句赋值语句，这样一来子元素的位置就确定了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">mLeft = left;<br>mTop = top;<br>mRight = right;<br>mBottom = bottom;<br></code></pre></td></tr></table></figure>
<p><code>View</code>的测量宽&#x2F;高和最终&#x2F;宽高有什么区别？这个问题可以具体为：<code>View</code>的<code>getMeasuredWidth</code>和<code>getWidth</code>这两个方法有什么区别，至于<code>getMeasuredHeight</code>和<code>getHeight</code>的区别和前两者完全一样。为了回答这个问题，首先，我们看一下getwidth和getHeight这两个方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getWidth</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> mRight -mLeft;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> mBottom -mTop;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从<code>getWidth</code>和<code>getHeight</code>的源码再结合<code>mLeft</code>、<code>mRight</code>、<code>mTop</code>和<code>mBottom</code>这四个变量的赋值过程来看，<code>getWidth</code>方法的返回值刚好就是<code>View</code>的测量宽度，而<code>getHeight</code>方法的返回值也刚好就是<code>View</code>的测量高度。经过上述分析，现在我们可以回答这个问题了：在<code>View</code>的默认实现中，<code>View</code>的测量宽&#x2F;高和最终宽&#x2F;高是相等的，只不过测量宽&#x2F;高形成于<code>View</code>的<code>measure</code>过程，而最终宽&#x2F;高形成于<code>View</code>的<code>layout</code>过程，即两者的赋值时机不同，测量宽&#x2F;高的赋值时机稍微早一些。因此，在日常开发中，我们可以认为<code>View</code>的<code>测量宽/高</code>就<code>等于``最终宽/高</code>，但是的确存在某些特殊情况会导致两者不一致.</p>
<h5 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a>draw过程</h5><p>Draw过程就比较简单了，它的作用是将View绘制到屏幕上面。View的绘制过程遵循<br>如下几步：</p>
<ul>
<li>绘制背景background.draw(canvas)。</li>
<li>绘制自己（onDraw）。</li>
<li>绘制children（dispatchDraw）。</li>
<li>绘制装饰（onDrawScrollBars）。<br>这一点通过draw方法的源码可以明显看出来，如下所示。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">privateFlags</span> <span class="hljs-operator">=</span> mPrivateFlags;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">dirtyOpaque</span> <span class="hljs-operator">=</span> (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;(mAttachInfo == <span class="hljs-literal">null</span> || !mAttachInfo.mIgnoreDirtyState);<br>    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Draw traversal performs several drawing steps which must be executed</span><br><span class="hljs-comment">    * in the appropriate order:</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * 1. Draw the background</span><br><span class="hljs-comment">    * 2. If necessary,save the canvas&#x27; layers to prepare for fading</span><br><span class="hljs-comment">    * 3. Draw view&#x27;s content</span><br><span class="hljs-comment">    * 4. Draw children</span><br><span class="hljs-comment">    * 5. If necessary,draw the fading edges and restore layers</span><br><span class="hljs-comment">    * 6. Draw decorations (scrollbars for instance)</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// Step 1,draw the background,if needed</span><br>    <span class="hljs-type">int</span> saveCount;<br>    <span class="hljs-keyword">if</span> (!dirtyOpaque) &#123;<br>        drawBackground(canvas);<br>    &#125;<br>    <span class="hljs-comment">// skip step 2 &amp; 5 if possible (common case)</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">viewFlags</span> <span class="hljs-operator">=</span> mViewFlags;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">horizontalEdges</span> <span class="hljs-operator">=</span> (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">verticalEdges</span> <span class="hljs-operator">=</span> (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;<br>        <span class="hljs-comment">// Step 3,draw the content</span><br>        <span class="hljs-keyword">if</span> (!dirtyOpaque) onDraw(canvas);<br>            <span class="hljs-comment">// Step 4,draw the children</span><br>        dispatchDraw(canvas);<br>        <span class="hljs-comment">// Step 6,draw decorations (scrollbars)</span><br>        onDrawScrollBars(canvas);<br>        <span class="hljs-keyword">if</span> (mOverlay != <span class="hljs-literal">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;<br>            mOverlay.getOverlayView().dispatchDraw(canvas);<br>        &#125;<br>        <span class="hljs-comment">// we&#x27;re done...</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>View绘制过程的传递是通过dispatchDraw来实现的，dispatchDraw会遍历调用所有子元素的draw方法，如此draw事件就一层层地传递了下去。View有一个特殊的方法setWillNotDraw，先看一下它的源码，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* If this view doesn&#x27;t do any drawing on its own,set this flag to</span><br><span class="hljs-comment">* allow further optimizations. By default,this flag is not set on</span><br><span class="hljs-comment">* View,but could be set on some View subclasses such as ViewGroup.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* Typically,if you override &#123;<span class="hljs-doctag">@link</span> #onDraw(android.graphics.Canvas)&#125;</span><br><span class="hljs-comment">* you should clear this flag.</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> willNotDraw whether or not this View draw on its own</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWillNotDraw</span><span class="hljs-params">(<span class="hljs-type">boolean</span> willNotDraw)</span> &#123;<br>    setFlags(willNotDraw ? WILL_NOT_DRAW : <span class="hljs-number">0</span>,DRAW_MASK);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从<code>setWillNotDraw</code>这个方法的注释中可以看出，如果一个<code>View</code>不需要绘制任何内容，那么设置这个标记位为<code>true</code>以后，系统会进行相应的优化。默认情况下，<code>View</code>没有启用这个优化标记位，但是<code>ViewGroup</code>会默认启用这个优化标记位。这个标记位对实际开发的意义是：当我们的自定义控件继承于<code>ViewGroup</code>并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。当然，当明确知道一个<code>ViewGroup</code>需要通过<code>onDraw</code>来绘制内容时，我们需要显式地关闭<code>WILL_NOT_DRAW</code>这个标记位。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Window和WindowManager</title>
    <url>/2017/03/21/Window%E5%92%8CWindowManager/</url>
    <content><![CDATA[<p>　　Window表示一个窗口的概念，在日常开发中直接接触WIndow的机会并不对，再试在某些特殊时候我们需要在桌面上显示一个类似悬浮窗的东西，那么这种效果就需要用到Window来实现。<br>　　Window只是个抽象类，它的具体实现是PhoneWindow。创建一个Window是很简单的事，只需要通过WindowManager即可完成，WindowManager是外界访问Window的入口，Window的具体实现位于WindowMangerService中，WindowMnager和WWindowMangerService的交互是一个IPC过程，Android中所有的视图都是通过Window来呈现的，不管是Activity、Dialog还是Toast，它们的视图实际上都是附加在Window上的，因此Window实际是View的直接管理者。</p>
<span id="more"></span>
<h3 id="Window的内部机制"><a href="#Window的内部机制" class="headerlink" title="Window的内部机制"></a>Window的内部机制</h3><p>　　Window是一个抽象的概念，每一个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系，因此Window并不是实际存在的，它是以View的形式存在，。这点从WindowManager的定义也可以看出，它提供的三个接口方法addView,updateViewLayout以及removeView都是针对View，这说明View才是Window存在的实体。在实际使用中无法直接访问Window，对Window的访问必须通过WindowManger。</p>
<h4 id="Window的添加过程"><a href="#Window的添加过程" class="headerlink" title="Window的添加过程"></a>Window的添加过程</h4><p>　　Window的添加过程需要通过WindowManager的addView来实现，WindowManager是一个接口，它的真正实现是WindowManagerImpl类，在WindowManagerImpl中Window的三大操作实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addView</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View view, <span class="hljs-meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;<br>       applyDefaultToken(params);<br>       mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);<br>   &#125;<br>   <br><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateViewLayout</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View view, <span class="hljs-meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;<br>       applyDefaultToken(params);<br>       mGlobal.updateViewLayout(view, params);<br>   &#125;<br><br><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeView</span><span class="hljs-params">(View view)</span> &#123;<br>       mGlobal.removeView(view, <span class="hljs-literal">false</span>);<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeViewImmediate</span><span class="hljs-params">(View view)</span> &#123;<br>       mGlobal.removeView(view, <span class="hljs-literal">true</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>　　WindowManagerImpl并没有直接实现Window的三大操作，而是全部交给了WindowManagerGlobal来处理，WindowManagerGlobal以工厂的形式向外提供自己的实现，WindowManagerImpl这种工作模式是典型的桥接模式，将所有的操作全部委托给WindowManagerGlobal来实现。在WindowManagerGlobal的addView方法主要分为如下几步：</p>
<ol>
<li><strong>检查参数是否合法，如果是子Window，那么还需要调整一些布局参数。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addView</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params,</span><br><span class="hljs-params">           Display display, Window parentWindow)</span> &#123;<br>       <span class="hljs-keyword">if</span> (view == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;view must not be null&quot;</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (display == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;display must not be null&quot;</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (!(params <span class="hljs-keyword">instanceof</span> WindowManager.LayoutParams)) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Params must be WindowManager.LayoutParams&quot;</span>);<br>       &#125;<br><br>       <span class="hljs-keyword">final</span> WindowManager.<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">wparams</span> <span class="hljs-operator">=</span> (WindowManager.LayoutParams) params;<br>       <span class="hljs-keyword">if</span> (parentWindow != <span class="hljs-literal">null</span>) &#123;<br>           parentWindow.adjustLayoutParamsForSubWindow(wparams);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">// If there&#x27;s no parent, then hardware acceleration for this view is</span><br>           <span class="hljs-comment">// set from the application&#x27;s hardware acceleration setting.</span><br>           <span class="hljs-keyword">final</span> <span class="hljs-type">Context</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> view.getContext();<br>           <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span><br>                   &amp;&amp; (context.getApplicationInfo().flags<br>                           &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="hljs-number">0</span>) &#123;<br>               wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;<br>           &#125;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>创建ViewRootImpl并将View添加到列表中。</strong><br>在WindowManagerGlobal内部有如下几个列表比较重要：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;View&gt;();<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ViewRootImpl&gt;();<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =<br>           <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;WindowManager.LayoutParams&gt;();<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArraySet</span>&lt;View&gt;();<br></code></pre></td></tr></table></figure>
<p>　　在以上声明中，mView存储的是多有WIndow所对应的View,mRoots存储的是所有Window所对应的ViewRootImpl，mParams存储的是所有Window所对应的布局参数，而mDyingView则存储了那些正在被删除的View对象，或者说是那些已经调用removeView方法但是删除操作还未完成的Window对象，在addView中通过如下方式将Window的一系列对象添加到列表中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewRootImpl</span>(view.getContext(), display);<br>   view.setLayoutParams(wparams);<br>   mViews.add(view);<br>   mRoots.add(root);<br>   mParams.add(wparams);<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong>通过ViewRootImpl来更新界面并完成Window的添加过程。</strong><br>这个过程由ViewRootImpl的setView方法来完成：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// do this last because it fires off messages to start doing things</span><br>       <span class="hljs-keyword">try</span> &#123;<br>           root.setView(view, wparams, panelParentView);<br>       &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;<br>           <span class="hljs-comment">// BadTokenException or InvalidDisplayException, clean up.</span><br>           <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>               <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> findViewLocked(view, <span class="hljs-literal">false</span>);<br>               <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                   removeViewLocked(index, <span class="hljs-literal">true</span>);<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">throw</span> e;<br>       &#125;<br></code></pre></td></tr></table></figure>
在setView内部会通过requestLayout来完成异步刷新请求。在下面的代码中，scheduleTraversals实际是View绘制的入口：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestLayout</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;<br>           checkThread();<br>           mLayoutRequested = <span class="hljs-literal">true</span>;<br>           scheduleTraversals();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
接着会通过WindowSession最终来完成Window的添加过程。<h4 id="Window的删除过程"><a href="#Window的删除过程" class="headerlink" title="Window的删除过程"></a>Window的删除过程</h4>Window的删除过程和添加过程一样，都是先通过WindowManagerImpl后，再进一步通过WindowManagerGlobal来实现的，如下：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeView</span><span class="hljs-params">(View view, <span class="hljs-type">boolean</span> immediate)</span> &#123;<br>        <span class="hljs-keyword">if</span> (view == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;view must not be null&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> findViewLocked(view, <span class="hljs-literal">true</span>);<br>            <span class="hljs-type">View</span> <span class="hljs-variable">curView</span> <span class="hljs-operator">=</span> mRoots.get(index).getView();<br>            removeViewLocked(index, immediate);<br>            <span class="hljs-keyword">if</span> (curView == view) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Calling with view &quot;</span> + view<br>                    + <span class="hljs-string">&quot; but the ViewAncestor is attached to &quot;</span> + curView);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
　　removeView的逻辑很清晰，首先通过findViewLocked来查找待删除的View的索引，这个查找过程就是建立的数据遍历，然后再通过调用removeViewLocked来做进一步的删除，如下：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeViewLocked</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">boolean</span> immediate)</span> &#123;<br>        <span class="hljs-type">ViewRootImpl</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> mRoots.get(index);<br>        <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> root.getView();<br><br>        <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">InputMethodManager</span> <span class="hljs-variable">imm</span> <span class="hljs-operator">=</span> InputMethodManager.getInstance();<br>            <span class="hljs-keyword">if</span> (imm != <span class="hljs-literal">null</span>) &#123;<br>                imm.windowDismissed(mViews.get(index).getWindowToken());<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">deferred</span> <span class="hljs-operator">=</span> root.die(immediate);<br>        <span class="hljs-keyword">if</span> (view != <span class="hljs-literal">null</span>) &#123;<br>            view.assignParent(<span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (deferred) &#123;<br>                mDyingViews.add(view);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
　　removeViewLocked是通过ViewRootImpl来完成删除操作的，在WindowManager中提供了两种删除接口removeView和removeViewImmediate,它们分别表示异步删除和同步删除，一般不需要使用removeViewImmediate这个方法。这里主要说异步删除的情况：具体的删除操作由ViewRootImpl的die方法来完成，在异步删除的情况下，die方法只是发送了一个请求删除的消息后就立刻返回了，<strong>这个时候View并没有完成删除操作</strong>，所以最后会将其添加到mDyingView中。ViewRootImpl的die方法如下：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">die</span><span class="hljs-params">(<span class="hljs-type">boolean</span> immediate)</span> &#123;<br>   <span class="hljs-comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span><br>   <span class="hljs-comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span><br>   <span class="hljs-keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;<br>       doDie();<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (!mIsDrawing) &#123;<br>       destroyHardwareRenderer();<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>       Log.e(mTag, <span class="hljs-string">&quot;Attempting to destroy the window while drawing!\n&quot;</span> +<br>               <span class="hljs-string">&quot;  window=&quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot;, title=&quot;</span> + mWindowAttributes.getTitle());<br>   &#125;<br>   mHandler.sendEmptyMessage(MSG_DIE);<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
　　在die方法中只是做了简单的判断，如果是异步删除，那么就发送一个MSG_DIE的消息，ViewRootImpl中的Handler会处理此消息并调用doDie方法，如果是同步删除，那么就不发送消息直接调用doDie方法。在doDie内部会调用dispatchDetachedFromWindow方法，真正删除View的逻辑在dispatchDetachedFromWindow方法内部实现。dispatchDetachedFromWindow方法主要做四件事：</li>
<li>垃圾回收相关的工作，比如清除数据和消息，移除回调等。</li>
<li>通过Session的remove方法删除Window：mWindowSession.remove(mWindow)，这同样是一个IPC过程，最终会调用WindowManagerService的removeWindow方法。</li>
<li>调用View的dispatchDetachedFromWindow方法，在内部会调用View的onDetachedFromWindow以及onDetachedFromWindowInternal()。</li>
<li>调用WindowManagerGlobal的doRemoveView方法刷新数据，包括mRoots、mParams以及mDyingViews，需要将当前Window锁关联的这三类对象从列表中删除。<h4 id="Window的更新过程"><a href="#Window的更新过程" class="headerlink" title="Window的更新过程"></a>Window的更新过程</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateViewLayout</span><span class="hljs-params">(View view, ViewGroup.LayoutParams params)</span> &#123;<br>       <span class="hljs-keyword">if</span> (view == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;view must not be null&quot;</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (!(params <span class="hljs-keyword">instanceof</span> WindowManager.LayoutParams)) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Params must be WindowManager.LayoutParams&quot;</span>);<br>       &#125;<br><br>       <span class="hljs-keyword">final</span> WindowManager.<span class="hljs-type">LayoutParams</span> <span class="hljs-variable">wparams</span> <span class="hljs-operator">=</span> (WindowManager.LayoutParams)params;<br><br>       view.setLayoutParams(wparams);<br><br>       <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> findViewLocked(view, <span class="hljs-literal">true</span>);<br>           <span class="hljs-type">ViewRootImpl</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> mRoots.get(index);<br>           mParams.remove(index);<br>           mParams.add(index, wparams);<br>           root.setLayoutParams(wparams, <span class="hljs-literal">false</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
首先它需要更新View的LayoutParams并替换掉老的LayoutParams，接着再更新ViewRootImpl中的layoutParams，这一步是通过ViewRootImpl的setLayoutParams方法来实现的。在ViewRootImpl中会通过scheduleTraversals方法来对View重新布局，包括测量、布局、重绘这三个过程，除了View本身的重绘以外，ViewRootImpl还会通过WindowSession开更新Window的视图，这个过程最终是由WindowManagerService的relayoutWindow()来具体实现，它同样是一个IPC的过程。</li>
</ol>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>elk简单环境搭建 for linux</title>
    <url>/2017/06/13/elk%E7%AE%80%E5%8D%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-for-linux/</url>
    <content><![CDATA[<p>环境：ubuntu 16.06虚拟机：4核8G内存<br>在官网下载的<code>tag.gz</code>包，官网地址<a href="https://www.elastic.co/webinars/introduction-elk-stack">https://www.elastic.co/webinars/introduction-elk-stack</a><br>安装版本是<strong>5.4.1</strong>，本文只安装了<code>Elasticsearch</code>、<code>Logstash</code>、<code>Kibana</code></p>
<span id="more"></span>
<h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><ol>
<li>下载压缩包并解压</li>
<li>在es的根目录下<code>config/elasticsearch.yml</code>文件，内容如下<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Use a descriptive name for the node:</span><br><span class="hljs-attr">node.name:</span> <span class="hljs-string">xuannode</span>  <span class="hljs-comment">##不要有&#x27;-&#x27;、&#x27;_&#x27;、&#x27;+&#x27;</span><br><span class="hljs-comment"># Path to directory where to store the data (separate multiple locations by comma):</span><br><span class="hljs-comment">#</span><br><span class="hljs-attr">path.data:</span> <span class="hljs-string">/home/huangyuan/elk/elasticsearch/data</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Path to log files:</span><br><span class="hljs-comment">#</span><br><span class="hljs-attr">path.logs:</span> <span class="hljs-string">/home/huangyuan/elk/elasticsearch/logs/*</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set the bind address to a specific IP (IPv4 or IPv6):</span><br><span class="hljs-comment">#</span><br><span class="hljs-attr">network.host:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set a custom port for HTTP:</span><br><span class="hljs-comment">#</span><br><span class="hljs-attr">http.port:</span> <span class="hljs-number">9200</span><br><span class="hljs-attr">discovery.zen.ping.unicast.hosts:</span> [<span class="hljs-string">&quot;0.0.0.0&quot;</span>]<br><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure>
<h4 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h4></li>
<li>下载压缩包并解压</li>
<li>创建一个<code>logstash.conf</code>文件，输入以下内容并保存:<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs conf">input&#123;<br>	file &#123;<br>		path =&gt; &quot;/home/huangyuan/elkdata/*.log&quot;<br>	&#125;<br>&#125;<br>output &#123;<br>	elasticsearch &#123;<br>		hosts =&gt; &quot;http://192.168.1.179:9200&quot;<br>		index =&gt; &quot;logstash-%&#123;+YYYY.MM.dd&#125;&quot;<br>	&#125;<br>    stdout &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>启动时执行 <code>bin/logstash -f logstash.conf</code><h4 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h4></li>
<li>下载压缩包并解压缩</li>
<li>编辑<code>config/kibana.yml</code><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Kibana is served by a back end server. This setting specifies the port to use.</span><br><span class="hljs-attr">server.port:</span> <span class="hljs-number">5601</span><br><span class="hljs-comment"># Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values.</span><br><span class="hljs-comment"># The default is &#x27;localhost&#x27;, which usually means remote machines will not be able to connect.</span><br><span class="hljs-comment"># To allow connections from remote users, set this parameter to a non-loopback address.</span><br><span class="hljs-attr">server.host:</span> <span class="hljs-string">&quot;192.168.1.179&quot;</span><br><span class="hljs-comment"># The Kibana server&#x27;s name.  This is used for display purposes.</span><br><span class="hljs-attr">server.name:</span> <span class="hljs-string">&quot;xuankibina&quot;</span><br><span class="hljs-comment"># The URL of the Elasticsearch instance to use for all your queries.</span><br><span class="hljs-attr">elasticsearch.url:</span> <span class="hljs-string">&quot;http://192.168.1.179:9200&quot;</span><br></code></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>启动的时候依次启动 es、logstash、kibana就可以了<br>PS:<br>1.在LogStash的配置文件<code>logstash.conf</code>中,<code>input</code>配置的就是logstash要监听的文件路径，启动之后，先在监听的文件夹中创建一个log文件并输入随意内容。<br>2. <code>elasticsearch</code>不能用<code>root</code>用户启动<br>3. 启动es报错<code>max virtual memory areas vm.max_map_count [65530]is too low, increase to at least [262144]</code>:解决方法是修改<code>/etc/sysctl.conf</code>配置文件，添加<code>vm.max_map_count=262144</code>，重启机器才起作用.</p>
<hr>
以上]]></content>
      <tags>
        <tag>运维</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>flask笔记一 快速入门</title>
    <url>/2017/07/15/flask%E7%AC%94%E8%AE%B0%E4%B8%80(%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8)/</url>
    <content><![CDATA[<p>学习python和flask中看过的资料和自己的实践总结<br><a href="http://flask.pocoo.org/">Flask英文</a><br>以下内容来自<a href="http://docs.jinkan.org/docs/flask">flask中文</a></p>
<span id="more"></span>
<h4 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h4><p>Flask依赖两个外部库：Werkzeug和Jinja2。Werkzeug是一个WSGI工具集、Jinja2负责渲染模板。首先需要python2.6或者更高的版本，python3.X安装方式可能有所不一致。</p>
<h6 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h6><p>virtualenv 为每个不同项目提供一份 Python 安装。它并没有真正安装多个 Python 副本，但是它确实提供了一种巧妙的方式来让各项目环境保持独立。<br><code>sudo apt-get install python-virtualenv</code><br>virtualenv安装完成后，用IDE比如pycharm创建一个Flask的项目工程，并在其下创建一个venv文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> myproject</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> myproject</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">virtualenv venv</span><br>New python executable in venv/bin/python<br>Installing distribute............done.<br></code></pre></td></tr></table></figure>
<p>然后激活相应的环境<br><code>$ . venv/bin/activate</code><br>然后激活virtualenv中的Flask<br><code>$ pip install Flask</code></p>
<h4 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h4><p>在pycharm中，打开setting<br><img src="/image/python/Flask/pycharm_project_setting1.png" alt="项目设置"><br>在Project Interpreter中选择当前工程文件下的virtualenv<br>打开工程的Configuration<br><img src="/image/python/Flask/pycharm_project_setting2.png" alt="项目设置"><br>在python interpreter中选择当前工程文件下的virtualenv</p>
<h4 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h4><h6 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h6><p>刚刚新建的工程看起来会是这样的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello_world</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World!&#x27;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app.run()<br></code></pre></td></tr></table></figure>
<p>运行这段程序(文件名不要是 flask.py，这会和已有的文件冲突)，浏览器访问<code>127.0.0.1:5000</code>，然后就会看到熟悉的<code>hello world</code>.<br>那么，这段代码做了什么？</p>
<ol>
<li>首先，我们导入了 Flask 类。这个类的实例将会是我们的 WSGI 应用程序。<br>接下来，我们创建一个该类的实例，第一个参数是应用模块或者包的名称。 如果你使用单一的模块（如本例），你应该使用 <strong>name</strong> ，因为模块的名称将会因其作为单独应用启动还是作为模块导入而有不同（ 也即是 ‘<strong>main</strong>‘ 或实际的导入名）。这是必须的，这样 Flask 才知道到哪去找模板、静态文件等等。详情见 Flask 的文档。</li>
<li>然后，我们使用 route() 装饰器告诉 Flask 什么样的URL 能触发我们的函数。<br>这个函数的名字也在生成 URL 时被特定的函数采用，这个函数返回我们想要显示在用户浏览器中的信息。</li>
<li>最后我们用 run() 函数来让应用运行在本地服务器上。 其中 if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘: 确保服务器只会在该脚本被 Python 解释器直接执行的时候才会运行，而不是作为模块导入的时候。<br>  欲关闭服务器，按 Ctrl+C。<br>你会发现它只能从自己的计算机上访问，网络中其他任何地方都不能访问，我们可以修改run()方法使该服务公开可用<br><code>app.run(host=&#39;0.0.0.0&#39;)</code><br>这样会让操作系统监听所有的公网IP<br>同样可以开启debug模式<br><code>app.debug = True;app.run()</code><br>或者<br><code>app.run(debug=True)</code> <h6 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h6>如上面的代码所示，route()装饰其吧一个函数绑定到对应的URL上<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Index Page&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/hello&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello World&#x27;</span><br></code></pre></td></tr></table></figure>
不仅如此，还可以构造含有动态部分的URL，也可以在一个函数上附着多个规则<h6 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h6>要给 URL 添加变量部分，你可以把这些特殊的字段标记为 <variable_name> ， 这个部分将会作为命名参数传递到你的函数。规则可以用 <a href="converter:variable_name">converter:variable_name</a> 指定一个可选的转换器。如下所示</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/user/&lt;username&gt;&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_user_profile</span>(<span class="hljs-params">username</span>):<br>    <span class="hljs-comment"># show the user profile for that user</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;User %s&#x27;</span> % username<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/post/&lt;int:post_id&gt;&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_post</span>(<span class="hljs-params">post_id</span>):<br>    <span class="hljs-comment"># show the post with the given id, the id is an integer</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Post %d&#x27;</span> % post_id<br></code></pre></td></tr></table></figure>
<h6 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h6><p>HTTP有许多不同的访问URL方法。默认情况下，路由只回应GET请求，但是通过route()装饰器传递methods参数可以改变这个行为。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        do_the_login()<br>    <span class="hljs-keyword">else</span>:<br>        show_the_login_form()<br></code></pre></td></tr></table></figure>
<h6 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h6><p>像javaweb一样，不会直接用servlet直接输出html代码，Flask可以使用render_template()方法来渲染模板，Flask配备Jinja2模板引擎<a href="http://docs.jinkan.org/docs/jinja2/">Jinja2中文</a>，<a href="http://jinja.pocoo.org/">Jinja2英文</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> render_template<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/hello/&#x27;</span></span>)</span><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/hello/&lt;name&gt;&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">name=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;hello.html&#x27;</span>, name=name)<br></code></pre></td></tr></table></figure>
<p>Flask 会在 templates 文件夹里寻找模板。所以，如果你的应用是个模块，这个文件夹应该与模块同级；如果它是一个包，那么这个文件夹作为包的子目录:<br>情况 1: 模块:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/application.py<br>/templates<br>    /hello.html<br></code></pre></td></tr></table></figure>
<p>情况 2: 包:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/application<br>    /__init__.py<br>    /templates<br>        /hello.html<br></code></pre></td></tr></table></figure>
<p>下面是<code>hello.html</code>文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs Jinja2">&lt;!doctype html&gt;<br>&lt;title&gt;Hello from Flask&lt;/title&gt;<br>&#123;% if name %&#125;<br>  &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt;<br>&#123;% else %&#125;<br>  &lt;h1&gt;Hello World!&lt;/h1&gt;<br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure>
<h6 id="访问请求数据"><a href="#访问请求数据" class="headerlink" title="访问请求数据"></a>访问请求数据</h6><p>可以通过<code>request.form</code>属性来访问表单数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/signin&quot;</span>, methods=[<span class="hljs-string">&quot;POST&quot;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">signin</span>():<br>    <span class="hljs-built_in">print</span> request.args.get(<span class="hljs-string">&quot;username&quot;</span>)<br>    username = request.form[<span class="hljs-string">&quot;username&quot;</span>]<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;hello.html&#x27;</span>, name=username)<br></code></pre></td></tr></table></figure>
<p>如果form表单中不存在所要获取的键，会抛出特殊的KeyError异常。</p>
<h6 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h6><p>首先确保HTML表单中设置 <code>enctype=&quot;multipart/form-data&quot; </code>属性，否则浏览器根本不会发送文件。<br>已上传的文件存储在内存或是文件系统中一个临时的位置。可以通过请求对象的<code>file</code>属性访问它。每个上传的文件都会存储在这个字典里。同时它还有一个<code>save()</code>方法，这个方法允许把文件保额哦村到服务器的文件系统上。如果像知道上传的文件在客户端是什么名字，可以访问<code>filename</code>属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/upload&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">upload_file</span>():<br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        f = request.files[<span class="hljs-string">&#x27;the_file&#x27;</span>]<br>        f.save(<span class="hljs-string">&#x27;/var/www/uploads/uploaded_file.txt&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h6 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h6><p>可以通过<code>cookies</code>属性来访问Cookies，用响应对象的<code>set_cookie</code>方法来设置Cookies。请求对象的<code>cookies</code>属性是一个内容为客户端提交的所有Cookies的字典.<br>读取cookies：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> request<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    username = request.cookies.get(<span class="hljs-string">&#x27;username&#x27;</span>)<br>    <span class="hljs-comment"># use cookies.get(key) instead of cookies[key] to not get a</span><br>    <span class="hljs-comment"># KeyError if the cookie is missing.</span><br></code></pre></td></tr></table></figure>
<p>存储cookie：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> make_response<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    resp = make_response(render_template(...))<br>    resp.set_cookie(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;the username&#x27;</span>)<br>    <span class="hljs-keyword">return</span> resp<br></code></pre></td></tr></table></figure>
<p>需要注意的是，Cookies是设置在响应对象上的。由于通常视图函数只是返回字符串，之后Flask将字符串转换为响应对象。</p>
<h6 id="重定向和错误"><a href="#重定向和错误" class="headerlink" title="重定向和错误"></a>重定向和错误</h6><p>可以使用<code>redirect()</code>函数把用户重定向到其他地方。用<code>abort()</code>函数放弃请求并返回错误代码，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> abort, redirect, url_for<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;login&#x27;</span>))<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    abort(<span class="hljs-number">401</span>)<br>    this_is_never_executed()<br></code></pre></td></tr></table></figure>
<p>这是一个完全没有任何意义的代码，因为用户会从主页重定向到一个不能访问的页面。默认情况下，错误代码会显示一个黑白的错误页面，如果要定制错误页面，可以使用<code>errorhandler()</code>装饰器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> render_template<br><br><span class="hljs-meta">@app.errorhandler(<span class="hljs-params"><span class="hljs-number">404</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">page_not_found</span>(<span class="hljs-params">error</span>):<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;page_not_found.html&#x27;</span>), <span class="hljs-number">404</span><br></code></pre></td></tr></table></figure>
<p>注意&#96;render_template()调用之后的404，这告诉Flask，该页的错误代码是404。默认是200,也就是一切正常</p>
<h6 id="关于响应"><a href="#关于响应" class="headerlink" title="关于响应"></a>关于响应</h6><p>视图函数的返回值会被自动转换为一个响应对象。如果返回值是一个字符串， 它被转换为该字符串为主体的、状态码为 200 OK<code>的 、 MIME 类型是 </code>text&#x2F;html 的响应对象。Flask 把返回值转换为响应对象的逻辑是这样：</p>
<ol>
<li>如果返回的是一个合法的响应对象，它会从视图直接返回。</li>
<li>如果返回的是一个字符串，响应对象会用字符串数据和默认参数创建。</li>
<li>如果返回的是一个元组，且元组中的元素可以提供额外的信息。这样的元组必须是 (response, status, headers) 的形式，且至少包含一个元素。 status 值会覆盖状态代码， headers 可以是一个列表或字典，作为额外的消息标头值。</li>
<li>如果上述条件均不满足， Flask 会假设返回值是一个合法的 WSGI 应用程序，并转换为一个请求对象。<br>如果你想在视图里操纵上述步骤结果的响应对象，可以使用 make_response() 函数。</li>
</ol>
<p>譬如你有这样一个视图:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.errorhandler(<span class="hljs-params"><span class="hljs-number">404</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">not_found</span>(<span class="hljs-params">error</span>):<br>    <span class="hljs-keyword">return</span> render_template(<span class="hljs-string">&#x27;error.html&#x27;</span>), <span class="hljs-number">404</span><br></code></pre></td></tr></table></figure>
<p>只需要把返回值表达式传递给<code>make_response()</code>，获取结果对象并修改，然后再返回它:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.errorhandler(<span class="hljs-params"><span class="hljs-number">404</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">not_found</span>(<span class="hljs-params">error</span>):<br>    resp = make_response(render_template(<span class="hljs-string">&#x27;error.html&#x27;</span>), <span class="hljs-number">404</span>)<br>    resp.headers[<span class="hljs-string">&#x27;X-Something&#x27;</span>] = <span class="hljs-string">&#x27;A value&#x27;</span><br>    <span class="hljs-keyword">return</span> resp<br></code></pre></td></tr></table></figure>
<h6 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h6><p>除请求对象之后，还有一个<code>session</code>对象，它允许你在不同请求间存储特定用户的信息。他是在Cookies的基础上实现，并且对Cookies进行密钥签名。这意味着用户可以查看你Cookie的内容，但却不能修改它，除非用户知道签名的密钥。<br>要使用会话，需要设置一个密钥</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, session, redirect, url_for, escape, request<br><br>app = Flask(__name__)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;username&#x27;</span> <span class="hljs-keyword">in</span> session:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Logged in as %s&#x27;</span> % escape(session[<span class="hljs-string">&#x27;username&#x27;</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;You are not logged in&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/login&#x27;</span>, methods=[<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-keyword">if</span> request.method == <span class="hljs-string">&#x27;POST&#x27;</span>:<br>        session[<span class="hljs-string">&#x27;username&#x27;</span>] = request.form[<span class="hljs-string">&#x27;username&#x27;</span>]<br>        <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;</span><br><span class="hljs-string">            &lt;p&gt;&lt;input type=text name=username&gt;</span><br><span class="hljs-string">            &lt;p&gt;&lt;input type=submit value=Login&gt;</span><br><span class="hljs-string">        &lt;/form&gt;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/logout&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logout</span>():<br>    <span class="hljs-comment"># remove the username from the session if it&#x27;s there</span><br>    session.pop(<span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-literal">None</span>)<br>    <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">&#x27;index&#x27;</span>))<br><br><span class="hljs-comment"># set the secret key.  keep this really secret:</span><br>app.secret_key = <span class="hljs-string">&#x27;A0Zr98j/3yX R~XHH!jmN]LWX/,?RT&#x27;</span><br></code></pre></td></tr></table></figure>
<p>这里提到的<code>escape()</code>可以在模板引擎外做转义</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter-Android混编及互相调用</title>
    <url>/2019/03/13/flutter-Android%E6%B7%B7%E7%BC%96%E5%8F%8A%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>基本和官网一毛一样。。。。看了官网就不用看这个了，看了也是浪费时间，我也写不出花来</p>
<span id="more"></span>

<h4 id="创建flutter-module"><a href="#创建flutter-module" class="headerlink" title="创建flutter module"></a>创建flutter module</h4><p>命令行执行 <code>flutter create -t module flutter_module</code>或者直接使用AS创建。<br>路径可以和你的工程平级，也可以是工程的子级。只是在配置<code>setting.gradle</code>时注意一下文件夹位置就好。</p>
<h4 id="修改工程的-setting-gradle"><a href="#修改工程的-setting-gradle" class="headerlink" title="修改工程的 setting.gradle"></a>修改工程的 setting.gradle</h4><p>添加如下代码</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">setBinding(<span class="hljs-keyword">new</span> Binding([<span class="hljs-attr">gradle:</span> <span class="hljs-variable language_">this</span>]))                       <br>evaluate(<span class="hljs-keyword">new</span> File( <br>        settingsDir.parentFile,<br>        <span class="hljs-string">&#x27;flutter_check/.android/include_flutter.groovy&#x27;</span><br>))<br></code></pre></td></tr></table></figure>
<p>如果flutter module和工程平级，则是上面的代码。<br>如果flutter module是工程的子目录，则<code>settingsDir.parentFile,</code>改为<code>settingsDir,</code></p>
<h4 id="主工程依赖"><a href="#主工程依赖" class="headerlink" title="主工程依赖"></a>主工程依赖</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">dependencies &#123;<br>    ...<br>    implementation(project(<span class="hljs-string">&#x27;:flutter&#x27;</span>),&#123;<br>        exclude <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;com.android.support&#x27;</span><br>    &#125;)<br>    ...<br></code></pre></td></tr></table></figure>
<p>设置一下编译用的Java版本</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">compileOptions &#123;<br>        sourceCompatibility <span class="hljs-number">1.8</span><br>        targetCompatibility <span class="hljs-number">1.8</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>如果有support包冲突，则exclude排除一下</p>
<h4 id="Android中加载flutter界面"><a href="#Android中加载flutter界面" class="headerlink" title="Android中加载flutter界面"></a>Android中加载flutter界面</h4><p>找个Activity，在onCreate中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">FlutterView</span> <span class="hljs-variable">flutterView</span> <span class="hljs-operator">=</span> Flutter.createView(<span class="hljs-built_in">this</span>, getLifecycle(), <span class="hljs-string">&quot;main&quot;</span>);<br>setContentView(flutterView);<br></code></pre></td></tr></table></figure>
<p>在flutter module中<code>main.dart</code>中添加</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:ui&#x27;</span>;<br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(_widgetForRoute(<span class="hljs-built_in">window</span>.defaultRouteName));<br>&#125;<br><br>Widget _widgetForRoute(<span class="hljs-built_in">String</span> route) &#123;<br>  <span class="hljs-keyword">switch</span> (route) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;main&#x27;</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br>      <span class="hljs-keyword">return</span> App();<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> Center(<br>        child: Text(<span class="hljs-string">&#x27;Unknown route: <span class="hljs-subst">$route</span>&#x27;</span>, textDirection: TextDirection.ltr),<br>      );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里注意的是，case中的<code>main</code>要和Activity中创建FlutterView参数一致。</p>
<h4 id="互相调用"><a href="#互相调用" class="headerlink" title="互相调用"></a>互相调用</h4><p>通过 <code>MethodChannel</code>互相调用<br>在Activity中初始化一个<code>MethodChannel</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(FlutterView flutterView)</span> &#123;<br>        mChannel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChannel</span>(flutterView, <span class="hljs-string">&quot;my_flutter/plugin&quot;</span>);<br><br>        mChannel.setMethodCallHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChannel</span>.MethodCallHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodCall</span><span class="hljs-params">(MethodCall methodCall, MethodChannel.Result result)</span> &#123;<br>                <span class="hljs-keyword">switch</span> (methodCall.method) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;to_license&quot;</span>:<br>                        startActivity(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(MainActivity.<span class="hljs-built_in">this</span>,LicenseActivity.class));<br>                        result.success(<span class="hljs-literal">true</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;to_webview&quot;</span>:<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> methodCall.arguments.toString();<br><br>                        <span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> Uri.parse(url);<br>                        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_VIEW, uri);<br>                        <span class="hljs-keyword">if</span> (intent.resolveActivity(getPackageManager()) != <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-comment">// 网址正确 跳转成功</span><br>                            startActivity(intent);<br>                            result.success(<span class="hljs-literal">true</span>);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            result.success(<span class="hljs-literal">false</span>);<br>                        &#125;<br>                        result.success(<span class="hljs-string">&quot;jump&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure>
<p>注意channel的名字，这里设置一个<code>MethodChannel.MethodCallHandler</code>,在回调函数中可以通过<code>methodCall.method</code>拿到fluter调用的方法名字。result则是回调flutter，这个方法执行的结果。<br>在flutter中</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//初始化一个channel，名字和Android中一致</span><br>MethodChannel channel = <span class="hljs-keyword">const</span> MethodChannel(<span class="hljs-string">&#x27;my_flutter/plugin&#x27;</span>);<br><span class="hljs-comment">//在某个控件的点击事件上调用Android</span><br>onTap: () <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">await</span> channel.invokeMethod(<span class="hljs-string">&#x27;to_webview&#x27;</span>,<span class="hljs-string">&quot;https://blog.huangyuanlove.com&quot;</span>);<br>        <span class="hljs-comment">// 将 dynamic 类型转换成需要的类型（与平台端返回值给定的类型要一致）</span><br>    &#125; <span class="hljs-keyword">on</span> PlatformException <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-built_in">print</span>(e.message);<br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure>
<p>反之，Android调用flutter也是一样的。Android中调用<br><code>mChannel.invokeMethod(&quot;methodName&quot;,&quot;params&quot;);</code><br>在flutter中<br><code>channel.setMethodCallHandler(methodHandler);</code><br>混编的情况下flutter的热重载还是有效的，在flutter module的目录下执行<code>flutter attach</code>，会有提示。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter_Key</title>
    <url>/2023/01/23/flutter-Key/</url>
    <content><![CDATA[<p>官方视频在这里，有条件的可以看下<br><a href="https://www.youtube.com/watch?v=kn0EOS-ZiIc">https://www.youtube.com/watch?v=kn0EOS-ZiIc</a><br>也可以看下这个对diff算法的详解<br><a href="https://juejin.cn/post/6935422635194974244">https://juejin.cn/post/6935422635194974244</a><br>主要代码如下</p>
<span id="more"></span>
<p>一个用于获取颜色的RandomColor</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomColor</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Random _random = Random();<br><br>  <span class="hljs-keyword">static</span> Color getColor() &#123;<br>    <span class="hljs-keyword">return</span> Color.fromRGBO(<br>      _random.nextInt(<span class="hljs-number">256</span>),<br>      _random.nextInt(<span class="hljs-number">256</span>),<br>      _random.nextInt(<span class="hljs-number">256</span>),<br>      <span class="hljs-number">1</span>,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个继承自StatefulWidget的widget，使用State保存了颜色信息</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomColorBoxStateful</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  RandomColorBoxStateful(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;RandomColorBoxStateful&gt; createState() =&gt; RandomColorBoxState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomColorBoxState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">RandomColorBoxStateful</span>&gt; </span>&#123;<br><br>  <span class="hljs-keyword">late</span> Color myColor;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    myColor = RandomColor.getColor();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&quot;<span class="hljs-subst">$myColor</span>&quot;</span>,style: TextStyle(color: myColor),);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个继承自StatelessWidget的widget，内容差不多</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomColorBoxStateless</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>   RandomColorBoxStateless(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br>  Color myColor = RandomColor.getColor();<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>      <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&quot;<span class="hljs-subst">$myColor</span>&quot;</span>,style: TextStyle(color: myColor),););<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个用来显示界面的SwapColorBox</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwapColorBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  State&lt;StatefulWidget&gt; createState() =&gt; SwapColorBoxState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwapColorBoxState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">SwapColorBox</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">List</span>&lt;Widget&gt; tiles = [ RandomColorBoxStateful(), RandomColorBoxStateful() ];<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      body: SafeArea(child: Column(children: tiles)),<br>      floatingActionButton: FloatingActionButton(<br>        child: Icon(Icons.sentiment_very_satisfied),<br>        onPressed: swapTiles,<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> swapTiles() &#123;<br>    setState(() &#123;<br>      <span class="hljs-built_in">List</span>&lt;Widget&gt; tmp = [tiles[<span class="hljs-number">1</span>],tiles[<span class="hljs-number">0</span>]];<br>      tiles = tmp;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这时点击floatingActionButton会发现页面没有变化。</p>
<h3 id="如何修改"><a href="#如何修改" class="headerlink" title="如何修改"></a>如何修改</h3><p>好几种办法</p>
<ul>
<li>将SwapColorBoxState中的tiles改为 List<Widget> tiles &#x3D; [ RandomColorBoxStateless(), RandomColorBoxStateless() ]</li>
<li>将SwapColorBoxState中的tiles中RandomColorBoxStateful加上UniqueKey : List<Widget> tiles &#x3D; [ RandomColorBoxStateful(key: UniqueKey(), ), RandomColorBoxStateful(key: UniqueKey(), ) ];</li>
<li>将RandomColorBoxStateful中的myColor放在RandomColorBoxStateful中而不是RandomColorBoxState中</li>
</ul>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>元素树没有交换，虽然我们交换了Widget，但是其Element并没有交换，而颜色状态又是由State维护，所以在执行build的时候颜色并没有变化。<br>先看下更新的代码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Element</span>&gt; updateChildren(<span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Element</span>&gt; oldChildren, <span class="hljs-built_in">List</span>&lt;Widget&gt; newWidgets, &#123; <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">Element</span>&gt;? forgottenChildren, <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object?</span>&gt;? slots &#125;) &#123;<br><br><br>  <span class="hljs-built_in">Element?</span> replaceWithNullIfForgotten(<span class="hljs-built_in">Element</span> child) &#123;<br>    <span class="hljs-keyword">return</span> forgottenChildren != <span class="hljs-keyword">null</span> &amp;&amp; forgottenChildren.contains(child) ? <span class="hljs-keyword">null</span> : child;<br>  &#125;<br><br>  <span class="hljs-built_in">Object?</span> slotFor(<span class="hljs-built_in">int</span> newChildIndex, <span class="hljs-built_in">Element?</span> previousChild) &#123;<br>    <span class="hljs-keyword">return</span> slots != <span class="hljs-keyword">null</span><br>      ? slots[newChildIndex]<br>      : IndexedSlot&lt;<span class="hljs-built_in">Element?</span>&gt;(newChildIndex, previousChild);<br>  &#125;<br><br><br>  <span class="hljs-built_in">int</span> newChildrenTop = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> oldChildrenTop = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> newChildrenBottom = newWidgets.length - <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">int</span> oldChildrenBottom = oldChildren.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Element</span>&gt; newChildren = oldChildren.length == newWidgets.length ?<br>      oldChildren : <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Element</span>&gt;.filled(newWidgets.length, _NullElement.instance);<br><br>  <span class="hljs-built_in">Element?</span> previousChild;<br><br>  <span class="hljs-comment">// Update the top of the list.</span><br>  <span class="hljs-keyword">while</span> ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element?</span> oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]);<br>    <span class="hljs-keyword">final</span> Widget newWidget = newWidgets[newChildrenTop];<br>   <br>    <span class="hljs-keyword">if</span> (oldChild == <span class="hljs-keyword">null</span> || !Widget.canUpdate(oldChild.widget, newWidget))<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!;<br>    <br>    newChildren[newChildrenTop] = newChild;<br>    previousChild = newChild;<br>    newChildrenTop += <span class="hljs-number">1</span>;<br>    oldChildrenTop += <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Scan the bottom of the list.</span><br>  <span class="hljs-keyword">while</span> ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element?</span> oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenBottom]);<br>    <span class="hljs-keyword">final</span> Widget newWidget = newWidgets[newChildrenBottom];<br>    <br>    <span class="hljs-keyword">if</span> (oldChild == <span class="hljs-keyword">null</span> || !Widget.canUpdate(oldChild.widget, newWidget))<br>      <span class="hljs-keyword">break</span>;<br>    oldChildrenBottom -= <span class="hljs-number">1</span>;<br>    newChildrenBottom -= <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Scan the old children in the middle of the list.</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> haveOldChildren = oldChildrenTop &lt;= oldChildrenBottom;<br>  <span class="hljs-built_in">Map</span>&lt;Key, <span class="hljs-built_in">Element</span>&gt;? oldKeyedChildren;<br>  <span class="hljs-keyword">if</span> (haveOldChildren) &#123;<br>    oldKeyedChildren = &lt;Key, <span class="hljs-built_in">Element</span>&gt;&#123;&#125;;<br>    <span class="hljs-keyword">while</span> (oldChildrenTop &lt;= oldChildrenBottom) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element?</span> oldChild = replaceWithNullIfForgotten(oldChildren[oldChildrenTop]);<br>     <br>      <span class="hljs-keyword">if</span> (oldChild != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldChild.widget.key != <span class="hljs-keyword">null</span>)<br>          oldKeyedChildren[oldChild.widget.key!] = oldChild;<br>        <span class="hljs-keyword">else</span><br>          deactivateChild(oldChild);<br>      &#125;<br>      oldChildrenTop += <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Update the middle of the list.</span><br>  <span class="hljs-keyword">while</span> (newChildrenTop &lt;= newChildrenBottom) &#123;<br>    <span class="hljs-built_in">Element?</span> oldChild;<br>    <span class="hljs-keyword">final</span> Widget newWidget = newWidgets[newChildrenTop];<br>    <span class="hljs-keyword">if</span> (haveOldChildren) &#123;<br>      <span class="hljs-keyword">final</span> Key? key = newWidget.key;<br>      <span class="hljs-keyword">if</span> (key != <span class="hljs-keyword">null</span>) &#123;<br>        oldChild = oldKeyedChildren![key];<br>        <span class="hljs-keyword">if</span> (oldChild != <span class="hljs-keyword">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (Widget.canUpdate(oldChild.widget, newWidget)) &#123;<br>            <span class="hljs-comment">// we found a match!</span><br>            <span class="hljs-comment">// remove it from oldKeyedChildren so we don&#x27;t unsync it later</span><br>            oldKeyedChildren.remove(key);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Not a match, let&#x27;s pretend we didn&#x27;t see it for now.</span><br>            oldChild = <span class="hljs-keyword">null</span>;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>   <br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!;<br>   <br>    newChildren[newChildrenTop] = newChild;<br>    previousChild = newChild;<br>    newChildrenTop += <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// We&#x27;ve scanned the whole list.</span><br>  <br>  newChildrenBottom = newWidgets.length - <span class="hljs-number">1</span>;<br>  oldChildrenBottom = oldChildren.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// Update the bottom of the list.</span><br>  <span class="hljs-keyword">while</span> ((oldChildrenTop &lt;= oldChildrenBottom) &amp;&amp; (newChildrenTop &lt;= newChildrenBottom)) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> oldChild = oldChildren[oldChildrenTop];<br>   <br>    <span class="hljs-keyword">final</span> Widget newWidget = newWidgets[newChildrenTop];<br>   <br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> newChild = updateChild(oldChild, newWidget, slotFor(newChildrenTop, previousChild))!;<br>   <br>    newChildren[newChildrenTop] = newChild;<br>    previousChild = newChild;<br>    newChildrenTop += <span class="hljs-number">1</span>;<br>    oldChildrenTop += <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Clean up any of the remaining middle nodes from the old list.</span><br>  <span class="hljs-keyword">if</span> (haveOldChildren &amp;&amp; oldKeyedChildren!.isNotEmpty) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> oldChild <span class="hljs-keyword">in</span> oldKeyedChildren.values) &#123;<br>      <span class="hljs-keyword">if</span> (forgottenChildren == <span class="hljs-keyword">null</span> || !forgottenChildren.contains(oldChild))<br>        deactivateChild(oldChild);<br>    &#125;<br>  &#125;<br> <br>  <span class="hljs-keyword">return</span> newChildren;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>前置条件：</p>
<h4 id="Widget-canUpdate"><a href="#Widget-canUpdate" class="headerlink" title="Widget.canUpdate()"></a>Widget.canUpdate()</h4><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;<br>  <span class="hljs-keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType<br>      &amp;&amp; oldWidget.key == newWidget.key;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>比较两个Widget的runtimeType和key是否相同</p>
<h4 id="Element-update"><a href="#Element-update" class="headerlink" title="Element.update()"></a>Element.update()</h4><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> update(<span class="hljs-keyword">covariant</span> Widget newWidget) &#123;<br>   _widget = newWidget;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只是简单的替换所持有Widget，并没有更新自己的其他属性</p>
<h3 id="更新算法"><a href="#更新算法" class="headerlink" title="更新算法"></a>更新算法</h3><p>framwork中将节点列表分成了三部分：顶部、中间部分、底部，当发生更新时，尽最大可能的复用Element，无法复用的才会去创建新的Element</p>
<ol>
<li>首先自顶向下的进行diff并更新子节点，也就是第一个while循环，是否能复用就是调用的canUpdate</li>
<li>然后自底向上的进行diff(这里没有更新子节点)，也就是第二个while循环，依然是用canUpdate看判断是否可以复用</li>
<li>然后在这两个中间的部分寻找可以复用的Element，并进行存储</li>
<li>这时候就已经扫描完整棵树了，接下来更新中间部分</li>
<li>最后更新底部</li>
</ol>
<p>为什么在自底向上的进行diff时候没有更新：因为这时候拿不到Slot信息<br>回到我们上面提到的例子中点击按钮时会触发<code>Column</code>的更新，也就是<code>MultiChildRenderObjectElement</code>的更新，就会触发上面的<code>updateChildren()</code>方法<br>所以在自顶向下的更新中，<code>canUpdate()</code>返回的是<code>true</code>(当我们设置了Key之后，这里会返回false，不进行复用)，也就是可以复用<code>element</code>，接着执行了<code>updateChild(Element? child, Widget? newWidget, Object? newSlot)</code><br>这里的<code>child</code>是<em>旧element</em>，<code>newWidget</code>也就是要显示的<em>widget</em>，两者并不相等，所以就执行了<code>child.update(newWidget);</code>只是简单的对所持有的<code>widget</code>进行了赋值。我们知道<code>StatefullWidget</code>中<code>State</code>和<code>StatefulElement</code>互相持有，并且两者都持有<code>StatefulWidget</code>。所以<code>State</code>并没有被更新，所持有的颜色值还是交换之前的颜色值，所以点击交换按钮后，<code>Widget</code>虽然交换了位置，但是<code>Element</code>并没有更新。<br>有点像是A机器生产A物品，B机器生产B物品；原来操作机器A的去操作机器B，原来操作机器B的去操作机器A，虽然换了操作员，但生产A的机器还是生产A，生产B的机器还是生产B。</p>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>这里的key就两个分支<code>LocalKey</code> 和<code>GlobalKey</code> 。我们知道<em>key</em>的作用就是为<code>Widget</code>确认唯一的身份，可以在多子组件更新中被识别，这就是<code>LocalKey</code>的作用。所以<code>LocalKey</code>保证的是 <strong>相同父级</strong>组件的身份唯一性。而 <code>GlobalKey</code> 是整个应用中，组件的身份唯一。</p>
<p><code>LocalKey</code>下面有<code>UniqueKey</code>、<code>ValueKey&lt;T&gt;</code>、<code>ObjectKey</code>,区别也很简单，戳进去看下源码就好了</p>
<h4 id="Globalkey"><a href="#Globalkey" class="headerlink" title="Globalkey"></a>Globalkey</h4><p>对于<code>GlobalKey</code>来讲，只要获取到了<code>Element</code>，就能获取到<code>Widget</code>对象。只要<code>Element</code>是<code>StatefulElement</code>，就能获取到<code>State</code>.<br>那么如何获取到Element呢？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Element?</span> <span class="hljs-keyword">get</span> _currentElement =&gt; WidgetsBinding.instance.buildOwner!._globalKeyRegistry[<span class="hljs-keyword">this</span>];<br><br><span class="hljs-comment">///<span class="language-markdown">BuildOwner</span></span><br><span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;GlobalKey, <span class="hljs-built_in">Element</span>&gt; _globalKeyRegistry = &lt;GlobalKey, <span class="hljs-built_in">Element</span>&gt;&#123;&#125;;<br><span class="hljs-keyword">void</span> _registerGlobalKey(GlobalKey key, <span class="hljs-built_in">Element</span> element) &#123;<br>  _globalKeyRegistry[key] = element;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么是在什么时候调用_registerGlobalKey注册的呢？前面提到的mount方法中</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (key <span class="hljs-keyword">is</span> GlobalKey) &#123;<br>  owner!._registerGlobalKey(key, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到 就是在这里注册的。<br>并且会在unmount中进行反注册</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> Key? key = _widget?.key;<br><span class="hljs-keyword">if</span> (key <span class="hljs-keyword">is</span> GlobalKey) &#123;<br>  owner!._unregisterGlobalKey(key, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>源码中也对<code>GlobalKey</code>的使用场景做出了介绍，当你真的需要获取某个<code>BuildContext</code>或<code>State</code>时，用<code>GlobalKey</code>是完全没有问题的。</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter_StatefulWidget</title>
    <url>/2023/01/18/flutter-StatefulWidget/</url>
    <content><![CDATA[<h3 id="createState-是何时被调用的？"><a href="#createState-是何时被调用的？" class="headerlink" title="createState()是何时被调用的？"></a>createState()是何时被调用的？</h3><p>断点查看调用栈，发现是在<code>StatefulElement</code>的构造方法中创建的,而<code>element</code>的创建则是在父元素调用<code>inflateWidget</code>时触发子元素的<code>createElement</code>方法创建的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">StatefulElement(StatefulWidget widget)<br>    : _state = widget.createState(),<br>      <span class="hljs-keyword">super</span>(widget) &#123;<br>  state._element = <span class="hljs-keyword">this</span>;<br>  state._widget = widget;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>去掉断言代码可以看到，在构造方法中调用了<code>createState()</code>来创建<code>State</code>对象，接着对<code>_state</code>对象的<code>_element</code>和<code>_widget</code>成员进行赋值。<br>到这里我们可以清楚的知道:<code>State</code>和<code>StatefulElement</code>互相持有，并且两者都持有<code>StatefulWidget</code>。</p>
<h3 id="State类中的方法"><a href="#State类中的方法" class="headerlink" title="State类中的方法"></a>State类中的方法</h3><p>这里面定义了生命周期方法</p>
<ul>
<li>initState()</li>
<li>didUpdateWidget(covariant T oldWidget)</li>
<li>void reassemble()</li>
<li>void deactivate()</li>
<li>void activate()</li>
<li>void dispose()</li>
<li>Widget build(BuildContext context)</li>
<li>void didChangeDependencies()</li>
</ul>
<p>其实看一下这些方法上面的注释基本上就能理解的差不多，断点走一遍流程，也就都了解了</p>
<h3 id="回调时机"><a href="#回调时机" class="headerlink" title="回调时机"></a>回调时机</h3><p><code>StatefulElement</code>继承自<code>ComponentElement</code>类，该类在<code>mount()</code>时调用的了<code>_firstBuild()</code>方法，这个方法被<code>StatefulElement</code>覆写，可以看到在这里里面调用了<code>state.initState()</code>方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> _firstBuild() &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    _debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="hljs-keyword">true</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object?</span> debugCheckForReturnedFuture = state.initState() <span class="hljs-keyword">as</span> <span class="hljs-built_in">dynamic</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    _debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="hljs-keyword">false</span>);<br>  &#125;<br>  state.didChangeDependencies();<br>  <span class="hljs-keyword">super</span>._firstBuild();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>紧着这就调用了<code>state.didChangeDependencies()</code>方法,最后调用了<code>super._firstBuild()</code>;<br>还是在<code>ComponentElement</code>类中的<code>_firstBuild()</code>方法中调用了<code>rebuild()--&gt;performRebuild</code>,这里<code>performRebuild()</code>在<code>StatefulElement</code>有被重写</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> performRebuild() &#123;<br>  <span class="hljs-keyword">if</span> (_didChangeDependencies) &#123;<br>    state.didChangeDependencies();<br>    _didChangeDependencies = <span class="hljs-keyword">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">super</span>.performRebuild();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的<code>_didChangeDependencies</code>默认为<code>false</code>，所以第一次进来并不会触发<code>state.didChangeDependencies()</code>方法;接下来执行了<code>super.performRebuild()</code>;<br>同样的在<code>ComponentElement</code>类中的<code>performRebuild()</code>方法中调用了<code>build()</code>方法,当然这里的<code>build</code>方法已经被子类<code>StatefulElement</code>重写，调用了<code>state.build(this)</code>方法，然后调用了<code>updateChild()</code>方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> performRebuild() &#123;<br>  <span class="hljs-keyword">assert</span>(_debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="hljs-keyword">true</span>));<br>  Widget? built;<br>  <span class="hljs-keyword">try</span> &#123;<br>    built = build();<br>    debugWidgetBuilderValue(widget, built);<br>  &#125; <span class="hljs-keyword">catch</span> (e, stack) &#123;<br>    _debugDoingBuild = <span class="hljs-keyword">false</span>;<br>    built = ErrorWidget.builder(...);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>     _dirty = <span class="hljs-keyword">false</span>;<br>    <br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    _child = updateChild(_child, built, slot);<br>    <br>  &#125; <span class="hljs-keyword">catch</span> (e, stack) &#123;<br>    built = ErrorWidget.builder();<br>    _child = updateChild(<span class="hljs-keyword">null</span>, built, slot);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里就接上了控件是如何进行挂载的</p>
<h3 id="如何更新"><a href="#如何更新" class="headerlink" title="如何更新"></a>如何更新</h3><p>我们知道在<code>StatefulWidget</code>中可以使用<code>setState()</code>来更新页面内容，那么表示状态的属性是在什么时机赋值，这里有两种方式</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">_color = Colors.red;<br>setState(()&#123;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">setStaate(()&#123;<br>  _color = Colors.red;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>戳进去看源码</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> setState(VoidCallback fn) &#123;<br>  <span class="hljs-keyword">assert</span>(fn != <span class="hljs-keyword">null</span>);<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Object?</span> result = fn() <span class="hljs-keyword">as</span> <span class="hljs-built_in">dynamic</span>;<br>  <span class="hljs-keyword">assert</span>(() &#123;<br>    <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">is</span> Future) &#123;<br>      <span class="hljs-keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[<br>        ErrorSummary(<span class="hljs-string">&#x27;setState() callback argument returned a Future.&#x27;</span>),<br>        ErrorDescription(<br>          <span class="hljs-string">&#x27;The setState() method on <span class="hljs-subst">$this</span> was called with a closure or method that &#x27;</span><br>          <span class="hljs-string">&#x27;returned a Future. Maybe it is marked as &quot;async&quot;.&#x27;</span>,<br>        ),<br>        ErrorHint(<br>          <span class="hljs-string">&#x27;Instead of performing asynchronous work inside a call to setState(), first &#x27;</span><br>          <span class="hljs-string">&#x27;execute the work (without updating the widget state), and then synchronously &#x27;</span><br>          <span class="hljs-string">&#x27;update the state inside a call to setState().&#x27;</span>,<br>        ),<br>      ]);<br>    &#125;<br>    <span class="hljs-comment">// We ignore other types of return values so that you can do things like:</span><br>    <span class="hljs-comment">//   setState(() =&gt; x = 3);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;());<br>  _element!.markNeedsBuild();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一坨断言，判断<code>callback</code>是不是空，<code>callback</code>的返回值是不是<code>Future</code>类型;然后调用<code>_element!.markNeedsBuild()</code>。所以就这段代码来看，上面两种写法都可以，但还是建议向源码看齐：状态属性的改变写在<code>callback</code>中，确保在<code>markNeedsBuild()</code>之前，状态值是自己期望的结果；</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> markNeedsBuild() &#123;<br>  <span class="hljs-keyword">if</span> (_lifecycleState != _ElementLifecycle.active)<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (dirty)<br>    <span class="hljs-keyword">return</span>;<br>  _dirty = <span class="hljs-keyword">true</span>;<br>  owner!.scheduleBuildFor(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果当前状态不是active则不标记，如果已经标记过也不在标记；</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">/// <span class="language-markdown">Adds an element to the dirty elements list so that it will be rebuilt</span></span><br><span class="hljs-comment">/// <span class="language-markdown">when [WidgetsBinding.drawFrame] calls [buildScope].</span></span><br><span class="hljs-keyword">void</span> scheduleBuildFor(<span class="hljs-built_in">Element</span> element) &#123;<br><br>  <span class="hljs-keyword">if</span> (element._inDirtyList) &#123;<br>    _dirtyElementsNeedsResorting = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != <span class="hljs-keyword">null</span>) &#123;<br>    _scheduledFlushDirtyElements = <span class="hljs-keyword">true</span>;<br>    onBuildScheduled!();<br>  &#125;<br>  _dirtyElements.add(element);<br>  element._inDirtyList = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里也是进行了二次判断，保证不会被多次重绘。注意<code>onBuildScheduled()</code>的调用，它的定义是<code>VoidCallback? onBuildScheduled</code>;并且是在<code>BuildOwner</code>类中的构造方法中初始化的，那么这个<code>onBuildScheduled</code>到底是什么方法?断点看一下是<code>WidgetsBinding#_handleBuildScheduled</code>这个方法。它是在什么时候被赋值的？<code>owner</code>是<code>element</code>对象中的一个成员变量<code>_owner</code>,搜一下看一看到是在<code>mount()</code>方法中赋值的，值为<code>parent.owner</code>。还记的之前初始化根节点的的时候调用的<code>WidgetsBinding#attachRootWidget(Widget rootWidget)</code>这个方法中创建<code>RenderObjectToWidgetAdapter</code>对象后调用的<code>attachToRenderTree()</code>方法中有传入<code>BuildOwner</code>对象，接着向上查找，发现是在<code>initInstances()</code>方法中创建的.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> initInstances() &#123;<br>  <span class="hljs-keyword">super</span>.initInstances();<br>  _instance = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-comment">// Initialization of [_buildOwner] has to be done after</span><br>  <span class="hljs-comment">// [super.initInstances] is called, as it requires [ServicesBinding] to</span><br>  <span class="hljs-comment">// properly setup the [defaultBinaryMessenger] instance.</span><br>  _buildOwner = BuildOwner();<br>  buildOwner!.onBuildScheduled = _handleBuildScheduled;<br>  platformDispatcher.onLocaleChanged = handleLocaleChanged;<br>  platformDispatcher.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;<br>  SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);<br><br>  platformMenuDelegate = DefaultPlatformMenuDelegate();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在<code>_handleBuildScheduled</code> 中就只是调用了<code>ensureVisualUpdate()</code>方法，然后调用了<code>scheduleFrame()</code>;</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> scheduleFrame() &#123;<br>  <span class="hljs-keyword">if</span> (_hasScheduledFrame || !framesEnabled)<br>    <span class="hljs-keyword">return</span>;<br>  ensureFrameCallbacksRegistered();<br>  platformDispatcher.scheduleFrame();<br>  _hasScheduledFrame = <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里先确保两个回调确实被注册了，然后通过<code>platformDispatcher.scheduleFrame()</code>这个<em>native</em>方法向系统发送一个帧调度的请求。<br>然后会回调<code>_handleDrawFrame()</code>方法，也就是<code>ensureFrameCallbacksRegistered()</code>方法中确保两个回调方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> handleDrawFrame() &#123;<br>  <span class="hljs-keyword">assert</span>(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);<br>  _frameTimelineTask?.finish(); <span class="hljs-comment">// end the &quot;Animate&quot; phase</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// PERSISTENT FRAME CALLBACKS</span><br>    _schedulerPhase = SchedulerPhase.persistentCallbacks;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> FrameCallback callback <span class="hljs-keyword">in</span> _persistentCallbacks)<br>      _invokeFrameCallback(callback, _currentFrameTimeStamp!);<br><br>    <span class="hljs-comment">// POST-FRAME CALLBACKS</span><br>    _schedulerPhase = SchedulerPhase.postFrameCallbacks;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">List</span>&lt;FrameCallback&gt; localPostFrameCallbacks =<br>        <span class="hljs-built_in">List</span>&lt;FrameCallback&gt;.of(_postFrameCallbacks);<br>    _postFrameCallbacks.clear();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> FrameCallback callback <span class="hljs-keyword">in</span> localPostFrameCallbacks)<br>      _invokeFrameCallback(callback, _currentFrameTimeStamp!);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    _schedulerPhase = SchedulerPhase.idle;<br>    _frameTimelineTask?.finish(); <span class="hljs-comment">// end the Frame</span><br>    <span class="hljs-keyword">assert</span>(() &#123;<br>      <span class="hljs-keyword">if</span> (debugPrintEndFrameBanner)<br>        debugPrint(<span class="hljs-string">&#x27;▀&#x27;</span> * _debugBanner!.length);<br>      _debugBanner = <span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;());<br>    _currentFrameTimeStamp = <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后是调用 <code>_invokeFrameCallback</code>，这里的<code>_persistentCallbacks</code>是个<code>list</code>，通过</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> addPersistentFrameCallback(FrameCallback callback) &#123;<br>  _persistentCallbacks.add(callback);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法添加回调；这里的回调是在<code>RendererBinding</code>类中的<code>initInstances()</code>方法中注册的，实际上调用的方法是</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">_handlePersistentFrameCallback<br>  <span class="hljs-keyword">void</span> _handlePersistentFrameCallback(<span class="hljs-built_in">Duration</span> timeStamp) &#123;<br>    drawFrame();<br>    _scheduleMouseTrackerUpdate();<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>然后调用了<code>drawFrame();</code>方法,需要注意的是:<code>RendererBinding</code>是一个<em>mixin</em>的类，被<code>WidgetsBinding</code>混入，并且<code>WidgetsBinding</code>类中重写了<code>drawFrame()</code>方法，所以最后走的是<code>WidgetsBinding</code>类中的<code>drawFrame()</code>方法；在这里面调用了<code>buildOwner!.buildScope(renderViewElement!);</code><br>在这个方法中先对脏列表进行排序</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _sort(<span class="hljs-built_in">Element</span> a, <span class="hljs-built_in">Element</span> b) &#123;<br>  <span class="hljs-keyword">if</span> (a.depth &lt; b.depth)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (b.depth &lt; a.depth)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (b.dirty &amp;&amp; !a.dirty)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">if</span> (a.dirty &amp;&amp; !b.dirty)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后循环调用<code>element.rebuild();</code>触发<code>performRebuild()</code>接着就是<code>widget</code>的<code>build()</code>方法被触发.</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter_boost接入及分析</title>
    <url>/2019/09/12/flutter-boost%E6%8E%A5%E5%85%A5%E5%8F%8A%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>flutter_boost 地址：<a href="https://github.com/alibaba/flutter_boost">https://github.com/alibaba/flutter_boost</a><br>集成之后的项目地址：<a href="https://github.com/huangyuanlove/flutter_boost_demo">https://github.com/huangyuanlove/flutter_boost_demo</a><br>flutter版本： v1.5.4-hotfix.2<br>flutter_boost版本：0.1.52</p>
<span id="more"></span>

<h4 id="集成过程"><a href="#集成过程" class="headerlink" title="集成过程"></a>集成过程</h4><p>前提：<strong>项目已经集成flutter，并且可以运行</strong></p>
<h5 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h5><p>根据官方说法：<br>打开pubspec.yaml并将以下行添加到依赖项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">flutter_boost:</span> <span class="hljs-string">^0.1.52</span><br></code></pre></td></tr></table></figure>
<p>或者可以直接依赖github的项目的版本，Tag，pub发布会有延迟，推荐直接依赖Github项目</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-attr">flutter_boost:</span><br>        <span class="hljs-attr">git:</span><br>            <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;https://github.com/alibaba/flutter_boost.git&#x27;</span><br>            <span class="hljs-attr">ref:</span> <span class="hljs-string">&#x27;0.1.52&#x27;</span><br>            <br></code></pre></td></tr></table></figure>
<p>然后 <code>flutter packages get</code>一下</p>
<p>在主工程的build.gradle中依赖一下<br><code>implementation project(path: &#39;:flutter_boost&#39;)</code>,官方没有提这个，但是我在项目中不添加这个依赖，找不到对应的类</p>
<h5 id="在flutter-nodule侧"><a href="#在flutter-nodule侧" class="headerlink" title="在flutter_nodule侧"></a>在flutter_nodule侧</h5><p>在<code>main.dart</code>中注册一下路由，过程和使用命名路由相似</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_MyAppState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyApp</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br><br>    FlutterBoost.singleton.registerPageBuilders(&#123;<br>      <span class="hljs-string">&#x27;first&#x27;</span>: (pageName, params, _) =&gt; FirstRouteWidget(),<br>      <span class="hljs-string">&#x27;second&#x27;</span>: (pageName, params, _) =&gt; SecondRouteWidget(params),<br>      <span class="hljs-string">&#x27;tab&#x27;</span>: (pageName, params, _) =&gt; TabRouteWidget(),<br>      <span class="hljs-string">&#x27;flutterFragment&#x27;</span>: (pageName, params, _) =&gt; FragmentRouteWidget(params),<br><br>      <span class="hljs-comment">///<span class="language-markdown">可以在native层通过 getContainerParams 来传递参数</span></span><br>      <span class="hljs-string">&#x27;flutterPage&#x27;</span>: (pageName, params, _) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flutterPage params:<span class="hljs-subst">$params</span>&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> FlutterRouteWidget();<br>      &#125;,<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>        title: <span class="hljs-string">&#x27;Flutter Boost example&#x27;</span>,<br>        builder: FlutterBoost.init(postPush: _onRoutePushed),<br>        home: Container());<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> _onRoutePushed(<br>      <span class="hljs-built_in">String</span> pageName, <span class="hljs-built_in">String</span> uniqueId, <span class="hljs-built_in">Map</span> params, Route route, Future _) &#123;<br>  &#125;<br>  <br></code></pre></td></tr></table></figure>
<p>其中 <code>FirstRouteWidget</code>、<code>SecondRouteWidget</code> 、<code>TabRouteWidget</code>、<code>FragmentRouteWidget</code>、<code>FlutterRouteWidget</code>代码可以在<code>simple_page_widgets.dart</code>中找到</p>
<h5 id="在原生Android侧"><a href="#在原生Android侧" class="headerlink" title="在原生Android侧"></a>在原生Android侧</h5><p>修改<code>Application</code>继承<code>FlutterApplication</code>,并且在<code>onCreate</code>初始化<code>FlutterBoost</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">FlutterBoost.init(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Platform</span>() &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Application <span class="hljs-title function_">getApplication</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MyApplication.<span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDebug</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openContainer</span><span class="hljs-params">(Context context, String url, Map&lt;String, Object&gt; urlParams, <span class="hljs-type">int</span> requestCode, Map&lt;String, Object&gt; exts)</span> &#123;<br>        <span class="hljs-comment">//在flutter中调用FlutterBoost.singleton.open()方法，最终会走到这里进行处理</span><br>        PageRouter.openPageByUrl(context,url,urlParams,requestCode);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IFlutterEngineProvider <span class="hljs-title function_">engineProvider</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoostEngineProvider</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> BoostFlutterEngine <span class="hljs-title function_">createEngine</span><span class="hljs-params">(Context context)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoostFlutterEngine</span>(context, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DartExecutor</span>.DartEntrypoint(<br>                        context.getResources().getAssets(),<br>                        FlutterMain.findAppBundlePath(context),<br>                        <span class="hljs-string">&quot;main&quot;</span>),<span class="hljs-string">&quot;/&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">whenEngineStart</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ANY_ACTIVITY_CREATED;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerPlugins</span><span class="hljs-params">(PluginRegistry registry)</span> &#123;<br>        <span class="hljs-built_in">super</span>.registerPlugins(registry);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>Android侧包含flutter_view的容器，比如Activity需要继承<code>BoostFlutterActivity</code>，并实现<code>getContainerUrl()</code>和<code>getContainerUrlParams()</code>方法<br>其中<code>getContainerUrl</code>方法返回的值就是在<code>main.dart</code>中注册的路由，<code>getContainerUrlParams</code>方法返回值则是对应的<code>params</code>。</p>
<h4 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h4><p>目前的做法是在Android这边配置打开的协议，和iOS统一，打开页面之后传递的参数全部附加在Uri上，<br>比如在flutter中的调用打开另外一个flutter界面，第一个参数uri就是<code>sample://flutter/launch</code>,如果是打开native页面，则是<code>sample://native/launch</code><br>这样两端各自处理各自的逻辑就好了。<br>在Android端， <code>PageRouter</code>类用来处理native和flutter页面互相打开的逻辑，将传递进来的参数拼接成Uri的形式，通过Intent.setData()方式传递到下一个页面，而不用关系是打开native还是flutter，<br>在FlutterView的容器<code>FlutterPageActivity</code>中，我们通过解析Uri，还原一下要打开的flutter页面的router以及需要的参数，通过上面说的两个方法传递给flutter。</p>
<h4 id="flutter-boost流程"><a href="#flutter-boost流程" class="headerlink" title="flutter_boost流程"></a>flutter_boost流程</h4><h5 id="在flutter中打开flutter或者原生"><a href="#在flutter中打开flutter或者原生" class="headerlink" title="在flutter中打开flutter或者原生"></a>在flutter中打开flutter或者原生</h5><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">FlutterBoost.singleton.open(<span class="hljs-string">&quot;sample://nativePage&quot;</span>, urlParams:&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<span class="hljs-string">&quot;aaa&quot;</span>: <span class="hljs-string">&quot;bbb&quot;</span>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt;&gt; open(<span class="hljs-built_in">String</span> url,&#123;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; urlParams,<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt; exts&#125;)&#123;<br><br>  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; properties = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;();<br>  properties[<span class="hljs-string">&quot;url&quot;</span>] = url;<br>  properties[<span class="hljs-string">&quot;urlParams&quot;</span>] = urlParams;<br>  properties[<span class="hljs-string">&quot;exts&quot;</span>] = exts;<br>  <span class="hljs-keyword">return</span> channel.invokeMethod&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">dynamic</span>&gt;&gt;(<br>      <span class="hljs-string">&#x27;openPage&#x27;</span>, properties);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里也是通过channel调用原生的方法，方法名字是<strong>openPage</strong></p>
<p>在FlutterBoost.BoostMethodHandler中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;openPage&quot;</span>:<br>                &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Map&lt;String,Object&gt; params = methodCall.argument(<span class="hljs-string">&quot;urlParams&quot;</span>);<br>                        Map&lt;String,Object&gt; exts = methodCall.argument(<span class="hljs-string">&quot;exts&quot;</span>);<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> methodCall.argument(<span class="hljs-string">&quot;url&quot;</span>);<br><br>                        mManager.openContainer(url, params, exts, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterViewContainerManager</span>.OnResult() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResult</span><span class="hljs-params">(Map&lt;String, Object&gt; rlt)</span> &#123;<br>                                <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>                                    result.success(rlt);<br>                                &#125;<br>                            &#125;<br>                        &#125;);<br>                    &#125;<span class="hljs-keyword">catch</span> (Throwable t)&#123;<br>                        result.error(<span class="hljs-string">&quot;open page error&quot;</span>,t.getMessage(),t);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>

<p>这里的mManager是<code>FlutterViewContainerManager</code>一个实例，<code>openContainer</code>方法的实现是这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">openContainer</span><span class="hljs-params">(String url, Map&lt;String, Object&gt; urlParams, Map&lt;String, Object&gt; exts,OnResult onResult)</span> &#123;<br>    。。。<br>    FlutterBoost.singleton().platform().openContainer(context,url,urlParams,requestCode,exts);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意最后一句<code>FlutterBoost.singleton().platform()</code>这里的<code>platform</code>返回的是 <code>IPlatform</code>类型，也就是我们在Application中初始化<code>FlutterBoost</code>时传入的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">FlutterBoost.init(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Platform</span>()&#123;...&#125;)<br></code></pre></td></tr></table></figure>

<p>最终调用了这里面的<code>openContainer</code>方法，将路由处理交给了原生。</p>
<p>总结：</p>
<p>在flutter中调用 <code>FlutterBoost.singleton.open</code> 方法，通过<code>channel</code>调用原生，这里的channel的实现类是<code>BoostChannel</code>,在其初始化时注册的methodHandler。 调用原生<code>FlutterBoost.BoostMethodHandler</code>中的<code>onMethodCall()</code>中的<code>case  &#39;openPage&#39;</code>,然后<code>mManager.openContainer</code>，之后就是 <code>FlutterBoost.singleton().platform().openContainer(context,url,urlParams,requestCode,exts);</code></p>
<h5 id="在flutter中关闭页面"><a href="#在flutter中关闭页面" class="headerlink" title="在flutter中关闭页面"></a>在flutter中关闭页面</h5><p>调用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">BoostContainerSettings settings = BoostContainer.of(context).settings;<br>FlutterBoost.singleton.close(settings.uniqueId,result: &#123;<span class="hljs-string">&quot;result&quot;</span>:<span class="hljs-string">&quot;data from second&quot;</span>&#125;);<br></code></pre></td></tr></table></figure>
<p>在上面的flutter打开原生或者flutter页面时传的map参数，打下断点或者输出一下，可以看到里面会有一个<code>__container_uniqueid_key__</code>,<br>这个key是flutter_boost用来标示flutterview的容器，当我们需要在flutter中关闭页面的时候，需要传入这个key。<br>而关闭页面的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;closePage&quot;</span>:<br>            &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">uniqueId</span> <span class="hljs-operator">=</span> methodCall.argument(<span class="hljs-string">&quot;uniqueId&quot;</span>);<br>                    Map&lt;String,Object&gt; resultData = methodCall.argument(<span class="hljs-string">&quot;result&quot;</span>);<br>                    Map&lt;String,Object&gt; exts = methodCall.argument(<span class="hljs-string">&quot;exts&quot;</span>);<br><br>                    mManager.closeContainer(uniqueId, resultData,exts);<br>                    result.success(<span class="hljs-literal">true</span>);<br>                &#125;<span class="hljs-keyword">catch</span> (Throwable t)&#123;<br>                    result.error(<span class="hljs-string">&quot;close page error&quot;</span>,t.getMessage(),t);<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure>
<p>也是通过<code>FlutterViewContainerManager</code>的实例进行关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">IContainerRecord <span class="hljs-title function_">closeContainer</span><span class="hljs-params">(String uniqueId, Map&lt;String, Object&gt; result,Map&lt;String,Object&gt; exts)</span> &#123;<br>    <span class="hljs-type">IContainerRecord</span> <span class="hljs-variable">targetRecord</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;IFlutterViewContainer, IContainerRecord&gt; entry : mRecordMap.entrySet()) &#123;<br>        <span class="hljs-keyword">if</span> (TextUtils.equals(uniqueId, entry.getValue().uniqueId())) &#123;<br>            targetRecord = entry.getValue();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(targetRecord == <span class="hljs-literal">null</span>) &#123;<br>        Debuger.exception(<span class="hljs-string">&quot;closeContainer can not find uniqueId:&quot;</span> + uniqueId);<br>    &#125;<br><br>    FlutterBoost.singleton().platform().closeContainer(targetRecord,result,exts);<br>    <span class="hljs-keyword">return</span> targetRecord;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用FlutterBoost.singleton().platform()的关闭容器方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeContainer</span><span class="hljs-params">(IContainerRecord record, Map&lt;String, Object&gt; result, Map&lt;String, Object&gt; exts)</span> &#123;<br>    <span class="hljs-keyword">if</span>(record == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    record.getContainer().finishContainer(result);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终还是调用的record中container的finish方法。<br>而在ContainerRecord类(IContainerRecord的实现类)的onAppear方法中，会将当前页面放入自己维护的栈中。<br>具体执行顺序：<br>当打开FlutterView的容器(这里是我们自己继承自<code>BoostFlutterActivity</code>的类，实现了<code>finishContainer()</code>方法)，在<code>BoostFlutterActivity.onCreate()</code>中，调用<br><code> FlutterBoost.singleton().containerManager().generateSyncer(this);</code>,将当前的容器放在<code>FlutterViewContainerManager</code>中，并且记录上面讲到唯一标示<br>当关闭容器的时候，则从里面查找到对应的容器，执行finishContainer()。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter_runApp到挂载根节点</title>
    <url>/2023/01/18/flutter-runApp%E5%88%B0%E6%8C%82%E8%BD%BD%E6%A0%B9%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>flutter应用的入口点在main方法中调用的<code>runApp(Widget app)</code>方法中</p>
<figure class="highlight dart"><figcaption><span>widgets.binding.runApp</span></figcaption><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> runApp(Widget app) &#123;<br>  WidgetsFlutterBinding.ensureInitialized()<br>    ..scheduleAttachRootWidget(app)<br>    ..scheduleWarmUpFrame();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的<code>WidgetsFlutterBinding</code>混入了七个 <code>xxxbinding</code></p>
<ul>
<li>[GestureBinding], which implements the basics of hit testing.</li>
<li>[SchedulerBinding], which introduces the concepts of frames.</li>
<li>[ServicesBinding], which provides access to the plugin subsystem.</li>
<li>[PaintingBinding], which enables decoding images.</li>
<li>[SemanticsBinding], which supports accessibility.</li>
<li>[RendererBinding], which handles the render tree.</li>
<li>[WidgetsBinding], which handles the widget tree.</li>
</ul>
<p>并且类中只有一个<code>ensureInitialized()</code>方法用来初始化<code>WidgetsBinding</code>对象,接着去执行了<code>scheduleAttachRootWidget</code>、<code>scheduleWarmUpFrame</code>方法<br>在<code>ensureInitialized</code>方法中调用<code>WidgetsFlutterBinding</code>进行了初始化</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">static</span> WidgetsBinding ensureInitialized() &#123;<br>  <span class="hljs-keyword">if</span> (WidgetsBinding._instance == <span class="hljs-keyword">null</span>)<br>    WidgetsFlutterBinding();<br>  <span class="hljs-keyword">return</span> WidgetsBinding.instance;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="scheduleAttachRootWidget"><a href="#scheduleAttachRootWidget" class="headerlink" title="scheduleAttachRootWidget"></a>scheduleAttachRootWidget</h3><p>接着看 scheduleAttachRootWidget这个方法中执行了</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Timer.run(() &#123;<br>  attachRootWidget(rootWidget);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>在attachRootWidget方法中</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> attachRootWidget(Widget rootWidget) &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> isBootstrapFrame = renderViewElement == <span class="hljs-keyword">null</span>;<br>  _readyToProduceFrames = <span class="hljs-keyword">true</span>;<br>  _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(<br>    container: renderView,<br>    debugShortDescription: <span class="hljs-string">&#x27;[root]&#x27;</span>,<br>    child: rootWidget,<br>  ).attachToRenderTree(buildOwner!, renderViewElement <span class="hljs-keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;?);<br>  <span class="hljs-keyword">if</span> (isBootstrapFrame) &#123;<br>    SchedulerBinding.instance.ensureVisualUpdate();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意看这里的<code>_renderViewElement</code>对象是由<code>RenderObjectToWidgetAdapter.attachToRenderTree()</code>返回的;<br>在初始化<code>RenderObjectToWidgetAdapter</code>对象时传入了<code>renderView</code> 和<code>rootWidget</code>作为参数,这里的<code>rootWidget</code>就是我们<code>runApp</code>中传入的参数;<br>那么这里的<code>renderView</code>是什么时候初始化的?我们在上面提到的<code>WidgetsFlutterBinding</code>混入了七个<code>xxxbinding</code>,这里需要了解mixin的执行顺序:<br>虽然首先执行的是<code>WidgetsBinding</code>的<code>initInstances</code>方法,但由于第一就执行了<code>super.initInstances()</code>,所以会先执行前一个<code>RenderBinding</code>的<code>initInstances</code>,然后不断super,所以最终<code>initInstances</code>实际的逻辑执行顺序,可以看成是从前面的Binding往后面的Binding,所以在<code>WidgetsBinding</code>的<code>attachRootWidget</code>方法内<code>renderView</code>已经被初始化了.</p>
<h3 id="RenderObjectToWidgetAdapter"><a href="#RenderObjectToWidgetAdapter" class="headerlink" title="RenderObjectToWidgetAdapter"></a>RenderObjectToWidgetAdapter</h3><p>继承自<code>RenderObjectWidget</code>,它有两个关键的抽象方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">RenderObjectElement createElement();<br>RenderObject createRenderObject(BuildContext context);<br></code></pre></td></tr></table></figure>
<p>看下是怎么覆写的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>RenderObjectToWidgetElement&lt;T&gt; createElement() =&gt; RenderObjectToWidgetElement&lt;T&gt;(<span class="hljs-keyword">this</span>);<br><br><span class="hljs-meta">@override</span><br>RenderObjectWithChildMixin&lt;T&gt; createRenderObject(BuildContext context) =&gt; container;<br></code></pre></td></tr></table></figure>
<p>我们接着看attachToRenderTree</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt;? element ]) &#123;<br>  <span class="hljs-keyword">if</span> (element == <span class="hljs-keyword">null</span>) &#123;<br>    owner.lockState(() &#123;<br>      element = createElement();<br>      <span class="hljs-keyword">assert</span>(element != <span class="hljs-keyword">null</span>);<br>      element!.assignOwner(owner);<br>    &#125;);<br>    owner.buildScope(element!, () &#123;<br>      element!.mount(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    element._newWidget = <span class="hljs-keyword">this</span>;<br>    element.markNeedsBuild();<br>  &#125;<br>  <span class="hljs-keyword">return</span> element!;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里传入了<code>BuildOwner</code>的实例<code>owner</code>和根元素对象.首先执行了<code>owner.lockState</code>,这个方法只是进行了一些断言来保证执行<code>callback</code>期间状态的锁定,这里<code>callback</code>就是4~6行代码;<br>在这个<code>callback</code>中执行了<code>createElement()</code>,用于创建元素,创建出来的元素也就是树的根节点;这里注意一下<code>createElement</code>是<code>RenderObjectToWidgetAdapter</code>实例的方法,看下上面的方法中传入的<code>this</code>也就是<code>RenderObjectToWidgetAdapter</code>对象本身;那么在创建Element时为啥要传入Widget对象？跟踪到最父级的Element发现是为了给_widget赋值.<em>也就是说Element持有了Widget对象,并且该元素由该组件创建</em></p>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>接下来是<code>owner.buildScope</code>,这里传入了根元素和回调函数,同样的是进行了一些断言后回调了<code>callback</code>,在<code>callback</code>中执行了元素的挂载,注意这里传入的两个参数都是<code>null</code>.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> mount(<span class="hljs-built_in">Element?</span> parent, <span class="hljs-built_in">Object?</span> newSlot) &#123;<br>  <span class="hljs-keyword">assert</span>(parent == <span class="hljs-keyword">null</span>);<br>  <span class="hljs-keyword">super</span>.mount(parent, newSlot);<br>  _rebuild();<br>  <span class="hljs-keyword">assert</span>(_child != <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>mount</code>方法是<code>RenderObjectToWidgetElement</code>类覆写的<code>Element</code>中定义的方法,这里执行了父类的<code>mount</code>方法和<code>_rebuild</code>方法;<br>先看mount的调用路径<br><code>RootRenderObjectElement--&gt;RenderObjectElement--&gt;Element</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> mount(<span class="hljs-built_in">Element?</span> parent, <span class="hljs-built_in">Object?</span> newSlot) &#123;<br>  <span class="hljs-keyword">assert</span>(_lifecycleState == _ElementLifecycle.initial);<br>  <span class="hljs-keyword">assert</span>(widget != <span class="hljs-keyword">null</span>);<br>  <span class="hljs-keyword">assert</span>(_parent == <span class="hljs-keyword">null</span>);<br>  <span class="hljs-keyword">assert</span>(parent == <span class="hljs-keyword">null</span> || parent._lifecycleState == _ElementLifecycle.active);<br>  <span class="hljs-keyword">assert</span>(slot == <span class="hljs-keyword">null</span>);<br>  _parent = parent;<br>  _slot = newSlot;<br>  _lifecycleState = _ElementLifecycle.active;<br>  _depth = _parent != <span class="hljs-keyword">null</span> ? _parent!.depth + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// Only assign ownership if the parent is non-null. If parent is null</span><br>    <span class="hljs-comment">// (the root node), the owner should have already been assigned.</span><br>    <span class="hljs-comment">// See RootRenderObjectElement.assignOwner().</span><br>    _owner = parent.owner;<br>  &#125;<br>  <span class="hljs-keyword">assert</span>(owner != <span class="hljs-keyword">null</span>);<br>  <span class="hljs-keyword">final</span> Key? key = widget.key;<br>  <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">is</span> GlobalKey) &#123;<br>    owner!._registerGlobalKey(key, <span class="hljs-keyword">this</span>);<br>  &#125;<br>  _updateInheritance();<br>  attachNotificationTree();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里维护了一些成员信息,并将树的深度_depth加1,到这里也就以为着根元素节点挂载完成<br>当<code>Element#mount</code>执行完成后,回到<code>RenderObjectToWidgetElement#mount</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> mount(<span class="hljs-built_in">Element?</span> parent, <span class="hljs-built_in">Object?</span> newSlot) &#123;<br>  <span class="hljs-keyword">super</span>.mount(parent, newSlot);<br>  <span class="hljs-keyword">assert</span>(() &#123;<br>    _debugDoingBuild = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;());<br>  _renderObject = (widget <span class="hljs-keyword">as</span> RenderObjectWidget).createRenderObject(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-keyword">assert</span>(!_renderObject!.debugDisposed!);<br>  <span class="hljs-keyword">assert</span>(() &#123;<br>    _debugDoingBuild = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;());<br>  <span class="hljs-keyword">assert</span>(() &#123;<br>    _debugUpdateRenderObjectOwner();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;());<br>  <span class="hljs-keyword">assert</span>(_slot == newSlot);<br>  attachRenderObject(newSlot);<br>  _dirty = <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里面执行了<code>widget</code>的<code>createRenderObject(this)</code>方法来创建<code>_renderObject</code>;注意一下,这里的<code>widget</code>其实就是根组件.也就是<code>RenderObjectToWidgetAdapter</code>的实例对象,调用其<code>createRenderObject</code>方法返回的是其实例中的<code>container</code>对象,也就是说<code>Element</code>中的<code>_renderObject</code>是在<code>mount</code>方法中通过<code>widget.createRenderObject</code>方法创建的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>RenderObjectWithChildMixin&lt;T&gt; createRenderObject(BuildContext context) =&gt; container;<br></code></pre></td></tr></table></figure>
<p>这里的<code>container</code>对象也就是前面提到的<code>attachRootWidget</code>中传入的<code>renderView</code>对象.<br>对于根节点的三棵树来讲,已经完成了创建过程,单着并不代表所有的节点都是这中情况.一般情况下,组件不会持有渲染对象,只不过根组件比较特殊,需要有一个开始渲染的节点,<code>createRenderObject</code>方法返回的RenderView也有特殊性</p>
<p>总结一下</p>
<ul>
<li><code>RenderObjectToWidgetAdapter</code>通过构造方法持有<code>RenderView</code>对象</li>
<li><code>RenderObjectToWidgetAdapter</code>通过<code>createElement</code>方法创建<code>RenderObjectToWidgetElement</code>对象</li>
<li><code>RenderObjectToWidgetElement</code>通过<code>mount</code>方法持有<code>RenderView</code></li>
<li><code>RenderObjectToWidgetElement</code>通过构造方法(Element)持有<code>RenderObjectToWidgetAdapter</code></li>
</ul>
<h3 id="根渲染对象的关联"><a href="#根渲染对象的关联" class="headerlink" title="根渲染对象的关联"></a>根渲染对象的关联</h3><p>挂载完了我们接着看<code>RenderObjectElement#mount</code>方法中调用的<code>attachRenderObject(newSlot)</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> attachRenderObject(<span class="hljs-built_in">Object?</span> newSlot) &#123;<br>  <span class="hljs-keyword">assert</span>(_ancestorRenderObjectElement == <span class="hljs-keyword">null</span>);<br>  _slot = newSlot;<br>  _ancestorRenderObjectElement = _findAncestorRenderObjectElement();<br>  _ancestorRenderObjectElement?.insertRenderObjectChild(renderObject, newSlot);<br>  <span class="hljs-keyword">final</span> ParentDataElement&lt;ParentData&gt;? parentDataElement = _findAncestorParentDataElement();<br>  <span class="hljs-keyword">if</span> (parentDataElement != <span class="hljs-keyword">null</span>)<br>    _updateParentData(parentDataElement.widget <span class="hljs-keyword">as</span> ParentDataWidget&lt;ParentData&gt;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先调用<code>_findAncestorRenderObjectElement从</code>元素树中向上查找第一个<code>RenderObjectElement</code>类型的元素节点作为先祖节点,然后调用其<code>insertRenderObjectChild</code>方法将自身持有的<code>renderObject</code>插入的渲染树中;<br>然后调用<code>_findAncestorParentDataElement</code>方法从元素树中向上查找第一个<code>ParentDataElement&lt;ParentData&gt;</code>类型的节点,如果非空,则执行<code>_updateParentData</code>方法;由于当前是根节点,这两个查找的方法返回的都是空</p>
<h3 id="节点挂载"><a href="#节点挂载" class="headerlink" title="节点挂载"></a>节点挂载</h3><p>当父类的mount方法执行完毕后,回过头来看<code>RenderObjectToWidgetElement#mount</code>方法中调用的<code>_rebuild()</code>方法.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> _rebuild() &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    _child = updateChild(_child, (widget <span class="hljs-keyword">as</span> RenderObjectToWidgetAdapter&lt;T&gt;).child, _rootChildSlot);<br>  &#125; <span class="hljs-keyword">catch</span> (exception, stack) &#123;<br>    <span class="hljs-keyword">final</span> FlutterErrorDetails details = FlutterErrorDetails(<br>      exception: exception,<br>      stack: stack,<br>      <span class="hljs-keyword">library</span>: <span class="hljs-string">&#x27;widgets library&#x27;</span>,<br>      context: ErrorDescription(<span class="hljs-string">&#x27;attaching to the render tree&#x27;</span>),<br>    );<br>    FlutterError.reportError(details);<br>    <span class="hljs-keyword">final</span> Widget error = ErrorWidget.builder(details);<br>    _child = updateChild(<span class="hljs-keyword">null</span>, error, _rootChildSlot);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用了<code>updateChild</code>方法,这里面有三个参数.第一个参数<code>_child</code>现在为<code>null</code>,最后一个<code>_rootChildSlot</code>是一个<code>object</code>,注意一下第二个参数<code>widget.child</code>:这里的widget是root也就是<code>RenderObjectToWidgetAdapter</code>对象的实例,它的<code>child</code>也就是是我们在<code>runApp</code>中传入的<code>widget</code>对象,也就是我们在前面<code>attachRootWidget</code>方法中创建<code>RenderObjectToWidgetAdapter</code>时传入的<code>child</code>参数.</p>
<p>接着看updateChild方法,我们在注释中找到了行为说明</p>
<table>
<thead>
<tr>
<th></th>
<th>newWidget &#x3D;&#x3D; null</th>
<th>newWidget !&#x3D; null</th>
</tr>
</thead>
<tbody><tr>
<td>child &#x3D;&#x3D; null</td>
<td>Returns null</td>
<td>Returns new [Element]</td>
</tr>
<tr>
<td>child !&#x3D; null</td>
<td>Old child is removed, returns null</td>
<td>Old child updated if possible, returns child or new [Element]</td>
</tr>
</tbody></table>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Element?</span> updateChild(<span class="hljs-built_in">Element?</span> child, Widget? newWidget, <span class="hljs-built_in">Object?</span> newSlot) &#123;<br>  <span class="hljs-keyword">if</span> (newWidget == <span class="hljs-keyword">null</span>) &#123;...&#125;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> newChild;<br>  <span class="hljs-keyword">if</span> (child != <span class="hljs-keyword">null</span>) &#123;...&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// The [debugProfileBuildsEnabled] code for this branch is inside</span><br>    <span class="hljs-comment">// [inflateWidget], since some [Element]s call [inflateWidget] directly</span><br>    <span class="hljs-comment">// instead of going through [updateChild].</span><br>    newChild = inflateWidget(newWidget, newSlot);<br>  &#125;<br>  <span class="hljs-keyword">assert</span>(...);<br>  <span class="hljs-keyword">return</span> newChild;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了节省篇幅,这里删除了没有执行的代码;因为这里的child为空,所以会走inflateWidget(newWidget, newSlot)方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Element</span> inflateWidget(Widget newWidget, <span class="hljs-built_in">Object?</span> newSlot) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">final</span> Key? key = newWidget.key;<br>    <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">is</span> GlobalKey) &#123;<br>      <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element?</span> newChild = _retakeInactiveElement(key, newWidget);<br>      <span class="hljs-keyword">if</span> (newChild != <span class="hljs-keyword">null</span>) &#123;<br>        newChild._activateWithParent(<span class="hljs-keyword">this</span>, newSlot);<br>        <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element?</span> updatedChild = updateChild(newChild, newWidget, newSlot);<br>        <span class="hljs-keyword">return</span> updatedChild!;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">Element</span> newChild = newWidget.createElement();<br>    newChild.mount(<span class="hljs-keyword">this</span>, newSlot);<br>    <span class="hljs-keyword">return</span> newChild;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (isTimelineTracked)<br>      Timeline.finishSync();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里检查了组件是否有key并且key是不是GlobalKey.这里先放一下<br>后面调用<code>newWidget.createElement()</code>创建了<code>element</code>,并且调用其<code>mount</code>进行挂载.<br>然后就开始了树的遍历进行挂载,根据我们在<code>runApp</code>中传入的组件不同,调用不同对象的方法,</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter-网络请求与json解析</title>
    <url>/2019/03/13/flutter-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B8%8Ejson%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>网络请求项目中用了两种，一个是dart自己的<code>dart:io</code>,另外一个是<code>dio</code>这个库。<br>json解析则用的是<code>dart:convert</code>。</p>
<span id="more"></span>
<h4 id="发起HTTP请求"><a href="#发起HTTP请求" class="headerlink" title="发起HTTP请求"></a>发起HTTP请求</h4><p>首先我们需要先导入http的支持包，然后创建httpClient。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:io&#x27;</span>;<br><span class="hljs-keyword">var</span> httpClient = <span class="hljs-keyword">new</span> HttpClient();<br></code></pre></td></tr></table></figure>

<p>HttpClient支持常见的get、post、put、delete请求。</p>
<h4 id="处理异步"><a href="#处理异步" class="headerlink" title="处理异步"></a>处理异步</h4><p>众所周知，网络请求是耗时操作，所以我们需要进行异步操作，建议使用async&#x2F;await语法来调用API。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> httpClient = <span class="hljs-keyword">new</span> HttpClient(); <span class="hljs-comment">//创建Client</span><br><span class="hljs-built_in">String</span> dataUrl =<span class="hljs-string">&quot;XXXXXXXX&quot;</span>; <span class="hljs-comment">//构建uri</span><br><span class="hljs-keyword">var</span> uri = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uri</span>.http(<br>    <span class="hljs-string">&#x27;example.com&#x27;</span>, <span class="hljs-string">&#x27;/path1/path2&#x27;</span>, &#123;<span class="hljs-string">&#x27;param1&#x27;</span>: <span class="hljs-string">&#x27;42&#x27;</span>, <span class="hljs-string">&#x27;param2&#x27;</span>: <span class="hljs-string">&#x27;foo&#x27;</span>&#125;);<span class="hljs-comment">//或者这么构建也可以</span><br><span class="hljs-keyword">var</span> request = <span class="hljs-keyword">await</span> httpClient.getUrl(<span class="hljs-built_in">Uri</span>.parse(dataUrl));<span class="hljs-comment">//发起请求</span><br><span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> request.close();<span class="hljs-comment">//关闭连接</span><br><span class="hljs-keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;<br>  <span class="hljs-keyword">var</span> jsonStr = <span class="hljs-keyword">await</span> response.transform(utf8.decoder).join();<br>  <span class="hljs-built_in">print</span>(jsonStr)<br>  <br>&#125; <span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请求失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h4><p>采用的是官网中描述的方法<br>使用’dart:convert’;<br>配合插件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br>  <span class="hljs-attr">json_annotation:</span> <span class="hljs-string">^2.0.0</span><br><br><span class="hljs-attr">dev_dependencies:</span><br>  <span class="hljs-attr">flutter_test:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br>  <span class="hljs-attr">build_runner:</span> <span class="hljs-string">^1.0.0</span><br>  <span class="hljs-attr">json_serializable:</span> <span class="hljs-string">^2.0.0</span><br></code></pre></td></tr></table></figure>

<p>由于这种解析方式不支持泛型，只能采用组合+继承的方式来实现了：</p>
<p>请求基类</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;<br><span class="hljs-keyword">part</span> <span class="hljs-string">&#x27;base_result_bean.g.dart&#x27;</span>;<br><br><span class="hljs-meta">@JsonSerializable</span>()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseResultBean</span></span>&#123;<br>  BaseResultBean();<br>  <span class="hljs-built_in">String</span> status;<br>  <span class="hljs-meta">@JsonKey</span>(name: <span class="hljs-string">&quot;current_page&quot;</span>)<br>  <span class="hljs-built_in">int</span> currentPage;<br><br>  <span class="hljs-meta">@JsonKey</span>(name: <span class="hljs-string">&quot;total_comments&quot;</span>)<br>  <span class="hljs-built_in">int</span> totalComments;<br>  <span class="hljs-meta">@JsonKey</span>(name: <span class="hljs-string">&quot;page_count&quot;</span>)<br>  <span class="hljs-built_in">int</span> pageCount;<br>  <span class="hljs-built_in">int</span> count;<br>  <span class="hljs-keyword">factory</span> BaseResultBean.fromJson(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; json) =&gt;_$BaseResultBeanFromJson(json);<br>  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; toJson() =&gt; _$BaseResultBeanToJson(<span class="hljs-keyword">this</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>写个model</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:json_annotation/json_annotation.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;base_result_bean.dart&#x27;</span>;<br><span class="hljs-keyword">part</span> <span class="hljs-string">&#x27;joke_bean.g.dart&#x27;</span>;<br><br><span class="hljs-meta">@JsonSerializable</span>()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JokeModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseResultBean</span></span>&#123;<br>  JokeModel();<br>  <span class="hljs-built_in">List</span>&lt;JokeBean&gt; comments;<br>  <span class="hljs-keyword">factory</span> JokeModel.fromJson(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; json) =&gt; _$JokeModelFromJson(json);<br>  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; toJson() =&gt; _$JokeModelToJson(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-meta">@JsonSerializable</span>()<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JokeBean</span> </span>&#123;<br>  JokeBean();<br><br>  <span class="hljs-meta">@JsonKey</span>(name: <span class="hljs-string">&quot;vote_positive&quot;</span>)<br>  <span class="hljs-built_in">String</span> votePositive;<br><br>  <span class="hljs-meta">@JsonKey</span>(name: <span class="hljs-string">&quot;vote_negative&quot;</span>)<br>  <span class="hljs-built_in">String</span> voteNegative;<br><br>  <span class="hljs-meta">@JsonKey</span>(name: <span class="hljs-string">&quot;sub_comment_count&quot;</span>)<br>  <span class="hljs-built_in">String</span> subCommentCount;<br>  <span class="hljs-keyword">factory</span> JokeBean.fromJson(<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; json) =&gt; _$JokeBeanFromJson(json);<br>  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; toJson() =&gt; _$JokeBeanToJson(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>写完之后会报错，别慌，根目录下执行<br><code>flutter packages pub run build_runner build</code><br>这条命令每次改变实体类的时候都需要执行，可以换成<br><code>flutter packages pub run build_runner watch</code></p>
<p>现在，我们解析json就可以这么写了</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (response.statusCode == HttpStatus.ok) &#123;<br>      <span class="hljs-keyword">var</span> jsonStr = <span class="hljs-keyword">await</span> response.transform(utf8.decoder).join();<br>      <span class="hljs-keyword">var</span> boredImageModel = JokeModel.fromJson(json.decode(jsonStr));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果是比较简单的json解析，可以直接通过<code>json.decode</code>进行处理，比如</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Smith&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;john@example.com&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>可以这么取</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; user = json.decode(jsonStr);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Howdy, <span class="hljs-subst">$&#123;user[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>!&#x27;</span>);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;We sent the verification link to <span class="hljs-subst">$&#123;user[<span class="hljs-string">&#x27;email&#x27;</span>]&#125;</span>.&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>在flutter中文网推荐了<code>dio</code>这个库，<a href="https://github.com/flutterchina/dio">dio github</a>，这里简单的使用了一下，并没有用到高级功能</p>
<p><code>pubspec.yaml</code>中添加依赖<code>dio: ^2.1.0</code>,导包:<code>import &#39;package:dio/dio.dart&#39;;</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-keyword">void</span>&gt; getHttp(<span class="hljs-built_in">bool</span> isLoadMore) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">if</span> (isLoading) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      setState(() &#123;<br>        isLoading = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (!isLoadMore) &#123;<br>          pageNumber = <span class="hljs-number">1</span>;<br>        &#125;<br>      &#125;);<br>    &#125;<br>    <span class="hljs-built_in">String</span> dataUrl =<br>        <span class="hljs-string">&quot;https://i.jandan.net/?oxwlxojflwblxbsapi=jandan.get_duan_comments&amp;page=<span class="hljs-subst">$pageNumber</span>&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      Response&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&gt; response = <span class="hljs-keyword">await</span> Dio().<span class="hljs-keyword">get</span>(dataUrl);<br>      <span class="hljs-keyword">if</span> (response.statusCode == <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-keyword">var</span> jokeModel = JokeModel.fromJson(response.data);<br><br>        setState(() &#123;<br>          isLoading = <span class="hljs-keyword">false</span>;<br>          pageNumber++;<br>          <span class="hljs-keyword">if</span> (isLoadMore) &#123;<br>            widgets.addAll(jokeModel.comments);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            widgets = jokeModel.comments;<br>          &#125;<br>        &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        isLoading = <span class="hljs-keyword">false</span>;<br>        _showError();<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-built_in">print</span>(e.toString());<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>一个简单的请求，并没有体现出<code>dio</code>的强势的地方，具体使用可以看一下<code>https://github.com/flutterchina/dio/blob/master/README-ZH.md</code>介绍。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter_plugin开发</title>
    <url>/2019/09/16/flutter_plugin%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>一个开发Flutter plugin  和 在Flutter中嵌入原生控件的笔记。完全是照着的官网来实践的。</p>
<p><a href="https://flutter.dev/docs/development/packages-and-plugins/developing-packages">https://flutter.dev/docs/development/packages-and-plugins/developing-packages</a></p>
<p>Flutter中的package分为两种，一种是纯dart语言的的package，比如 <a href="https://pub.dev/packages/fluro"><code>fluro</code></a>，称之为<em>Dart packages</em></p>
<p>还有一种是由原生平台代码(Android:java or kotlin，iOS：OC or swift)，比如<a href="https://pub.dev/packages/battery"><code>battery</code></a>，称之为<em>Plugin packages</em>。</p>
<p>下面是对<em>Plugin packages</em>开发的实践</p>
<span id="more"></span>

<h3 id="Create-the-package"><a href="#Create-the-package" class="headerlink" title="Create the package"></a>Create the package</h3><p>创建工程，命令行</p>
<p><code>flutter create --org com.example --template=plugin name</code></p>
<p>默认Android是java，iOS是OC，也可以指定默认语言</p>
<p><code>flutter create --template=plugin -i swift -a kotlin name</code></p>
<p>也可以同过AS创建，选择<code>Flutter plugin</code>就好。</p>
<p>主要文件如下(以工程根目录为基础目录来说的)：</p>
<ul>
<li><p>lib</p>
<p>刚创建好的项目中，该文件夹下只有一个以项目名命名的dart文件，创建了一个MethodChannel 和实现了一个<code>platformVersion</code>方法</p>
</li>
<li><p>android</p>
<p>这里需要注意一下，在AndroidStudio中以Project方式预览工程时，该目录下的src.main文件夹下只有一个清单文件，可以切换到Android方式预览。可以看到src.main下有一个实现<code>MethodCallHandler</code>接口的类，并且已经实现了<code>getPlatformVersion</code>的调用，我们开发插件原生代码就是在这里写的</p>
</li>
<li><p>iOS</p>
<p>在AndroidStudio下看到只有两个文件夹Assets和Classes，在Classes下有个<code>.h</code> 和<code>.m</code>，也是创建了<code>FlutterMethodChannel</code>和实现了<code>platformVersion</code>调用</p>
</li>
<li><p>Example</p>
<p>在这里测试我们自己写的插件，并且给使用这提供示例。该文件夹下包含Android、iOS和Flutter代码</p>
</li>
</ul>
<h3 id="Implement-the-package"><a href="#Implement-the-package" class="headerlink" title="Implement the package"></a>Implement the package</h3><p>As a plugin package contains code for several platforms written in several programming languages, some specific steps are needed to ensure a smooth experience.</p>
<h4 id="Define-the-package-API"><a href="#Define-the-package-API" class="headerlink" title="Define the package API"></a>Define the package API</h4><p>假如我们要开发一个打开某些原生界面的插件，比如打开原生设置页面、拨号页面、浏览器等</p>
<p>在<code>lib</code>下的dart文件中，增加一个名字为<code>openOSView</code>的方法调用，并且传递一个String类型的url参数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterPluginOpenNative</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> MethodChannel _channel =<br>      <span class="hljs-keyword">const</span> MethodChannel(<span class="hljs-string">&#x27;flutter_plugin_open_native&#x27;</span>);<br><br>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">get</span> platformVersion <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> version = <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;getPlatformVersion&#x27;</span>);<br>    <span class="hljs-keyword">return</span> version;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> Future&lt;<span class="hljs-keyword">void</span>&gt;  openNative(<span class="hljs-built_in">String</span> url) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">await</span> _channel.invokeMethod(<span class="hljs-string">&#x27;openOSView&#x27;</span>,url);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Add-Android-platform-code"><a href="#Add-Android-platform-code" class="headerlink" title="Add Android platform code"></a>Add Android platform code</h4><p>在Android下实现了<code>MethodCallHandler</code>接口的类中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodCall</span><span class="hljs-params">(MethodCall call, Result result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (call.method.equals(<span class="hljs-string">&quot;getPlatformVersion&quot;</span>)) &#123;<br>      result.success(<span class="hljs-string">&quot;Android &quot;</span> + android.os.Build.VERSION.RELEASE);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(call.method.equals(<span class="hljs-string">&quot;openOSView&quot;</span>))&#123;<br>      <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>      intent.setAction(Intent.ACTION_VIEW);<br>      intent.setData(Uri.parse(call.arguments.toString()));<br>      activity.startActivity(intent);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      result.notImplemented();<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h4 id="Add-iOS-platform-code"><a href="#Add-iOS-platform-code" class="headerlink" title="Add iOS platform code"></a>Add iOS platform code</h4><p>在iOS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs objective-c">- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result &#123;<br>    if ([@&quot;getPlatformVersion&quot; isEqualToString:call.method]) &#123;<br>        result([@&quot;iOS &quot; stringByAppendingString:[[UIDevice currentDevice] systemVersion]]);<br>    &#125;<br>    else if([@&quot;openOSView&quot; isEqualToString:call.method])&#123;<br>        NSString * phoneUri = call.arguments;<br>        [[UIApplication sharedApplication] openURL:[NSURL URLWithString:phoneUri]];<br>    &#125;<br>    <br>    else &#123;<br>        result(FlutterMethodNotImplemented);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果是用XCode开发的话，选择打开example–&gt;ios–&gt;Runner.xcworkspace，该文件存在于</p>
<p><code>Pods--&gt;Development Pods--&gt;projectname</code>下</p>
<p><img src="/image/flutter/flutter_plugin_project_in_xcode.png" alt="project in xcode"></p>
<p>第一个红框是项目中example–&gt;ios中的内容</p>
<p>第二个红框是项目中ios文件夹下内容</p>
<hr>
<p>这样，一个简单的插件就开发完了，我们可以在example中测试一下，由于插件特别简单，不需要在原生侧做初始化之类的工作，使用创建项目时生成的代码就可以满足我们的需要。</p>
<p>在<code>example--&gt;lib--&gt;main.dart</code>中放一个按钮，点击的时候调用<code>FlutterPluginOpenNative.openNative(&quot;https://blog.huangyuanlove.com&quot;);</code>然后运行到设备，查看一下效果</p>
<p><code>flutter run -d all</code> 可以运行到所有已连接的设备</p>
<hr>
<h3 id="Flutter嵌入原生控件"><a href="#Flutter嵌入原生控件" class="headerlink" title="Flutter嵌入原生控件"></a>Flutter嵌入原生控件</h3><p>上面是开发的插件，下面是如果在flutter中嵌入原生控件</p>
<p>这里用到了Flutter中的两个类<code>AndroidView</code>和<code>UiKitView</code>，懒得翻译直接看官方版<a href="https://api.flutter.dev/flutter/widgets/AndroidView-class.html">https://api.flutter.dev/flutter/widgets/AndroidView-class.html</a>  和<a href="https://api.flutter.dev/flutter/widgets/UiKitView-class.html">https://api.flutter.dev/flutter/widgets/UiKitView-class.html</a></p>
<p>例如，我们要嵌入原生展示文字的控件，对于Android来讲，一般是TextView，对于iOS来讲，一般是UILabel。</p>
<h4 id="在-flutter侧"><a href="#在-flutter侧" class="headerlink" title="在 flutter侧"></a>在 flutter侧</h4><p>一般是一个Controller和一个StatefulWidget，当然这里的Controller只是一个普通类，用来创建channel和原生通信</p>
<p>代码如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> TextViewCreatedCallback(TextViewController controller);<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextViewController</span> </span>&#123;<br>  TextViewController._(<span class="hljs-built_in">int</span> id)<br>      : _channel = <span class="hljs-keyword">new</span> MethodChannel(<span class="hljs-string">&#x27;me.chunyu.textview/textview&#x27;</span>);<br><br>  <span class="hljs-keyword">final</span> MethodChannel _channel;<br><br>  <span class="hljs-comment">//调用setText方法给控件设置文字，需要原生侧进行实现</span><br>  Future&lt;<span class="hljs-keyword">void</span>&gt; setText(<span class="hljs-built_in">String</span> text) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">assert</span>(text != <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">return</span> _channel.invokeMethod(<span class="hljs-string">&#x27;setText&#x27;</span>, text);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidTextView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br><br>  <span class="hljs-keyword">final</span> TextViewCreatedCallback onTextViewCreated;<br>  <span class="hljs-keyword">const</span> AndroidTextView(&#123;<br>    Key key,<br>    <span class="hljs-keyword">this</span>.onTextViewCreated,<br>  &#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  _AndroidTextViewState createState() =&gt; _AndroidTextViewState();<br>&#125;<br><br><span class="hljs-comment">//对Android平台返回AndroidView，对iOS平台返回UiKitView，并且制定viewType</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_AndroidTextViewState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">AndroidTextView</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">if</span> (defaultTargetPlatform == TargetPlatform.android) &#123;<br>      <span class="hljs-keyword">return</span> AndroidView(<br>        viewType: <span class="hljs-string">&#x27;me.chunyu.textview/textview&#x27;</span>,<br>        onPlatformViewCreated: _onPlatformViewCreated,<br>      );<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (defaultTargetPlatform == TargetPlatform.iOS)&#123;<br>      <span class="hljs-keyword">return</span> UiKitView(<br>        viewType: <span class="hljs-string">&#x27;me.chunyu.textview/textview&#x27;</span>,<br>        onPlatformViewCreated: _onPlatformViewCreated,<br>      );<br>    &#125;<br>    <span class="hljs-keyword">return</span> Text(<br>        <span class="hljs-string">&#x27;<span class="hljs-subst">$defaultTargetPlatform</span> is not yet supported by the text_view plugin&#x27;</span>);<br><br>  &#125;<br>  <span class="hljs-keyword">void</span> _onPlatformViewCreated(<span class="hljs-built_in">int</span> id) &#123;<br>    <span class="hljs-keyword">if</span> (widget.onTextViewCreated == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;id _onPlatformViewCreated :--&gt; <span class="hljs-subst">$id</span>&quot;</span>);<br><br><br>    widget.onTextViewCreated(<span class="hljs-keyword">new</span> TextViewController._(id));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="在Android侧"><a href="#在Android侧" class="headerlink" title="在Android侧"></a>在Android侧</h4><p>我们需要一个实现了<code>PlatformViewFactory</code>的类 和一个实现了<code>PlatformView</code>、<code>MethodCallHandler</code>接口的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextViewFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PlatformViewFactory</span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BinaryMessenger messenger;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TextViewFactory</span><span class="hljs-params">(BinaryMessenger messenger)</span> &#123;<br>    <span class="hljs-built_in">super</span>(StandardMessageCodec.INSTANCE);<br>    <span class="hljs-built_in">this</span>.messenger = messenger;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> PlatformView <span class="hljs-title function_">create</span><span class="hljs-params">(Context context, <span class="hljs-type">int</span> id, Object o)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlutterTextView</span>(context, messenger, id);<br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlutterTextView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PlatformView</span>, MethodCallHandler  &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TextView textView;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodChannel methodChannel;<br><br>  FlutterTextView(Context context, BinaryMessenger messenger, <span class="hljs-type">int</span> id) &#123;<br>    Log.e(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-string">&quot;id :--&gt;&quot;</span> +id);<br>    textView = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextView</span>(context);<br>    textView.setTextColor(Color.BLUE);<br>    textView.setBackgroundColor(Color.GREEN);<br>    methodChannel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChannel</span>(messenger, <span class="hljs-string">&quot;me.chunyu.textview/textview&quot;</span>);<br>    methodChannel.setMethodCallHandler(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> View <span class="hljs-title function_">getView</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> textView;<br>  &#125;<br><br>  <span class="hljs-comment">//实现以下flutter通过channel调用的`setText`方法</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodCall</span><span class="hljs-params">(MethodCall methodCall, MethodChannel.Result result)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (methodCall.method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;setText&quot;</span>:<br>        setText(methodCall, result);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        result.notImplemented();<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-comment">//设置文字，并返回成功</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(MethodCall methodCall, Result result)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> (String) methodCall.arguments;<br>    textView.setText(text);<br>    result.success(<span class="hljs-literal">null</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispose</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里需要注意，在插件的<code>registerWith</code>方法中注册一下<code>channel</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">registrar.platformViewRegistry().registerViewFactory(<span class="hljs-string">&quot;me.chunyu.textview/textview&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextViewFactory</span>(registrar.messenger()));<br></code></pre></td></tr></table></figure>



<h4 id="在iOS侧"><a href="#在iOS侧" class="headerlink" title="在iOS侧"></a>在iOS侧</h4><p>一个<code>.h</code>文件，声明一下实现<code>NSObject&lt;FlutterPlatformView&gt;</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><span class="hljs-meta">#import <span class="hljs-string">&lt;Foundation/Foundation.h&gt;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;Flutter/Flutter.h&gt;</span></span><br><span class="hljs-built_in">NS_ASSUME_NONNULL_BEGIN</span><br><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">AndroidTextView</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">FlutterPlatformView</span>&gt;</span><br>- (<span class="hljs-keyword">instancetype</span>)initWithWithFrame:(<span class="hljs-built_in">CGRect</span>)frame<br>                   viewIdentifier:(int64_t)viewId<br>                        arguments:(<span class="hljs-type">id</span> _Nullable)args<br>                  binaryMessenger:(<span class="hljs-built_in">NSObject</span>&lt;FlutterBinaryMessenger&gt;*)messenger;<br><br><span class="hljs-keyword">@end</span><br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">FlutterAndroidTextViewFactory</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">FlutterPlatformViewFactory</span>&gt;</span><br><br>- (<span class="hljs-keyword">instancetype</span>)initWithMessenger:(<span class="hljs-built_in">NSObject</span>&lt;FlutterBinaryMessenger&gt;*)messager;<br><br><span class="hljs-keyword">@end</span><br><br><span class="hljs-built_in">NS_ASSUME_NONNULL_END</span><br></code></pre></td></tr></table></figure>

<p>一个<code>.m</code>文件，实现以上方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc"><br><span class="hljs-meta">#import <span class="hljs-string">&quot;AndroidTextView.h&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">FlutterAndroidTextViewFactory</span></span>&#123;<br>    <span class="hljs-built_in">NSObject</span>&lt;FlutterBinaryMessenger&gt;*_messenger;<br>&#125;<br><br>- (<span class="hljs-keyword">instancetype</span>)initWithMessenger:(<span class="hljs-built_in">NSObject</span>&lt;FlutterBinaryMessenger&gt; *)messager&#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-variable language_">super</span> init];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        _messenger = messager;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>-(<span class="hljs-built_in">NSObject</span>&lt;FlutterMessageCodec&gt; *)createArgsCodec&#123;<br>    <span class="hljs-keyword">return</span> [FlutterStandardMessageCodec sharedInstance];<br>&#125;<br><br>-(<span class="hljs-built_in">NSObject</span>&lt;FlutterPlatformView&gt; *)createWithFrame:(<span class="hljs-built_in">CGRect</span>)frame viewIdentifier:(int64_t)viewId arguments:(<span class="hljs-type">id</span>)args&#123;<br>    AndroidTextView * androidTextView = [[AndroidTextView alloc] initWithWithFrame:frame viewIdentifier:viewId arguments:args binaryMessenger:_messenger];<br>    <br>    <span class="hljs-keyword">return</span> androidTextView;<br>    <br>&#125;<br><br><span class="hljs-keyword">@end</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">AndroidTextView</span></span>&#123;<br>    int64_t _viewId;<br>    FlutterMethodChannel* _channel;<br>    <span class="hljs-built_in">UILabel</span> * _label;<br>    <br>&#125;<br><br>- (<span class="hljs-keyword">instancetype</span>)initWithWithFrame:(<span class="hljs-built_in">CGRect</span>)frame viewIdentifier:(int64_t)viewId arguments:(<span class="hljs-type">id</span>)args binaryMessenger:(<span class="hljs-built_in">NSObject</span>&lt;FlutterBinaryMessenger&gt; *)messenger&#123;<br>    <span class="hljs-keyword">if</span> ([<span class="hljs-variable language_">super</span> init]) &#123;<br>        _label = [[<span class="hljs-built_in">UILabel</span> alloc] init];<br>        _label.textColor = <span class="hljs-built_in">UIColor</span>.redColor;<br>        _label.backgroundColor = <span class="hljs-built_in">UIColor</span>.blueColor;<br>        _label.font = [<span class="hljs-built_in">UIFont</span> fontWithName:<span class="hljs-string">@&quot;Arial&quot;</span> size:<span class="hljs-number">30</span>];<br>        _viewId = viewId;<br>        <span class="hljs-built_in">NSString</span>* channelName =  <span class="hljs-string">@&quot;me.chunyu.textview/textview&quot;</span>;<br>        _channel = [FlutterMethodChannel methodChannelWithName:channelName binaryMessenger:messenger];<br>        __<span class="hljs-keyword">weak</span> __typeof__(<span class="hljs-keyword">self</span>) weakSelf = <span class="hljs-keyword">self</span>;<br>        [_channel setMethodCallHandler:^(FlutterMethodCall *  call, FlutterResult  result) &#123;<br>            [weakSelf onMethodCall:call result:result];<br>        &#125;];   <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>-(<span class="hljs-built_in">UIView</span> *)view&#123;<br>    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;invoke view()&quot;</span>);<br>    <span class="hljs-keyword">return</span> _label;<br>&#125;<br><span class="hljs-comment">//实现flutter侧通过channel调用的`setText`方法</span><br>-(<span class="hljs-type">void</span>)onMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result&#123;<br>    <span class="hljs-keyword">if</span> ([[call method] isEqualToString:<span class="hljs-string">@&quot;setText&quot;</span>]) &#123;<br>        _label.text = [call arguments];<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, call.arguments);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<p>在plugin中的<code>registerWithRegistrar</code>方法中注册一下<code>channel</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">[registrar registerViewFactory:[[FlutterAndroidTextViewFactory alloc] initWithMessenger:registrar.messenger] withId:<span class="hljs-string">@&quot;me.chunyu.textview/textview&quot;</span>];<br></code></pre></td></tr></table></figure>

<p>需要注意的是，如果想要在iOS中显示这种flutter嵌入原生的空间，需要在info.plist文件中加入</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><code class="hljs objc">&lt;key&gt;io.flutter.embedded_views_preview&lt;/key&gt;<br>&lt;<span class="hljs-literal">true</span>/&gt;<br></code></pre></td></tr></table></figure>

<p>在flutter中嵌入原生控件并不推荐，性能跟不上，消耗太大了，但是在某些情况下不得不这么搞。。。。。</p>
<h3 id="Adding-documentation"><a href="#Adding-documentation" class="headerlink" title="Adding documentation"></a>Adding documentation</h3><p>这个没啥好说的，跟着官方做就好了</p>
<p>When you publish a package, API documentation is automatically generated and published to dartdocs.org, see for example the <a href="https://pub.dev/documentation/device_info/latest">device_info docs</a></p>
<h3 id="Adding-licenses-to-the-LICENSE-file"><a href="#Adding-licenses-to-the-LICENSE-file" class="headerlink" title="Adding licenses to the LICENSE file"></a>Adding licenses to the LICENSE file</h3><p>添加协议</p>
<h3 id="Publishing-packages"><a href="#Publishing-packages" class="headerlink" title="Publishing packages"></a>Publishing packages</h3><p>发布之前运行一下 <code>flutter pub pub publish --dry-run</code>，根据提示修改不满足需求的地方。</p>
<p>之后执行<code>flutter pub pub publish</code>，具体可以看For details on publishing, see the <a href="https://dart.dev/tools/pub/publishing">publishing docs</a> for the Pub site.</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter从入门到挣扎</title>
    <url>/2019/03/13/flutter%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%8C%A3%E6%89%8E/</url>
    <content><![CDATA[<p>我司准备上Flutter了，我不喜不悲。花了大概一周的时间了解了一下。写了点小玩意练手。感觉如下：</p>
<ul>
<li>Flutter用的前端的布局思想，就现在看来，只能算是一个UI框架加上一些简单逻辑，一旦涉及到系统的东西，比如打开系统自带浏览器、浏览系统图库等就无能为力了，只能通过<code>MethodChannel</code>和原生交互。</li>
<li>学会Flutter并不意味着就不用了解原生开发了，如果遇到了上面的情况，要么用别人写的库，要么等谷歌出封装好的包。但就现在看来，flutter也是刚刚崭露头角，京东貌似是去年下半年才开始在主业务上使用flutter。一些三方库的质量参差不齐，能在Android上运行的到iOS上就凉凉，打debug包没问题打release包就GG</li>
</ul>
<p>下面是自己在学习、练手的时候做的一些笔记，劝退流开始了。。。。</p>
<span id="more"></span>

<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>这个看官网教程就好，基本没啥坑，如果有的话也在iOS环境上，比如pod失效之类的</p>
<p>链接在这里</p>
<p><a href="https://flutter.dev/docs/get-started/install">https://flutter.dev/docs/get-started/install</a></p>
<p>英文看不懂的可以看中文的</p>
<p><a href="https://flutterchina.club/get-started/install/">https://flutterchina.club/get-started/install/</a>    不过这个更新速度有点慢。</p>
<p>如果环境搭不好的话，也不用看下面的了，可以放弃了。</p>
<h4 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h4><p>这个用到啥搜啥就行，常用也就这几个</p>
<ul>
<li>TabBar</li>
<li>Card</li>
<li>Container</li>
<li>Text</li>
<li>Column</li>
<li>Offstage</li>
<li>FadeInImage</li>
<li>Row</li>
<li>Icon</li>
<li>RefreshIndicator</li>
<li>ListView</li>
</ul>
<p>对了，项目中还用了一个上拉加载更多，只需加添加一个滑动监听，在ListView.builder设置一下controller就好</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">if</span> (_scrollController.position.pixels == _scrollController.position.maxScrollExtent) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;滑动到了最底部&#x27;</span>);<br>&#125;<br><br><br><span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> RefreshIndicator(<br>      onRefresh: () =&gt; _loadData(<span class="hljs-keyword">false</span>),<br>      child: ListView.builder(<br>          controller: _scrollController,<br>          itemCount: widgets.length + <span class="hljs-number">1</span>,<br>          itemBuilder: (BuildContext context, <span class="hljs-built_in">int</span> position) &#123;<br>            <span class="hljs-keyword">return</span> _getRow(position);<br>          &#125;),<br>    );<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>至于为啥<code>itemCount</code>需要数据总数+1，是为了显示出来下面的加载中动画。</p>
<p>在<code>Widget _getRow(int i)</code>方法中，判断是不是要渲染不是，不是渲染数据那就是渲染加载更多的这个控件</p>
<h4 id="网络请求及json解析"><a href="#网络请求及json解析" class="headerlink" title="网络请求及json解析"></a>网络请求及json解析</h4><p>看这里 </p>
<p><a href="https://blog.huangyuanlove.com/2019/03/13/flutter-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E4%B8%8Ejson%E8%A7%A3%E6%9E%90/">https://blog.huangyuanlove.com/2019/03/13/flutter-网络请求与json解析/</a></p>
<h4 id="Android和flutter混编及互相调用"><a href="#Android和flutter混编及互相调用" class="headerlink" title="Android和flutter混编及互相调用"></a>Android和flutter混编及互相调用</h4><p>看这里</p>
<p><a href="https://blog.huangyuanlove.com//2019/03/13/flutter-Android%E6%B7%B7%E7%BC%96%E5%8F%8A%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8/">https://blog.huangyuanlove.com//2019/03/13/flutter-Android混编及互相调用/</a></p>
<h4 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h4><p><a href="https://github.com/huangyuanlove/JanDan_flutter">https://github.com/huangyuanlove/JanDan_flutter</a></p>
<p>效果图</p>
<p><img src="/image/flutter/jan_dan.gif" alt="煎蛋"> </p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter性能瓶颈</title>
    <url>/2019/04/18/flutter%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88/</url>
    <content><![CDATA[<p>跟着视频自己做了一下，<a href="https://www.bilibili.com/video/av48772383">https://www.bilibili.com/video/av48772383</a></p>
<p>我在B站学flutter调优。。。。</p>
<ol>
<li>如何分析Flutter 对Skia的调用 </li>
<li>如何捕捉SK Picture来分析每一条绘图指令 </li>
<li>常见Skia函数调用性能瓶颈</li>
</ol>
<span id="more"></span>

<h4 id="如何分析Flutter-对Skia的调用"><a href="#如何分析Flutter-对Skia的调用" class="headerlink" title="如何分析Flutter 对Skia的调用"></a>如何分析Flutter 对Skia的调用</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">flutter <span class="hljs-built_in">run</span> <span class="hljs-comment">--profile --trace-skia</span><br></code></pre></td></tr></table></figure>
<p><img src="/image/flutter/trace_skia.png" alt="flutter run --profile --trace-skia"> </p>
<p><strong>可在浏览器中查看</strong><br>打开上图的中地址</p>
<p><img src="/image/flutter/trace_skia_view.png" alt="trace_skia_view"> </p>
<p><strong>全选一下</strong> </p>
<p><img src="/image/flutter/trace_skia_timeline.png" alt="trace_skia_timeline.png"> </p>
<p><strong>操作一下应用，然后点击浏览器又上角Refresh</strong> </p>
<p><img src="/image/flutter/skia_invoke.png" alt="skia_invoke"> </p>
<p>这里可以看到最底层的skia函数调用情况。<br>很多同学问怎么放大函数调用的时间区域(把时间线加长)<br><img src="/image/flutter/trace_skia_tools.png" alt="skia_invoke"><br>这里有四个选项，<br>第一个是选择区域，当你选中这个选项，然后按住鼠标左键在时间线上选择，就可以选中一段时间，和PS中的区域选择工具很像。<br>第二个是移动区域，当你选中这个选项，然后按住鼠标左键在下面有颜色的地方拖动，就可以拖动时间线<br>第三个是放大缩小，当你选中这个选项，然后按住鼠标左键在下面有颜色的地方向上拖动是放大，向下拖动是缩小。<br>第四个是区域选择，当你选中这个选项，然后按住鼠标左键在下面有颜色的地方拖动，可以统计选择的区域总共是多长时间。</p>
<h4 id="如何捕捉SK-Picture来分析每一条绘图指令"><a href="#如何捕捉SK-Picture来分析每一条绘图指令" class="headerlink" title="如何捕捉SK Picture来分析每一条绘图指令"></a>如何捕捉SK Picture来分析每一条绘图指令</h4><p><strong>接上一步</strong> </p>
<p>这里的port是我们在浏览器中查看的端口 </p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">flutter screenshot <span class="hljs-attribute">--type</span>=skia <span class="hljs-attribute">--observatory-port</span>=&lt;port&gt;<br></code></pre></td></tr></table></figure>

<p><img src="/image/flutter/flutter_screenshot.png" alt="flutter screenshot"> </p>
<p>这里会生成一个skp文件，文件可以在<a href="https://debugger.skia.org/">https://debugger.skia.org/</a> 这里进行分析。如果网络不好的话可以在本地起一个服务，需要自己编译一下skia。 </p>
<p><strong>需fq</strong> </p>
<ol>
<li>下载depot_tools并设置环境变量</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone &#x27;https://chromium.googlesource.com/chromium/tools/depot_tools.git&#x27;<br>export PATH=&quot;$&#123;PWD&#125;/depot_tools:$&#123;PATH&#125;&quot; <br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p>下载skia并且更新 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone https://skia.googlesource.com/skia.git <br>cd skia <br>python tools/git-sync-deps <br></code></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
</li>
</ol>
<p>使用GN生成构建文件 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bin/gn gen out/Static --args=&#x27;is_official_build=true&#x27; <br>bin/gn gen out/Shared --args=&#x27;is_official_build=true is_component_build=true&#x27; <br></code></pre></td></tr></table></figure>

<p>GN也支持更细粒度的配置 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">bin/gn gen out/Debug <br>bin/gn gen out/Release --args=&#x27;is_debug=false&#x27; <br>bin/gn gen out/Clang --args=&#x27;cc=&quot;clang&quot; cxx=&quot;clang++&quot;&#x27; <br>bin/gn gen out/Cached --args=&#x27;cc_wrapper=&quot;ccache&quot;&#x27; <br>bin/gn gen out/RTTI --args=&#x27;extra_cflags_cc=[&quot;-frtti&quot;]&#x27; <br></code></pre></td></tr></table></figure>

<ol start="4">
<li>编译并启动本地服务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Build.</span> <br>ninja -C out/Release skiaserve <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Run the debugger locally</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">By default the address will be</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">http://127.0.0.1:8888</span> <br>out/Release/skiaserve <br></code></pre></td></tr></table></figure>

<p>skia编译教程<a href="https://skia.org/dev/tools/debugger">https://skia.org/dev/tools/debugger</a><br>选择上一步导出的spk文件并上传，</p>
<p><img src="/image/flutter/skia_debugger.png" alt="skp"> </p>
<p>可以分析每一步进行了哪些操作，有哪些重复绘制 </p>
<h4 id="常见Skia函数调用性能瓶颈"><a href="#常见Skia函数调用性能瓶颈" class="headerlink" title="常见Skia函数调用性能瓶颈"></a>常见Skia函数调用性能瓶颈</h4><p>saveLayer、clipPath 函数<br>基本都是flutter自己的控件调用的 </p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>Skia有两套很不同的后端，Flutter 在iOS模拟器中使用纯cpu的后端，而实际设备一般使用GPU硬件加速后端，所以性能很不一样 </p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter路由简介</title>
    <url>/2019/06/27/flutter%E8%B7%AF%E7%94%B1%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>管理多个页面时有两个核心概念和类：<a href="https://docs.flutter.io/flutter/widgets/Route-class.html">Route</a>和 <a href="https://docs.flutter.io/flutter/widgets/Navigator-class.html">Navigator</a>。 一个route是一个屏幕或页面的抽象，Navigator是管理route的Widget。Navigator可以通过route入栈和出栈来实现页面之间的跳转。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。这和原生开发类似，无论是Android还是iOS，导航管理都会维护一个路由栈，路由入栈(push)操作对应打开一个新页面，路由出栈(pop)操作对应页面关闭操作，而路由管理主要是指如何来管理路由栈。</p>
<span id="more"></span>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>比如我们想要从A界面打开B界面，并且从B界面返回时需要携带数据给A界面，我们可以这么写</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.push(context, MaterialPageRoute(builder: (context) &#123;<br><span class="hljs-keyword">return</span> SaveImageWidget();<br>&#125;)).then((onValue) &#123;<br><span class="hljs-built_in">print</span>(onValue);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>当我们从B界面返回的时候</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.of(context).pop(<span class="hljs-string">&quot;B界面返回的数据&quot;</span>);<br></code></pre></td></tr></table></figure>

<p><code>MaterialPageRoute</code>继承自<code>PageRoute</code>类，<code>PageRoute</code>类是一个抽象类，表示占有整个屏幕空间的一个模态路由页面，它还定义了路由构建及切换时过渡动画的相关接口及属性。</p>
<h4 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h4><p><code>Navigator</code>是一个路由管理的widget，它通过一个栈来管理一个路由widget集合。通常当前屏幕显示的页面就是栈顶的路由。方法大致分为两种：push:打开新页面，包括<code>pushAndRemoveUntil</code>,<code>pushNamed</code>,<code>pushNamedAndRemoveUntil</code>,<code>pushReplacement</code>,<code>pushReplacementNamed</code>,；pop：弹出当前界面,包括<code>popAndPushNamed</code>,<code>popUntil</code></p>
<h5 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h5><p>这里需要说一下命名路由，上面的打开新界面的时候，push方法中参数是MaterialPageRoute，还有一种是给定路由字符串，在此之前，我们需要先注册路由表：</p>
<p>找到flutter工程的入口main方法，找到<code>MaterialApp</code>,添加<code>routers</code>属性，</p>
<p><img src="/image/flutter/register_routers.png" alt="注册路由表"></p>
<p>代码在这里 <a href="https://github.com/huangyuanlove/test_flutter/blob/master/lib/main.dart">https://github.com/huangyuanlove/test_flutter/blob/master/lib/main.dart</a></p>
<p>具体页面代码在这里 <a href="https://github.com/huangyuanlove/test_flutter/tree/master/lib/test_named_router">https://github.com/huangyuanlove/test_flutter/tree/master/lib/test_named_router</a></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.of(context).pushNamed(<span class="hljs-string">&#x27;a_router_widget&#x27;</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这种方法只是简单的将我们需要进入的页面push到栈顶，以此来显示当前页面,其参数是一个字符串类型，传入的是页面对应的路由名称</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.of(context).pushReplacementNamed(<span class="hljs-string">&#x27;d_router_widget&#x27;</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这种方法是将当前界面替换成要跳转的界面，比如A打开B，B使用这种方法打开C，当从C界面返回的时候，会直接返回A。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.of(context).popAndPushNamed(<span class="hljs-string">&#x27;d_router_widget&#x27;</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>指将当前页面pop，然后跳转到指定页面（将当前路由弹出导航器，并将命名路由推到它的位置。）</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.of(context).pushNamedAndRemoveUntil(<span class="hljs-string">&#x27;d_router_widget&#x27;</span>, (Route&lt;<span class="hljs-built_in">dynamic</span>&gt; route) =&gt; <span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>指将指定的页面加入到路由中，然后将其他所有的页面全部pop, (Route<dynamic> route) &#x3D;&gt;  false将确保删除推送路线之前的所有路线。<br>Push the route with the given name onto the navigator, and then remove all<br>the previous routes until the <code>predicate</code> returns true.</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.of(context).pushNamedAndRemoveUntil(<span class="hljs-string">&#x27;d_router_widget&#x27;</span>, ModalRoute.withName(<span class="hljs-string">&#x27;a_router_widget&#x27;</span>));<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Push the route with the given name onto the navigator, and then remove all<br>the previous routes until the <code>predicate</code> returns true.</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.of(context).maybePop();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>maybePop 会自动进行判断，如果当前页面pop后，会显示其他页面，不会出现问题，则将执行当前页面的pop操作，否则将不执行。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.of(context).canPop();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>判断当前页面能否进行pop操作，并返回bool值</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.of(context).pop();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>直接退出当前页面</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Navigator.popUntil(context, ModalRoute.withName(<span class="hljs-string">&#x27;a_router_widget&#x27;</span>));<br></code></pre></td></tr></table></figure>

<blockquote>
<p>弹出界面，直到遇到第一个名字为给name的路由界面</p>
</blockquote>
<h4 id="命名路由传参"><a href="#命名路由传参" class="headerlink" title="命名路由传参"></a>命名路由传参</h4><p>现在命名路由也支持 参数传递了</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">FlatButton(onPressed: () &#123;<br>              <span class="hljs-built_in">Map</span> arguments = &#123;<br>              <span class="hljs-string">&quot;shareContent&quot;</span>: <span class="hljs-string">&quot;这是分享的内容&quot;</span>,<br>              <span class="hljs-string">&quot;shareImageUrl&quot;</span>: <span class="hljs-string">&quot;这是分享的图片链接&quot;</span>,<br>              <span class="hljs-string">&quot;shareTitle&quot;</span>: <span class="hljs-string">&quot;这是分享的标题&quot;</span><br>              &#125;;<br>              Navigator.of(context).pushNamed(<span class="hljs-string">&quot;c_router_widget&quot;</span>,arguments: arguments).then((value)&#123;<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是B界面打开 c_router_widget 接收到的Value<span class="hljs-subst">$value</span>&quot;</span>);<br>              &#125;);<br>            &#125;, child: Text(<span class="hljs-string">&quot;命名路由C&quot;</span>))<br></code></pre></td></tr></table></figure>

<p>我们在注册路由的时候可以这么写</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-string">&quot;c_router_widget&quot;</span>: (BuildContext context) &#123;<br>          <span class="hljs-built_in">Map</span> arguments = ModalRoute.of(context).settings.arguments;<br>          <span class="hljs-keyword">return</span> CRouterWidget(<br>              shareContent: arguments[<span class="hljs-string">&quot;shareContent&quot;</span>],<br>              shareImageUrl: arguments[<span class="hljs-string">&quot;shareContent&quot;</span>],<br>              shareTitle: arguments[<span class="hljs-string">&quot;shareTitle&quot;</span>]);<br>        &#125;,<br></code></pre></td></tr></table></figure>

<p>也就是使用<code>ModalRoute.of(context).settings.arguments</code>来获取参数，或者在具体界面中获取也一样。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>git工具</title>
    <url>/2017/05/10/git%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>公司代码版本管理系统由svn迁到了git，对于AndroidStudio来讲，内置的GUI工具足以应付日常开发，但在请求失败的情况下，对失败原因的提示不够清晰。个人习惯上用命令行，但是对于命令行中比较两个文件差异以及合并来说，个人还是不大习惯，于是就配置成了使用其他软件进行合并。可以使用<code>$ git difftool --tool-help</code>查看对比文件差异支持的软件，用<code>$ git mergetool --tool-help</code>查看合并代码支持的软件，个人只试过两种:<code>codecompare</code>和<code>beyond compare</code>。不习惯<code>bc</code>的界面，最后决定使用<code>codecompare</code>。</p>
<span id="more"></span>
<h4 id="配置codecompare为diff和merge工具"><a href="#配置codecompare为diff和merge工具" class="headerlink" title="配置codecompare为diff和merge工具"></a>配置codecompare为diff和merge工具</h4><ol>
<li>安装codecompare软件</li>
<li>配置codecompare为diff工具<br> <code>git config --global diff.tool codecompare</code></li>
<li>配置codecompare的路径<code>path 后面是软件的安装路径</code><br> <code>git config --global difftool.codecompare.path D://CodeCompare//CodeCompare.exe</code></li>
<li>配置codecompare为merge工具<br> <code>git config --global merge.tool codecompare</code></li>
<li>配置codecompare的路径<code>path 后面是软件的安装路径</code><br> <code>git config --global mergetool.codecompare.path D://CodeCompare//CodeMerge.exe</code></li>
</ol>
<p>在比较本地修改后的文件与本地仓库中的文件差异时，执行 <code>git difftool &lt;filename&gt;</code>即可。<br><img src="/image/git/git_diff_tool_codecompare.png" alt="codecompare实例"><br>当更新代码自动合并失败的时候，执行 <code>git mergetool</code>即可。<br><img src="/image/git/git_merge_tool_codecompare.png" alt="codecompare实例"></p>
<h4 id="配置beyond-compare为diff和merge工具"><a href="#配置beyond-compare为diff和merge工具" class="headerlink" title="配置beyond compare为diff和merge工具"></a>配置beyond compare为diff和merge工具</h4><p>配置方式和codecompare一样，需要注意的是：</p>
<ol>
<li>如果<code>beyond compare</code>软件是4.X</li>
</ol>
<ol>
<li>如果git的版本低于2.2.0,配置的时候用<code>bc3</code></li>
<li>如果git的版本大于等于2.2.0,配置的时候用<code>bc</code><br>这个如何配置<a href="http://www.scootersoftware.com/support.php?zz=kb_vcs#gitwindows">官网</a>有说明，就不再赘述<br>在比较本地修改后的文件与本地仓库中的文件差异时，执行 <code>git difftool &lt;filename&gt;</code>即可。<br><img src="/image/git/git_diff_tool_bc.png" alt="bc实例"><br>当更新代码自动合并失败的时候，执行 <code>git mergetool</code>即可。<br><img src="/image/git/git_merge_tool_bc.png" alt="bc实例"><br>有人不习惯git自动merge成功后填写merge信息的编辑器，说明一下，默认的编辑器是<code>vim</code>,不习惯用的话可以使用 <code>git config --global core.edit &lt;软件路径&gt;</code>来修改。需要注意的是，git命令行似乎读不到windows系统的path，需要写软件的绝对路径。</li>
</ol>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git版本控制</title>
    <url>/2019/01/27/git%E6%9C%AC%E5%9C%B0%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>版本库也也是仓库，表现为一个目录或者是一个文件夹，这个文件夹里面的所有文件都可以被Git管理起来，文件修改删除也都能被Git记录下来，方便版本控制。</p>
<p> git相关概念简介：</p>
<ul>
<li>工作区：就是存放文件的文件夹。</li>
<li>版本库：可以粗略的理解为 <code>.git</code> 文件夹</li>
<li>版本库中包含一个<code>暂存区</code> 和 多个<code>分支</code>，当我们执行完<code>git init</code> 的时候，系统自动为我们创建了一个<code>master</code> 分支</li>
</ul>
<span id="more"></span>
<h4 id="1-本地版本库"><a href="#1-本地版本库" class="headerlink" title="1 本地版本库"></a>1 本地版本库</h4><h5 id="1-1-创建本地版本库"><a href="#1-1-创建本地版本库" class="headerlink" title="1.1 创建本地版本库"></a>1.1 创建本地版本库</h5><p>   在适当的位置创建一个文件夹，名字随便但最好要有意义，同时不建议文件夹路径中有中文。打开git shell，切换到创建的文件夹中，输入<code>git init</code>，将当前文件夹初始化为git仓库，会发现当前文件夹下多出了一个 <code>.get</code> 文件夹。</p>
<h5 id="1-2-将文件添加到仓库和文件修改"><a href="#1-2-将文件添加到仓库和文件修改" class="headerlink" title="1.2 将文件添加到仓库和文件修改"></a>1.2 将文件添加到仓库和文件修改</h5><p>在当前目录下新建一个文本文档，名字随便，当然要有意义，我新建的是<code>TestGit.txt</code>,新建完之后，我们在 <code>git shell</code>中输入<code>git status</code>来查看工作区的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br><br>No commits yet<br><br>Untracked files:<br>  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)<br><br>        Test.txt<br><br>nothing added to commit but untracked files present (use &quot;git add&quot; to track)<br><br></code></pre></td></tr></table></figure>

<p>注意，<strong>一定要看git返回的提示是否成功</strong>、<strong>一定要看git返回的提示是否成功</strong>、<strong>一定要看git返回的提示是否成功</strong>。</p>
<p> 第一行提示我们现在在 <code>master</code> 这个分支上，下面提示我们有一个文件没有被追踪，可以使用<code>git add fileName</code> 方式添加，我们输入 <code>git add Test.txt</code>,然后再用<code>git status</code>来查看工作区间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br><br>No commits yet<br><br>Changes to be committed:<br>  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)<br><br>        new file:   Test.txt<br><br><br>huangyuan@xuan MINGW64 ~/Desktop/test (master)<br><br></code></pre></td></tr></table></figure>

<p>系统提示已经将该文件添加到暂存区，可以使用 <code>git rm --cached FileName</code>将文件从暂存区删除（这并不会删除你创建的文件，只是删除git版本库中的暂存），接下来可以使用<code>git commit -m “注释”</code> 将暂存区内容提交到到<code>master</code>分支，然后我们再查看工作区状态，发现工作区是干净的:</p>
<figure class="highlight plaintext"><figcaption><span>git status</span></figcaption><table><tr><td class="code"><pre><code class="hljs $">On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure>

<p>我们已经创建并且添加了一个文件到版本仓库，现在修改<code>Test.txt</code>文件，随便写点东西，然后保存，回到git shell，使用<code>git status</code> 查看工作区状态，提示文件已经被修改，可以使用<code>git add fileName</code> 将修改后的文件添加到暂存区，或者使用<code>git checkout -- fileName</code> 将文件返回到修改前的状态（这个修改前的状态是指的上一次提交之后版本库的文件状态），或者使用<code>git diff fileName</code>命令来查看修改了哪些东西：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git status</span><br>On branch master<br>Changes not staged for commit:<br>  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)<br>  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)<br><br>        modified:   Test.txt<br><br>no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)<br></code></pre></td></tr></table></figure>

<p>使用 <code>git add</code>更新将要被commit的文件</p>
<p>使用 <code>git checkout -- Test.txt</code> 命令还原文件状态，会发现文件变回上次提交之后的状态了。</p>
<p>####1.3 版本回退<br>如果我们新建了很多文件，并且都提交到了版本库，现在想要回退到某一个版本，可以使用<code>git log</code>或者<code>git log --graph</code> （<code>git reflog</code> 会记录每一次使用的命令）来查看每一次提交的<code>commitid</code>、<code>Author</code>、<code>Date</code>，我们可以通过<code>git reset --hard commitid</code> 或者 <code>git reset --hard HEAD</code>来将版本回退到某一个特定的版本。</p>
<p>其中 <code>HEAD</code> 表示的是当前版本库中的最新版本，<code>HEAD^</code>表示的是上一个版本，<code>HEAD^^</code>或者<code>HEAD~2</code> 表示的是上上个版本，依此类推。（ps：当使用 <code>commitid</code> 来回退版本的时候，不需要将id全部写出来，只写出前边一部分即可）：</p>
<p>这样的话，工作区的内容也回退到了指定版本的状态。</p>
<p>注意，git reset 参数可以是一下几种</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [&lt;commit&gt;]<br>   or: git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;...<br>   or: EXPERIMENTAL: git reset [-q] [--stdin [-z]] [&lt;tree-ish&gt;]<br>   or: git reset --patch [&lt;tree-ish&gt;] [--] [&lt;paths&gt;...]<br><br>    -q, --quiet           be quiet, only report errors<br>    --mixed               reset HEAD and index<br>    --soft                reset only HEAD<br>    --hard                reset HEAD, index and working tree<br>    --merge               reset HEAD, index and working tree<br>    --keep                reset HEAD but keep local changes<br>    --recurse-submodules[=&lt;reset&gt;]<br>                          control recursive updating of submodules<br>    -p, --patch           select hunks interactively<br>    -N, --intent-to-add   record only the fact that removed paths will be added later<br>    -z                    EXPERIMENTAL: paths are separated with NUL character<br>    --stdin               EXPERIMENTAL: read paths from &lt;stdin&gt;<br></code></pre></td></tr></table></figure>

<h4 id="2-远程仓库"><a href="#2-远程仓库" class="headerlink" title="2 远程仓库"></a>2 远程仓库</h4><h5 id="2-1-创建新仓库"><a href="#2-1-创建新仓库" class="headerlink" title="2.1 创建新仓库"></a>2.1 创建新仓库</h5><p>我们已经在本地创建好了仓库，现在想在远程github上创建一个仓库，是本地仓库和远程仓库可以进行同步，大家也可以协同工作。</p>
<p>打开我们自己的github主页，点击界面上的绿色按钮<code>New repository</code></p>
<p><img src="/image/git/NewRepository.PNG" alt="New repository"></p>
<p>打开创建仓库的界面,如下图所示</p>
<p><img src="/image/git/CreatNewRepository.PNG" alt="Create new repository"></p>
<p> 填入仓库名字（不能和已有仓库名字相同）、描述、权限（私有的貌似要收费）、选择初始化的时候是否创建<code>README</code>文件（Markdown格式）、是否添加<code>gitignore</code>文件、是否添加版权（一般是选 GNU General Public License  或者 Apache License，关于这两个协议，大家可以去网上搜一下），然后点击下面的 <code>Create repository</code>就完成了远程仓库创建（如果这里选择了添加协议，就不由有下面的2.2步骤）</p>
<h5 id="2-2-推送本地文件到远程仓库"><a href="#2-2-推送本地文件到远程仓库" class="headerlink" title="2.2 推送本地文件到远程仓库"></a>2.2 推送本地文件到远程仓库</h5><p>如果我们在创建远程仓库的时候没有选择添加任何文件，那么创建成功的仓库将会是一个空仓库如下图所示：</p>
<p><img src="/image/git/emptyRepository.PNG" alt="empty repository"></p>
<p>如果选择了添加文件不会有上图所示的提示，而是显示仓库里面包含的文件，下面我们将本地仓库和远程仓库关联起来（其实空仓库都有详细的提示，我也只是负责翻译一下）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo # repository name&gt;&gt; README.md<br>git init<br>git add README.md<br>git commit -m &quot;first commit&quot;<br>git remote add origin git@github.com:your name/repository name.git<br>git push -u origin master<br></code></pre></td></tr></table></figure>

<p>第一条命令，创建 <code>README.md</code>文件，并将<code># repository name</code> 写入到文件<br>2,3,4前面介绍过了，关键是5,6,：<br>第五条命令，将本地仓库和你自己的远程仓库关联起来，<code>origin</code>是本地别名，后面的是远程仓库的地址<br>第六条命令，将本地仓库的文件推送到远程仓库<br>如果在本地有建立好的仓库，可以切换到仓库目录，执行第五第六条命令。<br>如果选择了添加文件，但是本地没有仓库，可以点击仓库页面右下角的 <code>Download ZIP</code>按钮，下载远程仓库到本地，然后切换到仓库目录，这时就不需要关联仓库了。不想点击按钮下载的话可以使用 <code>git clone</code>命令，格式如下：<br><code>git clone git@github.com:your name/repository name.git</code></p>
<h4 id="3-github分支"><a href="#3-github分支" class="headerlink" title="3 github分支"></a>3 github分支</h4><p>在git中，每当我们<code>commit</code>的时候，git将会把提交的时间串成一条线，这条线就是一个分支，也就是主分支，也叫<code>master</code>分支（默认情况下）。严格来说，<code>HEAD</code>并没有指向提交，而是指向了<code>master</code>，<code>master</code>指向的提交。每次提交的时候，<code>master</code>就会将当前提交时间串在时间线上，并且指向当前时间点，随着不断的提交，	<code>master</code>分支也越来越长，当我们使用<code>git log</code>命令的时候，查看到的就是这条时间线。</p>
<h5 id="3-1-分支管理"><a href="#3-1-分支管理" class="headerlink" title="3.1 分支管理"></a>3.1 分支管理</h5><p>当我们创建一个新的分支，比如叫 <code>dev</code>，现在<code>dev</code>指向的提交就是<code>master</code>指向的提交，但是<code>HEAD</code>现在指向<code>dev</code>，现在我们再提交的时候就是提交在<code>dev</code>分支了，而<code>master</code>分支不变。当我们在<code>dev</code>分支上完成开发工作，检查无误后，就可以将<code>dev</code>分支合并(merge)<code>master</code>分支上了。<br>应用场景：当我们的软件开发完成1.0版本后，现在有了新的需求，要开发2.0版本。但不幸的是，在开发到一半的时候，1.0版本发现了几个bug，没办法，改吧，但是我们显然不能再现在的工程基础上修改，如果在现在工程上修改的话，1.0版本的软件将会带有部分2.0版本的特性或者功能，成了1.5版本。这时候，我们在完成1.0版本后，就可以新建一个分支，在新的分支上进行新的开发，在确认完成后，再合并到主分支。<br>操作如下：</p>
<p><code>git checkout -b dev</code></p>
<p><code>-b</code>参数表示创建并切换到新的分支，相当于下面两条命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git branch dev<br>git checkout dev<br></code></pre></td></tr></table></figure>

<p>然后使用<code>git branch</code>命令查看所有的分支，在当前所在的分支上会有<code>*</code>提示.</p>
<p>现在我们处于<code>dev</code>分支下，<code>Test.txt</code>文件里面没有任何内容，对<code>Test.txt</code>进行修改并提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git add Test.txt<br>git commit -m &quot;branch test&quot;<br></code></pre></td></tr></table></figure>

<h5 id="3-2-合并分支"><a href="#3-2-合并分支" class="headerlink" title="3.2 合并分支"></a>3.2 合并分支</h5><p>然后切换到<code>master</code>分支，再去查看<code>Test.txt</code>文件中的内容，并不是和<code>dev</code>分子相同。这是因为我们提交的内容在<code>dev</code>分支上，<code>master</code>分支并没有做什么改变。</p>
<p>然后对两个分支进行合并,合并完成后删除<code>dev</code>分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git merge dev<br>git branch -d dev<br></code></pre></td></tr></table></figure>
<p>合并完成后发现<code>Test.txt</code>文件内容与<code>dev</code>分支下的完全相同。</p>
<h5 id="3-3-合并时的冲突"><a href="#3-3-合并时的冲突" class="headerlink" title="3.3 合并时的冲突"></a>3.3 合并时的冲突</h5><p>不幸的是，没有什么是一帆风顺的，合并时遇到了冲突怎么办？系统给出了这么个提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">D:\GitRepositorys [master]&gt; git merge dev<br>warning: Cannot merge binary files: Test.txt (HEAD vs<br>Auto-merging Test.txt<br>CONFLICT (content): Merge conflict in Test.txt<br>Automatic merge failed; fix conflicts and then commit<br>D:\GitRepositorys [master +0 ~0 -0 !1 | +0 ~0 -0 !1]&gt;<br></code></pre></td></tr></table></figure>

<p>这个冲突貌似只能手动修改(借助一些工具比如beyond compile)，打开冲突的文件，查看冲突提示，手动修改完成后再提交、合并<br>（其实我也不大懂，只是建议不要在两个分支上同时修改同一个文件）</p>
<h4 id="4-常用分支管理策略"><a href="#4-常用分支管理策略" class="headerlink" title="4 常用分支管理策略"></a>4 常用分支管理策略</h4><h5 id="4-1-分支合并模式"><a href="#4-1-分支合并模式" class="headerlink" title="4.1   分支合并模式"></a>4.1   分支合并模式</h5><p>通常情况下，git在合并分支的时候会用<code>Fast forward</code>模式，但是在这种模式下，删除分支后，会丢掉分支信息，也就是分支提交的信息，如果强制禁用<code>Fast forward</code>模式，git在葛冰分支的时候会生成一个新的<code>commit</code>，语法格式如下（将dev分支合并到master分支上）：<br><code>git merge --no-ff -m &quot;禁用Fast forward 模式合并分支&quot; dev</code></p>
<h5 id="4-2-分支策略"><a href="#4-2-分支策略" class="headerlink" title="4.2 分支策略"></a>4.2 分支策略</h5><p>首先，<code>master</code>分支是非常稳定的，也就是仅仅用来发布新的版本。<br>其次，从<code>master</code>分支上创建一个新的分支（dev），每个开发人员都有自己的分支（从dev分支上创建的），推送代码时只要将自己的分支和dev分支合并就可以了，<br>最后，当药发布新版本时，只需要将dev分支合并到master分支就可以了</p>
<h5 id="4-3-bug分支"><a href="#4-3-bug分支" class="headerlink" title="4.3 bug分支"></a>4.3 bug分支</h5><p>当你正在进行开发时，突然间发现了以前的一个bug，需要立刻修复，但是你现在的开发工作还没有完成，没有办法提交，git提供了一个<code>stash</code>功能，可以把当前场景保存起来，等以后可以恢复现场：<code>git stash</code>，现在用<code>git status</code>查看工作区，是干净的了，可以创建一个新的分支（首先要确定从哪个分支上修复bug），修复完成后，合并并删除bug分支。<br>现在我们需要恢复现场，使用<code>git stash list</code>命令来查看保存了哪些现场，恢复现场有两种方式，一是用<code>git stash apply stash@&#123;NUM&#125;</code> 或者是用<code>git stash pop</code>，区别是前者不会删除stash，恢复现场后需要收到执行 <code>git stash drop</code>来删除。当然，也可以多次stash然后使用<code>git stash apply stash@&#123;num&#125;</code>来恢复指定的现场。</p>
<h4 id="5-多人协作"><a href="#5-多人协作" class="headerlink" title="5. 多人协作"></a>5. 多人协作</h4><h5 id="5-1-克隆仓库"><a href="#5-1-克隆仓库" class="headerlink" title="5.1 克隆仓库"></a>5.1 克隆仓库</h5><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>
<p>要查看远程库的信息，用g<code>it remote：</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git remote<br>origin<br></code></pre></td></tr></table></figure>
<p>或者，用<code>git remote -v</code>显示更详细的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">$ git remote -v<br>origin  git@github.com:michaelliao/learngit.git (fetch)<br>origin  git@github.com:michaelliao/learngit.git (push)<br></code></pre></td></tr></table></figure>
<p>上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p>
<h5 id="5-2-推送分支"><a href="#5-2-推送分支" class="headerlink" title="5.2 推送分支"></a>5.2 推送分支</h5><p>推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：<br><code>$ git push origin master</code><br>如果要推送其他分支，比如dev，就改成：<br><code>$ git push origin dev</code></p>
<p>其中<code>origin</code>就是上篇文章中提到的<code>本地别名</code></p>
<h5 id="5-3-抓取分支"><a href="#5-3-抓取分支" class="headerlink" title="5.3 抓取分支"></a>5.3 抓取分支</h5><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。当我们从远程仓库克隆的时候，我们只能看到本地<code>master</code>分支，如果我们要在其他分支上开发，就必须创建<code>origin</code>的其他分支到本地，或者说建立远程分支和本地分支的关联:<br><code>git checkout -b dev origin/dev</code>,然后，我们就可以在<code>dev</code>分支上继续修改，然后将修改后的项目推送到远程</p>
<h4 id="6-标签管理"><a href="#6-标签管理" class="headerlink" title="6. 标签管理"></a>6. 标签管理</h4><h5 id="6-1-创建标签"><a href="#6-1-创建标签" class="headerlink" title="6.1 创建标签"></a>6.1 创建标签</h5><p>首先切换到需要打标签的分支上，<code>git checkout branch-name</code>,<br>然后使用命令<code>git tag &lt;name&gt;</code>就可以了，默认标签是打在最新提交上的，如果我们想要打在以前的提交上，可以使用<code>git log</code>查看以前提交的commit id，然后使用<code>git tag &lt;name&gt; &lt;commit id&gt;</code>就可以了。可以使用命令<code>git tag</code>查看标签，但是标签不是按照时间顺序排序的，而是按照字母顺序排序。在打标签的时候可以带有说明，语法格式如下：<br><code>git tag -a &lt;tag-name&gt; -m &quot;comment&quot; &lt;commit id&gt;</code><br>使用命令<code>git show &lt;tag-name&gt;</code>可以查看详细信息。</p>
<h5 id="6-2-删除标签"><a href="#6-2-删除标签" class="headerlink" title="6.2 删除标签"></a>6.2 删除标签</h5><p>如果标签打错了，可以使用<code>git tag -d &lt;tag-name&gt;</code>来删除指定的标签，默认情况下，标签不会自动推送到远程。如果想把某个标签推送到远程，可以使用<code>git push origin &lt;tag-name&gt;</code>，或者一次性推送所有本地的标签:<code>git push origin --tags</code>,如果标签已经推送的远程仓库，想要删除远程仓库的标签需要如下两步:<br>首先删除本地标签 <code>git tag -d  &lt;tag-name&gt;</code><br>然后从远程删除 <code>git push origin :refs/tags/&lt;tag-name&gt;</code></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>运维</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle-java插件</title>
    <url>/2018/12/19/gradle-java%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>当我们使用java插件时，只需要在gradle文件中应用<code>apply plugin :&#39;java&#39;</code>一下 就好了，插件中有很多默认的配置，比如源代码位置在<code>src/main/java</code>，<code>src/test/java</code>是单元测试用例的存放目录，<code>src/main/resources</code>是要打包的文件存放目录，比如配置文件和图片等。当然我们也可以改变java插件的默认配置，只需要在<code>build.gradle</code>中配置对应目录即可。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">sourceSets&#123;<br>    main&#123;<br>        java&#123;<br>            srcDir <span class="hljs-string">&#x27;src/java&#x27;</span><br>        &#125;<br>        resources&#123;<br>            srcDir <span class="hljs-string">&#x27;src/resources&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一般我们在IDEA中导入eclipse项目的时候可以暂时这样配置。</p>
<span id="more"></span>

<h4 id="配置第三方依赖"><a href="#配置第三方依赖" class="headerlink" title="配置第三方依赖"></a>配置第三方依赖</h4><p>要想使用三方依赖，首先要告诉Gradle从哪里找到这些依赖，一般我们从某个仓库中查找我们需要的jar包，所以我们应该配置使用什么类型的仓库：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">repositories&#123;<br>    mavenCentral()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面配置了一个Maven中央仓库，告诉Gradle可以在Maven中央仓库中查找我们依赖的jar，此外，我们也可以从jcenter、ivy、本地Maven库、自己搭建的Maven仓库查找：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">repositories&#123;<br>    mavenCentral()<br>    maven&#123;<br>        url <span class="hljs-string">&quot;http://mymaven.com&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有了仓库，我们就可以使用我们的依赖了</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">dependencies&#123;<br>    compile <span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;com.squareup.okhttp3&#x27;</span>,<span class="hljs-attr">name:</span><span class="hljs-string">&#x27;okhttp&#x27;</span>,<span class="hljs-attr">version:</span><span class="hljs-string">&#x27;3.0.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">dependencies&#123;<br>    compile <span class="hljs-string">&#x27;com.squareup.okhttp3:okhttp:3.0.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>此外，java插件可以为不同的源集在编译时指定不同的依赖，比如main源集指定一个编译时依赖，vip源集可以指定另外一个不同的依赖：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">dependencies&#123;<br>    mainCompile <span class="hljs-string">&#x27;com.squareup.okhttp3:okhttp:3.0.1&#x27;</span><br>    vipCompile <span class="hljs-string">&#x27;com.squareup.okhttp3:okhttp:2.5.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>依赖还可以是一个子项目(module):</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">dependencies&#123;<br>    compile project (<span class="hljs-string">&#x27;:module&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>依赖还可以是一个文件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">dependencies&#123;<br>    compile file (<span class="hljs-string">&#x27;libs/xxx.jar&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当我们依赖的jar包较多时，可以这么写</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">dependencies&#123;<br>    compile fileTree(<span class="hljs-attr">dir:</span> <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-attr">include:</span> [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="源码集合-SourceSet"><a href="#源码集合-SourceSet" class="headerlink" title="源码集合(SourceSet)"></a>源码集合(SourceSet)</h4><p>SourceSet–源代码集合–源集，是Java插件来描述和管理源代码及其资源的一个抽象概念，是一个Java源代码文件和资源文件的合集。</p>
<p>有了源集，我们就能针对不同的业务和应用对我们的源码进行分组。Java插件在Project下为我们提供了一个sourceSet属性以及一个sourceSet{}闭包来访问和配置源集</p>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">String</td>
<td align="left">只读，比如main</td>
</tr>
<tr>
<td align="left">output.classesDir</td>
<td align="left">File</td>
<td align="left">该源集编译后的class文件目录</td>
</tr>
<tr>
<td align="left">output.resourcesDir</td>
<td align="left">File</td>
<td align="left">编译后生成的资源目录</td>
</tr>
<tr>
<td align="left">compileClasspath</td>
<td align="left">FileCollection</td>
<td align="left">编译该源集时所需要的classpath</td>
</tr>
<tr>
<td align="left">java</td>
<td align="left">SourceDirectorySet</td>
<td align="left">该源集的java源文件</td>
</tr>
<tr>
<td align="left">java.srcDir</td>
<td align="left">Set</td>
<td align="left">该源集的Java源文件所在目录</td>
</tr>
<tr>
<td align="left">resources</td>
<td align="left">SourceDirectorySet</td>
<td align="left">该源集的资源文件</td>
</tr>
<tr>
<td align="left">resources.srcDir</td>
<td align="left">Set</td>
<td align="left">该源集的资源文件所在目录</td>
</tr>
</tbody></table>
<h4 id="发布构件"><a href="#发布构件" class="headerlink" title="发布构件"></a>发布构件</h4><p>Gradle构建的产物，我们称之为构件，一个构件可以是一个jar包，也可以是一个zip或者war包。想要发布构件，需要先定义发布什么样的构件。下面以发布一个Jar构件为例：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span><span class="hljs-string">&#x27;java&#x27;</span><br>task publishJar(<span class="hljs-attr">type:</span>Jar)<br>version <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>artifacts &#123;<br>    archives publishJar<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发布的构件是通过<code>artifacts&#123;&#125;</code>闭包配置的，例子中我们通过一个Task来为我们发布提供构件，除了使用Task之外，还可以 直接发布一个文件对象：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> publishFile = file(<span class="hljs-string">&#x27;build/buildile&#x27;</span>)<br>artifacts &#123;<br>    archives publishFile<br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置好需要发布的构件后就可以发布，就是把你的构件上传到一个指定的目录、仓库等</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span><span class="hljs-string">&#x27;java&#x27;</span><br><br>task publishJar(<span class="hljs-attr">type:</span>Jar)<br><br>version <span class="hljs-string">&#x27;1.0.0&#x27;</span><br><br>artifacts &#123;<br>    archives publishJar<br>&#125;<br><br>uploadArchives&#123;<br>    repositories &#123;<br>        flatDir&#123;<br>            name <span class="hljs-string">&#x27;libs&#x27;</span><br>            dirs <span class="hljs-string">&quot;$projectDir/libs&quot;</span><br>        &#125;<br>        mavenLocal()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>uploadArchives</code>是一个UploadTask，用于上传发布我们的构件，上面的配置是发布到我们当前项目的libs目录和本地的Maven库(mavenLocal())，当你执行<code>uploadArchives</code>任务后，可以在用户目录下的<code>.m2/repository</code>文件夹下找到它。</p>
<p>假如我们要上传到自己公司搭建的Nexus私服为例：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span><span class="hljs-string">&#x27;java&#x27;</span><br>apply <span class="hljs-attr">plugin:</span><span class="hljs-string">&#x27;maven&#x27;</span><br><br>task publishJar(<span class="hljs-attr">type:</span>Jar)<br><br>group <span class="hljs-string">&#x27;com.company.projectName&#x27;</span><br>version <span class="hljs-string">&#x27;3.1415&#x27;</span><br><br>artifacts &#123;<br>    archives publishJar<br>&#125;<br><br><span class="hljs-keyword">def</span> publishFile = file(<span class="hljs-string">&#x27;build/buildile&#x27;</span>)<br>artifacts &#123;<br>    archives publishFile<br>&#125;<br><br><br>uploadArchives&#123;<br>    repositories &#123;<br>        flatDir&#123;<br>            name <span class="hljs-string">&#x27;libs&#x27;</span><br>            dirs <span class="hljs-string">&quot;$projectDir/libs&quot;</span><br>        &#125;<br>        mavenLocal()<br>        mavenDeployer&#123;<br>            repository(<span class="hljs-attr">url:</span> <span class="hljs-string">&quot;http://repo.mycompany.com/nexus/content/repositories/release&quot;</span>)&#123;<br>                authentication(<span class="hljs-attr">userName:</span><span class="hljs-string">&#x27;userName&#x27;</span>,<span class="hljs-attr">password:</span><span class="hljs-string">&#x27;pwd&#x27;</span>)<br>            &#125;<br>            snapshotRepository(<span class="hljs-attr">url:</span> <span class="hljs-string">&quot;http://repo.mycompany.com/nexus/content/repositories/snapshot&quot;</span>)&#123;<br>                authentication(<span class="hljs-attr">userName:</span><span class="hljs-string">&#x27;userName&#x27;</span>,<span class="hljs-attr">password:</span><span class="hljs-string">&#x27;pwd&#x27;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里引用了一个maven插件，它对Maven的发布构件支持的非常好，可以直接配置release和snapshot库。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle-android插件</title>
    <url>/2018/12/22/gradle-android%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>Android Gradle插件可以分为三类，分别对应Android中的三类工程：</p>
<ul>
<li>App应用工程，它可以生成一个可运行的apk应用，对应插件id：com.android.application</li>
<li>Library库工程，可以生成AAR包给其他工程使用，对用插件id:com.android.library</li>
<li>test测试工程，对App工程或者Library库工程进行单元测试，对应插件id：com.android.test</li>
</ul>
<p>通过配置不同的插件，配合AS，就可以进行编译测试发布等操作</p>
<span id="more"></span>

<h4 id="应用Android插件"><a href="#应用Android插件" class="headerlink" title="应用Android插件"></a>应用Android插件</h4><p>Android Gradle插件属于第三方插件，托管在Jcenter上，所以在应用之前，我们需要先配置classpath，</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    repositories &#123;<br>        jcenter()<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&#x27;com.android.tools.build:gradle:3.1.3&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们配置仓库为jcenter，这样当我们配置依赖的时候，Gradle就会去这个仓库里寻找我们的依赖，然后我们在dependencies{}中依赖Android插件。</p>
<p>buildscript{}这部分配置了可以写到根工程的build.gradle脚本文件中，这样所有的自工程就不用重复配置了，之后就可以应用Android Gradle插件了</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br>android &#123;<br>    compileSdkVersion <span class="hljs-number">28</span><br>    defaultConfig &#123;<br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">28</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&quot;1.0&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>android{}是Android插件提供的一个扩展类型，可以让我们自定义Android Gradle工程。compileSdkVersion是编译所依赖的Android SDK的版本</p>
<h4 id="Android-Gradle-工程示例"><a href="#Android-Gradle-工程示例" class="headerlink" title="Android Gradle 工程示例"></a>Android Gradle 工程示例</h4><p>Android Gradle插件继承于Java插件，具有所有的Java插件的特性。对于一个Android应用 ，常见的build.gradle文件内容如下</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.android.application&#x27;</span><br><br>android &#123;<br>    compileSdkVersion <span class="hljs-number">28</span><br>    buildToolsVersion <span class="hljs-string">&quot;28.0.3&quot;</span><br>    defaultConfig &#123;<br>        applicationId <span class="hljs-string">&quot;com.huangyuanlove.testandroid&quot;</span><br>        minSdkVersion <span class="hljs-number">19</span><br>        targetSdkVersion <span class="hljs-number">28</span><br>        versionCode <span class="hljs-number">1</span><br>        versionName <span class="hljs-string">&quot;1.0&quot;</span><br>        testInstrumentationRunner <span class="hljs-string">&quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br>    &#125;<br>    buildTypes &#123;<br>        release &#123;<br>            minifyEnabled <span class="hljs-literal">false</span><br>            proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>dependencies &#123;<br>    implementation fileTree(<span class="hljs-attr">dir:</span> <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-attr">include:</span> [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<br>    implementation <span class="hljs-string">&#x27;com.android.support:appcompat-v7:28.0.0-rc01&#x27;</span><br>    implementation <span class="hljs-string">&#x27;com.android.support.constraint:constraint-layout:1.1.2&#x27;</span><br>    implementation <span class="hljs-string">&#x27;com.android.support:design:28.0.0-rc01&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;junit:junit:4.12&#x27;</span><br>    androidTestImplementation <span class="hljs-string">&#x27;com.android.support.test:runner:1.0.2&#x27;</span><br>    androidTestImplementation <span class="hljs-string">&#x27;com.android.support.test.espresso:espresso-core:3.0.2&#x27;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Android Gradle工程的配置，都是在android{}中，这是唯一的一个入口。通过它，可以对Android Gradle工程进行自定义的配置，其具体实现是<code>com.android.build.gradle.AppExtension</code>，所以很多Android配置可以从这个类里去找，</p>
<h5 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h5><p>compileSdkVersion 28是配置我们编译Android工程的SDK，这里的23是Android SDK的API Level，该配置的原形是一个compileSdkVersion方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** <span class="hljs-doctag">@see</span> #getCompileSdkVersion() */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compileSdkVersion</span><span class="hljs-params">(String version)</span> &#123;<br>        checkWritability();<br>        <span class="hljs-built_in">this</span>.target = version;<br>    &#125;<br><br>    <span class="hljs-comment">/** <span class="hljs-doctag">@see</span> #getCompileSdkVersion() */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compileSdkVersion</span><span class="hljs-params">(<span class="hljs-type">int</span> apiLevel)</span> &#123;<br>        compileSdkVersion(<span class="hljs-string">&quot;android-&quot;</span> + apiLevel);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompileSdkVersion</span><span class="hljs-params">(<span class="hljs-type">int</span> apiLevel)</span> &#123;<br>        compileSdkVersion(apiLevel);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCompileSdkVersion</span><span class="hljs-params">(String target)</span> &#123;<br>        compileSdkVersion(target);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>在gradle中，方法的括号可以省略，同时我们也注意到了String类型的重载方法和两个<code>setCompileSdkVersion</code>方法，完全可以按照这四种方式来进行配置。</p>
<h5 id="buildToolsVersion"><a href="#buildToolsVersion" class="headerlink" title="buildToolsVersion"></a>buildToolsVersion</h5><p><code>buildToolsVersion &quot;28.0.3&quot;</code>表示我们使用的Android构建工具的版本。它的原形也是一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildToolsVersion</span><span class="hljs-params">(String version)</span> &#123;<br>        checkWritability();<br>        <span class="hljs-comment">//The underlying Revision class has the maven artifact semantic,</span><br>        <span class="hljs-comment">// so 20 is not the same as 20.0. For the build tools revision this</span><br>        <span class="hljs-comment">// is not the desired behavior, so normalize e.g. to 20.0.0.</span><br>        buildToolsRevision = Revision.parseRevision(version, Revision.Precision.MICRO);<br>    &#125;<br><br>    <span class="hljs-comment">/** &#123;<span class="hljs-doctag">@inheritDoc</span>&#125; */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBuildToolsVersion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buildToolsRevision.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBuildToolsVersion</span><span class="hljs-params">(String version)</span> &#123;<br>        buildToolsVersion(version);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>我们可以通过buildToolsVersion方法赋值，也可以通过android.buildToolsVersion这个属性读写它的值。</p>
<h5 id="defaultConfig"><a href="#defaultConfig" class="headerlink" title="defaultConfig"></a>defaultConfig</h5><p>defaultConfig是默认的配置，它是一个ProductFlavor。ProductFlavor允许我们根据不同的情况同时生成多个不同的APK包。如果不针对我们自定义的ProductFlavor单独配置的话，会为这个ProductFlavor使用默认的defaultConfig的配置。里面的属性就不再一一解释。</p>
<h5 id="buildTypes"><a href="#buildTypes" class="headerlink" title="buildTypes"></a>buildTypes</h5><p>buildTypes是一个NamedDomainObjectContainer类型，是一个域对象。我们可以在buildTypes{}里面新增任意多个我们需要构建的类型，Gradle会帮我们自动创建一个对应的BuildType，名字就是我们定义的名字。</p>
<ul>
<li><p>上面的 release就是一个BuildType。</p>
</li>
<li><p>minifyEnabled是否为该构建类型启用混淆，false表示不启用，true表示启用</p>
</li>
<li><p>proguardFiles，当我们启用混淆时，所使用proguard的配置文件，我们可以通过它配置混淆规则。它对应BuildType的proguardFiles方法，接受一个可变参数，所以我们同时可以配置多个配置文件。<br><code>getDefaultProguardFile</code>是Android扩展的一个方法，它可以读取你的AndroidSDK目录下默认的proguard配置文件。</p>
<h4 id="Android-Gradle任务"><a href="#Android-Gradle任务" class="headerlink" title="Android Gradle任务"></a>Android Gradle任务</h4></li>
<li><p>connectedCheck 在所有连接的设备或者模拟器上运行check检查。</p>
</li>
<li><p>devicesCheck 通过API连接远程设备运行checks。</p>
</li>
<li><p>lint在所有的ProductFlavor上运行lint检查。</p>
</li>
<li><p>install和uninstall类的任务可以直接在我们已连接的设备上安装或者卸载你的app。</p>
</li>
<li><p>signingReport可以打印App的签名</p>
</li>
<li><p>AndroidDependencies可以打印Android的依赖<br>还有一些其他类似的任务，可以通过.&#x2F;gradlew tasks 来查看</p>
</li>
</ul>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle任务</title>
    <url>/2018/11/19/gradle%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>参考《Android Gradle 权威指南》第四章Gradle任务，主要介绍任务的创建方式、访问任务、任务分组和描述、&lt;&lt;操作符、任务的执行分析、任务排序、启用和禁用、断言、规则等。</p>
<span id="more"></span>

<h4 id="任务的创建方式"><a href="#任务的创建方式" class="headerlink" title="任务的创建方式"></a>任务的创建方式</h4><h5 id="直接以任务名的方式创建"><a href="#直接以任务名的方式创建" class="headerlink" title="直接以任务名的方式创建"></a>直接以任务名的方式创建</h5><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> Task temp = task(createTaskByName)<br>temp.doLast &#123;<br>    println <span class="hljs-string">&quot;原型为 Task task(String name) throws InvalidUserDataException&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码中的<code>createTaskByName</code>就是我们创建的任务，可以通过<code>gradle -q createTaskByName</code>来执行这个任务。这种创建方式本质就上就是调用<code>Project</code>的<code>task(String name)</code>方法来创建任务，然后将<code>Task</code>类型的返回值赋值给我们定义的temp变量，最后通过<code>doLast</code>方式来配置任务。</p>
<h5 id="任务名字-任务配置的Map对象"><a href="#任务名字-任务配置的Map对象" class="headerlink" title="任务名字+任务配置的Map对象"></a>任务名字+任务配置的Map对象</h5><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> Task temp = task(createTaskByName,<span class="hljs-attr">group:</span> <span class="hljs-string">&#x27;custom&#x27;</span>)<br>temp.doLast &#123;<br>    println <span class="hljs-string">&quot;原型为 Task task(String name) throws InvalidUserDataException&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>和第一种方式大同小异，只是多了一个Map参数用以对task进行配置，比如上面的代码指定了该task所属的group，当我们在执行 <code>gradle -q tasks --all</code>就可以在对应的group中找到该任务。下面列出的是可用配置：</p>
<table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">type</td>
<td align="center">基于一个存在的Task来创建，类似继承</td>
<td align="center">DefaultTask</td>
</tr>
<tr>
<td align="center">overwirte</td>
<td align="center">是否替换存在的Task，可以和type配合使用</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">dependsOn</td>
<td align="center">用于配置任务依赖</td>
<td align="center">[]</td>
</tr>
<tr>
<td align="center">action</td>
<td align="center">添加到任务中的一个action或者一个闭包</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">description</td>
<td align="center">任务描述</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">group</td>
<td align="center">任务分组</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h5 id="任务名字-闭包形式"><a href="#任务名字-闭包形式" class="headerlink" title="任务名字+闭包形式"></a>任务名字+闭包形式</h5><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">task temp &#123;<br>    description <span class="hljs-string">&quot;这是任务名字+闭包形式创建任务&quot;</span><br>    doLast &#123;<br>    	println <span class="hljs-string">&quot;通过任务名字+闭包形式创建任务&quot;</span><br>    	println <span class="hljs-string">&quot;$&#123;description&#125;&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为Map的方式所能配置的信息有限，所以常见的创建任务是已这种方式进行，或者调用tasks.create方法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">tasks.create(<span class="hljs-string">&#x27;temp&#x27;</span>)&#123;<br>description <span class="hljs-string">&quot;这是任务名字+闭包形式创建任务&quot;</span><br>    doLast &#123;<br>    println <span class="hljs-string">&quot;通过任务名字+闭包形式创建任务&quot;</span><br>    println <span class="hljs-string">&quot;$&#123;description&#125;&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="访问任务"><a href="#访问任务" class="headerlink" title="访问任务"></a>访问任务</h4><ol>
<li>通过任务名字访问</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">task temp&#123;&#125;<br><span class="hljs-comment">//第一种方式</span><br>temp.doLast&#123;&#125;<br><span class="hljs-comment">//第二种方式</span><br>tasks[<span class="hljs-string">&#x27;temp&#x27;</span>].doLast&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>访问的时候，任务名就是key,这里说法有点不恰当，因为tasks并不是一个map，<code>[]</code>在groovy中是一个操作符，在groovy中的操作符都有对应的方法让我们重载，<code>a[b]</code>对应的是<code>a.getAt(b)</code>这个方法，对应上面的代码<code>tasks[&#39;temp&#39;]</code>其实是调用的<code>tasks.getAt(&#39;temp&#39;)</code>这个方法，在<code>gradle</code>源码中，发现调用的是<code>findByName(String name)</code>实现的。</p>
<p>然后就是通过路径访问，有两种方式，一种是<code>get</code>，一种是<code>find</code>，区别在于使用<code>get</code>的时候如果找不到该任务就是抛出<code>UnknownTaskException</code>，而find则会返回<code>null</code>.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">task temp<br>tasks[<span class="hljs-string">&#x27;temp&#x27;</span>].doLast&#123;<br>    println tasks.findByPath(<span class="hljs-string">&#x27;temp&#x27;</span>)<br>    println tasks.getByPath(<span class="hljs-string">&#x27;temp&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后就是通过名称访问，方式、区别和上面通过路径访问是一样的。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">task temp<br>tasks[<span class="hljs-string">&#x27;temp&#x27;</span>].doLast&#123;<br>    println tasks.findByName(<span class="hljs-string">&#x27;temp&#x27;</span>)<br>    println tasks.getByName(<span class="hljs-string">&#x27;temp&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>需要注意的是，通过路径访问的时候，参数值可以是路径值也可以是任务名字,但是通过名字访问的时候，参数值只能是任务的名字，不能为路径。</p>
<h4 id="lt-lt-操作符"><a href="#lt-lt-操作符" class="headerlink" title="&lt;&lt;操作符"></a>&lt;&lt;操作符</h4><p><code>&lt;&lt;</code>操作符在Gradle的Task上是doLast方法的短标记形式。</p>
<p><code>&lt;&lt;</code>是操作符，在Groovy中是可以重载的，<code>a&lt;&lt;b</code>对应的是<code>a.leftShift(b)</code>方法，所以Task接口中肯定有同一个leftShift方法重载的<code>&lt;&lt;</code>，在Gradle源码中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Task.java<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;p&gt;Adds the given closure to the end of this task&#x27;s action list.  The closure is passed this task as a parameter</span><br><span class="hljs-comment">     * when executed. You can call this method from your build script using the &amp;lt;&amp;lt; left shift operator.&lt;/p&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> action The action closure to execute.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> This task.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@deprecated</span> Use &#123;<span class="hljs-doctag">@link</span> #doLast(Closure action)&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Deprecated</span><br>    Task <span class="hljs-title function_">leftShift</span><span class="hljs-params">(Closure action)</span>;<br></code></pre></td></tr></table></figure>

<p>leftShift方法和doLast方法实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Task <span class="hljs-title function_">leftShift</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Closure action)</span> &#123;<br>       DeprecationLogger.nagUserOfDiscontinuedMethod(<span class="hljs-string">&quot;Task.leftShift(Closure)&quot;</span>, <span class="hljs-string">&quot;Please use Task.doLast(Action) instead.&quot;</span>);<br><br>       hasCustomActions = <span class="hljs-literal">true</span>;<br>       <span class="hljs-keyword">if</span> (action == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidUserDataException</span>(<span class="hljs-string">&quot;Action must not be null!&quot;</span>);<br>       &#125;<br>       taskMutator.mutate(<span class="hljs-string">&quot;Task.leftShift(Closure)&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>               getTaskActions().add(taskMutator.leftShift(convertClosureToAction(action, <span class="hljs-string">&quot;doLast &#123;&#125; action&quot;</span>)));<br>           &#125;<br>       &#125;);<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Task <span class="hljs-title function_">doLast</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Closure action)</span> &#123;<br>        hasCustomActions = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (action == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidUserDataException</span>(<span class="hljs-string">&quot;Action must not be null!&quot;</span>);<br>        &#125;<br>        taskMutator.mutate(<span class="hljs-string">&quot;Task.doLast(Closure)&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                getTaskActions().add(convertClosureToAction(action, <span class="hljs-string">&quot;doLast &#123;&#125; action&quot;</span>));<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="任务执行分析"><a href="#任务执行分析" class="headerlink" title="任务执行分析"></a>任务执行分析</h4><p>当我们在执行一个Task的时候，其实就是执行其拥有的actions列表，这个列表保存在Task对象实例中的actions成员变量中，在<code>AbstractTask</code>类中有这么一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> List&lt;ContextAwareTaskAction&gt; <span class="hljs-title function_">getTaskActions</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">if</span> (actions == <span class="hljs-literal">null</span>) &#123;<br>           actions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;ContextAwareTaskAction&gt;(<span class="hljs-number">3</span>);<br>       &#125;<br>       <span class="hljs-keyword">return</span> actions;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>我们写个demo来看一下actions怎么工作的</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">Task myTask = task test(<span class="hljs-attr">type :</span> CustomTask)<br><br>myTask.doFirst &#123;<br>    println <span class="hljs-string">&quot;doFirst&quot;</span><br>&#125;<br><br>myTask.doLast &#123;<br>    println <span class="hljs-string">&quot;doLast&quot;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultTask</span>&#123;<br><br>    <span class="hljs-meta">@TaskAction</span><br>    <span class="hljs-keyword">def</span> doSelf()&#123;<br>        println <span class="hljs-string">&quot;执行doSelf&quot;</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面代码定义了一个Task类型的CustomTask，并且声明了一个被<code>TaskAction</code>注解标准的<code>doSelf</code>方法。意思是该方法就是Task本身执行的方法，执行<code>test</code>任务，得到输出</p>
<blockquote>
<p>doFirst<br>执行doSelf<br>doLast</p>
</blockquote>
<p>我们可以看一下具体源码怎么写的</p>
<p>当我们使用Task方法创建一个task的时候，Gradle会解析其带有TaskAction标注的方法作为其Task执行的Action，然后通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prependParallelSafeAction</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Action&lt;? <span class="hljs-built_in">super</span> Task&gt; action)</span> &#123;<br>       <span class="hljs-keyword">if</span> (action == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidUserDataException</span>(<span class="hljs-string">&quot;Action must not be null!&quot;</span>);<br>       &#125;<br>       getTaskActions().add(<span class="hljs-number">0</span>, wrap(action));<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>添加到actions list里面。这时候Task刚被创建，所以不会有其他的action。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Task <span class="hljs-title function_">doFirst</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Action&lt;? <span class="hljs-built_in">super</span> Task&gt; action)</span> &#123;<br>        <span class="hljs-keyword">return</span> doFirst(<span class="hljs-string">&quot;doFirst &#123;&#125; action&quot;</span>, action);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Task <span class="hljs-title function_">doFirst</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String actionName, <span class="hljs-keyword">final</span> Action&lt;? <span class="hljs-built_in">super</span> Task&gt; action)</span> &#123;<br>        hasCustomActions = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (action == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidUserDataException</span>(<span class="hljs-string">&quot;Action must not be null!&quot;</span>);<br>        &#125;<br>        taskMutator.mutate(<span class="hljs-string">&quot;Task.doFirst(Action)&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                getTaskActions().add(<span class="hljs-number">0</span>, wrap(action, actionName));<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Task <span class="hljs-title function_">doLast</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Action&lt;? <span class="hljs-built_in">super</span> Task&gt; action)</span> &#123;<br>        <span class="hljs-keyword">return</span> doLast(<span class="hljs-string">&quot;doLast &#123;&#125; action&quot;</span>, action);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Task <span class="hljs-title function_">doLast</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String actionName, <span class="hljs-keyword">final</span> Action&lt;? <span class="hljs-built_in">super</span> Task&gt; action)</span> &#123;<br>        hasCustomActions = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (action == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidUserDataException</span>(<span class="hljs-string">&quot;Action must not be null!&quot;</span>);<br>        &#125;<br>        taskMutator.mutate(<span class="hljs-string">&quot;Task.doLast(Action)&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                getTaskActions().add(wrap(action, actionName));<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，doFirst每次都添加到list的最前面，doLast每次都添加到最后面。最后这个actions list就按照顺序形成了doFirst、doSelf、doLast三部分的Actions。</p>
<h4 id="任务排序"><a href="#任务排序" class="headerlink" title="任务排序"></a>任务排序</h4><p>这个并没有真正实现排序功能，而是通过<code>shouldRunAfter</code>和<code>mustRunAfter</code>这两个方法，他们可以控制一个任务应该或者一定在某个任务之后执行。</p>
<p><code>taskB.mustRunAfter(taskA)</code>表示<code>taskB</code>必须在<code>taskA</code>执行之后执行，这个规则比较严格</p>
<h4 id="任务的启用和禁用"><a href="#任务的启用和禁用" class="headerlink" title="任务的启用和禁用"></a>任务的启用和禁用</h4><p>Task中有个<code>enable</code>属性，用于启用和禁用任务，默认是<code>true</code>，表示启用，设置为<code>false</code>，则禁止该任务执行，输出会提示该任务被跳过。</p>
<h4 id="任务的onlyIf断言"><a href="#任务的onlyIf断言" class="headerlink" title="任务的onlyIf断言"></a>任务的onlyIf断言</h4><p>断言就是一个条件表达式，Task有一个<code>onlyIf</code>方法，它接受一个闭包作为参数，如果该闭包返回true则执行该任务，否则跳过。</p>
<p>假如我们首发渠道是应用宝，直接build会编译出来所有包，现在我们就采用onlyIf的方式通过属性来控制：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">final</span> String BUILD_APP_ALL = <span class="hljs-string">&quot;all&quot;</span>;<br><span class="hljs-keyword">final</span> String BUILD_APP_SHOUFA = <span class="hljs-string">&quot;shoufa&quot;</span>;<br><span class="hljs-keyword">final</span> String BUILD_APP_EXCLUDE_SHOUFA=<span class="hljs-string">&quot;exclude_shoufa&quot;</span>;<br><br>task qqRelease &lt;&lt;&#123;<br>    println <span class="hljs-string">&quot;应用宝&quot;</span><br>&#125;<br><br>task baiduRelease &lt;&lt;&#123;<br>    println <span class="hljs-string">&quot;百度&quot;</span><br>&#125;<br><br>task huaweiRelease &lt;&lt;&#123;<br>    println <span class="hljs-string">&quot;华为&quot;</span><br>&#125;<br><br>task miuiRelease &lt;&lt;&#123;<br>    println <span class="hljs-string">&quot;小米&quot;</span><br>&#125;<br><br>task test &lt;&lt;&#123;<br>    group BasePlugin.BUILD_GROUP<br>    description <span class="hljs-string">&quot;打渠道包&quot;</span><br>&#125;<br><br>test.dependsOn qqRelease,baiduRelease,huaweiRelease,miuiRelease<br><br>qqRelease.onlyIf &#123;<br>    <span class="hljs-keyword">def</span> execute = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span>(project.hasProperty(<span class="hljs-string">&quot;build_apps&quot;</span>))&#123;<br>        Object buildApp = project.property(<span class="hljs-string">&quot;build_apps&quot;</span>)<br>        <span class="hljs-keyword">if</span>(BUILD_APP_SHOUFA.equals(buildApp) || BUILD_APP_ALL.equals(buildApp))&#123;<br>            execute = <span class="hljs-literal">true</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            execute = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        execute = <span class="hljs-literal">true</span><br>    &#125;<br>    execute<br>&#125;<br><br>baiduRelease.onlyIf &#123;<br>    <span class="hljs-keyword">def</span> execute = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">if</span>(project.hasProperty(<span class="hljs-string">&quot;build_apps&quot;</span>))&#123;<br><br>        String buildApp = project.property(<span class="hljs-string">&quot;build_apps&quot;</span>)<br>        <span class="hljs-keyword">if</span>(BUILD_APP_SHOUFA.equals(buildApp) || BUILD_APP_ALL.equals(buildApp))&#123;<br>            execute = <span class="hljs-literal">true</span><br>            <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            execute = <span class="hljs-literal">false</span><br>            <br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        execute = <span class="hljs-literal">true</span><br>        <br>    &#125;<br>    execute<br><br>&#125;<br><br>huaweiRelease.onlyIf &#123;<br>    <span class="hljs-keyword">def</span> execute = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span>(project.hasProperty(<span class="hljs-string">&quot;build_apps&quot;</span>))&#123;<br>        Object buildApp = project.property(<span class="hljs-string">&quot;build_apps&quot;</span>)<br>        <span class="hljs-keyword">if</span>(BUILD_APP_EXCLUDE_SHOUFA.equals(buildApp) || BUILD_APP_ALL.equals(buildApp))&#123;<br>            execute = <span class="hljs-literal">true</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            execute = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        execute = <span class="hljs-literal">true</span><br>    &#125;<br>    execute<br>&#125;<br><br>miuiRelease.onlyIf &#123;<br>    <span class="hljs-keyword">def</span> execute = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span>(project.hasProperty(<span class="hljs-string">&quot;build_apps&quot;</span>))&#123;<br>        Object buildApp = project.property(<span class="hljs-string">&quot;build_apps&quot;</span>)<br>        <span class="hljs-keyword">if</span>(BUILD_APP_EXCLUDE_SHOUFA.equals(buildApp) || BUILD_APP_ALL.equals(buildApp))&#123;<br>            execute = <span class="hljs-literal">true</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            execute = <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        execute = <span class="hljs-literal">true</span><br>    &#125;<br>    execute<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面定义了4个渠道，其中百度和应用宝是首发，通过build_apps属性来控制要打哪些渠道包</p>
<blockquote>
<p>&#x2F;&#x2F;打所有渠道包</p>
<p>gradle test</p>
<p>gradle -P build_apps&#x3D;all test</p>
<p>&#x2F;&#x2F;打首发包</p>
<p>gradle -P build_apps&#x3D;shoufa test</p>
<p>&#x2F;&#x2F;打非首发包</p>
<p>gradle -P build_apps&#x3D;exclude_shoufa test</p>
</blockquote>
<p>命令行中的-P意思是为Project执行K-V格式属性的键值对</p>
<h4 id="任务规则"><a href="#任务规则" class="headerlink" title="任务规则"></a>任务规则</h4><p>我们知道创建的人物都爱TaskContainer里，是由其进行管理的，所以当我们访问任务的时候都是通过TaskContainer进行访问，而TaskContainer又是一个NamedDomainObjectCollection，所以我们说的任务规则其实就是NamedDomainObjectCollection的规则。</p>
<p>NamedDomainObjectCollection是一个具有唯一不变名字的域对象的集合，它里面所有的元素都有一个唯一不变的名字，该名字是String类型，所以我们可以通过名字获取该元素。但是这个唯一的名字可能不存在，具体到任务中就是说你想获取的这个任务不存在，这时候就会调用我们添加的规则来处理这种异常情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">findName</span><span class="hljs-params">(String name)</span>&#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> findByNameWithoutRules(name);<br>    <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    applyRules(name);<br>    <span class="hljs-keyword">return</span> findByNameWithoutRules(name);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以名字查找的时候，如果没有找到则调用applyRules(name)应用我们添加的规则。</p>
<p>我们可以通过调用addRule来添加我们自定义的规则，它有两个用法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Adds a rule to this collection. The given rule is invoked when an unknown object is requested by name.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> rule The rule to add.</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> The added rule.</span><br><span class="hljs-comment">    */</span><br>   Rule <span class="hljs-title function_">addRule</span><span class="hljs-params">(Rule rule)</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Adds a rule to this collection. The given closure is executed when an unknown object is requested by name. The</span><br><span class="hljs-comment">    * requested name is passed to the closure as a parameter.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> description The description of the rule.</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> ruleAction The closure to execute to apply the rule.</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> The added rule.</span><br><span class="hljs-comment">    */</span><br>   Rule <span class="hljs-title function_">addRule</span><span class="hljs-params">(String description, Closure ruleAction)</span>;<br></code></pre></td></tr></table></figure>

<p>一个是直接添加一个Rule，另一个是通过闭包配置成一个Rule再添加，两种方式大同小异。</p>
<p>当我们执行、依赖一个不存在的任务时，Gradle会执行失败，失败信息是任务不存在。我们使用规则对其进行改造，不会执行失败，而是打印提示信息：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">tasks.addRule(<span class="hljs-string">&quot;对该规则的一个描述&quot;</span>)&#123;<br>    String taskName -&gt;<br>        task(taskName) &lt;&lt;&#123;<br>            println(<span class="hljs-string">&quot;该$&#123;taskName&#125;任务不存在，请查证后再执行&quot;</span>)<br>        &#125;<br>&#125;<br><br>task testA &#123;<br>    dependsOn missTask<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle基础</title>
    <url>/2018/11/11/gradle%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>参考自《Android Gradle权威指南》</p>
<p>先来回顾一下groovy的一些基础语法</p>
<ol>
<li><p>调用方法的时候，圆括号是可以省略的，比如</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> method1(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123;<br>    println a+b<br>&#125;<br><br>task invokeMethod &lt;&lt;&#123;<br>	method1(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>    method1 <span class="hljs-number">1</span>,<span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>定义方法时，return是可以不写的，比如</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> getMaxNumber(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123;<br>    <span class="hljs-keyword">if</span>(a&gt;b)&#123;<br>        a<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        b<br>    &#125;<br>&#125;<br>task printMethodReturn &lt;&lt;&#123;<br>    <span class="hljs-keyword">def</span> max1 = getMaxNumber <span class="hljs-number">1</span>,<span class="hljs-number">2</span><br>    <span class="hljs-keyword">def</span> max2 = getMaxNumber <span class="hljs-number">3</span>,<span class="hljs-number">5</span><br>    println <span class="hljs-string">&quot;max1 :$&#123;max1&#125;,max2:$&#123;max2&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行<code>gradle printMethodReturn</code>可以看到输出  <code>max1 :2,max2:5</code></p>
</li>
<li><p>代码块是可以作为参数传递的，比如：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//最直接的写法</span><br>numList.each(&#123;println it&#125;)<br><span class="hljs-comment">//groovy规定，如果方法的最后一个参数是闭包，可以放大方法外面</span><br>numList.each()&#123;<br>    println it<br>&#125;<br><span class="hljs-comment">// 还规定了，如果出现上面的情况，圆括号也是可以省略的</span><br>numList.each&#123;<br>    println it<br>&#125;<br></code></pre></td></tr></table></figure>

<p>是不是和python很像。</p>
<span id="more"></span>

<h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>在Java中为了获取、修改属性的值，通常需要通过生成<code>getter/setter</code>方法，但是在<code>groovy</code>中我们可以这样</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">private</span> String name<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> getAge()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">12</span><br>    &#125;<br>&#125;<br><br>task PersonField &lt;&lt;&#123;<br>    Person p  = <span class="hljs-keyword">new</span> Person()<br>    println <span class="hljs-string">&quot;name is $&#123;p.name&#125;&quot;</span><br>    p.name = <span class="hljs-string">&quot;张三&quot;</span><br>    println <span class="hljs-string">&quot;name is $&#123;p.name&#125;&quot;</span><br>    println <span class="hljs-string">&quot;age is $&#123;p.age&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行该任务，得到输出</p>
<blockquote>
<p>name is null<br>name is 张三<br>age is 12</p>
</blockquote>
<p>在没有给name属性赋值时，输出为null，赋值之后，输出给定的值。并且并不需要通过getter&#x2F;setter方法来进行操作，看起来有点像kotlin。</p>
<p>对于age来讲，我们并没有在对象中声明该属性，也就是说并不一定需要定义成员变量才能作为类的属性访问。</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包其实就是一段代码块，我们以集合的each方法为例</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> customClosure(closure)&#123;<br>    <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>)&#123;<br>        closure(i)<br>    &#125;<br>&#125;<br><br>task testClosure &lt;&lt;&#123;<br>    customClosure&#123;<br>        print it<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行该任务，可以得到1到10的打印输出，可以将上述代码简单粗暴的理解为</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> customClosure()&#123;<br>    <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>)&#123;<br>        print i<br>    &#125;<br>&#125;<br><br>task testClosure &lt;&lt;&#123;<br>    customClosure()<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="闭包的参数"><a href="#闭包的参数" class="headerlink" title="闭包的参数"></a>闭包的参数</h5><p>上面的例子中只用到了一个参数，用于接收一个闭包，默认就是it，当有多个参数时，需要把参数一一列出</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">task helloClosure &lt;&lt;&#123;<br>    eachMap&#123;k,v -&gt; <br>        println <span class="hljs-string">&quot;$&#123;k&#125; is $&#123;v&#125;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> eachMap(closure)&#123;<br>    <span class="hljs-keyword">def</span> map1=[<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span>]<br>    map1.each&#123;<br>        closure(it.key,it.value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行helloClosure任务，得到</p>
<blockquote>
<p>$ gradle -q helloClosure<br>name is 张三<br>age is 18</p>
</blockquote>
<h5 id="闭包委托"><a href="#闭包委托" class="headerlink" title="闭包委托"></a>闭包委托</h5><p>groovy的闭包委托有thisObject、owner和delegate三个属性，当在闭包内调用方法时，	由他们来确定使用哪个对象来处理，默认情况owner和delegate是相等的，但是delegate属性可以被修改</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">//闭包委托</span><br><span class="hljs-keyword">def</span> method1()&#123;<br>    println <span class="hljs-string">&quot;Context this :$&#123;this.getClass()&#125; in root&quot;</span><br>    println <span class="hljs-string">&quot;method1 in root&quot;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Delegate</span>&#123;<br>    <span class="hljs-keyword">def</span> method1()&#123;<br>        println <span class="hljs-string">&quot;Delegate this : $&#123;this.getClass()&#125; in Delegate&quot;</span><br>        println <span class="hljs-string">&quot;method1 in Delegate&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">def</span> test(Closure&lt;Delegate&gt; closure)&#123;<br>            closure(<span class="hljs-variable language_">this</span>)<br>    &#125;<br>&#125;<br><br>task helloDelegate &lt;&lt;&#123;<br>    <span class="hljs-keyword">new</span> Delegate().test&#123;<br>        println <span class="hljs-string">&quot;thisObject :$&#123;thisObject.getClass()&#125;&quot;</span><br>        println <span class="hljs-string">&quot;owner:$&#123;owner.getClass()&#125;&quot;</span><br>        println <span class="hljs-string">&quot;delegate:$&#123;delegate.getClass()&#125;&quot;</span><br>        method1()<br>        it.method1()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行任务可以得到</p>
<blockquote>
<p>$ gradle -q helloDelegate<br>thisObject :class build_apnm7l2hrtoaa0bd51bpb5xcf<br>owner:class build_apnm7l2hrtoaa0bd51bpb5xcf$_run_closure4<br>delegate:class build_apnm7l2hrtoaa0bd51bpb5xcf$_run_closure4<br>Context this :class build_apnm7l2hrtoaa0bd51bpb5xcf in root<br>method1 in root<br>Delegate this : class Delegate in Delegate<br>method1 in Delegate</p>
</blockquote>
<p>从上面例子可以看到，在不进行任何修改的情况下，thisObject的优先级最高，默认情况下优先使用thisObject来处理闭包中的方法，如果有则执行。从输出中可以看到这个thisObject就是构建脚本的上下文，它和脚本中的this是一样的。</p>
<p>在DSL中，比如gradle，一般会指定delegate为当前的it，这样我们就可以在闭包中对该it进行配置，或者调用其方法：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String personName<br>    <span class="hljs-type">int</span> personAge<br><br>    <span class="hljs-keyword">def</span> dumpPerson()&#123;<br>        println <span class="hljs-string">&quot;name is $&#123;personName&#125;, age is $&#123;personAge&#125;&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">def</span> person(Closure&lt;Person&gt; closure)&#123;<br>    Person p = <span class="hljs-keyword">new</span> Person()<br>    closure.delegate = p<br>    <span class="hljs-comment">//委托模式优先</span><br>    closure.setResolveStrategy(Closure.DELEGATE_FIRST)<br>    closure(p)<br>&#125;<br><br>task configClosure &lt;&lt; &#123;<br>    person&#123;<br>        personName=<span class="hljs-string">&quot;张三&quot;</span><br>        personAge = <span class="hljs-number">20</span><br>        dumpPerson()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面实例中设置了	委托对象为当前创建的Person实例，并且设置了委托模式优先，所以我们使用person方法创建实例的时候，可以在闭包里面直接对该实例进行配置。</p>
<hr>
<p>以上，</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle插件</title>
    <url>/2018/12/09/gradle%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>把插件应用到你的项目，插件会扩展项目的功能，帮助你在项目的构建过程中做很多事情。</p>
<ol>
<li>可以添加任务到你的项目中，帮你完成一些事情，比如测试、编译、打包。</li>
<li>可以添加依赖配置到你的项目中，我们可以通过他们配置我们项目在构建过程中需要的依赖，比如变异的时候依赖第三方库等</li>
<li>可以向项目中现有的对象类型添加新的扩展属性、方法等，让你可以使用他们帮助我们配置、优化构建，比如<code>android&#123;&#125;</code>这个配置块就是Android Gradle插件为Project对象添加的一个扩展。</li>
<li>可以对项目进行一些约定，比如应用Java插件之后，约定<code>src/main/java</code>目录下使我们源代码存放位置，在编译的时候也是编译这个目录下的java源代码文件</li>
</ol>
<span id="more"></span>

<h4 id="如何应用一个插件"><a href="#如何应用一个插件" class="headerlink" title="如何应用一个插件"></a>如何应用一个插件</h4><p>插件的应用都是通过<code>Project.apply()</code>方法完成的，apply有好几种用法，并且插件也氛围二进制插件和脚本插件</p>
<h5 id="应用二进制插件"><a href="#应用二进制插件" class="headerlink" title="应用二进制插件"></a>应用二进制插件</h5><p>二进制插件就是实现了<code>org.gradle.api.Plugin</code>接口的插件，他们可以有<code>plugin id</code>，下面介绍如何应用一个Java插件</p>
<blockquote>
<p>apply plugin:’java’</p>
</blockquote>
<p>上面的语句把Java插件应用到我们的项目中了，其中<code>java</code>是Java插件的plugin id，它是唯一的。对于Gradle自带的核心插件都有一个容易记住的短名，称其为plugin id,比如这里的java，其实它对应的类型是<code>org.gradle.api.plugins.JavaPlugin</code>，所以通过该类型我们也可以应用这个插件</p>
<blockquote>
<p>apply plugin: org.gradle.api.plugins.JavaPlugin</p>
</blockquote>
<p>又因为包<code>org.gradle.api.plugins</code>是默认导入的，所以可以去掉包名直接写为：</p>
<blockquote>
<p>apply plugin:JavaPlugin</p>
</blockquote>
<p>以上三种写法是等价的，第二种写法一般适用于我们在build文件中自定义的插件，也就是脚本插件。</p>
<h5 id="应用脚本插件"><a href="#应用脚本插件" class="headerlink" title="应用脚本插件"></a>应用脚本插件</h5><p>build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">from :</span><span class="hljs-string">&#x27;version.gradle&#x27;</span><br>task test&lt;&lt;&#123;<br>    println <span class="hljs-string">&quot;app版本是$&#123;versionName&#125;,版本号是$&#123;versionCode&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>version.gradle</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs :jack_o_lantern:">ext&#123;<br>    versionName=&quot;1.0.0&quot;<br>    versionCode=1<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实这不能算是一个插件它只是一个脚本，应用脚本插件，其实就是把这个脚本加载进来，和二进制插件不同的是它使用<code>from</code>关键字,后面紧跟的是一个脚本文件，可以使本地的，也可以使网络存在的，如果是网络上的话要使用http url</p>
<h5 id="apply方法的其他用法"><a href="#apply方法的其他用法" class="headerlink" title="apply方法的其他用法"></a>apply方法的其他用法</h5><p>Project.apply()方法有3中使用方式，它们只是接受的参数不同，上面使用的是接受一个Map类型参数的形式，下面是其他两种方式</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-type">void</span> apply(Map&lt;String,?&gt; options);<br>void apply(Closure closure);<br>void apply(Action&lt;? super ObjectConfigurationAction&gt; action)<br></code></pre></td></tr></table></figure>

<p>闭包的方式如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply&#123;<br>    plugin <span class="hljs-string">&#x27;java&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>该闭包被用来配置一个<code>ObjectConfigurationAction</code>对象，所以可以在比暴力使用ObjectConfigurationAction对象的方法、属性等进行配置。</p>
<p>Action的方式</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply(<span class="hljs-keyword">new</span> Action&lt;ObjectConfigurationAction&gt;()&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">void</span> execute(ObjectConfigurationAction objectConfigurationAction)&#123;<br>        objectConfigurationAction.plugin(<span class="hljs-string">&#x27;java&#x27;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>Action的方式需要new一个Action，然后在execute方法里进行配置</p>
<h5 id="应用第三方发布的插件"><a href="#应用第三方发布的插件" class="headerlink" title="应用第三方发布的插件"></a>应用第三方发布的插件</h5><p>在使用第三方发布的插件的时候，必须要在buildscript{}里配置其classpath才能使用，比如在使用Android Gradle插件，就属于Android发布的第三方插件：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">buildscript&#123;<br>    repositories&#123;<br>        jcenter()<br>    &#125;<br>    dependencies&#123;<br>        classpath <span class="hljs-string">&#x27;com.android.application&#x27;</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>buildscript{}块是一个在构建项目之前，为项目进行前期准备和初始化相关配置依赖的地方，配置好所需的依赖，就可以应用插件了：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin :</span><span class="hljs-string">&#x27;com.android.application&#x27;</span><br></code></pre></td></tr></table></figure>

<p>如果没有提前在buildscript里配置依赖的classpath，会提示找不到这个插件</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle自定义插件</title>
    <url>/2020/11/26/gradle%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p><a href="https://blog.huangyuanlove.com/2018/11/09/groovy%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/">groovy 语法入门</a><br><a href="https://blog.huangyuanlove.com/2018/11/11/gradle%E5%9F%BA%E7%A1%80/">gradle 基础</a><br><a href="https://blog.huangyuanlove.com/2018/11/19/gradle%E4%BB%BB%E5%8A%A1/">gradle 任务</a><br><a href="https://blog.huangyuanlove.com/2018/12/09/gradle%E6%8F%92%E4%BB%B6/">gradle 插件</a><br><a href="https://blog.huangyuanlove.com/2018/12/19/gradle-java%E6%8F%92%E4%BB%B6/">gradle-java 插件</a><br><a href="https://blog.huangyuanlove.com/2018/12/22/gradle-android%E6%8F%92%E4%BB%B6/">gradle-android 插件</a></p>
<p>前面简单的写了点关于gradle的以及gradle插件的东西,现在我们来看一下如何自定义插件,<strong>本篇文章是基于AndroidStudio、Android工程进行讲述</strong>。</p>
<span id="more"></span>
<h4 id="存放插件源码"><a href="#存放插件源码" class="headerlink" title="存放插件源码"></a>存放插件源码</h4><p>我们可以在以下几个地方存放我们的插件源码</p>
<h5 id="Build-Script"><a href="#Build-Script" class="headerlink" title="Build Script"></a>Build Script</h5><p>每个module中都会有build.gradle文件，我们可以在该文件中编写一些所需要的插件功能，好处是可以被自动编译并且包含在构建脚本的class path中(项目根目录下的build.gradle中buildScript中使用classPath依赖的插件)，坏处是不能被其他模块访问，插件功能没办法重用。</p>
<h5 id="buildSrc-Module"><a href="#buildSrc-Module" class="headerlink" title="buildSrc Module"></a><code>buildSrc</code> Module</h5><p>根据所选语言的不同，我们可以把插件代码放在<code>rootProjectDir/buildSrc/src/main/java</code>、<code>rootProjectDir/buildSrc/src/main/groovy</code>、<code>rootProjectDir/buildSrc/src/main/kotlin</code> 文件夹下，同样的，我们也不需要做额外的操作就可以在其他module中使用，但是不能在其他项目中引用</p>
<h5 id="Standalone-Project"><a href="#Standalone-Project" class="headerlink" title="Standalone Project"></a>Standalone Project</h5><p>我们可以为插件单独创建一个项目或者一个module，将它编译为jar包或者其他形式发布出去，使得其他项目可以引用</p>
<h4 id="编写插件代码"><a href="#编写插件代码" class="headerlink" title="编写插件代码"></a>编写插件代码</h4><h5 id="先看下写在Build-Script中的构建脚本。"><a href="#先看下写在Build-Script中的构建脚本。" class="headerlink" title="先看下写在Build Script中的构建脚本。"></a>先看下写在<code>Build Script</code>中的构建脚本。</h5><p>这里的<code>Build Script</code>指的是每个module都会有<code>build.gradle</code>文件，我们对每个module的某些编译配置选项也会在这里配置.<br><strong>首先需要明确的是，我们可以在<code>build.gradle</code>文件编写Groovy、Java代码</strong>，还可以回顾一下之前写的一坨文章看一下。<br><strong>以下代码我是在resource1模块的build.gradle文件中编写</strong><br>先声明一个继承自<code>org.gradle.api.Plugin.Plugin</code>的类</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Plugin</span>&lt;Project&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">void</span> apply(Project project) &#123;<br>        project.task(<span class="hljs-string">&quot;greeting&quot;</span>) &#123;<br>            doLast &#123;<br>                println(<span class="hljs-string">&quot;hello &quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后apply一下</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> MyPlugin<br></code></pre></td></tr></table></figure>
<p>这时候点击<code>Sync Now</code>,会在对应的module中Tasks–&gt;other分组中展示；双击该任务或者使用命令行可执行(.&#x2F;gradlew resource1:greeting);<br>如果想要像<code>apply plugin: &#39;com.android.library&#39;</code>这种进行配置该如果办？我们可以这么做</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Plugin</span>&lt;Project&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-type">void</span> apply(Project project) &#123;<br>        <span class="hljs-keyword">def</span> extension = project.extensions.create(<span class="hljs-string">&quot;myPlugin&quot;</span>, MyPluginExtension)<br>        project.task(<span class="hljs-string">&quot;greeting&quot;</span>) &#123;<br>            doLast &#123;<br>                println(<span class="hljs-string">&quot;$extension.greeter ,$extension.message&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPluginExtension</span> &#123;<br>    <span class="hljs-keyword">def</span> message = <span class="hljs-string">&quot;default message from MyPluginExtension&quot;</span><br>    <span class="hljs-keyword">def</span> greeter = <span class="hljs-string">&quot;default greeter from MyPluginExtension&quot;</span><br>&#125;<br><br>apply <span class="hljs-attr">plugin:</span> MyPlugin<br>myPlugin &#123;<br>    message = <span class="hljs-string">&quot;hi&quot;</span><br>    greeter = <span class="hljs-string">&quot;xuan&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里需要注意的是，<code>project.extensions.create</code>方法中传入的第一个参数是我们在<code>build.gradle</code>文件配置块的名字；<br>另外，我们需要注意一个作用域的问题：如果我们想要在定义的类中使用一些三方的依赖包，需要在<strong>工程根目录下的build.gralde</strong>文件中<strong>buildscript</strong>使用classpath添加依赖，比如我想使用<code>commons-lang3</code>中的StringUtil来判断字符串是否为空，则</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&#x27;org.apache.commons:commons-lang3:3.11&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后在module中的build.gradle文件中使用，别忘了导入包。</p>
<h5 id="在buildSrc-Module中"><a href="#在buildSrc-Module中" class="headerlink" title="在buildSrc Module中"></a>在<code>buildSrc</code> Module中</h5><p>我们在工程中新建一个名字为<code>buildSrc</code>的文件夹，和各个module同级，然后按照module的格式，创建src&#x2F;main&#x2F;groovy|java|kotlin&#x2F;package_name、build.gradle文件，将上面写的插件实现复制过来，<br>文件夹结构看起像这样<br><img src="/image/gradle/gradle-plugin/gradle-plugin-with-buildSrc.png" alt="gradle-plugin-buildSrc"><br>然后在build.gradle文件中引入我们所需要的依赖、plugin等，看起来像这样</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;java-gradle-plugin&#x27;</span><br>&#125;<br>java &#123;<br>    sourceCompatibility = JavaVersion.VERSION_1_7<br>    targetCompatibility = JavaVersion.VERSION_1_7<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的pluginds相当于 <code>apply plugin:&#39;java-gradle-plugin&#39;</code>,这个插件是官方推荐使用的，相当于我们引用了<code>java</code>和<code>groovy</code>，并且添加了<code>gradleApi()</code>的依赖,可以看这里<a href="https://docs.gradle.org/nightly/userguide/custom_plugins.html">https://docs.gradle.org/nightly/userguide/custom_plugins.html</a>。<br>我们还需要给我们的plugin取个名字，这里有两种方案</p>
<ol>
<li>官方现在推荐<br>在<code>build.gradle</code>中配置<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">gradlePlugin &#123;<br>    plugins &#123;<br>        simplePlugin &#123;<br>            id = <span class="hljs-string">&#x27;first-plugin&#x27;</span><br>            implementationClass = <span class="hljs-string">&#x27;com.huangyuanlove.plugin.FirstPlugin&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>之前的写法<br>创建<code>main/resources/META-INF/gradle-plugins</code>文件夹，并在该文件夹下新建<code>first-plugin.properties</code>文件(这里的first-plugin就是插件的id)，在该文件中声明实现插件的类<code>implementation-class=com.huangyuanlove.plugin.FirstPlugin</code></li>
</ol>
<p>引用这个插件：<br>在使用这个插件的moudle中，</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;first-plugin&#x27;</span><br>greeting&#123;<br>    message=<span class="hljs-string">&quot;hi&quot;</span><br>    greeter=<span class="hljs-string">&quot;xuan&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后同步一下就可以使用了</p>
<h5 id="作为一个独立模块"><a href="#作为一个独立模块" class="headerlink" title="作为一个独立模块"></a>作为一个独立模块</h5><ol>
<li>编写、构建、发布<br>和上面差不多，新建一个<code>java library module</code>,然后像上面一样引入<code>java-gradle-plugin</code>,配置好插件id。<br>在独立模块中我们需要将插件发布一下，然后再依赖.<br>文件夹结构看起来像下面这样<br><img src="/image/gradle/gradle-plugin/gradle-plugin-with-module.png" alt="gradle-plugin-module"></li>
</ol>
<p>引入<code>maven</code>,配置一下发布信息，看起来像下面这样</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;java-library&#x27;</span><br>    id <span class="hljs-string">&#x27;kotlin&#x27;</span><br>    id <span class="hljs-string">&#x27;java-gradle-plugin&#x27;</span><br>    id <span class="hljs-string">&#x27;maven&#x27;</span><br>&#125;<br><br>java &#123;<br>    sourceCompatibility = JavaVersion.VERSION_1_7<br>    targetCompatibility = JavaVersion.VERSION_1_7<br>&#125;<br><br>dependencies &#123;<br>    implementation <span class="hljs-string">&quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;</span><br>&#125;<br>uploadArchives&#123; <span class="hljs-comment">//当前项目可以发布到本地文件夹中</span><br>    repositories &#123;<br>        mavenDeployer &#123;<br>            repository(<span class="hljs-attr">url:</span> uri(<span class="hljs-string">&#x27;/Users/huangyuan/maven_repo&#x27;</span>)) <span class="hljs-comment">//定义本地maven仓库的地址</span><br>            pom.groupId = <span class="hljs-string">&#x27;com.example.mygradleplugin&#x27;</span>   <span class="hljs-comment">//groupId</span><br>            pom.artifactId = <span class="hljs-string">&#x27;myplugin&#x27;</span>  <span class="hljs-comment">//artifactId</span><br>            pom.version = <span class="hljs-string">&#x27;1.0.2&#x27;</span> <span class="hljs-comment">//版本号</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同步一下，就会看到该模块的task中多了一个upload.uploadArchives任务，执行之后会在maven仓库对应的文件夹下看到发布的jar包</p>
<ol start="2">
<li>依赖、引用<br>在项目根目录中，添加一下仓库地址，然后使用classpath进行依赖<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    repositories &#123;<br>        <span class="hljs-comment">//添加该maven仓库，</span><br>        maven &#123;<br>            url uri(<span class="hljs-string">&#x27;/Users/huangyuan/maven_repo&#x27;</span>)<br>        &#125;<br>    &#125;<br>    dependencies &#123;<br>        <span class="hljs-comment">//添加发布的plugin的依赖</span><br>        classpath <span class="hljs-string">&#x27;com.example.mygradleplugin:myplugin:1.0.2&#x27;</span><br>    &#125;<br>&#125;<br><br>allprojects &#123;<br>    repositories &#123;<br>        maven &#123;<br>            url uri(<span class="hljs-string">&#x27;/Users/huangyuan/maven_repo&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
引用和上面一样，没什么好说的</li>
</ol>
<h4 id="进行调试"><a href="#进行调试" class="headerlink" title="进行调试"></a>进行调试</h4><p>当插件工作不是预期的结果时，我们可能需要进行断点调试(当然打日志的方法也不错)，在之前的版本中还需要新增remote配置，然后以debug方式执行这个任务，现在在AndroidStudio中(4.1.1版本)中，只需要在侧边找打这个任务，右键菜单debug执行就好了</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>groovy语法入门</title>
    <url>/2018/11/09/groovy%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>看了一些gradle构建脚本的教程，总感觉缺少了点什么，对于某些命令的写法不熟悉甚至看不懂，补一下groovy的基础知识。文章内容参考 <a href="http://groovy-lang.org/syntax.html">http://groovy-lang.org/syntax.html</a> (官网) 和 <a href="http://ifeve.com/groovy-syntax">http://ifeve.com/groovy-syntax</a> (翻译)</p>
<span id="more"></span>

<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><h5 id="单行注释、多行注释、文档注释-和java一致"><a href="#单行注释、多行注释、文档注释-和java一致" class="headerlink" title="单行注释、多行注释、文档注释 和java一致"></a>单行注释、多行注释、文档注释 和java一致</h5><h5 id="Shebang-line"><a href="#Shebang-line" class="headerlink" title="Shebang line"></a>Shebang line</h5><p>这个东西在Unix下被称为事务行，且允许脚本直接从命令行运行，前提是你应将安装了Groovy发布版，且在PATH中Groovy的命令行是可用的。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">#!/usr/bin/env groovy</span><br>println <span class="hljs-string">&quot;Hello from the shebang line&quot;</span><br></code></pre></td></tr></table></figure>

<p>其中<code>#</code>字符必须是第一个字符，任何缩进(空格、制表符)都会报错</p>
<h4 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">as</td>
<td align="center">assert</td>
<td align="center">break</td>
<td align="center">case</td>
</tr>
<tr>
<td align="center">catch</td>
<td align="center">class</td>
<td align="center">const</td>
<td align="center">continue</td>
</tr>
<tr>
<td align="center">def</td>
<td align="center">default</td>
<td align="center">do</td>
<td align="center">else</td>
</tr>
<tr>
<td align="center">enum</td>
<td align="center">extends</td>
<td align="center">false</td>
<td align="center">finally</td>
</tr>
<tr>
<td align="center">for</td>
<td align="center">goto</td>
<td align="center">if</td>
<td align="center">implements</td>
</tr>
<tr>
<td align="center">import</td>
<td align="center">in</td>
<td align="center">instanceof</td>
<td align="center">interface</td>
</tr>
<tr>
<td align="center">new</td>
<td align="center">null</td>
<td align="center">package</td>
<td align="center">return</td>
</tr>
<tr>
<td align="center">super</td>
<td align="center">switch</td>
<td align="center">this</td>
<td align="center">throw</td>
</tr>
<tr>
<td align="center">throws</td>
<td align="center">trait</td>
<td align="center">true</td>
<td align="center">try</td>
</tr>
<tr>
<td align="center">while</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="Identifiers-标识符"><a href="#Identifiers-标识符" class="headerlink" title="Identifiers 标识符"></a>Identifiers 标识符</h4><h5 id="正常标识符"><a href="#正常标识符" class="headerlink" title="正常标识符"></a>正常标识符</h5><p>同java</p>
<h4 id="引用字符串"><a href="#引用字符串" class="headerlink" title="引用字符串"></a>引用字符串</h4><p>引用标识符出现在一个点式表达式的点后面。例如，person.name表达式中的name，能通过person.”name”,person.’name’被引用.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> map = [:]<br><br>map.<span class="hljs-string">&quot;an identifier with a space and double quotes&quot;</span> = <span class="hljs-string">&quot;ALLOWED&quot;</span><br>map.<span class="hljs-string">&#x27;with-dash-signs-and-single-quotes&#x27;</span> = <span class="hljs-string">&quot;ALLOWED&quot;</span><br><br><span class="hljs-keyword">assert</span> map.<span class="hljs-string">&quot;an identifier with a space and double quotes&quot;</span> == <span class="hljs-string">&quot;ALLOWED&quot;</span><br><span class="hljs-keyword">assert</span> map.<span class="hljs-string">&#x27;with-dash-signs-and-single-quotes&#x27;</span> == <span class="hljs-string">&quot;ALLOWED&quot;</span><br></code></pre></td></tr></table></figure>

<p>Groovy提供了不同的字符串字面量。所有不同类型的字符串都被允许出现在点后面。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">map.<span class="hljs-string">&#x27;single quote&#x27;</span><br>map.<span class="hljs-string">&quot;double quote&quot;</span><br>map.<span class="hljs-string">&#x27;&#x27;&#x27;triple single quote&#x27;&#x27;&#x27;</span><br>map.<span class="hljs-string">&quot;&quot;&quot;triple double quote&quot;&quot;&quot;</span><br>map.<span class="hljs-regexp">/slashy string/</span><br>map.<span class="hljs-string">$/dollar slashy string/$</span><br></code></pre></td></tr></table></figure>

<p>普通字符串和Groovy的GStrings有一些不同（有插值的字符串），正如在后者的情况下，插入的值被插入到最后的字符串中，以计算整个标识符：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> firstname = <span class="hljs-string">&quot;Homer&quot;</span><br>map.<span class="hljs-string">&quot;Simson-$&#123;firstname&#125;&quot;</span> = <span class="hljs-string">&quot;Homer Simson&quot;</span><br><br><span class="hljs-keyword">assert</span> map.<span class="hljs-string">&#x27;Simson-Homer&#x27;</span> == <span class="hljs-string">&quot;Homer Simson&quot;</span><br></code></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>文本文字以字符链的形式表示被称作字符串。Groovy可以让你实例化java.lang.String对象，也可以实例化GString(groovy.lang.GString)，在其他编程语言中被称为插值字符串。</p>
<h5 id="单引号字符串"><a href="#单引号字符串" class="headerlink" title="单引号字符串"></a>单引号字符串</h5><p>单引号字符串是一系列被单引号包围的字符。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-string">&#x27;a single quoted string&#x27;</span><br></code></pre></td></tr></table></figure>

<p>单引号字符串是普通的java.lang.String，不支持插值。</p>
<h5 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h5><p>所有Groovy字符串能使用+操作符连接：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;ab&#x27;</span> == <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure>

<h5 id="三单引号字符串"><a href="#三单引号字符串" class="headerlink" title="三单引号字符串"></a>三单引号字符串</h5><p>三单引号字符串是一列被三个单引号包围的字符：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-string">&#x27;&#x27;&#x27;a triple single quoted string&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>

<p>三单引号字符串是普通的java.lang.String，不支持插值。 三单引号字符串是多行的。你可以使字符串内容跨越行边界，不需要将字符串分割为一些片段，不需要连接，或换行转义符：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> aMultilineString = <span class="hljs-string">&#x27;&#x27;&#x27;line one</span><br><span class="hljs-string">line two</span><br><span class="hljs-string">line three&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>

<p>如果你的代码是缩进的，如类中的方法体，字符串将包括缩进的空格。Groovy开发工具包含一些剥离缩进的方法，使用String#stripIndent()方法，并使用String#stripMargin()方法，需要一个分隔符来识别文本从一个字符串的开始删除。 当创建一个如下字符串：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> startingAndEndingWithANewline = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">line one</span><br><span class="hljs-string">line two</span><br><span class="hljs-string">line three</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>

<p>你将要注意的是，这个字符串的结果包含一个换行转义符作为第一个字符。它可以通过使用反斜杠换行符剥离该字符：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> strippedFirstNewline = <span class="hljs-string">&#x27;&#x27;&#x27;\</span><br><span class="hljs-string">line one</span><br><span class="hljs-string">line two</span><br><span class="hljs-string">line three</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">assert</span> !strippedFirstNewline.startsWith(<span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h6 id="转义特殊字符"><a href="#转义特殊字符" class="headerlink" title="转义特殊字符"></a>转义特殊字符</h6><p>你可以使用反斜杠字符转义单引号，避免终止字符串：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-string">&#x27;an escaped single quote: \&#x27; needs a backslash&#x27;</span><br></code></pre></td></tr></table></figure>
<p>你能使用双反斜杠来转义转义字符自身：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-string">&#x27;an escaped escape character: \\ needs a double backslash&#x27;</span><br></code></pre></td></tr></table></figure>

<p>一些特殊字符使用反斜杠作为转义字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs xxx">转义序列    字符<br>&#x27;\t&#x27;        tabulation<br>&#x27;\b&#x27;        backspace<br>&#x27;\n&#x27;        newline<br>&#x27;\r&#x27;        carriage return<br>&#x27;\f&#x27;        formfeed<br>&#x27;\\&#x27;        backslash<br>&#x27;\&#x27;&#x27;        single quote (for single quoted and triple single quoted strings)<br>&#x27;\&quot;&#x27;        double quote (for double quoted and triple double quoted strings)<br></code></pre></td></tr></table></figure>

<h5 id="双引号字符串"><a href="#双引号字符串" class="headerlink" title="双引号字符串"></a>双引号字符串</h5><p>双引号字符串是一些列被双引号包围的字符：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-string">&quot;a double quoted string&quot;</span><br></code></pre></td></tr></table></figure>

<p>如果没有插值表达式，双引号字符串是普通的java.lang.String，如果插值存在则是groocy.lang.GString实例。 为了转义一个双引号，你能使用反斜杠字符：”A double quote: \””。</p>
<h6 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h6><p>任何Groovy表达式可以在所有字符文本进行插值，除了单引号和三单引号字符串。插值是使用占位符上的字符串计算值替换占位符的操作。占位符表达式是被<code>$&#123;&#125;</code>包围，或前缀为$的表达式。当GString被传递给一个带有一个String参数的方法时，占位符的表达式被计算值，并通过调用表达式的<code>toString()</code>方法以字符串形式表示。 这里是一个占位符引用局部变量的字符串：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;Guillaume&#x27;</span> <span class="hljs-comment">// a plain string</span><br><span class="hljs-keyword">def</span> greeting = <span class="hljs-string">&quot;Hello $&#123;name&#125;&quot;</span><br><br><span class="hljs-keyword">assert</span> greeting.toString() == <span class="hljs-string">&#x27;Hello Guillaume&#x27;</span><br></code></pre></td></tr></table></figure>

<p>而且任何Groovy表达式是合法的，正如我们在示例中使用算数表达式所见一样:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> sum = <span class="hljs-string">&quot;The sum of 2 and 3 equals $&#123;2 + 3&#125;&quot;</span><br><span class="hljs-keyword">assert</span> sum.toString() == <span class="hljs-string">&#x27;The sum of 2 and 3 equals 5&#x27;</span><br></code></pre></td></tr></table></figure>

<p>不仅任何表达式，实际上也允许${}占位符。语句也是被允许的，但一个语句等效于null。如果有多个语句插入占位符，那么最后一个语句应该返回一个有意义的值被插入占位符。例如，”The sum of 1 and 2 is equal to ${def a &#x3D; 1; def b &#x3D; 2; a + b}”字符串是被支持的，也能如预期一样工作，但一个好的实践是在GString占位符插入一个简单的表达式。</p>
<p> 除了<code>$&#123;&#125;</code>占位符以外，也可以使用$作为表达式前缀：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> person = [<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;Guillaume&#x27;</span>, <span class="hljs-attr">age:</span> <span class="hljs-number">36</span>]<br><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;$person.name is $person.age years old&quot;</span> == <span class="hljs-string">&#x27;Guillaume is 36 years old&#x27;</span><br></code></pre></td></tr></table></figure>

<p>如果在GString中你需要转义$或${}占位符，使它们不出现插值，那么你只需要使用反斜杠字符转义美元符号：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;$&#123;name&#125;&#x27;</span> == <span class="hljs-string">&quot;\$&#123;name&#125;&quot;</span><br></code></pre></td></tr></table></figure>

<h6 id="插入闭包表达式的特殊情况"><a href="#插入闭包表达式的特殊情况" class="headerlink" title="插入闭包表达式的特殊情况"></a>插入闭包表达式的特殊情况</h6><p>到目前为止，我们仅仅看到在<code>$&#123;&#125;</code>占位符中插入任意表达式，但一个闭包表达式标记的特殊情况。当占位符包括一个箭头<code>$&#123;-&gt;&#125;</code>,这表达式实际是一个闭包表达式，你可以把它看做一个前面紧靠美元符号的闭包： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> sParameterLessClosure = <span class="hljs-string">&quot;1 + 2 == $&#123;-&gt; 3&#125;&quot;</span> （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">assert</span> sParameterLessClosure == <span class="hljs-string">&#x27;1 + 2 == 3&#x27;</span><br><br><span class="hljs-keyword">def</span> sOneParamClosure = <span class="hljs-string">&quot;1 + 2 == $&#123; w -&gt; w &lt;&lt; 3&#125;&quot;</span> （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> sOneParamClosure == <span class="hljs-string">&#x27;1 + 2 == 3&#x27;</span><br></code></pre></td></tr></table></figure>
<p>（1）这是一个不携带参数的无参闭包<br>（2）这里的闭包携带一个java.io.StringWrite参数，你能使用&lt;&lt;追加内容。在这两处，占位符被嵌入闭包。</p>
<p>在外观上，定义一个表达式被插入看着有一些冗长，但闭包相比表达式有一个有趣的优势：延迟计算。<br>让我们思考如下示例：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> number = <span class="hljs-number">1</span> （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">def</span> eagerGString = <span class="hljs-string">&quot;value == $&#123;number&#125;&quot;</span><br><span class="hljs-keyword">def</span> lazyGString = <span class="hljs-string">&quot;value == $&#123; -&gt; number &#125;&quot;</span><br><br><span class="hljs-keyword">assert</span> eagerGString == <span class="hljs-string">&quot;value == 1&quot;</span> （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> lazyGString == <span class="hljs-string">&quot;value == 1&quot;</span> （<span class="hljs-number">3</span>）<br><br>number = <span class="hljs-number">2</span> （<span class="hljs-number">4</span>）<br><span class="hljs-keyword">assert</span> eagerGString == <span class="hljs-string">&quot;value == 1&quot;</span> （<span class="hljs-number">5</span>）<br><span class="hljs-keyword">assert</span> lazyGString == <span class="hljs-string">&quot;value == 2&quot;</span> （<span class="hljs-number">6</span>）<br></code></pre></td></tr></table></figure>
<p>（1）我们定义一个包含1的number变量，然后插入两个GString之中，在eagerGString中作为表达式，在lazyGString中作为闭包。<br>（2）我们期望对于eagerGString得到的结果字符串是包含1的相同字符串<br>（3）lazyGString相似<br>（4）然后给变量赋一个新值<br>（5）使用纯插值表达式，这值在GString创建时结合<br>（6）但使用闭包表达式，GString被强转为Sring时，闭包被调用，并产生包含新数值的更新字符串。<br>一个嵌入的闭包表达式，携带超过一个参数，那么在运行时将会产生一个异常。闭包仅仅允许携带0个或1个参数。</p>
<h6 id="与Java的互操作性"><a href="#与Java的互操作性" class="headerlink" title="与Java的互操作性"></a>与Java的互操作性</h6><p>当一个方法（无论是在Java或是Groovy中实现）预期需要一个java.lang.String，而我们传递了一个groovy.lang.GString实例，GString的toString()方法将会被自动透明的调用。 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">String takeString(String message) &#123; （<span class="hljs-number">4</span>）<br>  <span class="hljs-keyword">assert</span> message <span class="hljs-keyword">instanceof</span> String （<span class="hljs-number">5</span>）<br>  <span class="hljs-keyword">return</span> message<br>&#125;<br><br><span class="hljs-keyword">def</span> message = <span class="hljs-string">&quot;The message is $&#123;&#x27;hello&#x27;&#125;&quot;</span> （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">assert</span> message <span class="hljs-keyword">instanceof</span> GString （<span class="hljs-number">2</span>）<br><br><span class="hljs-keyword">def</span> result = takeString(message) （<span class="hljs-number">3</span>）<br><span class="hljs-keyword">assert</span> result <span class="hljs-keyword">instanceof</span> String<br><span class="hljs-keyword">assert</span> result == <span class="hljs-string">&#x27;The message is hello&#x27;</span><br></code></pre></td></tr></table></figure>

<p>（1）我们创建一个GSring变量 </p>
<p>（2）我们仔细检查GString实例 </p>
<p>（3）我们将GString传递个一个携带String参数的方法 </p>
<p>（4）takeString()明确说明它的唯一参数是一个String </p>
<p>（5）我们也验证一个参数是String而不是GString </p>
<h6 id="GString和String的hashCode"><a href="#GString和String的hashCode" class="headerlink" title="GString和String的hashCode"></a>GString和String的hashCode</h6><p>虽然插值字符串可以代替普通Java字符串，它们用一种不同的方式是字符串不同：它们的hashCode是不同的。普通Java字符串是不可变的，而一个GString依赖于插入的值，它的String是可变的。即使有相同的字符串结果，GString和String也没有相同的hashCode。 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;one: $&#123;1&#125;&quot;</span>.hashCode() != <span class="hljs-string">&quot;one: 1&quot;</span>.hashCode()<br></code></pre></td></tr></table></figure>

<p>GString和String有不同的hashCode值，应该避免使用GSring作为Map的键值，我们使用String代替GString取出一个关联值。 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> key = <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-keyword">def</span> m = [<span class="hljs-string">&quot;$&#123;key&#125;&quot;</span>: <span class="hljs-string">&quot;letter $&#123;key&#125;&quot;</span>] （<span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">assert</span> m[<span class="hljs-string">&quot;a&quot;</span>] == <span class="hljs-literal">null</span> （<span class="hljs-number">2</span>）<br></code></pre></td></tr></table></figure>

<p>（1）map被一个初始化键值对创建，其键值是GString </p>
<p>（2）当我们尝试使用String键值获取值时，我们并没获取对应值，因为String和GString有不同的hashCode </p>
<h5 id="三双引号字符串"><a href="#三双引号字符串" class="headerlink" title="三双引号字符串"></a>三双引号字符串</h5><p>三双引号字符串与双引号字符串相同，增加多行，像三单引号字符串一样。 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> name = <span class="hljs-string">&#x27;Groovy&#x27;</span><br><span class="hljs-keyword">def</span> template = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  Dear Mr $&#123;name&#125;,</span><br><span class="hljs-string"></span><br><span class="hljs-string">  You&#x27;re the winner of the lottery!</span><br><span class="hljs-string"></span><br><span class="hljs-string">  Yours sincerly,</span><br><span class="hljs-string"></span><br><span class="hljs-string">  Dave</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">assert</span> template.toString().contains(<span class="hljs-string">&#x27;Groovy&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>无论是双引号还是单引号，在三双引号字符串中需要被转义。 </p>
<h5 id="斜杠字符串"><a href="#斜杠字符串" class="headerlink" title="斜杠字符串"></a>斜杠字符串</h5><p>除了通常的带引号字符串，groovy提供斜杠字符串，使用&#x2F;作为分隔符。斜杠字符串对于定义正则表达式和模式是特别有用的，因为不需要转义反斜杠。 一个斜杠字符串： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> fooPattern = <span class="hljs-regexp">/.*foo.*/</span><br><span class="hljs-keyword">assert</span> fooPattern == <span class="hljs-string">&#x27;.*foo.*&#x27;</span><br></code></pre></td></tr></table></figure>

<p>只有正斜杠需要反斜杠转义： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> escapeSlash = <span class="hljs-regexp">/The character \/</span> is a forward slash/<br><span class="hljs-keyword">assert</span> escapeSlash == <span class="hljs-string">&#x27;The character / is a forward slash&#x27;</span><br></code></pre></td></tr></table></figure>

<p>斜杠字符串是多行的： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> multilineSlashy = /one<br>two<br>three/<br><span class="hljs-keyword">assert</span> multilineSlashy.contains(<span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>斜杠字符串也能被插值（如，GString）: </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> color = <span class="hljs-string">&#x27;blue&#x27;</span><br><span class="hljs-keyword">def</span> interpolatedSlashy = <span class="hljs-regexp">/a $&#123;color&#125; car/</span><br><br><span class="hljs-keyword">assert</span> interpolatedSlashy == <span class="hljs-string">&#x27;a blue car&#x27;</span><br></code></pre></td></tr></table></figure>

<p>有几个陷阱需要注意： 一个空的斜杠字符串不能使用双正斜杠表示，因为它被Groovy解析器作为一个单行注释理解。这就是为什么以下断言实际上无法编译，因为它看起来像一个无终止的语句： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;&#x27;</span> == <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure>

<h5 id="美元符修饰的斜杠字符串"><a href="#美元符修饰的斜杠字符串" class="headerlink" title="美元符修饰的斜杠字符串"></a>美元符修饰的斜杠字符串</h5><p>美元符斜杠字符串是一个有开口$&#x2F;和闭口$&#x2F;界定的多行GString。这转义字符是美元符，它能转义另一个美元符，或一个正斜杠。但是双美元符和双正斜杠不用被转义，除了转义像GString占位符序列开始的字符串子序列的美元符，或者你需要转义一个序列，开头看着像闭包美元符斜杠字符串分隔符。</p>
<p>示例：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> name = <span class="hljs-string">&quot;Guillaume&quot;</span><br><span class="hljs-keyword">def</span> date = <span class="hljs-string">&quot;April, 1st&quot;</span><br><br><span class="hljs-keyword">def</span> dollarSlashy = <span class="hljs-string">$/</span><br><span class="hljs-string">  Hello $name,</span><br><span class="hljs-string">  today we&#x27;re $&#123;date&#125;.</span><br><span class="hljs-string"></span><br><span class="hljs-string">  $ dollar sign</span><br><span class="hljs-string">  $$ escaped dollar sign</span><br><span class="hljs-string">  \ backslash</span><br><span class="hljs-string">  / forward slash</span><br><span class="hljs-string">  $/ escaped forward slash</span><br><span class="hljs-string">  $/$</span> escaped dollar slashy string delimiter<br>/$<br><br><span class="hljs-keyword">assert</span> [<br>  <span class="hljs-string">&#x27;Guillaume&#x27;</span>,<br>  <span class="hljs-string">&#x27;April, 1st&#x27;</span>,<br>  <span class="hljs-string">&#x27;$ dollar sign&#x27;</span>,<br>  <span class="hljs-string">&#x27;$ escaped dollar sign&#x27;</span>,<br>  <span class="hljs-string">&#x27;\\ backslash&#x27;</span>,<br>  <span class="hljs-string">&#x27;/ forward slash&#x27;</span>,<br>  <span class="hljs-string">&#x27;$/ escaped forward slash&#x27;</span>,<br>  <span class="hljs-string">&#x27;/$ escaped dollar slashy string delimiter&#x27;</span><br><br>].each &#123; dollarSlashy.contains(it) &#125;<br></code></pre></td></tr></table></figure>

<h5 id="字符串总结表"><a href="#字符串总结表" class="headerlink" title="字符串总结表"></a>字符串总结表</h5><table>
<thead>
<tr>
<th align="center">String name</th>
<th align="center">String syntax</th>
<th align="center">Interpolated</th>
<th align="center">Multiline</th>
<th align="center">Escape character</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Single quoted</td>
<td align="center">‘…’</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">|</td>
</tr>
<tr>
<td align="center">Triple single quoted</td>
<td align="center">‘’’…’’’</td>
<td align="center"></td>
<td align="center">是</td>
<td align="center">|</td>
</tr>
<tr>
<td align="center">Double quoted</td>
<td align="center">“…”</td>
<td align="center">是</td>
<td align="center"></td>
<td align="center">|</td>
</tr>
<tr>
<td align="center">Triple double quoted</td>
<td align="center">“””…”””</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">|</td>
</tr>
<tr>
<td align="center">slashy</td>
<td align="center">&#x2F;…&#x2F;</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">|</td>
</tr>
<tr>
<td align="center">Dollar</td>
<td align="center">$&#x2F;…&#x2F;$</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">|</td>
</tr>
</tbody></table>
<h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><p>与Java不同，Groovy没有显式的字符文本，然而你可以通过三种不同方式，可以将Groovy字符串实际作为一个字符使用。 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-type">char</span> c1 = <span class="hljs-string">&#x27;A&#x27;</span> （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">assert</span> c1 <span class="hljs-keyword">instanceof</span> Character<br><br><span class="hljs-keyword">def</span> c2 = <span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-type">char</span> （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> c2 <span class="hljs-keyword">instanceof</span> Character<br><br><span class="hljs-keyword">def</span> c3 = (<span class="hljs-type">char</span>)<span class="hljs-string">&#x27;C&#x27;</span> （<span class="hljs-number">3</span>）<br><span class="hljs-keyword">assert</span> c3 <span class="hljs-keyword">instanceof</span> Character<br></code></pre></td></tr></table></figure>

<p>（1）当定义变量时，通过指定char类型，使变量包含字符 </p>
<p>（2）通过as操作符使用类型强制转换 </p>
<p>（3）通过char操作符做类型转换 </p>
<p>第一个选项是（1）有趣的当一个字符在一个变量中，而另外两个（2和3）是更令人关注时char值必须作为一个方法调用的参数。 </p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>Groovy支持不同类型的整数和小数，通常以Java的Number类型返回。 </p>
<h5 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h5><p>整数类型与Java相同：</p>
<ul>
<li>byte</li>
<li>char</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>java.lang.BigInteger<br>你能以如下定义创建这些类型的整数：<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// primitive types</span><br><span class="hljs-type">byte</span> b = <span class="hljs-number">1</span><br><span class="hljs-type">char</span> c = <span class="hljs-number">2</span><br><span class="hljs-type">short</span> s = <span class="hljs-number">3</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">4</span><br><span class="hljs-type">long</span> l = <span class="hljs-number">5</span><br><br><span class="hljs-comment">// infinite precision</span><br>BigInteger bi = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
如果你通过使用def关键字使用可选类型，那么整数的类型将是可变的：它取决于这个类型实际包含的值。</li>
</ul>
<p>对于正数：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">assert</span> a <span class="hljs-keyword">instanceof</span> Integer<br><br><span class="hljs-comment">// Integer.MAX_VALUE</span><br><span class="hljs-keyword">def</span> b = <span class="hljs-number">2147483647</span><br><span class="hljs-keyword">assert</span> b <span class="hljs-keyword">instanceof</span> Integer<br><br><span class="hljs-comment">// Integer.MAX_VALUE + 1</span><br><span class="hljs-keyword">def</span> c = <span class="hljs-number">2147483648</span><br><span class="hljs-keyword">assert</span> c <span class="hljs-keyword">instanceof</span> Long<br><br><span class="hljs-comment">// Long.MAX_VALUE</span><br><span class="hljs-keyword">def</span> d = <span class="hljs-number">9223372036854775807</span><br><span class="hljs-keyword">assert</span> d <span class="hljs-keyword">instanceof</span> Long<br><br><span class="hljs-comment">// Long.MAX_VALUE + 1</span><br><span class="hljs-keyword">def</span> e = <span class="hljs-number">9223372036854775808</span><br><span class="hljs-keyword">assert</span> e <span class="hljs-keyword">instanceof</span> BigInteger<br></code></pre></td></tr></table></figure>

<p>对于负数也一样： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> na = <span class="hljs-number">-1</span><br><span class="hljs-keyword">assert</span> na <span class="hljs-keyword">instanceof</span> Integer<br><br><span class="hljs-comment">// Integer.MIN_VALUE</span><br><span class="hljs-keyword">def</span> nb = <span class="hljs-number">-2147483648</span><br><span class="hljs-keyword">assert</span> nb <span class="hljs-keyword">instanceof</span> Integer<br><br><span class="hljs-comment">// Integer.MIN_VALUE - 1</span><br><span class="hljs-keyword">def</span> nc = <span class="hljs-number">-2147483649</span><br><span class="hljs-keyword">assert</span> nc <span class="hljs-keyword">instanceof</span> Long<br><br><span class="hljs-comment">// Long.MIN_VALUE</span><br><span class="hljs-keyword">def</span> nd = <span class="hljs-number">-9223372036854775808</span><br><span class="hljs-keyword">assert</span> nd <span class="hljs-keyword">instanceof</span> Long<br><br><span class="hljs-comment">// Long.MIN_VALUE - 1</span><br><span class="hljs-keyword">def</span> ne = <span class="hljs-number">-9223372036854775809</span><br><span class="hljs-keyword">assert</span> ne <span class="hljs-keyword">instanceof</span> BigInteger<br></code></pre></td></tr></table></figure>

<h6 id="可选择的非十进制表示"><a href="#可选择的非十进制表示" class="headerlink" title="可选择的非十进制表示"></a>可选择的非十进制表示</h6><p>二进制数 </p>
<p>在Java6及以前和Groovy一样，数字只能使用十进制，八进制和十六进制表示，使用Java7和Groovy2你能使用0b前缀作为一个二进制符号： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-type">int</span> xInt = <span class="hljs-number">0b10101111</span><br><span class="hljs-keyword">assert</span> xInt == <span class="hljs-number">175</span><br><br><span class="hljs-type">short</span> xShort = <span class="hljs-number">0b11001001</span><br><span class="hljs-keyword">assert</span> xShort == <span class="hljs-number">201</span> <span class="hljs-keyword">as</span> <span class="hljs-type">short</span><br><br><span class="hljs-type">byte</span> xByte = <span class="hljs-number">0b11</span><br><span class="hljs-keyword">assert</span> xByte == <span class="hljs-number">3</span> <span class="hljs-keyword">as</span> <span class="hljs-type">byte</span><br><br><span class="hljs-type">long</span> xLong = <span class="hljs-number">0b101101101101</span><br><span class="hljs-keyword">assert</span> xLong == <span class="hljs-number">2925</span>l<br><br>BigInteger xBigInteger = <span class="hljs-number">0b111100100001</span><br><span class="hljs-keyword">assert</span> xBigInteger == <span class="hljs-number">3873</span>g<br><br><span class="hljs-type">int</span> xNegativeInt = <span class="hljs-number">-0</span>b10101111<br><span class="hljs-keyword">assert</span> xNegativeInt == <span class="hljs-number">-175</span><br></code></pre></td></tr></table></figure>

<p>八进制数</p>
<p>八进制数使用0后面跟八进制数的典型格式表示。 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-type">int</span> xInt = <span class="hljs-number">077</span><br><span class="hljs-keyword">assert</span> xInt == <span class="hljs-number">63</span><br><br><span class="hljs-type">short</span> xShort = <span class="hljs-number">011</span><br><span class="hljs-keyword">assert</span> xShort == <span class="hljs-number">9</span> <span class="hljs-keyword">as</span> <span class="hljs-type">short</span><br><br><span class="hljs-type">byte</span> xByte = <span class="hljs-number">032</span><br><span class="hljs-keyword">assert</span> xByte == <span class="hljs-number">26</span> <span class="hljs-keyword">as</span> <span class="hljs-type">byte</span><br><br><span class="hljs-type">long</span> xLong = <span class="hljs-number">0246</span><br><span class="hljs-keyword">assert</span> xLong == <span class="hljs-number">166</span>l<br><br>BigInteger xBigInteger = <span class="hljs-number">01111</span><br><span class="hljs-keyword">assert</span> xBigInteger == <span class="hljs-number">585</span>g<br><br><span class="hljs-type">int</span> xNegativeInt = <span class="hljs-number">-077</span><br><span class="hljs-keyword">assert</span> xNegativeInt == <span class="hljs-number">-63</span><br></code></pre></td></tr></table></figure>

<p>十六进制数 </p>
<p>十六进制数使用0x后面跟十六进制数的典型格式表示。 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-type">int</span> xInt = <span class="hljs-number">0x77</span><br><span class="hljs-keyword">assert</span> xInt == <span class="hljs-number">119</span><br><br><span class="hljs-type">short</span> xShort = <span class="hljs-number">0xaa</span><br><span class="hljs-keyword">assert</span> xShort == <span class="hljs-number">170</span> <span class="hljs-keyword">as</span> <span class="hljs-type">short</span><br><br><span class="hljs-type">byte</span> xByte = <span class="hljs-number">0x3a</span><br><span class="hljs-keyword">assert</span> xByte == <span class="hljs-number">58</span> <span class="hljs-keyword">as</span> <span class="hljs-type">byte</span><br><br><span class="hljs-type">long</span> xLong = <span class="hljs-number">0xffff</span><br><span class="hljs-keyword">assert</span> xLong == <span class="hljs-number">65535</span>l<br><br>BigInteger xBigInteger = <span class="hljs-number">0xaaaa</span><br><span class="hljs-keyword">assert</span> xBigInteger == <span class="hljs-number">43690</span>g<br><br>Double xDouble = <span class="hljs-keyword">new</span> Double(<span class="hljs-string">&#x27;0x1.0p0&#x27;</span>)<br><span class="hljs-keyword">assert</span> xDouble == <span class="hljs-number">1.0</span>d<br><br><span class="hljs-type">int</span> xNegativeInt = <span class="hljs-number">-0x77</span><br><span class="hljs-keyword">assert</span> xNegativeInt == <span class="hljs-number">-119</span><br></code></pre></td></tr></table></figure>

<h5 id="小数"><a href="#小数" class="headerlink" title="小数"></a>小数</h5><p>小数类型与Java一样：</p>
<ul>
<li>float</li>
<li>double</li>
<li>java.lang.BigDecimal</li>
</ul>
<p>你能采用如下定义方式创建这些类型的数字：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// primitive types</span><br><span class="hljs-type">float</span> f = <span class="hljs-number">1.234</span><br><span class="hljs-type">double</span> d = <span class="hljs-number">2.345</span><br><br><span class="hljs-comment">// infinite precision</span><br>BigDecimal bd = <span class="hljs-number">3.456</span><br></code></pre></td></tr></table></figure>
<p>小数能使用指数，使用e或E指数字母，紧跟着一个可选符号，且有一个整数表示<br>指数：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span> <span class="hljs-number">1e3</span> == <span class="hljs-number">1</span>_000<span class="hljs-number">.0</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">2E4</span> == <span class="hljs-number">20</span>_000<span class="hljs-number">.0</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">3e+1</span> == <span class="hljs-number">30.0</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">4E-2</span> == <span class="hljs-number">0.04</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">5e-1</span> == <span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure>
<p>为了精确的进行小数计算，Groovy选择java.lang.BigDecimal作为小数类型。此外，float和double也被支持，但要求有一个显式类型定义，类型转换或后缀。即使BigDecimal是默认的小数，携带float或double作为类型参数的方法或闭包也可以接受这些数值。<br>小数不能使用二进制，八进制和十六进制表示。</p>
<h5 id="有下划线的文本"><a href="#有下划线的文本" class="headerlink" title="有下划线的文本"></a>有下划线的文本</h5><p>当写一个很长的数字，使用眼睛很难弄清楚有多少数字组合在一起，例如使用千，单词等组合。通过允许你在数字中添加一些下划线，更容易发现这些组合：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-type">long</span> creditCardNumber = <span class="hljs-number">1234</span>_5678_9012_3456L<br><span class="hljs-type">long</span> socialSecurityNumbers = <span class="hljs-number">999</span>_99_9999L<br><span class="hljs-type">double</span> monetaryAmount = <span class="hljs-number">12</span>_345_132<span class="hljs-number">.12</span><br><span class="hljs-type">long</span> hexBytes = <span class="hljs-number">0xFF</span>_EC_DE_5E<br><span class="hljs-type">long</span> hexWords = <span class="hljs-number">0xFFEC</span>_DE5E<br><span class="hljs-type">long</span> maxLong = <span class="hljs-number">0x7fff</span>_ffff_ffff_ffffL<br><span class="hljs-type">long</span> alsoMaxLong = <span class="hljs-number">9</span>_223_372_036_854_775_807L<br><span class="hljs-type">long</span> bytes = <span class="hljs-number">0b11010010</span>_01101001_10010100_10010010<br></code></pre></td></tr></table></figure>
<h5 id="数字类型后缀"><a href="#数字类型后缀" class="headerlink" title="数字类型后缀"></a>数字类型后缀</h5><p>通过使用大写或小写类型后缀（见下表），我们能强制将一个数字（包括二进制，八进制，十六进制）给一个指定类型。</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Suffix</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BigInteger</td>
<td align="center">G 或 g</td>
</tr>
<tr>
<td align="center">Long</td>
<td align="center">L 或 l</td>
</tr>
<tr>
<td align="center">Integer</td>
<td align="center">I 或 i</td>
</tr>
<tr>
<td align="center">BigDecimal</td>
<td align="center">G 或 g</td>
</tr>
<tr>
<td align="center">Double</td>
<td align="center">D 或 d</td>
</tr>
<tr>
<td align="center">Float</td>
<td align="center">F 或 f</td>
</tr>
</tbody></table>
<p>如： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span> <span class="hljs-number">42</span>I == <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">&#x27;42&#x27;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-number">42</span>i == <span class="hljs-keyword">new</span> Integer(<span class="hljs-string">&#x27;42&#x27;</span>) <span class="hljs-comment">// lowercase i more readable</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">123</span>L == <span class="hljs-keyword">new</span> Long(<span class="hljs-string">&quot;123&quot;</span>) <span class="hljs-comment">// uppercase L more readable</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">2147483648</span> == <span class="hljs-keyword">new</span> Long(<span class="hljs-string">&#x27;2147483648&#x27;</span>) <span class="hljs-comment">// Long type used, value too large for an Integer</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">456</span>G == <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&#x27;456&#x27;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-number">456</span>g == <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">&#x27;456&#x27;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-number">123.45</span> == <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">&#x27;123.45&#x27;</span>) <span class="hljs-comment">// default BigDecimal type used</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">1.200065</span>D == <span class="hljs-keyword">new</span> Double(<span class="hljs-string">&#x27;1.200065&#x27;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-number">1.234</span>F == <span class="hljs-keyword">new</span> Float(<span class="hljs-string">&#x27;1.234&#x27;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-number">1.23E23</span>D == <span class="hljs-keyword">new</span> Double(<span class="hljs-string">&#x27;1.23E23&#x27;</span>)<br><span class="hljs-keyword">assert</span> <span class="hljs-number">0b1111</span>L.<span class="hljs-keyword">class</span> == Long <span class="hljs-comment">// binary</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">0xFF</span>i.<span class="hljs-keyword">class</span> == Integer <span class="hljs-comment">// hexadecimal</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">034</span>G.<span class="hljs-keyword">class</span> == BigInteger <span class="hljs-comment">// octal</span><br></code></pre></td></tr></table></figure>

<h5 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h5><p>尽管运算在以后会被覆盖，讨论数学运算和结果类型仍然是重要的。<br>除法与幂方二元操作符放在一边（下文讨论）。</p>
<ul>
<li>byte char short和int进行二元操作的结果是int</li>
<li>使用long与byte char short int进行二元操作的结果是long</li>
<li>使用BigInteger与任意其他整数类型进行二元操作结果是BigInteger</li>
<li>float double与BigDecimal进行二元运算的结果是double</li>
<li>两个BigDecimal进行二元运算的结果是BigDecimal</li>
</ul>
<p>下表总结了这些原则：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">byte</th>
<th align="center">char</th>
<th align="center">short</th>
<th align="center">int</th>
<th align="center">long</th>
<th align="center">BigInteger</th>
<th align="center">float</th>
<th align="center">double</th>
<th align="center">BigDecimal</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">int</td>
<td align="center">int</td>
<td align="center">int</td>
<td align="center">int</td>
<td align="center">long</td>
<td align="center">BigInteger</td>
<td align="center">double</td>
<td align="center">double</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center"></td>
<td align="center">int</td>
<td align="center">int</td>
<td align="center">int</td>
<td align="center">long</td>
<td align="center">BigInteger</td>
<td align="center">double</td>
<td align="center">double</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">int</td>
<td align="center">int</td>
<td align="center">long</td>
<td align="center">BigInteger</td>
<td align="center">double</td>
<td align="center">double</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">int</td>
<td align="center">long</td>
<td align="center">BigInteger</td>
<td align="center">double</td>
<td align="center">double</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">long</td>
<td align="center">BigInteger</td>
<td align="center">double</td>
<td align="center">double</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">BigInteger</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">BigInteger</td>
<td align="center">double</td>
<td align="center">double</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">double</td>
<td align="center">double</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">double</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">BigDecimal</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">BigDecimal</td>
</tr>
</tbody></table>
<p>由于Groovy操作符重载，BigInteger与BigDecimal通常也能进行运算操作，与Java不同，在Java中你不得不显式使用方法操作这些数字。 </p>
<h6 id="除法运算符的情况"><a href="#除法运算符的情况" class="headerlink" title="除法运算符的情况"></a>除法运算符的情况</h6><p>如果任何一个操作数是float或double,那么除法运算符&#x2F;(和&#x2F;&#x3D; 用于除法和赋值)产生double结果，否则（当两个操作数是一个与整型类型short, char, byte, int, long, BigInteger or BigDecimal的任意组合）是一个BigDecimal结果。</p>
<p>如果除法是精确的（如，结果可以在相同的精度和标度范围内精确表示），那么BigDecimal的除法实际执行的是divide()方法，或使用两个操作数的最大精度加10,和一个最大值为10的标度的MathContext。</p>
<p>对于整数除法和Java相同，你应该使用intdiv()方法，因为Groovy没有专门提供一个整数操作符。</p>
<h6 id="幂运算情况"><a href="#幂运算情况" class="headerlink" title="幂运算情况"></a>幂运算情况</h6><p>幂运算操作符使用**操作符，有两个参数：基数和指数。幂运算的结果取决于它的操作数以及操作的结果（特别是结果可以被表示为一个整数值）。</p>
<p>以下这些原则被用于决定Groovy幂运算操作结果的类型：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><code class="hljs vbnet">（<span class="hljs-number">1</span>）如果指数是一个小数<br>	<span class="hljs-number">1</span>.如果结果能作为一个<span class="hljs-type">Integer</span>表示，那么返回一个<span class="hljs-type">Integer</span><br>	<span class="hljs-number">2</span>..如果结果能作为一个<span class="hljs-type">Long</span>表示，那么返回一个<span class="hljs-type">Long</span><br>	<span class="hljs-number">3</span>.否则返回一个<span class="hljs-type">Double</span><br><br>（<span class="hljs-number">2</span>）如果指数是一个整数<br> 	<span class="hljs-number">1</span>.如果是一个严格的负数，那么返回一个<span class="hljs-type">Integer</span>，<span class="hljs-type">Long</span>或<span class="hljs-type">Double</span>，结果值使用那种类型填充。<br>        <span class="hljs-number">2</span>.如果指数是正数或<span class="hljs-number">0</span><br> 	  <span class="hljs-number">1</span>)如果基数是BigDecimal，那么返回一个BigDecimal结果值<br>	  <span class="hljs-number">2</span>)如果基数是BigInteger，那么返回一个BigInteger结果值<br>	  <span class="hljs-number">3</span>)如果基数是<span class="hljs-type">Integer</span>，那么返回一个<span class="hljs-type">Integer</span>值，否则返回BigInteger<br>	  <span class="hljs-number">4</span>)如果基数是<span class="hljs-type">Long</span>，那么返回一个<span class="hljs-type">Long</span>值，否则返回BigInteger<br></code></pre></td></tr></table></figure>

<p>我们使用一些实例说明这些原则： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// base and exponent are ints and the result can be represented by an Integer</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">2</span> ** <span class="hljs-number">3</span> <span class="hljs-keyword">instanceof</span> Integer <span class="hljs-comment">// 8</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">10</span> ** <span class="hljs-number">9</span> <span class="hljs-keyword">instanceof</span> Integer <span class="hljs-comment">// 1_000_000_000</span><br><br><span class="hljs-comment">// the base is a long, so fit the result in a Long</span><br><span class="hljs-comment">// (although it could have fit in an Integer)</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">5</span>L ** <span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> Long <span class="hljs-comment">// 25</span><br><br><span class="hljs-comment">// the result can&#x27;t be represented as an Integer or Long, so return a BigInteger</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">100</span> ** <span class="hljs-number">10</span> <span class="hljs-keyword">instanceof</span> BigInteger <span class="hljs-comment">// 10e20</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">1234</span> ** <span class="hljs-number">123</span> <span class="hljs-keyword">instanceof</span> BigInteger <span class="hljs-comment">// 170515806212727042875...</span><br><br><span class="hljs-comment">// the base is a BigDecimal and the exponent a negative int</span><br><span class="hljs-comment">// but the result can be represented as an Integer</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">0.5</span> ** <span class="hljs-number">-2</span> <span class="hljs-keyword">instanceof</span> Integer <span class="hljs-comment">// 4</span><br><br><span class="hljs-comment">// the base is an int, and the exponent a negative float</span><br><span class="hljs-comment">// but again, the result can be represented as an Integer</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> ** <span class="hljs-number">-0.3</span>f <span class="hljs-keyword">instanceof</span> Integer <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// the base is an int, and the exponent a negative int</span><br><span class="hljs-comment">// but the result will be calculated as a Double</span><br><span class="hljs-comment">// (both base and exponent are actually converted to doubles)</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">10</span> ** <span class="hljs-number">-1</span> <span class="hljs-keyword">instanceof</span> Double <span class="hljs-comment">// 0.1</span><br><br><span class="hljs-comment">// the base is a BigDecimal, and the exponent is an int, so return a BigDecimal</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">1.2</span> ** <span class="hljs-number">10</span> <span class="hljs-keyword">instanceof</span> BigDecimal <span class="hljs-comment">// 6.1917364224</span><br><br><span class="hljs-comment">// the base is a float or double, and the exponent is an int</span><br><span class="hljs-comment">// but the result can only be represented as a Double value</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">3.4</span>f ** <span class="hljs-number">5</span> <span class="hljs-keyword">instanceof</span> Double <span class="hljs-comment">// 454.35430372146965</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">5.6</span>d ** <span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> Double <span class="hljs-comment">// 31.359999999999996</span><br><br><span class="hljs-comment">// the exponent is a decimal value</span><br><span class="hljs-comment">// and the result can only be represented as a Double value</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">7.8</span> ** <span class="hljs-number">1.9</span> <span class="hljs-keyword">instanceof</span> Double <span class="hljs-comment">// 49.542708423868476</span><br><span class="hljs-keyword">assert</span> <span class="hljs-number">2</span> ** <span class="hljs-number">0.1</span>f <span class="hljs-keyword">instanceof</span> Double <span class="hljs-comment">// 1.0717734636432956</span><br></code></pre></td></tr></table></figure>

<h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p>Boolean是一种特殊的数据类型，用于表示真值：true和false。使用这种数据类型作为跟踪真假条件的简单标志。 Boolean能被存储在变量中，成员变量中，就像其他数据类型一样： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> myBooleanVariable = <span class="hljs-literal">true</span><br><span class="hljs-type">boolean</span> untypedBooleanVar = <span class="hljs-literal">false</span><br>booleanField = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p>true和false是仅有的两个原始布尔值。但更复杂的布尔表达式能使用逻辑操作符表示。</p>
<p> 除此之外，Groovy有一些特殊的规则（经常因为Groovy真值涉及）用于将非布尔值对象转化为一个布尔值。 </p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>Groovy使用逗号分隔列表中的值，并使用方括号包围，用来指定一个列表。</p>
<p>Groovy的列表是java.util.List，因为Groovy没有定义任何集合类。当定义一个列表常量时，默认的列表具体实现是java.util.ArrayList，除非你指定，我们将在后面看到。 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] （<span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">assert</span> numbers <span class="hljs-keyword">instanceof</span> List （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> numbers.size() == <span class="hljs-number">3</span> （<span class="hljs-number">3</span>）<br></code></pre></td></tr></table></figure>

<p>（1）我们定义用逗号分隔，并用方括号包围列表数字，并将列表赋值给一个变量<br>（2）list是java java.util.List接口的实例<br>（3）列表的大小可以使用size()方法查询，表明列表有三个元素</p>
<p>在上面的示例中，我们使用了一个元素类型相同的列表，我们也能创建包含不同类型元素的列表：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> heterogeneous = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-literal">true</span>] （<span class="hljs-number">1</span>）<br></code></pre></td></tr></table></figure>

<p>（1）我们的列表包含一个数字，一个字符串，一个布尔值 </p>
<p>我们提及到，默认的列表字面量实际是java.util.ArrayList的实例，但列表使用不同返回类型也是可以的，使用as操作符进行类型转换，或使用变量的定义类型： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> arrayList = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">assert</span> arrayList <span class="hljs-keyword">instanceof</span> java.util.ArrayList<br><br><span class="hljs-keyword">def</span> linkedList = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-keyword">as</span> LinkedList （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">assert</span> linkedList <span class="hljs-keyword">instanceof</span> java.util.LinkedList<br><br>LinkedList otherLinked = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> otherLinked <span class="hljs-keyword">instanceof</span> java.util.LinkedList<br></code></pre></td></tr></table></figure>

<p>（1）我们使用as操作符进行类型转换，显式请求一个java.util.LinkedList实现<br>（2）我们使用类型为java.util.LinkedList的变量保存列表字面量</p>
<p>你能通过下标操作符<code>[]</code>(读和写元素值)并使用正索引值访问列表元素或负索引值从列表尾部访问元素，也可以使用范围，或使用左移<code>&lt;&lt;</code>追加列表元素：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> letters = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br><br><span class="hljs-keyword">assert</span> letters[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;a&#x27;</span> （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">assert</span> letters[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;b&#x27;</span><br><br><span class="hljs-keyword">assert</span> letters[<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;d&#x27;</span> （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> letters[<span class="hljs-number">-2</span>] == <span class="hljs-string">&#x27;c&#x27;</span><br><br>letters[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;C&#x27;</span> （<span class="hljs-number">3</span>）<br><span class="hljs-keyword">assert</span> letters[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;C&#x27;</span><br><br>letters &lt;&lt; <span class="hljs-string">&#x27;e&#x27;</span> （<span class="hljs-number">4</span>）<br><span class="hljs-keyword">assert</span> letters[ <span class="hljs-number">4</span>] == <span class="hljs-string">&#x27;e&#x27;</span><br><span class="hljs-keyword">assert</span> letters[<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;e&#x27;</span><br><br><span class="hljs-keyword">assert</span> letters[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>] == [<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>] （<span class="hljs-number">5</span>）<br><span class="hljs-keyword">assert</span> letters[<span class="hljs-number">2.</span><span class="hljs-number">.4</span>] == [<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>] （<span class="hljs-number">6</span>）<br></code></pre></td></tr></table></figure>

<p>（1）访问列表的第一个元素（索引从零开始计算） </p>
<p>（2）使用负索引访问列表的最后一个元素：-1是列表从尾部开始的第一个元素 </p>
<p>（3）使用赋值操作为列表的第三个元素设置一个新值 </p>
<p>（4）使用&lt;&lt;左移操作符在列表尾部追加一个元素 </p>
<p>（5）一次访问两个元素，并返回一个包含这两个元素的新列表 </p>
<p>（6）使用范围访问列表中这个范围内的元素，从start到end元素位置 </p>
<p>因为列表可以很自然的做到元素类型不同，因此列表也可以包含列表用于创建多维列表： </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> multi = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]] （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">assert</span> multi[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">2</span> （<span class="hljs-number">2</span>）<br></code></pre></td></tr></table></figure>

<p>（1）定义一个数字列表的列表 </p>
<p>（2）访问顶级列表的第二个元素，内部列表的第一个元素 </p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>Groovy使用列表标记来标记数组，但为了创建字面量数组，你需要通过类型转换或类型定义来定义数组类型。 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">String[] arrStr = [<span class="hljs-string">&#x27;Ananas&#x27;</span>, <span class="hljs-string">&#x27;Banana&#x27;</span>, <span class="hljs-string">&#x27;Kiwi&#x27;</span>] （<span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">assert</span> arrStr <span class="hljs-keyword">instanceof</span> String[] （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> !(arrStr <span class="hljs-keyword">instanceof</span> List)<br><br><span class="hljs-keyword">def</span> numArr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-type">int</span>[] （<span class="hljs-number">3</span>）<br><br><span class="hljs-keyword">assert</span> numArr <span class="hljs-keyword">instanceof</span> <span class="hljs-type">int</span>[] （<span class="hljs-number">4</span>）<br><span class="hljs-keyword">assert</span> numArr.size() == <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>（1）使用显式变量类型定义一个字符串数组<br>（2）断言说明我们创建了一个字符串数组<br>（3）使用as操作符创建以int数组<br>（4）断言表明我们创建了一个原始类型的int数组</p>
<p>你也能创建多维数组：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> matrix3 = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] （<span class="hljs-number">1</span>）<br><span class="hljs-keyword">assert</span> matrix3.size() == <span class="hljs-number">3</span><br><br>Integer[][] matrix2 （<span class="hljs-number">2</span>）<br>matrix2 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]<br><span class="hljs-keyword">assert</span> matrix2 <span class="hljs-keyword">instanceof</span> Integer[][]<br></code></pre></td></tr></table></figure>

<p>（1）你能定义一个新数组的边界<br>（2）或不指定它的边界定义一个新数组</p>
<p>通过与列表相同的标记访问数组的元素：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">String[] names = [<span class="hljs-string">&#x27;Cédric&#x27;</span>, <span class="hljs-string">&#x27;Guillaume&#x27;</span>, <span class="hljs-string">&#x27;Jochen&#x27;</span>, <span class="hljs-string">&#x27;Paul&#x27;</span>]<br><span class="hljs-keyword">assert</span> names[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;Cédric&#x27;</span> （<span class="hljs-number">1</span>）<br><br>names[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;Blackdrag&#x27;</span> （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> names[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;Blackdrag&#x27;</span><br></code></pre></td></tr></table></figure>

<p>（1）取得数组的第一个元素<br>（2）为数组的第三个元素设置一个新值</p>
<p>Java数组初始化标记Groovy不支持，因为大括号会被误解为Groovy的闭包标记。</p>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>在其它语言中，有时候称为字典或关联数组，Groovy称为映射。映射使键到值关联，使用冒号将键值分隔开，每个键值对使用逗号，整个键和值使用方括号包围。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> colors = [<span class="hljs-attr">red:</span> <span class="hljs-string">&#x27;#FF0000&#x27;</span>, <span class="hljs-attr">green:</span> <span class="hljs-string">&#x27;#00FF00&#x27;</span>, <span class="hljs-attr">blue:</span> <span class="hljs-string">&#x27;#0000FF&#x27;</span>] （<span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">assert</span> colors[<span class="hljs-string">&#x27;red&#x27;</span>] == <span class="hljs-string">&#x27;#FF0000&#x27;</span> （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> colors.green == <span class="hljs-string">&#x27;#00FF00&#x27;</span> （<span class="hljs-number">3</span>）<br><br>colors[<span class="hljs-string">&#x27;pink&#x27;</span>] = <span class="hljs-string">&#x27;#FF00FF&#x27;</span> （<span class="hljs-number">4</span>）<br>colors.yellow = <span class="hljs-string">&#x27;#FFFF00&#x27;</span> （<span class="hljs-number">5</span>）<br><br><span class="hljs-keyword">assert</span> colors.pink == <span class="hljs-string">&#x27;#FF00FF&#x27;</span><br><span class="hljs-keyword">assert</span> colors[<span class="hljs-string">&#x27;yellow&#x27;</span>] == <span class="hljs-string">&#x27;#FFFF00&#x27;</span><br><br><span class="hljs-keyword">assert</span> colors <span class="hljs-keyword">instanceof</span> java.util.LinkedHashMap<br></code></pre></td></tr></table></figure>

<p>（1）我们定义了一个字符串颜色名关联十六进制的html颜色的映射<br>（2）我们使用下标标记检查red键值关联的内容<br>（3）我们也能使用属性标记访问绿颜色十六进制表达式<br>（4）相似的，我们也能使用下标标记添加一个新的键值对<br>（5）或者使用属性标记添加yellow颜色</p>
<p>当使用这些键的名字时，我们实际上在映射中定义了一个键值。<br>Groovy创建的映射实际是java.util.LinkedHashMap的实例。</p>
<p>如果你尝试在映射中访问不存在的键：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">assert</span> colors.unknown == <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>

<p>你将取回null。</p>
<p>在上面的示例中我们使用字符串键值，你也可以使用其他类型作为键值：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> numbers = [<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;two&#x27;</span>]<br><br><span class="hljs-keyword">assert</span> numbers[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;one&#x27;</span><br></code></pre></td></tr></table></figure>

<p>这里我们使用数字作为键值，作为数字能清楚的识别数字，因此Groovy不会像之前的示例一样创建一个字符串的键。但是考虑你想传递一个变量代替键的情况下，有一个变量值将会作为键：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> key = <span class="hljs-string">&#x27;name&#x27;</span><br><span class="hljs-keyword">def</span> person = [<span class="hljs-attr">key:</span> <span class="hljs-string">&#x27;Guillaume&#x27;</span>] （<span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">assert</span> !person.containsKey(<span class="hljs-string">&#x27;name&#x27;</span>) （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> person.containsKey(<span class="hljs-string">&#x27;key&#x27;</span>) （<span class="hljs-number">3</span>）<br></code></pre></td></tr></table></figure>

<p>（1）key同’Guillaume’关联，名字将会变为”key”字符串，而不是其值<br>（2）这个映射不包括”name”键<br>（3）代替的是，映射包括一个”key”键</p>
<p>你也能通过引用的字符串以及键: [“name”: “Guillaume”]。如果你的见字符串不是一个合法的标识符，这是强制的，例如，如果你想创建一个字符串键像哈希：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">[<span class="hljs-string">&quot;street-name&quot;</span>: <span class="hljs-string">&quot;Main street&quot;</span>]。<br></code></pre></td></tr></table></figure>

<p>在映射定义中需要传递变量值，你必须使用圆括号包围这个变量或表达式：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">person = [(key): <span class="hljs-string">&#x27;Guillaume&#x27;</span>] （<span class="hljs-number">1</span>）<br><br><span class="hljs-keyword">assert</span> person.containsKey(<span class="hljs-string">&#x27;name&#x27;</span>) （<span class="hljs-number">2</span>）<br><span class="hljs-keyword">assert</span> !person.containsKey(<span class="hljs-string">&#x27;key&#x27;</span>) （<span class="hljs-number">3</span>）<br></code></pre></td></tr></table></figure>

<p>（1）这次，我们使用圆括号包围key变量，指示解析器我们传递一个变量，而不是定义一个字符串键<br>（2）映射包含name键<br>（3）但映射不像之前包含key键</p>
<p>转载自 <a href="http://ifeve.com/groovy-syntax/">http://ifeve.com/groovy-syntax/</a></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+gitpage搭建自己的博客(一)</title>
    <url>/2016/10/21/hexo-gitpage%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%80/</url>
    <content><![CDATA[<p><strong>不说环境直接写配置的行为都是耍流氓</strong><br>按照惯例,先说自己的环境:<code>ubunu</code>,然后就没有然后了.<hr></p>
<span id="more"></span>
<p>　　<code>hexo</code>类似<code>wordpress</code>的博客框架,<code>gitpage</code>是<code>github</code>的一个服务,请原谅我这个不大准确的表达,事实上真的差不多.<br>安装<code>hexo</code>需要安装<code>nodejs</code>,使用<code>gitpage</code>需要<code>git</code>,至于如何安装<code>git</code>,在原来的csdn博客上有,<a href="http://blog.csdn.net/huangyuan_xuan/article/details/49125597">点击这里</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49125597">http://blog.csdn.net/huangyuan_xuan/article/details/49125597</a>.<br>之后需要在自己的github上创建一个仓库,名称结构如下:<code>username.github.io</code>,例如我的github主页是<code>https://github.com/huangyuanlove</code>,那么我的<code>gitpage</code>就是<code>huangyuanlove.github.io</code>.<br>到这里,默认大家的gitpage和git已经配置好了,包括sshkey之类的东西.</p>
<hr>
<p>　　我安装<code>node</code>是用<code>nvm</code>(node version manager)安装的,然后使用<code>node</code>中的<code>npm</code>(node package manager)安装hexo.windows下安装请转<a href="https://github.com/coreybutler/nvm-windows">这里</a> <a href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a><br>首先安装<code>nvm</code>:</p>
<blockquote>
<p><code>wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh  </code></p>
</blockquote>
<p><img src="/image/hexo/hexo_install_nvm.png" alt="安装nvm" title="安装nvm图片"><br>安装时间长短视网速而定,我安装了大概十多分钟,然后重启一下终端.<br>然后使用 <code>nvm ls-remote</code>查看一下有哪些本版可以安装,我当时安装的最新版是<code>6.6.0</code>,现在不知道是哪一版,如b下<br><img src="/image/hexo/nvm_ls-remote.png" alt="nvm ls-remote"><br>找一个合适的版本使用如下命令安装<br><code>nvm install version</code>,例如 <code>nvm install 6.6.0</code><br><img src="/image/hexo/nvm_install_6.6.0.png" alt="nvm ls-remote">,安装时间还是视网速而定,我也忘了装了多长时间了.<br>安装完成之后是这样的<br><img src="/image/hexo/nvm_install_down.png" alt="nvm_install_down"><br>之后<code>npm install -g hexo</code>安装<code>hexo</code>,<code>-g</code>参数是全局安装<br><img src="/image/hexo/npm_install_hexo.png" alt="npm_install_hexo"><br>安装完成之后使用<code>hexo -v</code>查看hexo的版本号<br><img src="/image/hexo/hexo-v.png" alt="hexo-v"><br>到此<code>hexo</code>安装完成,接下来就是初始化,进行配置了.下一篇再说吧,睡觉了.</p>
<hr>
<p>以上.</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>gitpage</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+gitpage搭建自己的博客(三)</title>
    <url>/2016/10/30/hexo-gitpage%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%B8%89/</url>
    <content><![CDATA[<p>前两篇介绍了怎么用gitpage+github搭建自己的博客，这次主要介绍怎么更换主题和加入评论、统计等。</p>
<hr>
<span id="more"></span>
<p><strong>更换主题</strong><br>首先将 <code>yilia</code>主题从github克隆到本地<code>thems</code>文件夹里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs git">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia<br></code></pre></td></tr></table></figure>
<p>看一下当前博客目录的结构<br><img src="/image/hexo/Catalog.png" alt="目录结构"></p>
<p>其中<code>_config.yml</code>文件就是整个<code>hexo</code>系统的主配置文件<br>另外刚才克隆的<code>yilia</code>主题就在<code>thems</code>文件夹下面<br>首先修改根目录下的<code>_config.yml</code>文件，切换到<code>yilia</code>主题<br>大概在文件的63-65行左右的位置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">yilia</span><br></code></pre></td></tr></table></figure>
<p>将原来的<code>theme</code>后面的 <code>landscape</code>主题改成<code>yilia</code><br>重启服务后主题就切换到<code>yilia</code>了，下面是<code>thems/yilia</code>文件夹下的<code>_config.yml</code>文件的配置.</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><br><span class="hljs-comment"># Header</span><br><span class="hljs-attr">menu:</span><br>  <span class="hljs-string">主页:</span> <span class="hljs-string">/</span><br>  <span class="hljs-string">简历:</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># SubNav</span><br><span class="hljs-attr">subnav:</span><br>  <span class="hljs-attr">github:</span> <span class="hljs-string">&quot;https://github.com/huangyuanlove&quot;</span><br>  <span class="hljs-comment">#weibo: &quot;#&quot;</span><br>  <span class="hljs-comment">#rss: &quot;#&quot;</span><br>  <span class="hljs-attr">zhihu:</span> <span class="hljs-string">&quot;https://www.zhihu.com/people/huangyuan_xuan&quot;</span><br>  <span class="hljs-comment">#douban: &quot;#&quot;</span><br>  <span class="hljs-comment">#mail: &quot;#&quot;</span><br>  <span class="hljs-comment">#facebook: &quot;#&quot;</span><br>  <span class="hljs-comment">#google: &quot;#&quot;</span><br>  <span class="hljs-comment">#twitter: &quot;#&quot;</span><br>  <span class="hljs-comment">#linkedin: &quot;#&quot;</span><br><br><span class="hljs-attr">rss:</span> <span class="hljs-string">/atom.xml</span><br><br><span class="hljs-comment"># 是否需要修改 root 路径</span><br><span class="hljs-comment"># 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，</span><br><span class="hljs-comment"># 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。</span><br><span class="hljs-attr">root:</span><br><br><span class="hljs-comment"># Content</span><br><span class="hljs-attr">excerpt_link:</span> <span class="hljs-string">more</span><br><span class="hljs-attr">fancybox:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">mathjax:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 是否开启动画效果</span><br><span class="hljs-attr">animate:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 是否在新窗口打开链接</span><br><span class="hljs-attr">open_in_new:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 自己添加的百度统计</span><br><span class="hljs-attr">baidu_tongji:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 网站icon</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">favicon.ico</span><br><br><span class="hljs-comment">#你的头像url</span><br><span class="hljs-attr">avatar:</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment">#是否开启分享</span><br><span class="hljs-attr">share_jia:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">share_addthis:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-comment">#多说评论</span><br><span class="hljs-attr">duoshuo:</span><br><br><span class="hljs-comment"># 如不需要，将该项置为false</span><br><span class="hljs-comment"># 比如</span><br><span class="hljs-comment">#smart_menu:</span><br><span class="hljs-comment">#  friends: false</span><br><br><span class="hljs-attr">smart_menu:</span><br>  <span class="hljs-attr">innerArchive:</span> <span class="hljs-string">&#x27;所有文章&#x27;</span><br>  <span class="hljs-attr">tagcloud:</span> <span class="hljs-string">&#x27;标签&#x27;</span><br>  <span class="hljs-comment">#friends: &#x27;友链&#x27;</span><br>  <span class="hljs-attr">aboutme:</span> <span class="hljs-string">&#x27;关于我&#x27;</span><br><br><span class="hljs-attr">friends:</span><br><span class="hljs-attr">aboutme:</span> <span class="hljs-string">&lt;a</span> <span class="hljs-string">href=&quot;http://www.huangyuanlove.com&quot;&gt;什么懂都点的Android攻城狮&lt;/a&gt;</span><br></code></pre></td></tr></table></figure>
<hr>
<p>以上是<code>yilia</code>主题的配置说明<br><strong>接入百度统计</strong><br>首先到<a href="http://tongji.baidu.com/web/welcome/login">百度统计平台</a> 申请一个帐号，按照提示填写完自己网站的信息，在网站中心左边栏点击代码获取，得到统计访问量的代码。<br>新建<code>themes/yilia/layout/_partial/baidu_tongji.ejs</code>文件，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript">&lt;% <span class="hljs-keyword">if</span> (theme.<span class="hljs-property">baidu_tongji</span>) &#123; %&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml">  统计访问量的代码</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure>
<p>然后编辑<code>themes/yilia/_config.yml</code>文件，添加一行<code>baidu_tongji: true</code>，注意冒号后面有空格。<br>编辑<code>themes/yilia/layout/_partial/head.ejs</code> 在 <code>&lt;/head&gt;</code> 前添加<br><code>&lt;%- partial(&quot;baidu_tongji&quot;) %&gt;</code><br>重启部署代码即可。<br>安装完成20分钟后就可以在后台看到统计的信息了，如果看不到统计信息，请检查是否配置正确，检测方式点<a href="http://tieba.baidu.com/p/3775626020">这里</a> <a href="http://tieba.baidu.com/p/3775626020">http://tieba.baidu.com/p/3775626020</a><br>以上是添加百度统计的方式<br><strong>添加多说评论</strong><br>到<a href="http://duoshuo.com/">多说</a> 申请帐号<br>使用三方登录完成后，点击<code>我要安装</code>，根据提示填写完信息<br><img src="/image/hexo/duoshuo.png" alt="多说"><br>记住站点名称，将站点名称填入 <code>thems/yilia/_config.yml</code>文件里面多说评论之后，注意冒号后面有空格。<br>保存重新部署就可以看到评论框了。<br>至于评论样式，可以在后台管理页面中的设置选项中设置。后台管理中还可以管理评论内容，添加敏感词汇过滤等。<br>以上是添加多说评论的过程。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>gitpage</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+gitpage搭建自己的博客(二)</title>
    <url>/2016/10/25/hexo-gitpage%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2-%E4%BA%8C/</url>
    <content><![CDATA[<p>之前我们已经安装好了<code>hexo</code>，接下来就是初始化了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">hexo init &lt;dir&gt;<br>cd &lt;dir&gt;<br>npm install<br></code></pre></td></tr></table></figure>
<span id="more"></span>
<p><img src="/image/hexo/hexo_init.png" alt="hexo_install"><br><img src="/image/hexo/npm_install.png" alt="hexo_install"><br>现在hexo就安装完成了，在存放hexo的文件夹目录下执行 <code>hexo s</code>，就可以启动hexo的服务，启动之后有提示，在浏览器中输入<code>127.0.0.1:4000</code>就可以看到最初的效果了，如下<br><img src="/image/hexo/hexo_hello.png" alt="hello_world"></p>
<hr>
<p>　　对了，还要发布到github。前提准备是在上一篇中已经创建好了github的仓库。接下来在存放hexo资源的文件夹下(以下用 heox_blog这个文件夹代替)执行<br><code>npm install hexo-deployer-git --save</code><br>修改hexo_blog文件夹下的<code>_config.yml</code>文件<br>在末尾添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">deploy:<br>  type: git<br>  repository: git@github.com:your name/your name.github.io.git<br>  branch: master<br></code></pre></td></tr></table></figure>
<p>注意，type，repository，branch冒号后面都有一个空格。保存后执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hexo">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure>
<p>就可以将写好的博客部署到github上了。（部署到github时建议按照顺序执行以上命令）</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs hexo">hexo generate == hexo g    --&gt;将md文件解析成静态的html文件<br>hexo deploy == hexo d      --&gt; 将文件部署到github<br>hexo server == hexo s      --&gt; 启动本地hexo服务<br>hexo clean				   --&gt; 清除缓存<br>hexo new &quot;title&quot; 			--&gt; 创建新的文章，文件在`hexo_blog/source/_posts`文件夹下<br></code></pre></td></tr></table></figure>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>gitpage</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>在kotlin协程中使用自定义CallAdapter处理错误</title>
    <url>/2024/03/29/kotlin%E4%B8%ADRetrofit2-x%E8%87%AA%E5%AE%9A%E4%B9%89CallAdapter%E5%81%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Retrofit在2019-06-05发布的2.6.0版本中就已经支持Kotlin 中的 suspend修饰符了，目前正准备在项目中使用 Kotlin，顺便替换一下网络库。这里先做一下调研和基础建设，方便后续的接入工作。<br>问就是15 年 16 年的老项目，之前并没有使用 Kotlin 的打算。</p>
<p>Retrofit已经在2024-03-28更新到2.11.0版本了，就用这个来做调研好了。</p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;com.squareup.retrofit2:retrofit:2.11.0&#x27;</span><br>implementation <span class="hljs-string">&#x27;com.squareup.retrofit2:converter-gson:2.11.0&#x27;</span><br>implementation <span class="hljs-string">&#x27;com.squareup.okhttp3:okhttp:4.12.0&#x27;</span><br></code></pre></td></tr></table></figure>
<p>由于需要对 OKHttpClient 做一些操作和定制，这里添加了 okhttp 的依赖。实体类的转换使用了 gson，为啥用 gson，问就是项目里面就是用的 gson，后面再介绍一下其他的converter。</p>
<ul>
<li>Gson: com.squareup.retrofit2:converter-gson</li>
<li>Jackson: com.squareup.retrofit2:converter-jackson</li>
<li>Moshi: com.squareup.retrofit2:converter-moshi</li>
<li>Protobuf: com.squareup.retrofit2:converter-protobuf</li>
<li>Wire: com.squareup.retrofit2:converter-wire</li>
<li>Simple XML: com.squareup.retrofit2:converter-simplexml</li>
<li>JAXB: com.squareup.retrofit2:converter-jaxb</li>
<li>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</li>
</ul>
<h3 id="声明请求接口"><a href="#声明请求接口" class="headerlink" title="声明请求接口"></a>声明请求接口</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MainPageApi</span></span>&#123;<br>  <span class="hljs-meta">@GET(<span class="hljs-string">&quot;app_interface/home_pag/&quot;</span>)</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMainPageInfoWithRow</span><span class="hljs-params">()</span></span>:Call&lt;MainPageInfo&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="创建-Retrofit-对象"><a href="#创建-Retrofit-对象" class="headerlink" title="创建 Retrofit 对象"></a>创建 Retrofit 对象</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()<br>    .baseUrl(BASE_URL)<br>    .addConverterFactory(GsonConverterFactory.create())<br>    .build()<br></code></pre></td></tr></table></figure>
<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> mainPageApi = retrofit.create(MainPageApi::<span class="hljs-keyword">class</span>.java)<br>mainPageApi.getMainPageInfoWithCall().enqueue(<span class="hljs-keyword">object</span>:retrofit2.Callback&lt;MainPageInfo&gt;&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">MainPageInfo</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">        response: <span class="hljs-type">retrofit2</span>.<span class="hljs-type">Response</span>&lt;<span class="hljs-type">MainPageInfo</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span> &#123;<br>        Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>,<span class="hljs-string">&quot;getMainPageInfoWithCall onResponse&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">MainPageInfo</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>        Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>,<span class="hljs-string">&quot;getMainPageInfoWithCall onFailure&quot;</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>到这里为止，我们还没有使用任何协程相关的特性，并且没有都得写回调，和 Java 写起来也没啥差别。</p>
<h3 id="支持协程"><a href="#支持协程" class="headerlink" title="支持协程"></a>支持协程</h3><p>我们对接口的声明加上<code>suspend</code>修饰</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@GET(<span class="hljs-string">&quot;app_interface/home_pag/&quot;</span>)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMainPageInfoWithRow</span><span class="hljs-params">()</span></span>:Call&lt;MainPageInfo&gt;<br></code></pre></td></tr></table></figure>
<p>这时候上面直接发送请求的代码会报错：<br><img src="/image/Android/kotlin/suspend_retrofit_error.png" alt="suspend_retrofit_error"><br>提示我们需要在协程中调用，这也简单，kotlin 对 activity 有个扩展的<code>lifecycleScope</code>成员变量，稍微修改一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">lifecycleScope.launch(Dispatchers.IO) &#123;<br>  mainPageApi.getMainPageInfoWithCall().enqueue(.....)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不习惯这么写的话，可以将网络请求写在 ViewModel 中，通过 LiveData创建一个可观察对象实现数据绑定。</p>
<p>不出意外的出意外了，应用崩溃，错误信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">java.lang.IllegalArgumentException: Suspend functions should not return Call, as they already execute asynchronously.<br>Change its return type to class com.huangyuanlove.androidtest.kotlin.retrofit.MainPageInfo<br></code></pre></td></tr></table></figure>
<p>意思是在协程中发起请求已经是异步的了，不需要再返回 Call 对象了，直接返回对应的实体即可。<br>简单，修改一下接口声明</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@GET(<span class="hljs-string">&quot;app_interface/home_page/&quot;</span>)</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMainPageInfoWithRow</span><span class="hljs-params">()</span></span>:MainPageInfo<br></code></pre></td></tr></table></figure>
<p>然后修改一下请求</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">lifecycleScope.launch(Dispatchers.IO) &#123;<br>  <span class="hljs-keyword">val</span> mainPageInfo = mainPageApi.getMainPageInfo()<br>  withContext(Dispatchers.Main) &#123;<br>    refreshUI(mainPageInfo)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行一下，一切正常。我们修改一下接口，请求一个不存在的地址，会返回404，不出意外，应用还是崩溃</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">retrofit2.HttpException: HTTP 404 <br>at retrofit2.KotlinExtensions$await$2$2.onResponse(KotlinExtensions.kt:53)<br>at retrofit2.OkHttpCall$1.onResponse(OkHttpCall.java:164)<br>at okhttp3.internal.connection.RealCall$AsyncCall.run(RealCall.kt:519)<br>at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)<br>at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)<br>at java.lang.Thread.run(Thread.java:929)<br>Suppressed: kotlinx.coroutines.internal.DiagnosticCoroutineContextException: [StandaloneCoroutine&#123;Cancelling&#125;@ffa6ad2, Dispatchers.IO]<br></code></pre></td></tr></table></figure>
<p>哦~异常没有处理，粗暴点，直接 try-catch，kotlin 中还有<code>runCatching</code>这个语法糖</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> mainPageInfoRow = runCatching &#123; mainPageApi.getMainPageInfoWithRow() &#125;<br><span class="hljs-keyword">if</span> (mainPageInfoRow.isFailure) &#123;<br>    ToastUtils.showToast(<span class="hljs-string">&quot;请求失败&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mainPageInfoRow.isSuccess) &#123;<br>    ToastUtils.showToast(<span class="hljs-string">&quot;请求成功&quot;</span>)<br>    withContext(Dispatchers.Main) &#123;<br>        <span class="hljs-keyword">if</span> (mainPageInfoRow.getOrNull() == <span class="hljs-literal">null</span>) &#123;<br>            ToastUtils.showToast(<span class="hljs-string">&quot;请求结果为空&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            refreshViewWithLaunch(mainPageInfoRow.getOrNull()!!)<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是有时候我们会用<code>HTTP状态码</code>来表示一些业务上逻辑错误，并且不同的状态码返回的 JSON 结构还可能不一样。 别问为啥要这么搞，应该是HTTP 状态码就应该表示网络请求的状态，业务状态应该放在返回的数据中约定字段来处理。问就是15年的老代码，之前就是这么搞的，并且大范围应用，涉及到的部门、业务占半数以上。<br>这时候我们需要自定义<code>CallAdapter</code>了</p>
<h3 id="自定义-CallAdapter"><a href="#自定义-CallAdapter" class="headerlink" title="自定义 CallAdapter"></a>自定义 CallAdapter</h3><p>这时候就应该翻一下源码了，在<code>example</code>有个<code>ErrorHandlingAdapter.java</code>,路径在<a href="https://github.com/square/retrofit/blob/trunk/samples/src/main/java/com/example/retrofit/ErrorHandlingAdapter.java">samples&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;example&#x2F;retrofit&#x2F;ErrorHandlingAdapter.java</a>。<br>我们来仿写一下，最关键的点在实现自己的 Call 类的时候，对callback 的处理。</p>
<h4 id="定义不同的返回状态"><a href="#定义不同的返回状态" class="headerlink" title="定义不同的返回状态"></a>定义不同的返回状态</h4><p>第一步，创建密闭类，来表示不同的状态，这里暂且定义了三种情况</p>
<ul>
<li>Success:HTTP状态码在<code>[200,300)</code>这个区间</li>
<li>NetError:HTTP状态码不在<code>[200,300)</code>这个区间</li>
<li>UnknownError:其他错误</li>
</ul>
<p>sealed class NetworkResponse&lt;out T : Any, out U : Any&gt; {<br>    data class Success<T : Any>(val body: T) : NetworkResponse&lt;T, Nothing&gt;()<br>    data class NetError(val httpCode:Int?,val errorMsg:String?,val exception: Throwable?) : NetworkResponse&lt;Nothing, Nothing&gt;()<br>    data class UnknownError(val error: Throwable?) : NetworkResponse&lt;Nothing, Nothing&gt;()<br>}</p>
<h4 id="创建自己的Call类"><a href="#创建自己的Call类" class="headerlink" title="创建自己的Call类"></a>创建自己的Call类</h4><p>这里为了简化方便，除了<code>enqueue</code>之外必须重写的方法，都是直接调用<code>delegate</code>对应的方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkResponseCall</span>&lt;<span class="hljs-type">S : Any, E : Any</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> delegate: Call&lt;S&gt;,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> errorConverter: Converter&lt;ResponseBody, E&gt;<br>) : Call&lt;NetworkResponse&lt;S, E&gt;&gt; &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clone</span><span class="hljs-params">()</span></span>: Call&lt;NetworkResponse&lt;S, E&gt;&gt; &#123;<br>        <span class="hljs-keyword">return</span> NetworkResponseCall(delegate.clone(), errorConverter);<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>: Response&lt;NetworkResponse&lt;S, E&gt;&gt; &#123;<br>        <span class="hljs-keyword">throw</span> UnsupportedOperationException(<span class="hljs-string">&quot;NetworkResponseCall doesn&#x27;t support execute&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isExecuted</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> delegate.isExecuted;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span></span> &#123;<br>        delegate.cancel()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isCanceled</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> delegate.isCanceled<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">request</span><span class="hljs-params">()</span></span>: Request &#123;<br>        <span class="hljs-keyword">return</span> delegate.request()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">timeout</span><span class="hljs-params">()</span></span>: Timeout &#123;<br>        <span class="hljs-keyword">return</span> delegate.timeout();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面是关键的<code>enqueue</code>方法,在这里面，将所有的请求都用<code>Response.success</code>返回，不再走<code>Response.error</code>.并且根据不同的 HTTP 状态码，返回的数据等条件转成一开始定义的密闭类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(callback: <span class="hljs-type">Callback</span>&lt;<span class="hljs-type">NetworkResponse</span>&lt;<span class="hljs-type">S</span>, E&gt;&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">return</span> delegate.enqueue(<span class="hljs-keyword">object</span> : Callback&lt;S&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">S</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">S</span>&gt;)</span></span> &#123;<br>            <span class="hljs-keyword">val</span> body = response.body()<br>            <span class="hljs-keyword">val</span> code = response.code()<br>            <span class="hljs-keyword">val</span> error = response.errorBody()<br><br>            <span class="hljs-keyword">if</span> (response.isSuccessful) &#123;<br>                <span class="hljs-keyword">if</span> (body != <span class="hljs-literal">null</span>) &#123;<br>                    callback.onResponse(<br>                        <span class="hljs-keyword">this</span><span class="hljs-symbol">@NetworkResponseCall</span>,<br>                        Response.success(NetworkResponse.Success(body))<br>                    )<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <br>                    callback.onResponse(<br>                        <span class="hljs-keyword">this</span><span class="hljs-symbol">@NetworkResponseCall</span>,<br>                        Response.success(NetworkResponse.UnknownError(<span class="hljs-literal">null</span>))<br>                    )<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">val</span> errorBody = <span class="hljs-keyword">when</span> &#123;<br>                    error == <span class="hljs-literal">null</span> -&gt; <span class="hljs-literal">null</span><br>                    error.contentLength() == <span class="hljs-number">0L</span> -&gt; <span class="hljs-literal">null</span><br>                    <span class="hljs-keyword">else</span> -&gt; NetworkResponse.NetError(code, error.toString(), <span class="hljs-literal">null</span>)<br>                &#125;<br>                <span class="hljs-keyword">if</span> (errorBody != <span class="hljs-literal">null</span>) &#123;<br>                    callback.onResponse(<br>                        <span class="hljs-keyword">this</span><span class="hljs-symbol">@NetworkResponseCall</span>,<br>                        Response.success(errorBody)<br>                    )<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    callback.onResponse(<br>                        <span class="hljs-keyword">this</span><span class="hljs-symbol">@NetworkResponseCall</span>,<br>                        Response.success(NetworkResponse.UnknownError(<span class="hljs-literal">null</span>))<br>                    )<br>                &#125;<br>            &#125;<br><br><br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">S</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;<br>            <span class="hljs-keyword">val</span> networkResponse = <span class="hljs-keyword">when</span> (t) &#123;<br>                <span class="hljs-keyword">is</span> Exception -&gt; NetworkResponse.NetError(<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,t)<br>                <span class="hljs-keyword">else</span> -&gt; NetworkResponse.UnknownError(t)<br>            &#125;<br>            callback.onResponse(<span class="hljs-keyword">this</span><span class="hljs-symbol">@NetworkResponseCall</span>, Response.success(networkResponse))<br>        &#125;<br><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="创建-CallAdapter"><a href="#创建-CallAdapter" class="headerlink" title="创建 CallAdapter"></a>创建 CallAdapter</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkResponseAdapter</span>&lt;<span class="hljs-type">S : Any, E : Any</span>&gt;</span>(<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> successType: Type,<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> errorBodyConverter: Converter&lt;ResponseBody, E&gt;<br>) : CallAdapter&lt;S, Call&lt;NetworkResponse&lt;S, E&gt;&gt;&gt; &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">responseType</span><span class="hljs-params">()</span></span>: Type = successType<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">adapt</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">S</span>&gt;)</span></span>: Call&lt;NetworkResponse&lt;S, E&gt;&gt; &#123;<br>        <span class="hljs-keyword">return</span> NetworkResponseCall(call, errorBodyConverter)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="创建CallAdapterFactory"><a href="#创建CallAdapterFactory" class="headerlink" title="创建CallAdapterFactory"></a>创建CallAdapterFactory</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">NetworkResponseAdapterFactory</span>:<span class="hljs-type">CallAdapter.Factory</span></span>()&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        returnType: <span class="hljs-type">Type</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        annotations: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Annotation</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">        retrofit: <span class="hljs-type">Retrofit</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: CallAdapter&lt;*, *&gt;? &#123;<br>        <span class="hljs-comment">// suspend functions wrap the response type in `Call`</span><br>        <span class="hljs-keyword">if</span>(Call::<span class="hljs-keyword">class</span>.java != getRawType(returnType))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>        &#125;<br>        check(returnType <span class="hljs-keyword">is</span> ParameterizedType)&#123;<br>            <span class="hljs-string">&quot;return type must be parameterized as Call&lt;NetworkResponse&lt;&lt;Foo&gt;&gt; or Call&lt;NetworkResponse&lt;out Foo&gt;&gt;&quot;</span><br>        &#125;<br>        <span class="hljs-comment">// get the response type inside the `Call` type</span><br>        <span class="hljs-keyword">val</span> responseType = getParameterUpperBound(<span class="hljs-number">0</span>,returnType)<br>        <span class="hljs-comment">// if the response type is not ApiResponse then we can&#x27;t handle this type, so we return null</span><br>        <span class="hljs-keyword">if</span>(getRawType(responseType) != NetworkResponse::<span class="hljs-keyword">class</span>.java)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>        &#125;<br><br><br>        <span class="hljs-comment">// the response type is ApiResponse and should be parameterized</span><br>        check(responseType <span class="hljs-keyword">is</span> ParameterizedType) &#123; <span class="hljs-string">&quot;Response must be parameterized as NetworkResponse&lt;Foo&gt; or NetworkResponse&lt;out Foo&gt;&quot;</span> &#125;<br><br>        <span class="hljs-keyword">val</span> successBodyType = getParameterUpperBound(<span class="hljs-number">0</span>, responseType)<br>        <span class="hljs-keyword">val</span> errorBodyType = getParameterUpperBound(<span class="hljs-number">1</span>, responseType)<br><br>        <span class="hljs-keyword">val</span> errorBodyConverter =<br>            retrofit.nextResponseBodyConverter&lt;Any&gt;(<span class="hljs-literal">null</span>, errorBodyType, annotations)<br><br>        <span class="hljs-keyword">return</span> NetworkResponseAdapter&lt;Any, Any&gt;(successBodyType, errorBodyConverter)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="构建-Retrofit-实例时添加该-Factory"><a href="#构建-Retrofit-实例时添加该-Factory" class="headerlink" title="构建 Retrofit 实例时添加该 Factory"></a>构建 Retrofit 实例时添加该 Factory</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> retrofit = Retrofit.Builder()<br>    .baseUrl(BASE_URL)<br>    .addCallAdapterFactory(NetworkResponseAdapterFactory())<br>    .addConverterFactory(GsonConverterFactory.create())<br>    .build()<br></code></pre></td></tr></table></figure>

<h4 id="使用typealias简化返回类型-可选"><a href="#使用typealias简化返回类型-可选" class="headerlink" title="使用typealias简化返回类型(可选)"></a>使用typealias简化返回类型(可选)</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpError</span></span>(<span class="hljs-keyword">val</span> httpCode:<span class="hljs-built_in">Int</span>,<span class="hljs-keyword">val</span> errorMsg:String?,<span class="hljs-keyword">val</span> exception: Throwable?)<br><span class="hljs-comment">// before</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DemoApiService</span> </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mainPageInfo</span><span class="hljs-params">()</span></span>: NetworkResponse&lt;MainPageInfo, HttpError&gt;<br>&#125;<br><span class="hljs-comment">// after</span><br><span class="hljs-keyword">typealias</span> GenericResponse&lt;S&gt; = NetworkResponse&lt;S, HttpError&gt;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApiService</span> </span>&#123;<br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">mainPageInfo</span><span class="hljs-params">()</span></span>: GenericResponse&lt;MainPageInfo&gt;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在 Activity 中直接使用lifecycleScope启动协程。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">lifecycleScope.launch(Dispatchers.IO) &#123;<br>    Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>, <span class="hljs-string">&quot;lifecycleScope.launch --&gt;&gt;&quot;</span> + Thread.currentThread().name);<br>    <span class="hljs-keyword">val</span> mainPageInfo = mainPageApi.getMainPageInfo()<br><br>    withContext(Dispatchers.Main) &#123;<br>        Log.e(<br>            <span class="hljs-string">&quot;KotlinActivity&quot;</span>,<br>            <span class="hljs-string">&quot;withContext(Dispatchers.Main) --&gt;&gt;&quot;</span> + Thread.currentThread().name<br>        );<br>        <span class="hljs-keyword">when</span>(mainPageInfo)&#123;<br><br>            <span class="hljs-keyword">is</span> NetworkResponse.NetError -&gt; Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>,<br>                <span class="hljs-string">&quot;NetError-&gt;<span class="hljs-variable">$mainPageInfo</span>&quot;</span><br>            )<br>            <span class="hljs-keyword">is</span> NetworkResponse.Success -&gt;  refreshViewWithLaunch(mainPageInfo.body)<br>            <span class="hljs-keyword">is</span> NetworkResponse.UnknownError -&gt; Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>,<span class="hljs-string">&quot;UnknownError-&gt;&quot;</span> + mainPageInfo.error)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>或者在 ViewModel 中借助 LiveData 将返回值转化为可观察对象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainPageInfoViewModel</span>:<span class="hljs-type">ViewModel</span></span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _mainPageInfo  = MutableLiveData&lt;MainPageInfo&gt;()<br>    <span class="hljs-keyword">val</span> mainPageInfo: LiveData&lt;MainPageInfo&gt; <span class="hljs-keyword">get</span>() = _mainPageInfo<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getMainPageInfo</span><span class="hljs-params">()</span></span>&#123;<br>        viewModelScope.launch(Dispatchers.IO)&#123;<br>            <span class="hljs-keyword">val</span> result = mainPageApi.getMainPageInfo()<br>            withContext(Dispatchers.Main)&#123;<br>                <span class="hljs-keyword">when</span>(result)&#123;<br>                    <span class="hljs-keyword">is</span> NetworkResponse.NetError -&gt; Log.e(<span class="hljs-string">&quot;MainPageInfoViewModel&quot;</span>,<br>                        <span class="hljs-string">&quot;NetError-&gt;<span class="hljs-variable">$result</span>&quot;</span><br>                    )<br>                    <span class="hljs-keyword">is</span> NetworkResponse.Success -&gt;  _mainPageInfo.value =  result.body<br>                    <span class="hljs-keyword">is</span> NetworkResponse.UnknownError -&gt; Log.e(<span class="hljs-string">&quot;MainPageInfoViewModel&quot;</span>,<span class="hljs-string">&quot;UnknownError-&gt;&quot;</span> + result.error)<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 Activity 中使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">mainPageInfoModel = ViewModelProvider(<span class="hljs-keyword">this</span>).<span class="hljs-keyword">get</span>(MainPageInfoViewModel::<span class="hljs-keyword">class</span>.java)<br>mainPageInfoModel.mainPageInfo.observe(<span class="hljs-keyword">this</span>, Observer &#123;<br>    <span class="hljs-keyword">if</span> (it != <span class="hljs-literal">null</span>) &#123;<br>        Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>, <span class="hljs-string">&quot;viewmodel获取结果成功&quot;</span>)<br>        refreshViewWithViewModelResult(it);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Log.e(<span class="hljs-string">&quot;KotlinActivity&quot;</span>, <span class="hljs-string">&quot;viewmodel获取结果为空&quot;</span>)<br>    &#125;<br>&#125;)<br>mainPageInfoModel.getMainPageInfo()<br></code></pre></td></tr></table></figure>
<p>暂时先这样吧，基本上够用了</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin中的 object 关键字</title>
    <url>/2024/05/31/kotlin%E4%B8%AD%E7%9A%84-object-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>kotlin 中的<code>object</code>关键字用处比较广泛，在官方文档<a href="https://book.kotlincn.net/text/object-declarations.html">对象表达式与对象声明</a>有详细的介绍，比如：创建匿名对象、创建匿名内部类并继承某个类，实现多个接口、使用匿名对象作为返回和值类型、从匿名对象访问变量、单例模式、数据对象、伴生对象等，不过文章是从<code>对象表达式</code>和<code>对象声明</code>角度来区分的。</p>
<span id="more"></span>

<h3 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h3><p>对象表达式可以用来创建匿名类，就是不用<code>class</code>来声明的类，当这个类只用一次的时候是很有帮助的。我们可以从头开始定义匿名类，也可以从现有类继承，还可以实现接口。匿名类的实例也称为匿名对象，因为它们是由表达式而不是名称定义的。</p>
<h4 id="创建匿名类"><a href="#创建匿名类" class="headerlink" title="创建匿名类"></a>创建匿名类</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> helloWorld = <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> hello = <span class="hljs-string">&quot;Hello&quot;</span><br>        <span class="hljs-keyword">val</span> world = <span class="hljs-string">&quot;World&quot;</span><br>        <span class="hljs-comment">//object expressions extend Any, so `override` is required on `toString()`</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-variable">$hello</span> <span class="hljs-variable">$world</span>&quot;</span><br>        &#125;<br>    &#125;<br>    println(helloWorld)<br>    println(helloWorld.javaClass.simpleName)<br>    println(helloWorld.javaClass.name)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，这种方式在某种意义上和 js 中创建对象差不多，<code>helloWorld</code>这个实例的<code>helloWorld.javaClass.simpleName</code>是空的。当然了匿名类也是类，只是没有名字而已，当然做了继承其他类，实现其他接口。注意，同样只能单继承多实现，并且父类构造函数需要参数时可以传适当的构造参数。<br>比如这样：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnClickListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">interface</span>  <span class="hljs-title">OnLongClickListener</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLongClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span><br>&#125;<br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnScroll</span></span>&#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onScroll</span><span class="hljs-params">(direction: <span class="hljs-type">Int</span>)</span></span><br>&#125;<br><span class="hljs-keyword">val</span> viewListener = <span class="hljs-keyword">object</span> : OnScroll(),OnLongClickListener, OnClickListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onScroll</span><span class="hljs-params">(direction: <span class="hljs-type">Int</span>)</span></span> &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;view clicked&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLongClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然也可以直接当成参数传入调用的方法，都是一样的。本质上都是创建了一个对象。</p>
<h4 id="使用匿名对象作为返回值或类型"><a href="#使用匿名对象作为返回值或类型" class="headerlink" title="使用匿名对象作为返回值或类型"></a>使用匿名对象作为返回值或类型</h4><p>当匿名对象被用作局部或私有但非内联声明（函数或属性）的类型时，其所有成员都可通过该函数或属性访问：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span>= <span class="hljs-keyword">object</span> &#123;<br>       <span class="hljs-keyword">val</span> x = <span class="hljs-string">&quot;x&quot;</span><br>  &#125;<br>    <br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>      println(getObject().x)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>如果方法供或者属性是 public 或者 private inline 时，它的实际类型可能如下：</p>
<ul>
<li>如果没有明确声明类型，则是<code>Any</code></li>
<li>如果只有一个父类或者一个接口，则是改父类或者接口类型</li>
<li>如果有一个父类和多个接口，则是方法明确返回的类型<br>比如<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC</span> </span>&#123;<br>    <span class="hljs-comment">// 返回值类型是 Any; 不能在其他方法中访问 x</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> x: String = <span class="hljs-string">&quot;x&quot;</span><br>    &#125;<br><br>    <span class="hljs-comment">// 返回值类型是 AA; 不能在其他方法中访问 x</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObjectAA</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span>: AA &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">funFromA</span><span class="hljs-params">()</span></span> &#123;&#125;<br>        <span class="hljs-keyword">val</span> x: String = <span class="hljs-string">&quot;x&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-comment">//这里会报错，访问不到 x 属性</span><br>            println(getObject().x)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回值类型是 BB; 不能在其他方法中访问 x</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObjectBB</span><span class="hljs-params">()</span></span>: BB = <span class="hljs-keyword">object</span>: AA, BB &#123; <span class="hljs-comment">// explicit return type is required</span><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">funFromA</span><span class="hljs-params">()</span></span> &#123;&#125;<br>        <span class="hljs-keyword">val</span> x: String = <span class="hljs-string">&quot;x&quot;</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-comment">//这里会报错，访问不到 x 属性</span><br>            println(getObject().x)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="匿名对象访问变量"><a href="#匿名对象访问变量" class="headerlink" title="匿名对象访问变量"></a>匿名对象访问变量</h4>对象表达式中的代码可以访问来自包含它的作用域的变量：<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AAA</span></span>&#123;<br>    <span class="hljs-keyword">val</span> x = <span class="hljs-string">&quot;x&quot;</span><br>    <span class="hljs-keyword">val</span> y = <span class="hljs-string">&quot;y&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getObject</span><span class="hljs-params">()</span></span> = <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> xx = x<span class="hljs-comment">//不报错</span><br>        <span class="hljs-keyword">val</span> yy = y<span class="hljs-comment">//不报错</span><br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AAAA</span></span>&#123;<br>        <span class="hljs-keyword">val</span> xx = x <span class="hljs-comment">//报错</span><br>    &#125;<br>    <span class="hljs-keyword">object</span> BBBB&#123;<br>        <span class="hljs-keyword">val</span> xx = x<span class="hljs-comment">//报错</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="对象声明"><a href="#对象声明" class="headerlink" title="对象声明"></a>对象声明</h3><h4 id="实现单例模式"><a href="#实现单例模式" class="headerlink" title="实现单例模式"></a>实现单例模式</h4><p>在Kotlin当中，要实现<code>单例模式</code>其实非常简单，我们直接用<code>object</code>修饰类即可,当然这个单例类也是可以有父类的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MyViewListener : OnClickListener, OnLongClickListener &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;view clicked&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLongClick</span><span class="hljs-params">(view: <span class="hljs-type">View</span>?)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;view long clicked&quot;</span>)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;test&quot;</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>调用的时候直接<code>类名.方法名</code>即可。这里有个注意点：对象声明不能在局部作用域（即不能直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中。</p>
<h4 id="数据对象-data-object"><a href="#数据对象-data-object" class="headerlink" title="数据对象(data object)"></a>数据对象(data object)</h4><p>当我们想要打印<code>object</code>对象声明时，字符串表示同时包含其名称和对象的哈希：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> MyObject<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(MyObject) <span class="hljs-comment">// MyObject@3ac3fd8b</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以还用<code>data</code>关键字来修饰它</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">object</span>  MyDataObject&#123;<br>    <span class="hljs-keyword">val</span> x = <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样的话，编译器会为这个对象生成<code>toString()</code>方法，该方法只会返回对象名字。还有成对出现的<code>equals()/hashCode()</code>.这里有一点需要注意：<br>被重写的<code>equals()</code>方法会将所有相同名字的<code>data object</code>都返回<code>true</code>,这个解释不是太严谨，因为绝大部分情况下，<code>data object</code>是单例的，在运行时只会有一个对象，但我们可以通过平台相关的方法创建另外一个实例对象，比如 jvm 上的反射、序列化和反序列化等。因此，在比较<code>data object</code>是否相同时，请使用<code>==</code>而不是<code>===</code></p>
<h5 id="data-class-和-data-object-的不同"><a href="#data-class-和-data-object-的不同" class="headerlink" title="data class 和 data object 的不同"></a>data class 和 data object 的不同</h5><p>虽然数据类和数据对象经常一起使用，并且有一些相同点，但有些函数在<code>data object</code>中是不会生成的</p>
<ul>
<li>没有<code>copy()</code>方法，因为<code>data object</code>用作单例对象，所以不会生成该方法。如果允许创建另外个实例对象，则违反了该模式。</li>
<li>没有<code>componentN()</code>方法，该方法的一个简单的用法就是用于结构对象，允许一次性获取对象的所有属性值，并将它们作为单独的参数传递给函数或构造器。但由于<code>data object</code>没有属性，生成这些方法是没有意义的。</li>
</ul>
<h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><p>在<code>kotlin</code>中并没有<code>static</code>关键字,那么我们如何实现静态方法的效果？我们可以使用<code>companion</code>和<code>object</code>关键字达到这个效果</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">MyClassOne</span></span>&#123;<br>    <span class="hljs-keyword">object</span> A&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createA</span><span class="hljs-params">()</span></span>: MyClassOne = MyClassOne()<br>    &#125;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> AA&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createAA</span><span class="hljs-params">()</span></span>: MyClassOne = MyClassOne()<br>    &#125;<br>&#125;<br>MyClassOne.A.createA()<br>MyClassOne.createAA()<br></code></pre></td></tr></table></figure>
<p>但是看反编译之后的代码，编译器还是为我们创建了<code>A</code>和<code>AA</code>两个类。如果在<code>jvm</code>平台，我们可以使用<code>@JvmStatic</code>注解，将伴生对象的成员生成为真正的静态方法和字段。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassOneJVMStatic</span></span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> AAA &#123;<br>        <span class="hljs-meta">@JvmStatic</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: MyClassOneJVMStatic = MyClassOneJVMStatic()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然，对于上面<code>MyClassOne</code>中的<code>AA</code>是可以省略名字的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassTwo</span></span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: MyClassTwo = MyClassTwo()<br>    &#125;<br>&#125;<br>MyClassTwo.Companion.create()<span class="hljs-comment">//正确，但会提示Companion是不必要的</span><br>MyClassTwo.create()<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure>
<p>请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: T<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> : Factory&lt;MyClass&gt; &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>: MyClass = MyClass()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> f: Factory&lt;MyClass&gt; = MyClass<br></code></pre></td></tr></table></figure>

<h3 id="对象表达式和对象声明之间的语义差异"><a href="#对象表达式和对象声明之间的语义差异" class="headerlink" title="对象表达式和对象声明之间的语义差异"></a>对象表达式和对象声明之间的语义差异</h3><p>对象表达式和对象声明之间有一个重要的语义差别：</p>
<ul>
<li>对象表达式是在使用他们的地方立即执行（及初始化）的。</li>
<li>对象声明是在第一次被访问到时延迟初始化的。</li>
<li>伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配 。</li>
</ul>
<p>参考：<br><a href="https://book.kotlincn.net/text/object-declarations.html">对象表达式与对象声明</a><br><a href="https://kotlinlang.org/docs/object-declarations.html">Object expressions and declarations</a><br><a href="https://book.kotlincn.net/text/java-to-kotlin-interop.html#%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5">静态字段</a></p>
<hr>
<p>已学习：</p>
<ul>
<li><p>扩展</p>
<ul>
<li><input type='checkbox' disabled='true' checked>扩展函数</input></li>
<li><input type='checkbox' disabled='true' checked>扩展属性</input></li>
<li><input type='checkbox' disabled='true' checked>作用域</input></li>
</ul>
</li>
<li><p>函数类型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li>
<li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li>
<li><input type='checkbox' disabled='true' checked>SAM 转换</input></li>
</ul>
</li>
<li><p>泛型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>逆变</input></li>
<li><input type='checkbox' disabled='true' checked>协变</input></li>
<li><input type='checkbox' disabled='true' checked>类型投影</input></li>
<li><input type='checkbox' disabled='true' checked>星投影</input></li>
<li><input type='checkbox' disabled='true' checked>泛型约束</input></li>
</ul>
</li>
<li><p>关键字</p>
<ul>
<li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li>
<li><input type='checkbox' disabled='true' checked>object:匿名内部类、单例模式、伴生对象</input></li>
</ul>
</li>
<li><p>委托</p>
<ul>
<li><input type='checkbox' disabled='true' checked>委托类</input></li>
<li><input type='checkbox' disabled='true' checked>委托属性</input></li>
<li><input type='checkbox' disabled='true' checked>自定义委托</input></li>
</ul>
</li>
</ul>
<p>未学习：</p>
<ul>
<li><p>关键字</p>
<ul>
<li>Unit</li>
<li>Nothing</li>
<li>inline,noinline,crossinline</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li>启动</li>
<li>挂起</li>
<li>Job</li>
<li>Context</li>
<li>Channel</li>
<li>Flow</li>
<li>select</li>
<li>并发、异常</li>
<li>launch</li>
<li>Dispatchers</li>
<li>CoroutineScope</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin中的内联函数</title>
    <url>/2024/06/26/kotlin%E4%B8%AD%E7%9A%84%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>众所周知，在 kotlin 中函数是一等公民，在源码、各种框架中都能看到高阶函数的身影，我们也发现伴随着高阶函数的还有几个关键字：<code>inline</code>,<code>noinline</code>,<code>crossinline</code>。那这些关键字有什么作用？应该如何使用？</p>
<span id="more"></span>

<h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p><code>inline</code>关键字用于指示编译器将函数及其参数内联展开到调用处。内联函数可以减少函数调用的开销，并允许非局部返回<br><strong>作用</strong>：</p>
<ul>
<li>减少函数调用开销：通过内联展开，消除了函数调用的开销。</li>
<li>允许非局部返回：内联函数的 lambda 参数可以使用 return 从外部函数返回。</li>
</ul>
<p>先看一下没有<code>inline</code>修饰的情况</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHi</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;hi&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    hello()<br>    sayHi()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>再看一下反编译成 java 代码的样子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InlineKt</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">$i$f$hello</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>      System.out.println(var1);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">var0</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hi&quot;</span>;<br>      System.out.println(var0);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">$i$f$hello</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>      System.out.println(var1);<br>      sayHi();<br>   &#125;<br><br>   <span class="hljs-comment">// $FF: synthetic method</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      main();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，被<code>inline</code>修饰的代码直接展开复制到了调用的地方，好处是什么？少了一层调用栈，减少了开销。坏处：函数体被展开复制到了调用的地方，编译后的产物体积肯定会增大。<br>那这样的话，为啥也要有<code>inline</code>关键字嘞，看着也没啥用。其实除了可以<strong>内联自己内部的代码</strong>，还可以<strong>内联作为参数的方法代码</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(postAction:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    postAction()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHi</span><span class="hljs-params">(postAction:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;hi&quot;</span>)<br>    postAction()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    hello &#123; println(<span class="hljs-string">&quot;hello lambda&quot;</span>) &#125;<br>    sayHi &#123; println(<span class="hljs-string">&quot;sayHi lambda&quot;</span>) &#125;<br><br>    hello (<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    &#125;)<br>    sayHi (<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;sayHi&quot;</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>众所众知，Java 中是不支持函数作为参数传递的，但 kotlin 可以，那么转成字节码运行在 jvm 上是怎么处理的？办法是将其包装成一个对象来调用。<br>看反编译成 java 的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">$i$f$hello</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>  System.out.println(var1);<br>  <span class="hljs-type">int</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello lambda&quot;</span>;<br>  System.out.println(var3);<br>  sayHi((Function0)<span class="hljs-literal">null</span>.INSTANCE);<br>  $i$f$hello = <span class="hljs-literal">false</span>;<br>  var1 = <span class="hljs-string">&quot;hello&quot;</span>;<br>  System.out.println(var1);<br>  var2 = <span class="hljs-literal">false</span>;<br>  var3 = <span class="hljs-string">&quot;hello&quot;</span>;<br>  System.out.println(var3);<br>  sayHi((Function0)<span class="hljs-literal">null</span>.INSTANCE);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，在调用<code>sayHi</code>的地方实际是创建了一个<code>Function0</code>对象进去，也许创建者一次对象的开销可以湖绿，但如果是用在频繁调用的场景下呢？比如页面刷新绘制、循环等等等等。如果真的是这样，这不就有可能会造成面试中经常问到的<code>内存抖动</code>么。<br>所以，这种时候，我们使用<code>inline</code>可以减少参数对象的创建，从而避免出现一些问题。<br>但是，我们也不能看见频繁调用的函数就加上<code>inline</code>，毕竟谁也不会为了减少一次调用栈，把函数体直接复制到每个调用的地方吧？主要还是用在高阶函数上，并且根据函数调用的情况综合来判断是否可以使用<code>inline</code>。</p>
<h3 id="noinline"><a href="#noinline" class="headerlink" title="noinline"></a>noinline</h3><p>noinline 关键字用于标记不应该内联的 lambda 参数。默认情况下，内联函数的所有 lambda 参数都会被内联展开，但有时我们可能希望某些 lambda 参数不被内联。</p>
<p><strong>作用</strong>：</p>
<ul>
<li>防止内联：阻止特定的 lambda 参数被内联展开。</li>
<li>保留 lambda 参数：适用于需要将 lambda 参数作为对象传递的情况。</li>
</ul>
<p>既然<code>inline</code>是一种优化，假设使用者也经过考虑，将函数用<code>inline</code>修饰，那为什么还会有<code>noinline</code>这个关键字？<br>先来思考一个问题：kotlin 中一切都是对象，函数也能作为参数或者返回值，那被内联的函数参数作为参数或者返回值时会怎么样？<br>答案是不可以，因为被内联的函数已经被展开了，不再是一个对象了，那怎么办？加上<code>noinline</code>，告诉编译器，这个函数参数不要进行内联。<br>这里也有一个例外情况，被内联的函数参数，可以作为其他内联函数的参数。为啥？因为被内联函数被展开复制到调用处了哇。<br>看个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(preAction:()-&gt;<span class="hljs-type">Unit</span>, postAction:()-&gt;<span class="hljs-type">Unit</span>)</span></span>:()-&gt;<span class="hljs-built_in">Unit</span>&#123;<br>    preAction()<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    postAction()<br>    another(postAction)<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Illegal usage of inline-parameter &#x27;postAction&#x27; in &#x27;public inline fun hello(preAction: () -&gt; Unit, postAction: () -&gt; Unit): () -&gt; Unit defined in root package in file Inline.kt&#x27;. Add &#x27;noinline&#x27; modifier to the parameter declaration</span><br><span class="hljs-comment">     */</span><br>    anotherInline(postAction)<br>    <span class="hljs-keyword">return</span> postAction<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Illegal usage of inline-parameter &#x27;postAction&#x27; in &#x27;public inline fun hello(preAction: () -&gt; Unit, postAction: () -&gt; Unit): () -&gt; Unit defined in root package in file Inline.kt&#x27;. Add &#x27;noinline&#x27; modifier to the parameter declaration</span><br><span class="hljs-comment">     */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">another</span><span class="hljs-params">(action:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;<br>    action()<br>&#125;<br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">anotherInline</span><span class="hljs-params">(action:()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;<br>    action()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里调用<code>another(postAction)</code> 和 <code>return postAction</code>时，IDE 会报错，提示需要加上<code>noinline</code>。<br>也就是说，如果 inline 函数参数中有函数对象，并且这个函数对象需还需要充当其他非 inline 函数的参数或者充当返回值，那么就需要加上<code>noinline</code>,还有个偷懒的办法，IDE告诉你需要加，那就加上。</p>
<h3 id="crossinline"><a href="#crossinline" class="headerlink" title="crossinline"></a>crossinline</h3><p>crossinline 关键字用于标记 lambda 参数，保证它们不会进行非局部返回。crossinline 参数不能使用 return 从外部函数返回。<br><strong>作用</strong>：<br> 防止非局部返回：确保 lambda 参数不会从外部函数返回。<br> 安全性：在某些情况下，防止非局部返回可以避免编译错误或逻辑问题。</p>
<p>这里有个词是<code>非局部返回</code>,什么意思呢？先看个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">( postAction: () -&gt; <span class="hljs-type">String</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    postAction()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    hello &#123;<br>        println(<span class="hljs-string">&quot;second hi&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-comment">//猜这里是哪个函数的返回</span><br>    &#125;<br>    println(<span class="hljs-string">&quot;after second hi\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>会发现<code>after second hi</code>没有打印，结束的是<code>main</code>函数而不是<code>hello</code>函数，但这里就会有个歧义，<code>return</code>结束哪个函数，需要看调用者是不是<code>inline</code>,这就挺郁闷的，所以这里就有了一个规定：</p>
<blockquote>
<p>lambda表达式中不允许直接 return，除非是当做内联函数的参数。<br>不能直接 return，但允许使用 return@label方式进行返回，结束 label 处的函数,这里的 label值可以自定义，但一般默认是调用的函数名字</p>
</blockquote>
<p>所以当我们这么写的时候</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hi</span><span class="hljs-params">( postAction: ()-&gt;<span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;hi&quot;</span>)<br>    postAction()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    hi &#123;<br>        println(<span class="hljs-string">&quot;hi&quot;</span>)<br>        <span class="hljs-keyword">return</span><span class="hljs-comment">//错误，提示 &#x27;return&#x27; is not allowed here</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 return 处会提示<code>&#39;return&#39; is not allowed here</code>,但如果我们一定要写，可以写成</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">hi &#123;<br>    println(<span class="hljs-string">&quot;hi&quot;</span>)<br>    <span class="hljs-keyword">return</span><span class="hljs-symbol">@hi</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里还没有<code>crossinline</code>的什么事，但想一想，如果多套一层：传入的函数参数，又作为其他函数的参数调用呢？比如这样</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(postAction: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    doAction &#123; postAction() &#125;<span class="hljs-comment">//注意这里</span><br>    run &#123; postAction() &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">(postAction: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    postAction()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意上面 doAction 的调用，是不允许这样写的，会给出报错提示：</p>
<blockquote>
<p>Can’t inline ‘postAction’ here: it may contain non-local returns. Add ‘crossinline’ modifier to parameter declaration ‘postAction’</p>
</blockquote>
<p>意思是这种<code>间接调用</code>可能会导致非本地返回问题，也就是说我不知道你传入的函数参数中有没有 return，如果有的话，又会造成上面说的那个问题。那怎么办？在postAction参数前面加上<code>crossinline</code>修饰符，这样就可以间接调用了。不过这又带来了一个新问题</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">crossinline</span> postAction: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    println(<span class="hljs-string">&quot;hello&quot;</span>)<br>    doAction &#123; postAction() &#125;<br>    run &#123; postAction() &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doAction</span><span class="hljs-params">(postAction: () -&gt; <span class="hljs-type">Unit</span>)</span></span> &#123;<br>    postAction()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  hello &#123;<br>    println(<span class="hljs-string">&quot;hi&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-comment">//错误 提示：&#x27;return&#x27; is not allowed here</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>会发现传入的Lambda 表达式中不允许这种直接 return 了，但还是可以使用 return@label 进行返回的。<br>但是你说：我既要又要怎么办？<br>抱歉，没办法，自己玩吧.</p>
<hr>
<p>参考<br><a href="https://book.kotlincn.net/text/inline-functions.html">内联函数</a>建议把函数这一节都看一下<br><a href="https://kotlinlang.org/docs/inline-functions.html">Inline functions</a><br><a href="https://rengwuxian.com/kotlin-source-noinline-crossinline/">Kotlin 源码里成吨的 noinline 和 crossinline 是干嘛的？看完这个视频你转头也写了一吨</a>  </p>
<hr>
<p>已学习：</p>
<ul>
<li><p>扩展</p>
<ul>
<li><input type='checkbox' disabled='true' checked>扩展函数</input></li>
<li><input type='checkbox' disabled='true' checked>扩展属性</input></li>
<li><input type='checkbox' disabled='true' checked>作用域</input></li>
</ul>
</li>
<li><p>函数类型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li>
<li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li>
<li><input type='checkbox' disabled='true' checked>SAM 转换</input></li>
</ul>
</li>
<li><p>泛型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>逆变</input></li>
<li><input type='checkbox' disabled='true' checked>协变</input></li>
<li><input type='checkbox' disabled='true' checked>类型投影</input></li>
<li><input type='checkbox' disabled='true' checked>星投影</input></li>
<li><input type='checkbox' disabled='true' checked>泛型约束</input></li>
</ul>
</li>
<li><p>关键字</p>
<ul>
<li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li>
<li><input type='checkbox' disabled='true' checked>object:匿名内部类、单例模式、伴生对象</input></li>
<li><input type='checkbox' disabled='true' checked>Unit、Nothing</input></li>
<li><input type='checkbox' disabled='true' checked>inline,noinline,crossinline</input></li>
</ul>
</li>
<li><p>委托</p>
<ul>
<li><input type='checkbox' disabled='true' checked>委托类</input></li>
<li><input type='checkbox' disabled='true' checked>委托属性</input></li>
<li><input type='checkbox' disabled='true' checked>自定义委托</input></li>
</ul>
</li>
</ul>
<p>未学习：</p>
<ul>
<li>协程<ul>
<li>启动</li>
<li>挂起</li>
<li>Job</li>
<li>Context</li>
<li>Channel</li>
<li>Flow</li>
<li>select</li>
<li>并发、异常</li>
<li>launch</li>
<li>Dispatchers</li>
<li>CoroutineScope</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin作用域函数:run、let、also、apply、with</title>
    <url>/2024/04/28/kotlin%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0-run%E3%80%81let%E3%80%81also%E3%80%81apply%E3%80%81with/</url>
    <content><![CDATA[<p>刚开始学习 kotlin 的时候，对于这些作用域函数一头雾水，搞不明白为什么要弄出来这么多东西。现在来看看他们具体的区别以及适用的场景。<br>Kotlin 标准库包含几个函数，它们的唯一目的是在对象的上下文中执行代码块。 当对一个对象调用这样的函数并提供一个<code>lambda表达式</code>时，它会形成一个临时作用域。在此作用域中，可以访问该对象而无需其名称。这些函数称为作用域函数。 共有以下五种：<code>let</code>、<code>run</code>、<code>with</code>、<code>apply</code>以及<code>also</code>。<br>废话不多说，先把从 kotlin 官方上扒拉下来的结论放这里</p>
<span id="more"></span>
<p><a href="https://book.kotlincn.net/text/scope-functions.html">作用域函数中文版</a><br><a href="https://kotlinlang.org/docs/scope-functions.html">作用域函数英文版</a></p>
<h3 id="总结在前面"><a href="#总结在前面" class="headerlink" title="总结在前面"></a>总结在前面</h3><p>文章太长太啰嗦，直接看这里的结论：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>对象引用</th>
<th>返回值</th>
<th>是否是扩展函数</th>
</tr>
</thead>
<tbody><tr>
<td>let</td>
<td>it</td>
<td>Lambda表达式结果</td>
<td>是</td>
</tr>
<tr>
<td>run</td>
<td>this</td>
<td>Lambda表达式结果</td>
<td>是</td>
</tr>
<tr>
<td>run</td>
<td>-</td>
<td>Lambda表达式结果</td>
<td>不是：调用无需上下文对象</td>
</tr>
<tr>
<td>with</td>
<td>this</td>
<td>Lambda表达式结果</td>
<td>不是：把上下文对象当做参数</td>
</tr>
<tr>
<td>apply</td>
<td>this</td>
<td>上下文对象</td>
<td>是</td>
</tr>
<tr>
<td>also</td>
<td>it</td>
<td>上下文对象</td>
<td>是</td>
</tr>
</tbody></table>
<p>以下是根据预期目的选择作用域函数的简短指南：</p>
<ul>
<li>对一个非空（non-null）对象执行 lambda 表达式：let</li>
<li>将表达式作为变量引入为局部作用域中：let</li>
<li>对象配置：apply</li>
<li>对象配置并且计算结果：run</li>
<li>在需要表达式的地方运行语句：非扩展的 run</li>
<li>附加效果：also</li>
<li>一个对象的一组函数调用：with<br>不同作用域函数的使用场景存在重叠，可以根据项目或团队中使用的特定约定来选择使用哪些函数。</li>
</ul>
<p><font color='red'>虽然作用域函数可以让代码更加简洁，但是要避免过度使用它们：这会使代码难以阅读并可能导致错误。 我们还建议避免嵌套作用域函数，同时链式调用它们时要小心：因为很容易混淆当前上下文对象与<code>this</code>或<code>it</code>的值。</font></p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假如我们有这么一个数据类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span></span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> price: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changePrice</span><span class="hljs-params">(price: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.price = price<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> book = Book(<span class="hljs-string">&quot;book name&quot;</span>, <span class="hljs-number">68</span>)<br></code></pre></td></tr></table></figure>

<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">run</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">run</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> <span class="hljs-title">with</span><span class="hljs-params">(receiver: <span class="hljs-type">T</span>, block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure>
<p>我们把看起来相近的作用域函数的声明放在一块对比着看，看到这里就清楚了的就不要往下看了，看了也是浪费时间。</p>
<h4 id="also"><a href="#also" class="headerlink" title="also"></a>also</h4><p>函数声明</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T<br></code></pre></td></tr></table></figure>
<p><code>also</code>函数是对泛型 T 的扩展函数，接收一个参数类型为T、无返回值(返回值为Unit类型)的函数，且<code>also</code>函数的返回值就是调用者。</p>
<ul>
<li>上下文对象作为 lambda 表达式的参数（it）来访问。</li>
<li>返回值是上下文对象本身。</li>
</ul>
<p>对于执行一些将上下文对象作为参数的操作很有用。 对于需要引用对象而不是其属性与函数的操作，或者不想屏蔽来自外部作用域的 this 引用时，请使用 also。<br>当你在代码中看到 also 时，可以将其理解为<strong>并且用该对象执行以下操作</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> alsoResult = book.also &#123;<br>    it.changePrice(<span class="hljs-number">20</span>)<br>    it.name = <span class="hljs-string">&quot;alsoResult&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;alsoResult <span class="hljs-variable">$alsoResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这里打印结果是<code>alsoResult Book(name=alsoResult, price=20)</code>,看源码的话，可以简单的里面为调用了一下传入的函数，然后返回了调用者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    block(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>函数声明</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">apply</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: T<br></code></pre></td></tr></table></figure>
<p>可以看得出来<code>apply</code>是泛型 T 的扩展函数，接收一个带有 T 类型接收者的无参、无返回值的函数，并且<code>apply</code>函数返回值就是 T 类型，也就是调用者的类型。因为这里参数中的 T 是作为接收者类型，而不是参数，所以在传入的函数中需要用<code>this</code>而非<code>it</code>来指代调用者。<br>用法和<code>also</code>相差无几，只不过一个是接收者类型，一个是参数。</p>
<ul>
<li>上下文对象 作为接收者（this）来访问。</li>
<li>返回值 是上下文对象本身。</li>
</ul>
<p>对于不返回值且主要在接收者（this）对象的成员上运行的代码块使用它。apply最常见的使用场景是用于对象配置。这样的调用可以理解为<strong>将以下赋值操作应用于对象</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> applyResult = book.apply &#123;<br>    changePrice(<span class="hljs-number">200</span>)<br>    name = <span class="hljs-string">&quot;applyResult&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;applyResult <span class="hljs-variable">$applyResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这里打印的结果是<code>applyResult Book(name=applyResult, price=200)</code>.<br>源码也和<code>also</code>几乎一样</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">also</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>: T &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    block(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>函数类型声明如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure>
<p>可以看到，let 是对泛型 T 的扩展函数，该扩展函数接收一个函数参数，并且函数参数的接收一个 T 类型的参数，且返回值是 R 类型，也是<code>let</code>这个扩展函数的返回值类型。</p>
<ul>
<li>上下文对象作为 lambda 表达式的参数（it）来访问。</li>
<li>返回值是 lambda 表达式的结果。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>    it.changePrice(<span class="hljs-number">100</span>)<br>    it.name = <span class="hljs-string">&quot;letResult&quot;</span><br>&#125;<br>println(<span class="hljs-string">&quot;letResult <span class="hljs-variable">$letResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这里传入的是一个 Lambda 表达式，前面说过，对于单参数值的Lambda 表达式，参数会被隐式声明为<code>it</code>,当然我们也可以指定一个具名意义的变量，比如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letResult = book.let &#123; bookEntry: Book -&gt;<br>    bookEntry.changePrice(<span class="hljs-number">100</span>)<br>    bookEntry.name = <span class="hljs-string">&quot;letResult&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里打印的结果是<code>letResult kotlin.Unit</code>。因为对于 Lambda 表达式来讲，如果最后一条语句是非赋值语句，则返回该语句的值；如果是赋值语句，则返回 Unit。<br>我们可以这么写来返回我们需要的值：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>    it<span class="hljs-comment">//返回值就是传入的 book 对象</span><br>&#125;<br><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>    <span class="hljs-number">1</span><span class="hljs-comment">//返回值就是1</span><br>&#125;<br><span class="hljs-keyword">val</span> letResult = book.let &#123;<br>     <span class="hljs-keyword">return</span><span class="hljs-symbol">@let</span> <span class="hljs-number">1</span><span class="hljs-comment">//之前的文章中说过的显示指定返回值，是 1</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>从另外一个角度看，<code>let</code>和 <code>also</code>、<code>apply</code>也差不多，只不过多了一个返回值类型，返回值就是传入的 Lambda 表达式的返回值<br>源码也差不了多少</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">let</span><span class="hljs-params">(block: (<span class="hljs-type">T</span>) -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block(<span class="hljs-keyword">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>let 可用于在调用链的结果上调用一个或多个函数。</li>
<li>let 经常用于执行包含非空值代码块。如需对非空对象执行操作， 可对其使用安全调用操作符<code>?.</code>并调用 let 在 lambda 表达式中执行操作。</li>
</ul>
<h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p><code>run</code>这个函数给了两种方式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">run</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">run</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure>
<p>先看第一种，看起来就是把<code>let</code>中函数参数中的 T 类型参数改成了接收者类型，也是返回 R 类型；这和<code>apply</code>与<code>also</code>的区别是一样的。</p>
<ul>
<li>上下文对象 作为接收者（this）来访问。</li>
<li>返回值 是 lambda 表达式结果。</li>
</ul>
<p>当 lambda 表达式同时初始化对象并计算返回值时，run 很有用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> runResult = book.run &#123;<br>    name = <span class="hljs-string">&quot;runResult&quot;</span><br>    changePrice(<span class="hljs-number">110</span>)<br>    <span class="hljs-keyword">this</span> <span class="hljs-comment">//作为返回值</span><br>&#125;<br>println(<span class="hljs-string">&quot;runResult <span class="hljs-variable">$runResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>源码是这样的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> T.<span class="hljs-title">run</span><span class="hljs-params">(block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>第二种</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> otherRunResult =  run &#123;<br>    Book(<span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-number">120</span>) <span class="hljs-comment">//作为返回值</span><br>&#125;<br>println(<span class="hljs-string">&quot;otherRunResult <span class="hljs-variable">$otherRunResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>源码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;R&gt;</span> <span class="hljs-title">run</span><span class="hljs-params">(block: () -&gt; <span class="hljs-type">R</span>)</span></span>: R &#123;<br>    contract &#123;<br>        callsInPlace(block, InvocationKind.EXACTLY_ONCE)<br>    &#125;<br>    <span class="hljs-keyword">return</span> block()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这也没啥好说的，只不过是这里并没有输入参数，只是可以使你在需要表达式的地方就可以执行一个语句。</p>
<h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>函数声明</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, R&gt;</span> <span class="hljs-title">with</span><span class="hljs-params">(receiver: <span class="hljs-type">T</span>, block: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">R</span>)</span></span>: R<br></code></pre></td></tr></table></figure>
<p><code>with</code>并不是扩展函数，需要传入一个T 类型的receiver，可以在 block 中访问这个receiver的方法和属性，</p>
<ul>
<li>上下文对象作为接收者（this）使用。</li>
<li>返回值是 lambda 表达式结果。</li>
</ul>
<p>建议当不需要使用 lambda 表达式结果时，使用 with 来调用上下文对象上的函数。 在代码中，with 可以理解为<strong>对于这个对象，执行以下操作.</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> withResult = with(book) &#123;<br>    changePrice(<span class="hljs-number">300</span>)<br>    name = <span class="hljs-string">&quot;withResult&quot;</span><br>    <span class="hljs-keyword">this</span> <span class="hljs-comment">//作为返回值</span><br>&#125;<br>println(<span class="hljs-string">&quot;withResult <span class="hljs-variable">$withResult</span>&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>这里的打印结果是<code>withResult Book(name=withResult, price=300)</code></p>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>这里再搬运一个总结的表格</p>
<table>
    <tr> 
        <th >函数名</th> 
        <th >作用</th> 
        <th >应用场景</th> 
        <th >备注</th> 
    </tr>
    <tr>
      <td>let</td>
      <td rowspan="2">定义一个变量在特定作用域内<br/>统一做判空处理</td>
      <td rowspan="2">明确一个变量所处特定的作用域范围内可使用<br/>针对一个可空对象统一做判空处理</td>
      <td rowspan="2">区别在于返回值<br/>let函数：返回值=最后一行|return的表达式<br/>also函数：返回值=传入对象本身</td>
    </tr>
    <tr>
      <td>also</td>
    </tr>
    <tr>
      <td>with</td>
      <td>调用同一个对象的多个方法|属性时，可以省去对象名，直接调用方法、访问属性</td>
      <td>需要多次调用同一个对象的属性|方法</td>
      <td>返回值=最后一行|return表达式</td>
    </tr>
    <tr>
      <td>run</td>
      <td rowspan="2">结合了let 函数和 with 函数的作用</td>
      <td>1.调用同一个对象的多个方法/属性时可以省去对象名重复，直接调用方法名 /属性即可<br/>2.定义一个变量在特定作用域内<br/>3.统一做判空处</</td>
      <td>优点:避免了let函数必须使用it参数替代对象弥补了with函数无法判空的缺点</td>
    </tr>
    <tr>
      <td>apply</td>
      <td>对象实例初始化时需要对对象中的属性进行赋值且返回该对象</td>
      <td>二者区别在于返回值:<br/>run函数返回最后一行的值|表达式<br/>apply函数返回传入的对象的本身</td>
    <tr>
</table>

<h3 id="另外一个角度的选择"><a href="#另外一个角度的选择" class="headerlink" title="另外一个角度的选择"></a>另外一个角度的选择</h3><h4 id="it-or-this"><a href="#it-or-this" class="headerlink" title="it or this"></a>it or this</h4><p>每个作用域函数都使用以下两种方式之一来引用上下文对象</p>
<ol>
<li>作为 lambda 表达式的接收者 （this）</li>
<li>作为 lambda 表达式的参数（it）</li>
</ol>
<p>两者都提供了同样的功能，<code>run</code>、<code>with</code>以及<code>apply</code>通过关键字<code>this</code>将上下文对象引用为<code>lambda</code>表达式的接收者。 因此，在它们的<code>lambda表达式</code>中可以像在普通的类函数中一样访问上下文对象。在大多数场景，当你访问接收者对象时你可以省略<code>this</code>， 来让你的代码更简短。 相对地，如果省略了<code>this</code>，就很难区分接收者对象的成员及外部对象或函数。因此，对于主要对对象的成员进行操作（调用其函数或赋值其属性）的lambda表达式， 建议将上下文对象作为接收者（this）。<br>反过来，<code>let</code>及<code>also</code>将上下文对象引用为<code>lambda表达式参数</code>。如果没有指定参数名，对象可以用隐式默认名称<code>it</code>访问。<code>it</code>比<code>this</code>简短，带有<code>it</code>的表达式通常更易读。不过，当调用对象函数或属性时，不能像<code>this</code>这样隐式地访问对象。 因此，当上下文对象在作用域中主要用作函数调用中的参数时，通过<code>it</code>访问上下文对象会更好。 在代码块中使用多个变量时，<code>it</code>也更好一些。</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>根据返回结果，作用域函数可以分为以下两类：</p>
<p>apply 及 also 返回上下文对象。<br>let、run 及 with 返回 lambda 表达式结果.<br>apply 及 also 的返回值是上下文对象本身。因此，它们可以作为辅助步骤包含在调用链中：可以继续在同一个对象上一个接一个地进行链式函数调用。</p>
<h3 id="写在最后的注意事项"><a href="#写在最后的注意事项" class="headerlink" title="写在最后的注意事项"></a>写在最后的注意事项</h3><p>在最开始的红色部分也提高过尽量不要嵌套使用作用域函数，警惕引发的上下文混淆。看下面的代码猜一下打印结果是什么。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> length = <span class="hljs-number">0</span><br>    <span class="hljs-string">&quot;hello&quot;</span>.apply &#123;<br>        println(<span class="hljs-string">&quot;this is apply <span class="hljs-variable">$length</span>&quot;</span>)<br>        println(<span class="hljs-string">&quot;this is apply <span class="hljs-subst">$&#123;this.length&#125;</span>&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-string">&quot;hello&quot;</span>.let &#123;<br>        println(<span class="hljs-string">&quot;this is let <span class="hljs-variable">$it</span>&quot;</span>)<br>        <span class="hljs-string">&quot;world&quot;</span>.also &#123;<br>            println(<span class="hljs-string">&quot;this is run <span class="hljs-variable">$it</span>&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerFunc</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-string">&quot;hi&quot;</span>.apply &#123;<br>            println(<span class="hljs-string">&quot;this is innerFunc apply <span class="hljs-variable">$length</span>&quot;</span>)<br>            println(<span class="hljs-string">&quot;this is innerFunc apply <span class="hljs-subst">$&#123;this.length&#125;</span>&quot;</span>)<br><br>        &#125;<br>    &#125;<br>    innerFunc()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>结果是如下：</p>
<blockquote>
<p>this is apply 0<br>this is apply 5<br>this is let hello<br>this is run world<br>this is innerFunc apply 0<br>this is innerFunc apply 2</p>
</blockquote>
<p>这里我们在写代码的时候，IDE 给了提示:<strong>Implicit parameter ‘it’ of enclosing lambda is shadowed</strong><br><img src="/image/kotlin/scope_func_implicit_param.png" alt="Implicit parameter &#39;it&#39; of enclosing lambda is shadowed "><br>我们可以通过修改隐式 it 的名字来避免这个问题</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-string">&quot;hello&quot;</span>.let &#123;<br>    println(<span class="hljs-string">&quot;this is let <span class="hljs-variable">$it</span>&quot;</span>)<br>    <span class="hljs-string">&quot;world&quot;</span>.also &#123; world-&gt;<br>        println(<span class="hljs-string">&quot;this is run <span class="hljs-variable">$world</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但最好还是避免这种嵌套调用的情况</p>
<hr>
<p>已学习：</p>
<ul>
<li><p>扩展</p>
<ul>
<li><input type='checkbox' disabled='true' checked>扩展函数</input></li>
<li><input type='checkbox' disabled='true' checked>扩展属性</input></li>
<li><input type='checkbox' disabled='true' checked>作用域</input></li>
</ul>
</li>
<li><p>函数类型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li>
<li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li>
<li><input type='checkbox' disabled='true' checked>SAM 转换</input></li>
</ul>
</li>
<li><p>关键字</p>
<ul>
<li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li>
</ul>
</li>
</ul>
<p>未学习：</p>
<ul>
<li><p>关键字</p>
<ul>
<li>object</li>
<li>Unit</li>
<li>Nothing</li>
<li>inline,noinline,crossinline</li>
</ul>
</li>
<li><p>泛型</p>
<ul>
<li>逆变</li>
<li>协变</li>
</ul>
</li>
<li><p>委托</p>
<ul>
<li>委托类</li>
<li>委托属性</li>
<li>自定义委托</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li>启动</li>
<li>挂起</li>
<li>Job</li>
<li>Context</li>
<li>Channel</li>
<li>Flow</li>
<li>select</li>
<li>并发、异常</li>
<li>launch</li>
<li>Dispatchers</li>
<li>CoroutineScope</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin中的Unit和Nothing 关键字</title>
    <url>/2024/06/14/kotlin%E4%B8%AD%E7%9A%84Unit%E5%92%8CNothing-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>让我们先从 kotlin 的类型继承关系开始：众所周知，kotlin 中所有东西都有类型，对象、函数等等，就连 Unit，Nothing 也有对应的类型。我们来看一下kotlin 中的类型层次结构。</p>
<span id="more"></span>

<h3 id="从顶部开始"><a href="#从顶部开始" class="headerlink" title="从顶部开始"></a>从顶部开始</h3><p>所有类型的 Kotlin 对象都被组织成子类型&#x2F;超类型关系的层次结构。该层次结构的“顶部”是抽象类Any。例如，String 和 Int 类型都是的子类型Any。</p>

<pre>
<code class="mermaid" >
graph BT

String-->Any
Int-->Any

</code>
</pre>
<p>这里的 Any 相当于 java 中的 Object，同样的，如果我们声明一个类，没有显式指定继承自哪个类，那这个类就是 Any 的直接子类。<br>如果该类指定了父类，那么 Any 会是该类的最终父类(祖先)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(<span class="hljs-keyword">val</span> name: String)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>(name:String):Person(name)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span></span>(name:String):Person(name)<br></code></pre></td></tr></table></figure>

<pre>
<code class="mermaid" >
graph BT
Person --> Any
Student-->Person
Teacher-->Person

</code>
</pre>
<p>如果一个类实现了多个接口，那么它就会有多个直接父类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Run</span></span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fly</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bird</span> : <span class="hljs-type">Run</span>,<span class="hljs-type">Fly</span></span><br></code></pre></td></tr></table></figure>

<pre>
<code class="mermaid" >
graph BT
Run --> Any
Fly --> Any
Bird-->Run
Bird-->Fly
</code>
</pre>

<p>Kotlin 类型检查器强制执行子类型&#x2F;父类型关系，我们可以将子类型存储到超类型变量中，反过来则不行，这和 java 是一样的逻辑。<br>另外，kotlin 中还有可空类型，上面我们提到的类型都是非空类型，可空类型只是在可空类型后面加了一个 <strong>?</strong>,</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> name :String =<span class="hljs-literal">null</span> <span class="hljs-comment">//错误：Null can not be a value of a non-null type String</span><br><span class="hljs-keyword">val</span> name :String? =<span class="hljs-literal">null</span> <span class="hljs-comment">//正确</span><br><span class="hljs-keyword">var</span> s: String? = <span class="hljs-literal">null</span><br><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&quot;a&quot;</span><br>s = s2<br>s = <span class="hljs-literal">null</span><br>s2 = s<span class="hljs-comment">//错误：Type mismatch.Required:String， Found:String?</span><br><br></code></pre></td></tr></table></figure>
<p>从这个角度来看，我们可以认为(仅仅是可以认为)非空类型是对应可空类型的子类，因为非空类型可以赋值给对应的可空类型，反之则不行。</p>

<pre>
<code class="mermaid" >
graph BT
Any --> Any?
String? --> Any?
String-->Any
String-->String?
</code>
</pre>

<h3 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h3><p>Kotlin中的Unit即相当于Java中的void关键字，用于表示返回空结果的函数。但这里有一些不一样的地方，当 Unit 用于函数返回值时，是可以省略不写的，但kotlin 还是会认为返回了 Unit。其次，Unit 是一个真实存在的类型，并且是一个单例的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun1</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun1&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun2</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun2&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Unit</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun3</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun3&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unitFun4</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;unitFun3&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Unit</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">object</span> <span class="hljs-built_in">Unit</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;kotlin.Unit&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>我们发现，上面这几种写法，效果是一样的。但这里有一个点需要注意一下：<br>对于<code>unitFun2()</code>这个函数，跟在函数名后面的<code>Unit</code>表示返回值类型，而函数体里面的<code>return Unit</code>中的 Unit 是一个单例对象。虽然看起来什么也没有返回，但它确实返回的一个单例对象。<br>回到我们上面提到的可空类型上，一个比较边缘的 case:Unit?类型</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> nullableUnit:<span class="hljs-built_in">Unit</span>? = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure>
<p>这个东西我从来没有使用过，是 kotlin 类型一致性的结果</p>

<pre>
<code class="mermaid" >
graph BT
Any --> Any?
Unit? --> Any?
Unit-->Any
Unit-->Unit?
</code>
</pre>

<p>那 Unit 这个东西有什么用呢？为啥不沿用 java 中的 void ？<br>扔物线大佬在他的文章中给出了具体的回答：去特殊化，<code>Unit</code>去掉了无返回值的函数的特殊性，消除了有返回值和无返回值的函数的本质区别，这样很多事做起来就会更简单了。<br>例：有返回值的函数在重写时没有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">make</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppleMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-comment">// 合法</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Apple <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewWorldMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-comment">// 非法</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>    world.refresh();<br>  &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewWorldMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Maker</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">make</span><span class="hljs-params">()</span> &#123;<br>    world.refresh();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<span class="hljs-comment">//只能去写一行 return null 来手动实现接近于「什么都不返回」的效果</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maker</span> </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: Any<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleMaker</span> : <span class="hljs-type">Maker</span></span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: Apple &#123;<br>    <span class="hljs-keyword">return</span> Apple()<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewWorldMaker</span> : <span class="hljs-type">Maker</span></span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span> &#123;<br>    world.refresh()<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Maker</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: T<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppleMaker</span> : <span class="hljs-type">Maker</span>&lt;<span class="hljs-type">Apple</span>&gt;</span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span>: Apple &#123;<br>    <span class="hljs-keyword">return</span> Apple()<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewWorldMaker</span> : <span class="hljs-type">Maker</span>&lt;<span class="hljs-type">Unit</span>&gt;</span>() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">make</span><span class="hljs-params">()</span></span> &#123;<br>    world.refresh()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>例：函数类型的函数参数</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">runTask</span><span class="hljs-params">(task: () -&gt; <span class="hljs-type">Any</span>)</span></span> &#123;<br>  <span class="hljs-keyword">when</span> (<span class="hljs-keyword">val</span> result = task()) &#123;<br>    <span class="hljs-built_in">Unit</span> -&gt; println(<span class="hljs-string">&quot;result is Unit&quot;</span>)<br>    String -&gt; println(<span class="hljs-string">&quot;result is a String: <span class="hljs-variable">$result</span>&quot;</span>)<br>    <span class="hljs-keyword">else</span> -&gt; println(<span class="hljs-string">&quot;result is an unknown type&quot;</span>)<br>  &#125;<br>&#125;<br><br>...<br><br>runTask &#123; &#125; <span class="hljs-comment">// () -&gt; Unit</span><br>runTask &#123; println(<span class="hljs-string">&quot;完成！&quot;</span>) &#125; <span class="hljs-comment">// () -&gt; String</span><br>runTask &#123; <span class="hljs-number">1</span> &#125; <span class="hljs-comment">// () -&gt; Int</span><br></code></pre></td></tr></table></figure>


<h3 id="Nothing"><a href="#Nothing" class="headerlink" title="Nothing"></a>Nothing</h3><p>这里抛出一个引子：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fail</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">throw</span> RuntimeException(<span class="hljs-string">&quot;Something went wrong&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的返回值是什么？它真的有返回值么？如果有，是什么类型？<br>实际上这个方法的返回值类型是<code>Nothing</code><br>kotlin中有这么一个方法:<code>TODO</code>,注意，这里的 TODO 是一个方法，而不是<code>//todo</code>这一个</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">TODO</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Nothing</span> = <span class="hljs-keyword">throw</span> NotImplementedError()<br></code></pre></td></tr></table></figure>
<p>我们来看一下 Nothing 定义</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Nothing has no instances. You can use Nothing to represent &quot;a value that never exists&quot;: for example,</span><br><span class="hljs-comment"> * if a function has the return type of Nothing, it means that it never returns (always throws an exception).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Nothing</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>()<br></code></pre></td></tr></table></figure>
<p>这个类无法创建出任何实例，所以所有 Nothing 类型的变量或者函数，都找不到可用的值。那这个东西有啥用？正如它的注释所说， 它可以作为函数「永不返回」的提示，也就是总是抛出异常。<br>那这个东西有啥用？<br>第一个作用就是作为函数「永不返回」的提示<br>第二个作用就是作为泛型对象的临时空白填充，比如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> emptyList: List&lt;<span class="hljs-built_in">Nothing</span>&gt; = listOf()<br><span class="hljs-keyword">var</span> apples: List&lt;Apple&gt; = emptyList<br><span class="hljs-keyword">var</span> users: List&lt;User&gt; = emptyList<br><span class="hljs-keyword">var</span> phones: List&lt;Phone&gt; = emptyList<br><span class="hljs-keyword">var</span> images: List&lt;Image&gt; = emptyList<br></code></pre></td></tr></table></figure>
<p>既省事，又省内存。当然也可以用在 Set、Map 中<br>第三个作用：语法的完整化<br>Nothing 的「是所有类型的子类型」这个特点，还帮助了 Kotlin 语法的完整化。在 Kotlin 的下层逻辑里，throw 这个关键字是有返回值的，它的返回值类型就是 Nothing。虽然说由于抛异常这件事已经跳出了程序的正常逻辑，所以 throw 返回不返回值、返回值类型是不是 Nothing 对于它本身都不重要，但它让类似 <code>TODO()</code>函数的写法成为了合法的。</p>

<pre>
<code class="mermaid" >
graph BT
String --> Any
Int --> Any
Unit --> Any
Person --> Any
Nothing --> Person
Nothing --> Unit
Nothing --> Int
Nothing --> String
</code>
</pre>


<p>参考<br><a href="http://natpryce.com/articles/000818.html">A Whirlwind Tour of the Kotlin Type Hierarchy</a><br><a href="https://rengwuxian.com/kotlin-unit/">Unit 为啥还能当函数参数？面向实用的 Kotlin Unit 详解</a><br><a href="https://rengwuxian.com/kotlin-nothing/">这玩意真的有用吗？对，是的！Kotlin 的 Nothing 详解</a></p>
<hr>
<p>已学习：</p>
<ul>
<li><p>扩展</p>
<ul>
<li><input type='checkbox' disabled='true' checked>扩展函数</input></li>
<li><input type='checkbox' disabled='true' checked>扩展属性</input></li>
<li><input type='checkbox' disabled='true' checked>作用域</input></li>
</ul>
</li>
<li><p>函数类型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li>
<li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li>
<li><input type='checkbox' disabled='true' checked>SAM 转换</input></li>
</ul>
</li>
<li><p>泛型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>逆变</input></li>
<li><input type='checkbox' disabled='true' checked>协变</input></li>
<li><input type='checkbox' disabled='true' checked>类型投影</input></li>
<li><input type='checkbox' disabled='true' checked>星投影</input></li>
<li><input type='checkbox' disabled='true' checked>泛型约束</input></li>
</ul>
</li>
<li><p>关键字</p>
<ul>
<li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li>
<li><input type='checkbox' disabled='true' checked>object:匿名内部类、单例模式、伴生对象</input></li>
<li><input type='checkbox' disabled='true' checked>Unit、Nothing</input></li>
</ul>
</li>
<li><p>委托</p>
<ul>
<li><input type='checkbox' disabled='true' checked>委托类</input></li>
<li><input type='checkbox' disabled='true' checked>委托属性</input></li>
<li><input type='checkbox' disabled='true' checked>自定义委托</input></li>
</ul>
</li>
</ul>
<p>未学习：</p>
<ul>
<li><p>关键字</p>
<ul>
<li>inline,noinline,crossinline</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li>启动</li>
<li>挂起</li>
<li>Job</li>
<li>Context</li>
<li>Channel</li>
<li>Flow</li>
<li>select</li>
<li>并发、异常</li>
<li>launch</li>
<li>Dispatchers</li>
<li>CoroutineScope</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin委托</title>
    <url>/2024/05/27/kotlin%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<p>经常在 Kotlin 的源码三方库中看到<code>by</code>关键字，这种写法就是委托，主要有两个应用场景，一个是委托类，另一个是委托属性，每个场景中又有不同的用法，我们可以对比 Java 的委托来学习 Kotlin 的委托。</p>
<span id="more"></span>

<h3 id="委托-类委托、接口委托"><a href="#委托-类委托、接口委托" class="headerlink" title="委托(类委托、接口委托)"></a>委托(类委托、接口委托)</h3><p>其实我们在 Java 和 Android 中经常会用到委托，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Delegated</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Base</span>&#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Base</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">BaseImpl</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>            <span class="hljs-built_in">this</span>.x = x;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Base</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Base base;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Derived</span><span class="hljs-params">(Base base)</span> &#123;<br>            <span class="hljs-built_in">this</span>.base = base;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>            base.print();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>我们有一个接口<code>Base</code>，一个实现类<code>BaseImpl</code>。假如我们想要在实现类中添加一些方法，但又不想重新写一遍接口实现，第一种我们可以继承<code>BaseImpl</code>,另外一种就是实现接口<code>Base</code>，传入一个实现类的实例，将所有的接口请求都交给实现类的实例来完成。<br>虽然官方说<strong>委托模式已经证明是实现继承的一个很好的替代方式(The Delegation pattern has proven to be a good alternative to implementation inheritance)</strong>,但选择权还是在大家手上，看情况而定，没有银弹。<br>那么在 kotlin 中应该怎么写呢？如果我们用 java 的思想来写，无非就是换换关键字，然后一坨模板代码，其实在 kotlin 中是可以通过<code>by</code>关键字零模板代码支持的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseImpl</span></span>(<span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span>) : Base &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> &#123;<br>        println(x)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span></span>(b: Base) : Base <span class="hljs-keyword">by</span> b<br></code></pre></td></tr></table></figure>
<p><code>Derived</code>的超类型列表中的<code>by</code>子句表示<code>b</code>将会在<code>Derived</code>中内部存储， 并且编译器将生成转发给<code>b</code>的所有<code>Base</code>的方法。<br>这个就是 kotlin 中的委托，有的地方也叫委托类或者委托接口。<br>这里有一点需要注意下，覆盖(override)是符合预期的：编译器会使用 override 覆盖的实现而不是委托对象中的.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Base</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessageLine</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseImpl</span></span>(<span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span>) : Base &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span> &#123; println(x) &#125;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessageLine</span><span class="hljs-params">()</span></span> &#123; println(x) &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived2</span></span>(b: Base) : Base <span class="hljs-keyword">by</span> b &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printMessage</span><span class="hljs-params">()</span></span> &#123; println(<span class="hljs-string">&quot;abc&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> b = BaseImpl(<span class="hljs-number">10</span>)<br>    Derived2(b).printMessage()<br>    Derived2(b).printMessageLine()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们在<code>Derived2</code>中覆写了<code>printMessage</code>这个方法，那么在调用的时候，就是用的我们覆写的方法。</p>
<h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> p: String <span class="hljs-keyword">by</span> Delegate()<br>&#125;<br></code></pre></td></tr></table></figure>
<p>语法是：<code>val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</code>。在<code>by</code>后面的表达式是该<code>委托</code>， 因为属性对应的<code>get()</code>（与<code>set()</code>）会被委托给它的<code>getValue()</code>与<code>setValue()</code>方法。 属性的委托不必实现接口，但是需要提供一个<code>getValue()</code>函数（对于<code>var</code>属性还有<code>setValue()</code>）。<br>先从最简单的委托开始，最后再看自定义委托。</p>
<h4 id="标准委托"><a href="#标准委托" class="headerlink" title="标准委托"></a>标准委托</h4><p>借用官网的一个例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>   <span class="hljs-keyword">var</span> newName: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>   <span class="hljs-meta">@Deprecated(<span class="hljs-string">&quot;Use &#x27;newName&#x27; instead&quot;</span>, ReplaceWith(<span class="hljs-string">&quot;newName&quot;</span>)</span>)<br>   <span class="hljs-keyword">var</span> oldName: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">this</span>::newName<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">val</span> myClass = MyClass()<br>   <span class="hljs-comment">// 通知：&#x27;oldName: Int&#x27; is deprecated.</span><br>   <span class="hljs-comment">// Use &#x27;newName&#x27; instead</span><br>   myClass.oldName = <span class="hljs-number">42</span><br>   println(myClass.newName) <span class="hljs-comment">// 42</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这是一种最简单的委托方式。通过查看对应的 java 代码，发现其实就是对同一个成员变量的读写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> newName;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNewName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.newName;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNewName</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>      <span class="hljs-built_in">this</span>.newName = var1;<br>   &#125;<br><br>   <span class="hljs-comment">/** <span class="hljs-doctag">@deprecated</span> */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOldName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.newName;<br>   &#125;<br><br>   <span class="hljs-comment">/** <span class="hljs-doctag">@deprecated</span> */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOldName</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>      <span class="hljs-built_in">this</span>.newName = var1;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>MyClass</code>中的四个方法都是对<code>newName</code>这个字段的读写。</p>
<p>除此之外，委托属性可以是：</p>
<ul>
<li>顶层属性</li>
<li>同一个类的成员或扩展属性</li>
<li>另一个类的成员或扩展属性</li>
</ul>
<p>比如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> topLevelInt: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassWithDelegate</span></span>(<span class="hljs-keyword">val</span> anotherClassInt: <span class="hljs-built_in">Int</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>(<span class="hljs-keyword">var</span> memberInt: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> anotherClassInstance: ClassWithDelegate) &#123;<br>    <span class="hljs-keyword">var</span> delegatedToMember: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> <span class="hljs-keyword">this</span>::memberInt<span class="hljs-comment">//同一个类的成员</span><br>    <span class="hljs-keyword">var</span> delegatedToTopLevel: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> ::topLevelInt<span class="hljs-comment">//顶层属性</span><br><br>    <span class="hljs-keyword">val</span> delegatedToAnotherClass: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> anotherClassInstance::anotherClassInt<span class="hljs-comment">//另一个类的成员</span><br>&#125;<br><span class="hljs-keyword">var</span> MyClass.extDelegated: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> ::topLevelInt<span class="hljs-comment">//顶层属性</span><br></code></pre></td></tr></table></figure>
<p>这种委托方式在我们做版本升级修改字段时是挺常用的,将旧字段委托给新字段，并将旧字段标记为过时。</p>
<h4 id="懒加载委托"><a href="#懒加载委托" class="headerlink" title="懒加载委托"></a>懒加载委托</h4><p>这种方式就是当我们首次访问这个属性的时候才会去初始化这个属性，从而避免不必要的资源消耗，和我们用 java 写单例模式的懒加载是一样的。<br>只会在首次访问的时候初始化这个属性，然后缓存起来，下次访问时直接返回。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> lazyValue: String <span class="hljs-keyword">by</span> lazy &#123;<br>    println(<span class="hljs-string">&quot;computed!&quot;</span>)<br>    <span class="hljs-string">&quot;Hello&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(lazyValue)<br>    println(lazyValue)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的 lazy 是一个高阶函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">lazy</span><span class="hljs-params">(initializer: () -&gt; <span class="hljs-type">T</span>)</span></span>: Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">actual</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">lazy</span><span class="hljs-params">(mode: <span class="hljs-type">LazyThreadSafetyMode</span>, initializer: () -&gt; <span class="hljs-type">T</span>)</span></span>: Lazy&lt;T&gt; =<br>    <span class="hljs-keyword">when</span> (mode) &#123;<br>        LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)<br>        LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)<br>        LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，lazy接收一个 mode 参数，如果没有传入的话，默认是<code>SynchronizedLazyImpl</code>线程安全的：该值只在一个线程中计算，但所有线程都会看到相同的值。如果初始化委托的同步锁不是必需的，这样可以让多个线程同时执行，那么将<code>LazyThreadSafetyMode.PUBLICATION</code>作为参数传给 lazy()。<br>如果我们确定初始化将总是发生在与属性使用位于相同的线程， 那么可以使用<code>LazyThreadSafetyMode.NONE</code>模式。它不会有任何线程安全的保证以及相关的开销。<br>所以这个参数的选择也要看具体应用场景。</p>
<h4 id="可观察委托"><a href="#可观察委托" class="headerlink" title="可观察委托"></a>可观察委托</h4><p>如果我们想要观察属性值的变化，可以使用<code>Delegates.observable()</code>，它接受两个参数：初始值与修改时处理程序（handler）。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">ObservableItem</span></span>&#123;<br>    <span class="hljs-keyword">var</span> name :String <span class="hljs-keyword">by</span> Delegates.observable(<span class="hljs-string">&quot;initialValue&quot;</span>)&#123;<br>        prop,old,new-&gt;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$prop</span>  <span class="hljs-variable">$old</span> -&gt; <span class="hljs-variable">$new</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当我们给<code>name</code>赋值的时候，就会触发传入的处理程序，但这里我们只能观察到赋值，但并不能做拦截，如果想要截获取值并<strong>否决</strong>,可以使用<code>vetoable()</code></p>
<h4 id="可否决委托"><a href="#可否决委托" class="headerlink" title="可否决委托"></a>可否决委托</h4><p>如果我们想在观察属性值变化的同时决定是否使用新的值，可以使用<code>Delegates.vetoable</code>,同样的，它也接受两个参数：它接受两个参数：初始值与修改时处理程序（handler）。只不过这里的 handler 需要返回一个布尔值，告诉程序是否使用新值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VetoableItem</span></span>&#123;<br>    <span class="hljs-keyword">var</span> name :String <span class="hljs-keyword">by</span> Delegates.vetoable(<span class="hljs-string">&quot;initialValue&quot;</span>)&#123;<br>        prop,old,new-&gt;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$prop</span>  <span class="hljs-variable">$old</span> -&gt; <span class="hljs-variable">$new</span>&quot;</span>)<br>        new.length &gt; <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> vetoableItem = VetoableItem()<br>    println(vetoableItem.name)<br>    vetoableItem.name = <span class="hljs-string">&quot;123&quot;</span><br>    println(vetoableItem.name)<br>    vetoableItem.name = <span class="hljs-string">&quot;1234&quot;</span><br>    println(vetoableItem.name)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">// initialValue</span><br><span class="hljs-comment">// var com.huangyuanlove.VetoableItem.name: kotlin.String  initialValue -&gt; 123</span><br><span class="hljs-comment">// initialValue</span><br><span class="hljs-comment">// var com.huangyuanlove.VetoableItem.name: kotlin.String  initialValue -&gt; 1234</span><br><span class="hljs-comment">// 1234</span><br></code></pre></td></tr></table></figure>
<p>在这里，只有当<code>new</code>的长度大于 3 时，我们才会将<code>new</code>赋值给<code>name</code>，</p>
<h4 id="将属性储存在映射中"><a href="#将属性储存在映射中" class="headerlink" title="将属性储存在映射中"></a>将属性储存在映射中</h4><p>一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者执行其他“动态”任务的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapItem</span></span>(map: Map&lt;String,Any?&gt;)&#123;<br>    <span class="hljs-keyword">val</span> name: String <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">val</span> age:<span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">val</span> address:String <span class="hljs-keyword">by</span> map<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">val</span> map:Map&lt;String,Any?&gt; = mapOf(<br>    <span class="hljs-string">&quot;name&quot;</span> to <span class="hljs-string">&quot;xuan&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span> to <span class="hljs-number">18</span>,<br>  )<br>  <span class="hljs-keyword">val</span> mapItem = MapItem(map)<br>  println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mapItem.age&#125;</span>&quot;</span>)<br>  println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mapItem.age&#125;</span>  <span class="hljs-subst">$&#123;mapItem.address&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里需要注意，假如我们传入的<code>map</code>里面没有对应属性，当程序运行时，这个属性没有被使用是没问题的，比如上面打印<code>name</code>和<code>age</code>。但是当我们使用这个属性的时候，就是上面打印<code>address</code>,会抛出异常<code>Key address is missing in the map.</code>.另外一方面，我们将传入的 map 的值声明为了可空，这就意味着在调用出传入了空值，比如<code>&quot;address&quot; to null,</code>,代码是可以运行的，但对<code>address</code>这个属性做处理的时候会报空指针异常，这些都是需要额外注意的地方。<br>还有一点需要注意，如果是对于<code>var</code>属性，需要将<code>Map</code>替换成<code>MutableMap</code>,但是这样的话它们两个可是双向绑定的哟，比如下面这种</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutableMapItem</span></span>(map:MutableMap&lt;String,Any?&gt;)&#123;<br>    <span class="hljs-keyword">var</span> name: String <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">by</span> map<br>    <span class="hljs-keyword">var</span> address: String <span class="hljs-keyword">by</span> map<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>      <span class="hljs-keyword">val</span> map:MutableMap&lt;String,Any?&gt; = mutableMapOf(<br>        <span class="hljs-string">&quot;name&quot;</span> to <span class="hljs-string">&quot;xuan&quot;</span>,<br>        <span class="hljs-string">&quot;age&quot;</span> to <span class="hljs-number">18</span>,<br>        <span class="hljs-string">&quot;address&quot;</span> to <span class="hljs-string">&quot;beijing&quot;</span><br>    )<br>    <span class="hljs-keyword">val</span> mutableMapItem = MutableMapItem(map)<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mutableMapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mutableMapItem.age&#125;</span> <span class="hljs-subst">$&#123;mutableMapItem.address&#125;</span>&quot;</span>)<br>    println(map)<br>    mutableMapItem.name = <span class="hljs-string">&quot;huang&quot;</span><br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mutableMapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mutableMapItem.age&#125;</span> <span class="hljs-subst">$&#123;mutableMapItem.address&#125;</span>&quot;</span>)<br>    println(map)<br>    mutableMapItem.name = <span class="hljs-string">&quot;yuan&quot;</span><br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;mutableMapItem.name&#125;</span>  <span class="hljs-subst">$&#123;mutableMapItem.age&#125;</span> <span class="hljs-subst">$&#123;mutableMapItem.address&#125;</span>&quot;</span>)<br>    println(map)<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-comment">// xuan  18 beijing</span><br><span class="hljs-comment">// &#123;name=xuan, age=18, address=beijing&#125;</span><br><span class="hljs-comment">// huang  18 beijing</span><br><span class="hljs-comment">// &#123;name=huang, age=18, address=beijing&#125;</span><br><span class="hljs-comment">// yuan  18 beijing</span><br><span class="hljs-comment">// &#123;name=yuan, age=18, address=beijing&#125;</span><br></code></pre></td></tr></table></figure>

<h4 id="局部属性委托"><a href="#局部属性委托" class="headerlink" title="局部属性委托"></a>局部属性委托</h4><p>可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">example</span><span class="hljs-params">(computeFoo: () -&gt; <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> memoizedFoo <span class="hljs-keyword">by</span> lazy(computeFoo)<br>    <span class="hljs-keyword">val</span> someCondition = <span class="hljs-literal">false</span><br><br>    <span class="hljs-keyword">if</span> (someCondition &amp;&amp; memoizedFoo&gt;<span class="hljs-number">0</span> ) &#123;<br>        println(memoizedFoo+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>memoizedFoo</code>变量只会在第一次访问时计算。 如果<code>someCondition</code>失败，那么该变量根本不会计算。</p>
<h4 id="自定义委托"><a href="#自定义委托" class="headerlink" title="自定义委托"></a>自定义委托</h4><p>先看一下自定义委托的要求有哪些，示例是这样的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Resource</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Owner</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> varResource: Resource <span class="hljs-keyword">by</span> ResourceDelegate()<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceDelegate</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> resource: Resource = Resource()) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: Resource &#123;<br>        <span class="hljs-keyword">return</span> resource<br>    &#125;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">Any</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">is</span> Resource) &#123;<br>            resource = value<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>总结一下</p>
<ol>
<li>对于<code>var</code>修饰的属性，我们必须要有<code>getValue</code>、<code>setValue</code>这两个方法，同时，这两个方法必须用<code>operator</code>关键字修饰。</li>
<li>由于<code>varResource</code>是<code>Owner</code>,因此<code>getValue</code>、<code>setValue</code>这两个方法中的<code>thisRef</code>的类型，必须要是<code>Owner</code>或者是<code>Owner的父类</code>。一般来说，这三处的类型是一致的，当我们不确定委托属性会处于哪个类的时候，就可以将<code>thisRef</code>的类型定义为<code>Any?</code>。</li>
<li>由于委托的属性是<code>Resource</code>类型，那么对于自定义委托中的<code>getValue</code>、<code>setValue</code>参数及返回值需要是<code>String类型或者是它的父类</code></li>
</ol>
<p>我们可以把上面的代码当成模板代码，都是这样写就好了。如果觉得麻烦，可以使用标准库中的接口<code>ReadOnlyProperty</code>和<code>ReadWriteProperty</code>将委托创建为匿名对象，而无需创建新类。它们提供所需的方法:<code>getValue()</code>在<code>ReadOnlyProperty</code>中声明；<code>ReadWriteProperty</code>扩展了它并添加了<code>setValue()</code>。这意味着可以在需要<code>ReadOnlyProperty</code>时传递 <code>ReadWriteProperty</code>。<br>比如像这样</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">resourceDelegate</span><span class="hljs-params">(resource: <span class="hljs-type">Resource</span>= Resource()</span></span>) :ReadWriteProperty&lt;Owner,Resource&gt; =<br>    <span class="hljs-keyword">object</span>:ReadWriteProperty&lt;Owner,Resource&gt;&#123;<br>        <span class="hljs-keyword">var</span> curValue = resource<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: Resource=curValue<br>        <br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Owner</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">Resource</span>)</span></span> &#123;<br>            curValue = value<br>        &#125;<br><br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Owner</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> readOnlyResource: Resource <span class="hljs-keyword">by</span> resourceDelegate()  <span class="hljs-comment">// ReadWriteProperty as val</span><br>    <span class="hljs-keyword">var</span> readWriteResource: Resource <span class="hljs-keyword">by</span> resourceDelegate()<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="提供委托"><a href="#提供委托" class="headerlink" title="提供委托"></a>提供委托</h4><p>通过定义 provideDelegate 操作符，可以扩展创建属性实现所委托对象的逻辑。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数， 那么会调用该函数来创建属性委托实例。比如在初始化之前检查一致性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceDelegate</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">ReadOnlyProperty</span>&lt;<span class="hljs-type">MyUI, T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">MyUI</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: T &#123; ... &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceLoader</span>&lt;<span class="hljs-type">T</span>&gt;</span>(id: ResourceID&lt;T&gt;) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">provideDelegate</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            thisRef: <span class="hljs-type">MyUI</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">            prop: <span class="hljs-type">KProperty</span>&lt;*&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>: ReadOnlyProperty&lt;MyUI, T&gt; &#123;<br>        checkProperty(thisRef, prop.name)<br>        <span class="hljs-comment">// 创建委托</span><br>        <span class="hljs-keyword">return</span> ResourceDelegate()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">checkProperty</span><span class="hljs-params">(thisRef: <span class="hljs-type">MyUI</span>, name: <span class="hljs-type">String</span>)</span></span> &#123; …… &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyUI</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">bindResource</span><span class="hljs-params">(id: <span class="hljs-type">ResourceID</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: ResourceLoader&lt;T&gt; &#123; …… &#125;<br><br>    <span class="hljs-keyword">val</span> image <span class="hljs-keyword">by</span> bindResource(ResourceID.image_id)<br>    <span class="hljs-keyword">val</span> text <span class="hljs-keyword">by</span> bindResource(ResourceID.text_id)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>provideDelegate</code>的参数与<code>getValue</code>的相同：</p>
<ul>
<li><code>thisRef</code>必须与<code>属性所有者</code>类型（对于扩展属性必须是被扩展的类型）相同或者是它的超类型；</li>
<li><code>property</code>必须是类型<code>KProperty&lt;*&gt;</code>或其超类型。</li>
</ul>
<hr>
<p>参考：</p>
<p><a href="https://book.kotlincn.net/text/delegation.html">委托</a><br><a href="https://kotlinlang.org/docs/delegation.html">Delegation</a></p>
<hr>
<p>已学习：</p>
<ul>
<li><p>扩展</p>
<ul>
<li><input type='checkbox' disabled='true' checked>扩展函数</input></li>
<li><input type='checkbox' disabled='true' checked>扩展属性</input></li>
<li><input type='checkbox' disabled='true' checked>作用域</input></li>
</ul>
</li>
<li><p>函数类型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li>
<li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li>
<li><input type='checkbox' disabled='true' checked>SAM 转换</input></li>
</ul>
</li>
<li><p>泛型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>逆变</input></li>
<li><input type='checkbox' disabled='true' checked>协变</input></li>
<li><input type='checkbox' disabled='true' checked>类型投影</input></li>
<li><input type='checkbox' disabled='true' checked>星投影</input></li>
<li><input type='checkbox' disabled='true' checked>泛型约束</input></li>
</ul>
</li>
<li><p>关键字</p>
<ul>
<li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li>
</ul>
</li>
<li><p>委托</p>
<ul>
<li><input type='checkbox' disabled='true' checked>委托类</input></li>
<li><input type='checkbox' disabled='true' checked>委托属性</input></li>
<li><input type='checkbox' disabled='true' checked>自定义委托</input></li>
</ul>
</li>
</ul>
<p>未学习：</p>
<ul>
<li><p>关键字</p>
<ul>
<li>object</li>
<li>Unit</li>
<li>Nothing</li>
<li>inline,noinline,crossinline</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li>启动</li>
<li>挂起</li>
<li>Job</li>
<li>Context</li>
<li>Channel</li>
<li>Flow</li>
<li>select</li>
<li>并发、异常</li>
<li>launch</li>
<li>Dispatchers</li>
<li>CoroutineScope</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin泛型:逆变与协变</title>
    <url>/2024/04/30/kotlin%E6%B3%9B%E5%9E%8B-%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98/</url>
    <content><![CDATA[<p>泛型中涉及到的概念也不少,型变(Variance)、逆变(Contravariance)、协变(Covariance)、不变(Invariant).在 kotlin 中还有三个关键字<code>in</code>、<code>out</code>、<code>where</code>、<code>reified</code>等,在java中同样也有<code>? extends</code>、<code>? super</code>、<code>?</code><br>这些概念是啥意思嘞？引用点概念说明</p>
<blockquote>
<p>型变(Variance)、协变(Covariance)、逆变(Contravariance)和不变(Invariant)是相关但不同的概念.</p>
</blockquote>
<blockquote>
<p>型变是指泛型类型参数在子类型关系中的行为.它描述了一个泛型类型是否允许类型参数的子类型关系与泛型类型参数的子类型关系保持一致.在泛型中,可以有三种型变类型：协变、逆变和不变.</p>
</blockquote>
<blockquote>
<p>协变是指如果一个泛型类型的子类型关系与其类型参数的子类型关系保持一致,则该泛型类型是协变的.简而言之,如果子类型的泛型参数是父类型泛型参数的子类型,就可以说该泛型类型是协变的.</p>
</blockquote>
<blockquote>
<p>逆变是指如果一个泛型类型的子类型关系与其类型参数的子类型关系相反,则该泛型类型是逆变的.简而言之,如果子类型的泛型参数是父类型泛型参数的超类型,就可以说该泛型类型是逆变的.</p>
</blockquote>
<blockquote>
<p>不变是指一个泛型类型的子类型关系与其类型参数无关,即类型参数的子类型关系与泛型类型的子类型关系无关.在不变的情况下,不能将父类型的对象赋值给子类型的对象,也不能将子类型的对象赋值给父类型的对象.</p>
</blockquote>
<blockquote>
<p>因此,可以说协变和逆变是型变的两种具体形式,而不变则是型变的一种特殊情况.</p>
</blockquote>
<blockquote>
<p>总结起来,协变、逆变和不变描述了泛型类型参数与泛型类型之间子类型关系的不同行为.协变和逆变是对子类型关系的具体约束,而不变则是没有任何子类型关系的约束.它们之间是互相排斥的关系,不是包含关系.</p>
</blockquote>
<p>一脸懵了吧😳?问题不大,结合代码具体看一下就差不多了</p>
<p>我们还是结合 java 和 kotlin 对比来看一下</p>
<h3 id="Java中的泛型"><a href="#Java中的泛型" class="headerlink" title="Java中的泛型"></a>Java中的泛型</h3><p>我们先用Java代码来看一下,假如我们有如下三个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Poodle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dog</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于 java 的多态性,我们可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animalDog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br><span class="hljs-type">Animal</span> <span class="hljs-variable">animalBird</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>();<br>ArrayList&lt;Animal&gt; animalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>animalList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>());<br>animalList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br></code></pre></td></tr></table></figure>
<p>这么写是没问题的,我们可以把子类添加到父类列表中,但当我们在<code>animalList</code>中获取数据时返回的是<code>Animal</code>类型,如果用到子类的特性,还需要使用<code>instanceof</code>来判断一下类型.<br>但如果我们这么写是不行的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java">ArrayList&lt;Animal&gt; animalList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br></code></pre></td></tr></table></figure>
<p>因为 java 的泛型具有不变性,在Java 里面认为<code>ArrayList&lt;Animal&gt;</code>和<code>ArrayList&lt;Dog&gt;</code>没啥关系.<br>同样的,当我们想要用方法重载时也会遇到这种情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">animal</span><span class="hljs-params">(ArrayList&lt;Dog&gt; dogs)</span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">animal</span><span class="hljs-params">(ArrayList&lt;Bird&gt; birds)</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果我们这么写的话会报错,IDE 会提示我们相应的信息</p>
<blockquote>
<p>animal(ArrayList<Dog>)’ clashes with ‘animal(ArrayList<Bird>)’; both methods have same erasure</p>
</blockquote>
<p>两个方法的参数有相同的擦除类型,编译后会被认为是同一个方法.<br>同样的,我们在<strong>捕获泛型异常</strong>时也会有类似的报错信息.</p>
<h3 id="Java中的泛型擦除"><a href="#Java中的泛型擦除" class="headerlink" title="Java中的泛型擦除"></a>Java中的泛型擦除</h3><p>面试常见的八股文,我们来复习一下,这部分可以跳过不看.<br>比如我们在C#中有如下代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params">String[] args</span>)</span>&#123; <br>        test&lt;<span class="hljs-built_in">string</span>&gt;(); <br>    &#125;    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>&lt;<span class="hljs-title">T</span>&gt;()</span>&#123; <br>        Console.WriteLine(<span class="hljs-keyword">typeof</span>(T)); <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure>
<p>这里的泛型 T 类型string 是可以在运行时获取到的,并且在这里是一个真实可用的类型.<br>但在Java是不行的,由于向上兼容历史代码的原因 Java 采用了<code>Code sharing</code>的策略,使得泛型只存在于源码阶段,编译过后的Class文件并不存在泛型,虚拟机并不知道泛型的存在,所以说Java中的泛型是一种伪泛型,这种参数类型只存在于源码阶段在编译后并不存在的机制我们叫做<strong>泛型擦除</strong>.为了保持泛型继承或实现关系的正确性,java 中还有一种策略：<strong>桥方法生成(Bridge Method Generation)</strong>:<br>一个简单的例子来说明桥方法生成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(T shape)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing shape: &quot;</span> + shape.toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(String shape)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing circle: &quot;</span> + shape);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在类型擦除后,编译器会生成桥方法来保持泛型继承关系的正确性.在这个示例中,编译器会生成一个桥方法,使得Circle类的方法签名与父类的方法签名保持一致,但返回类型被擦除为父类的类型参数.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(String shape)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Drawing circle: &quot;</span> + shape);<br>    &#125;<br><br>    <span class="hljs-comment">// 生成的桥方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Object shape)</span> &#123;<br>        draw((String) shape);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过生成的桥方法,即draw(Object shape),在类型擦除后仍然能够正确地调用泛型方法.这样,即使在编译器看不到具体的泛型类型信息,仍然可以通过桥方法来调用正确的方法实现.<br>感兴趣的话可以搜一下关键字:泛型擦除、桥方法生成、Code sharin、Code specialization</p>
<h3 id="Java-中的泛型通配符"><a href="#Java-中的泛型通配符" class="headerlink" title="Java 中的泛型通配符"></a>Java 中的泛型通配符</h3><p>假如我们真的有像上面那种赋值需求怎么搞？java 给我们提供了<code>泛型通配符</code>: <strong>? extends</strong> 和 <strong>? super</strong> 来解决这个问题.<br>啰嗦一下：在继承关系上,一般情况下将父类放在上方,子类放在下方.比如上面定义的类</p>

<pre>
<code class="mermaid" >
graph TB

A(Animal)
A10(Dog)
A11(Bird)
A20(Poodle)
A-->A10
A-->A11
A10-->A20

</code>
</pre>


<h4 id="extends"><a href="#extends" class="headerlink" title="? extends"></a>? extends</h4><p>我们可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&gt; arrayList ;<br>arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Bird&gt;();<br>arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br>arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();<br></code></pre></td></tr></table></figure>
<p>这里的<code>? extends</code>叫做<strong>上界通配符</strong>,可以使 Java 泛型具有<strong>协变性 Covariance</strong>,协变就是允许上面的赋值是合法的.<br>不过这里的<code>extends</code>和我们定义<code>class</code>时继承某个类用的<code>extends</code>有一点点不一样,除了上界所有的直接子类、间接子类还包含它本身,并且上界也可以是 interface.<br>在上面的例子中,<code>ArrayList&lt;? extends Animal&gt;</code>表示列表中可以存放 Animal 及其子类、间接子类的类型.也就是确认了它的上限能到哪一层.<br>但我们在使用的泛型通配符之后,在使用上会有一些小问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java">arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<span class="hljs-comment">//error</span><br>arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>());<span class="hljs-comment">//error</span><br>arrayList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>());<span class="hljs-comment">//error</span><br><span class="hljs-type">Animal</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span>  arrayList.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure>

<p>由于<code>arrayList</code>中存放的可以是<strong>Animal 及其子类、间接子类的类型</strong>,所以我们并不确定是哪种类型,因此我们无法向列表中添加元素,但可以确定的是,将列表中的元素赋值给 Animal类型的变量是没问题的.<br>像这种只能从列表中读取数据提供,但不能向列表中写入的情况我们称之为<code>生产者</code></p>
<h4 id="super"><a href="#super" class="headerlink" title="? super"></a>? super</h4><p>我们可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java">ArrayList&lt;? <span class="hljs-built_in">super</span> Dog&gt; list ;<br>list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Dog&gt;();<br>list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Animal&gt;();<br>list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Poodle&gt;();<span class="hljs-comment">//error</span><br><br></code></pre></td></tr></table></figure>
<p>这里的<code>? super</code>叫做<strong>下界通配符</strong>,可以使Java泛型具<strong>逆变性 Contravariance</strong>,逆变就是允许上面的赋值是合法的.<br>通过代码我们可以看到下界通配符确定了列表的下限,也就是确认了下限在哪一层,我们可以将该层及以上的类型赋值给 list.同样的,我们在使用上也有一点点小问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java">list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Poodle</span>());<br>list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>());<span class="hljs-comment">//error</span><br><br><span class="hljs-type">Object</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<p>因为list 中存放的肯定是<strong>Dog或者其父类、间接父类</strong>,根据里氏替换原则,任何使用父类的地方可以被它的子类替换,所以我们可以向 list 中添加<strong>Dog或其子类、间接子类</strong>.但是当我们从 list 中取数据的时候,由于不知道 list 中存放的具体是什么类型,在 java 中 Object 是所有类型的父类,所以这里取到的数据返回的<strong>Object</strong>类型.</p>
<p>一般情况下,我们获取到Object可以通过<code>className</code>或者<code>instanceof</code>来判断具体类型,但我们就先忽略吧.<br>像这种只写入而不读取的泛型类型声明情况称之为<strong>消费者 Consumer</strong>.</p>
<h4 id="无边界通配符"><a href="#无边界通配符" class="headerlink" title="无边界通配符"></a>无边界通配符</h4><p>还有一种无边界通配符,用单问号表示：List&lt;?&gt;,也就是没有任何限定,相当于<code>? extends Object</code>.需要注意的是,它和不使用类型的 List 还是有区别的：</p>
<ul>
<li>List&lt;?&gt; list表示的是列表保存某个特定类型的对象,但我们不能向其中添加任何元素,因为我们不清楚 list 中保存的是那种类型</li>
<li>没有泛型参数的 List 表示该列表持有的元素类型是 Object,因此可以添加任何类型的对象,但编译器会有警告信息.</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>小小的总结一下：<br>利用<code>? extends</code>形式的通配符可以实现泛型的向上转型,也就是支持协变.但使用上通配符后编译器为了保证运行时的安全,会限定对其写的操作,开放读的操作也就是<strong>只能读取不能修改</strong><br>利用<code>? super T</code>形式的通配符可以实现泛型的向下转型,也就是支持逆变,与上通配符相反,下边界通配符通常限定读的操作,开放写的操作,也就是<strong>只能修改不能读取</strong></p>
<p>Joshua Bloch 在其著作《Effective Java》第三版 中很好地解释了该问题 (第 31 条：“利用有限制通配符来提升 API 的灵活性”). 他称那些你只能从中读取的对象为生产者, 并称那些只能向其写入的对象为消费者.他建议：</p>
<blockquote>
<p>为了灵活性最大化,在表示生产者或消费者的输入参数上使用通配符类型.</p>
</blockquote>
<p>他还提出了以下助记符：PECS 代表生产者-Extends、消费者-Super(Producer-Extends, Consumer-Super).</p>
<h3 id="kotlin-中的泛型通配符"><a href="#kotlin-中的泛型通配符" class="headerlink" title="kotlin 中的泛型通配符"></a>kotlin 中的泛型通配符</h3><p>理清楚了 java 中的泛型通配符,接着我们看一下 kotlin 中的通配符,相对于 Java 的通配符提出了一种新的定义：<strong>声明处型变(declaration-site variance)<strong>与</strong>类型投影(type projections)</strong><br>先从 kotlin 中的通配符说起：<br>和 java 泛型一样，kotlin 中的泛型也是不变的，同样的，也提供了相应的关键字来支持<strong>协变</strong>和<strong>逆变</strong></p>
<ul>
<li>使用关键字<code>out</code>来支持协变，等同于 Java 中的上界通配符<code>? extends</code>。</li>
<li>使用关键字<code>in</code>来支持逆变，等同于 Java 中的下界通配符<code>? super</code>。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> outList: MutableList&lt;<span class="hljs-keyword">out</span> TestMain.Animal&gt; = mutableListOf()<br><span class="hljs-keyword">val</span> outListItem: TestMain.Animal = outList[<span class="hljs-number">0</span>]<br><br><br><span class="hljs-keyword">val</span> inList: MutableList&lt;<span class="hljs-keyword">in</span> TestMain.Animal&gt; = mutableListOf()<br>inList.add(TestMain.Dog())<br>inList.add(TestMain.Bird())<br>inList.add(TestMain.Poodle())<br><span class="hljs-keyword">val</span> inListItem: Any? = inList[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>
<p>无非是换了个写法而已，没多大差别.不过需要注意一下，kotlin 同时支持使用处型变和声明处型变。<br>举一个用烂了的例子</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span>&lt;<span class="hljs-type">out T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> T<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(t)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> producer: Producer&lt;TestMain.Animal&gt; = Producer()<br><span class="hljs-keyword">val</span> animal: TestMain.Animal = producer.produce()<br><br><span class="hljs-keyword">val</span> consumer: Consumer&lt;TestMain.Animal&gt; = Consumer()<br>consumer.consume(TestMain.Dog())<br></code></pre></td></tr></table></figure>
<p>如果我们确认泛型参数只用来输入或者输出，可以在声明处直接添加<code>in</code>或者<code>out</code>.当然也可以在使用处添加声明</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer1</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T? &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer1</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span> &#123;<br>        println(t)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">val</span> producer1: Producer1&lt;<span class="hljs-keyword">out</span> TestMain.Animal&gt; = Producer1()<br><span class="hljs-keyword">val</span> animal1: TestMain.Animal? = producer1.produce()<br><br><span class="hljs-keyword">val</span> consumer1: Consumer1&lt;<span class="hljs-keyword">in</span> TestMain.Animal&gt; = Consumer1()<br>consumer1.consume(TestMain.Dog())<br></code></pre></td></tr></table></figure>
<p>这里也就是经常说的 <strong>消费者 in, 生产者 out</strong></p>
<h4 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h4><p>这个东西可以理解为就是一个概念，根据官方描述是这样的:<br>将类型参数<code>T</code>声明为<code>out</code>非常简单，并且能避免使用处子类型化的麻烦，但是有些类实际上不能限制为只返回<code>T</code>！一个很好的例子是<code>Array</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: T &#123; …… &#125;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">set</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>, value: <span class="hljs-type">T</span>)</span></span> &#123; …… &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该类在<code>T</code>上既不能是协变的也不能是逆变的。这造成了一些不灵活性。考虑下述函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Any</span>&gt;, to: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Any</span>&gt;)</span></span> &#123;<br>    assert(from.size == to.size)<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> from.indices)<br>        to[i] = from[i]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个函数应该将项目从一个数组复制到另一个数组。让我们尝试在实践中应用它：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> ints: Array&lt;<span class="hljs-built_in">Int</span>&gt; = arrayOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">val</span> any = Array&lt;Any&gt;(<span class="hljs-number">3</span>) &#123; <span class="hljs-string">&quot;&quot;</span> &#125; <br>copy(ints, any)<br><span class="hljs-comment">//   ^ 其类型为 Array&lt;Int&gt; 但此处期望 Array&lt;Any&gt;</span><br></code></pre></td></tr></table></figure>
<p>这里我们遇到同样熟悉的问题：<code>Array&lt;T&gt;</code>在<code>T</code>上是<strong>不型变</strong>的，因此<code>Array&lt;Int&gt;</code> 与 <code>Array&lt;Any&gt;</code> 都不是另一个的子类型。为什么？ 再次重复，因为<code>copy</code>可能有非预期行为，例如它可能尝试写一个<code>String</code>到<code>from</code>，并且如果我们实际上传递一个<code>Int</code>的数组，以后会抛<code>ClassCastException</code>异常。<br>如果需要禁止<code>copy</code>功能写入<code>from</code>，可以执行以下操作:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">copy</span><span class="hljs-params">(from: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Any</span>&gt;, to: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">Any</span>&gt;)</span></span> &#123; …… &#125;<br></code></pre></td></tr></table></figure>
<p>这就是类型投影：意味着<code>from</code>不仅仅是一个数组，而是一个<code>受限制</code>的<strong>（投影的）</strong>数组。 只可以调用返回类型为类型参数<code>T</code>的方法，如上，这意味着只能调用<code>get()</code>。 这就是使用处型变的用法，并且是对应于 Java 的 <code>Array&lt;? extends Object&gt;</code>, 但更简单。</p>
<p>你也可以使用<code>in</code>投影一个类型：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fill</span><span class="hljs-params">(dest: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">String</span>&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123; …… &#125;<br></code></pre></td></tr></table></figure>
<p><code>Array&lt;in String&gt;</code> 对应于 Java 的<code>Array&lt;? super String&gt;</code>，也就是说，你可以传递一个<code>CharSequence</code>数组或一个<code>Object</code>数组给<code>fill()</code>函数。<br><strong>以上信息来自 <a href="(https://book.kotlincn.net/text/generics.html)">kotlin 中文网</a></strong></p>
<h4 id="星投影"><a href="#星投影" class="headerlink" title="星投影"></a>星投影</h4><p>有时你想说，你对类型参数一无所知，但仍然希望以安全的方式使用它。 这里的安全方式是定义泛型类型的这种投影，该泛型类型的每个具体实例化都会是该投影的子类型。</p>
<p>Kotlin 为此提供了所谓的<strong>星投影</strong>语法：</p>
<ul>
<li>对于<code>Foo &lt;out T : TUpper&gt;</code>，其中<code>T</code>是一个具有上界<code>TUpper</code>的协变类型参数，<code>Foo &lt;*&gt;</code>等价于<code>Foo &lt;out TUpper&gt;</code>。 意味着当<code>T</code>未知时，你可以安全地从<code>Foo &lt;*&gt;</code>读取<code>TUpper</code>的值。</li>
<li>对于<code>Foo &lt;in T&gt;</code>，其中<code>T</code>是一个逆变类型参数，<code>Foo &lt;*&gt;</code>等价于<code>Foo &lt;in Nothing&gt;</code>。 意味着当<code>T</code>未知时， 没有什么可以以安全的方式写入<code>Foo &lt;*&gt;</code>。</li>
<li>对于<code>Foo &lt;T : TUpper&gt;</code>，其中<code>T</code>是一个具有上界<code>TUpper</code>的不型变类型参数,<code>Foo&lt;*&gt;</code>对于读取值时等价于<code>Foo&lt;out TUpper&gt;</code> 而对于写值时等价于<code>Foo&lt;in Nothing&gt;</code>。</li>
</ul>
<p>如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。 例如，如果类型被声明为 interface Function &lt;in T, out U&gt;，可以使用以下星投影：</p>
<ul>
<li><code>Function&lt;*, String&gt;</code> 表示<code>Function&lt;in Nothing, String&gt;</code>。</li>
<li><code>Function&lt;Int, *&gt;</code> 表示<code>Function&lt;Int, out Any?&gt;</code>。</li>
<li><code>Function&lt;*, *&gt;</code> 表示<code>Function&lt;in Nothing, out Any?&gt;</code>。</li>
</ul>
<p><strong>以上信息来自 <a href="(https://book.kotlincn.net/text/generics.html)">kotlin 中文网</a></strong></p>
<h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><p>不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">singletonList</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span>: List&lt;T&gt; &#123;<br>    <span class="hljs-comment">// ……</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> T.<span class="hljs-title">basicToString</span><span class="hljs-params">()</span></span>: String &#123; <span class="hljs-comment">// 扩展函数</span><br>    <span class="hljs-comment">// ……</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>要调用泛型函数，在调用处函数名之后指定类型参数即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> l = singletonList&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>可以省略能够从上下文中推断出来的类型参数，所以以下示例同样适用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> l = singletonList(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>能够替换给定类型参数的所有可能类型的集合可以由<strong>泛型约束</strong>限制。<br>最常见的约束类型是上界，与Java的<code>extends</code>关键字对应：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="hljs-title">sort</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;  …… &#125;<br></code></pre></td></tr></table></figure>
<p>冒号之后指定的类型是上界，表明只有<code>Comparable&lt;T&gt;</code>的子类型可以替代<code>T</code>。 例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">sort(listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span><br>sort(listOf(HashMap&lt;<span class="hljs-built_in">Int</span>, String&gt;())) <span class="hljs-comment">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span><br></code></pre></td></tr></table></figure>
<p>默认的上界（如果没有声明）是 Any?。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，需要一个单独的 where-子句：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">copyWhenGreater</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt;, threshold: <span class="hljs-type">T</span>)</span></span>: List&lt;String&gt;<br>    <span class="hljs-keyword">where</span> T : CharSequence,<br>          T : Comparable&lt;T&gt; &#123;<br>    <span class="hljs-keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所传递的类型必须同时满足<code>where</code>子句的所有条件。在上述示例中，类型<code>T</code>必须<strong>既实现了 CharSequence 也实现了 Comparable</strong>。<br>这里需要注意的是，where 子句后面的第一个类型可以是接口也可以是抽象类、实现类，后续的类型只能是接口。在 Java 中也一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAbstractClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyInterface</span> &amp; MyAbstractClass&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>&#123; <span class="hljs-comment">//errpr</span><br>    t.test();<br>&#125;<br><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">MyAbstractClass</span> &amp; MyInterface &gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>&#123;<br>    t.test();<br>&#125;<br>    <br></code></pre></td></tr></table></figure>
<p>原因就是 java 中不可以多继承但可以多实现</p>
<h4 id="UnsafeVariance"><a href="#UnsafeVariance" class="headerlink" title="@UnsafeVariance"></a>@UnsafeVariance</h4><p>差点忘了这东西，这个注解就是告诉编译器我知道我在做什么，并且保证不会出问题，忽略协变和逆变的约束就好了<br>比如 kotlin 中的<code>Collection</code>这个类中的<code>contains</code>、<code>containsAll</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-type">out E</span>&gt; : <span class="hljs-type">Iterable</span>&lt;<span class="hljs-type">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contains</span><span class="hljs-params">(element: @<span class="hljs-type">UnsafeVariance</span> <span class="hljs-type">E</span>)</span></span>: <span class="hljs-built_in">Boolean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;@<span class="hljs-type">UnsafeVariance</span> <span class="hljs-type">E</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span><br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>对于协变的类型，通常我们是不允许将泛型类型作为传入参数的类型的，或者说，对于协变类型，我们通常是不允许其涉及泛型参数的部分被改变的。<br>这也很容易解&gt;释为什么 MutableCollection 是不变的，而 Collection 是协变的，因为在 Kotlin 当中，前者是可被修改的，后者是不可被修改的。<br>逆变的情形正好相反，即不可以将泛型参数作为方法的返回值。</p>
</blockquote>
<p>比如这种情形，为了让编译器放过一马，我们就可以用 @UnsafeVariance 来告诉编译器：“我知道我在干啥，保证不会出错，你不用担心”。<br><strong>以上信息来自<a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></strong></p>
<h4 id="reified-关键字"><a href="#reified-关键字" class="headerlink" title="reified 关键字"></a>reified 关键字</h4><p>由于存在类型擦除，导致我们无法在运行时获取泛型的具体类型，有些操作无法实现，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">testOne</span><span class="hljs-params">(Object param)</span>&#123;<br>    <span class="hljs-keyword">if</span>(param <span class="hljs-keyword">instanceof</span> T)&#123;<br>        System.out.println(<span class="hljs-string">&quot;T&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然，在 kotlin 中也不行。<br>但在 java 中我们通常会传入一个<code>Class&lt;T&gt;</code>来做相应的操作，在 kotlin 中同样也可以，不过 kotlin 中有一个更简单的方法:使用<code>reified</code>配合<code>inline</code>来实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> <span class="hljs-title">printIfTypeMatch</span><span class="hljs-params">(item: <span class="hljs-type">Any</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (item <span class="hljs-keyword">is</span> T) &#123; <span class="hljs-comment">// 👈 这里就不会在提示错误了</span><br>        println(item)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们经常用的 gson解析数据、反序列化的时候经常遇到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">fromJson</span><span class="hljs-params">(String json, Class&lt;T&gt; classOfT)</span> <span class="hljs-keyword">throws</span> JsonSyntaxException &#123; <br>    <br>&#125; <br></code></pre></td></tr></table></figure>
<p>这里就是通过多传入一个<code>Class&lt;T&gt;</code>来解决这个问题，在 kotlin 中我们可以通过扩展来变化一下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> Gson.<span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">String</span>)</span></span>: T&#123; <br>     <span class="hljs-keyword">return</span> fromJson(json, T::<span class="hljs-keyword">class</span>.java) <br> &#125; <br></code></pre></td></tr></table></figure>
<p>我们给 Gson 添加了一个扩展方法，在这个方法中，通过<code>inline</code>和<code>reified</code>关键字将泛型<code>T</code>变成了一个真实可用的类型，这两个关键字缺一不可。这里就简单的认为内联方法(inline)是将方法在编译时复制到调用处，使得泛型 T 的类型在编译时就可以确定。当然这么理解不是特别正确。后面学到<code>inline</code>、<code>noinline</code>、<code>crossinline</code>这几个关键字的时候再说吧</p>
<p>参考：</p>
<p><a href="https://book.kotlincn.net/text/generics.html">泛型：in、out、where</a><br><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a><br><a href="https://ethanhua.github.io/2018/01/09/genericity/">深入理解Java和Kotlin中的泛型</a><br><a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></p>
<hr>
<p>已学习：</p>
<ul>
<li><p>扩展</p>
<ul>
<li><input type='checkbox' disabled='true' checked>扩展函数</input></li>
<li><input type='checkbox' disabled='true' checked>扩展属性</input></li>
<li><input type='checkbox' disabled='true' checked>作用域</input></li>
</ul>
</li>
<li><p>函数类型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>带有接收者的函数类型</input></li>
<li><input type='checkbox' disabled='true' checked>Lambda表达式</input></li>
<li><input type='checkbox' disabled='true' checked>SAM 转换</input></li>
</ul>
</li>
<li><p>泛型</p>
<ul>
<li><input type='checkbox' disabled='true' checked>逆变</input></li>
<li><input type='checkbox' disabled='true' checked>协变</input></li>
<li><input type='checkbox' disabled='true' checked>类型投影</input></li>
<li><input type='checkbox' disabled='true' checked>星投影</input></li>
<li><input type='checkbox' disabled='true' checked>泛型约束</input></li>
</ul>
</li>
<li><p>关键字</p>
<ul>
<li><input type='checkbox' disabled='true' checked>作用域函数：with、let、run、apply、also</input></li>
</ul>
</li>
</ul>
<p>未学习：</p>
<ul>
<li><p>关键字</p>
<ul>
<li>object</li>
<li>Unit</li>
<li>Nothing</li>
<li>inline,noinline,crossinline</li>
</ul>
</li>
<li><p>委托</p>
<ul>
<li>委托类</li>
<li>委托属性</li>
<li>自定义委托</li>
</ul>
</li>
<li><p>协程</p>
<ul>
<li>启动</li>
<li>挂起</li>
<li>Job</li>
<li>Context</li>
<li>Channel</li>
<li>Flow</li>
<li>select</li>
<li>并发、异常</li>
<li>launch</li>
<li>Dispatchers</li>
<li>CoroutineScope</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>riverpod2.x中的 Provider 简介</title>
    <url>/2024/03/27/riverpod2-x%E4%B8%AD%E7%9A%84-Provider-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>原文来自：<a href="https://codewithandrea.com/articles/flutter-state-management-riverpod/">https://codewithandrea.com/articles/flutter-state-management-riverpod/</a></p>
<h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>Riverpod是一个响应式缓存和数据绑定框架，由Provider软件包演化而来。根据官方文档的说法，riverpod 是把 provider 重写了，实现了原来无法实现的功能。</p>
<h3 id="为什么使用-riverpod"><a href="#为什么使用-riverpod" class="headerlink" title="为什么使用 riverpod"></a>为什么使用 riverpod</h3><p>从设计上来说，Provider是对<code>InheritedWidget</code>的改进，因此它依赖于小部件树。<br>这是一个不幸的设计决策，可能会导致常见的<code>ProviderNotFoundException</code>：<br><img src="/image/riverpod/provider_demo.png" alt="provider_demo"><br>另一方面，Riverpod是编译时安全的，因为所有的 provider 都被声明为全局的，可以在任何地方访问，这也意味着这些 provider 可以不依赖于widget tree 来存储应用状态和业务逻辑。由于 Riverpod 是一个反应式框架，因此只需在需要时重建providers和widgets即可。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>3.0 已经有 preview 版本了，但还没有出正式版，这里使用稍微旧一点的版本</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter_riverpod:</span> <span class="hljs-string">^2.4.10</span><br></code></pre></td></tr></table></figure>
<p>为了简单起见，这里没有使用<code>hooks_riverpod</code>,至于使用注解来生成 provier，会在后续介绍。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>首先我们需要改造一下程序入口，提供一个<code>ProviderScope</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(<br>    ProviderScope(<br>      child: MyApp(),<br>    ),<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着声明一个全局的<code>Provider</code>，和这个 main 方法平级就可以</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> authorNameProvider = Provider&lt;<span class="hljs-built_in">String</span>&gt;(<br>  (ref) =&gt; <span class="hljs-string">&quot;xuan&quot;</span>,<br>);<br></code></pre></td></tr></table></figure>
<p>然后改造一下<code>MyApp</code>,让它可以读取到数据。改造前是继承<code>StatelessWidget</code>,这里需要改成继承自<code>ConsumerWidget</code>.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> value = ref.watch(helloWorldProvider);<br><br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: Scaffold(<br>        appBar: AppBar(title:  Text(<span class="hljs-string">&#x27;ProviderWidget&#x27;</span>)),<br>        body: Center(<br>          child: Text(value),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，继承<code>ConsumerWidget</code>之后，<code>build</code>方法的签名变了，多了一个<code>WidgetRef</code>对象，我们就是使用这个对象来读取、观察、监听各种 provider。</p>
<p>除了继承<code>ConsumerWidget</code>之外，还有其他方案可供使用</p>
<h4 id="使用-Consumer"><a href="#使用-Consumer" class="headerlink" title="使用 Consumer"></a>使用 Consumer</h4><p>在旧代码中新增使用 riverpod，但又不打算大面积重构时，可以考虑这种方案:使用<code>Consumer</code>包裹需要更新的控件。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_widget/third_part/riverpod/riverpod_widget.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:widget_with_codeview/widget_with_codeview.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderWithConsumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;ProviderWithConsumer&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: WidgetWithCodeView(<br>        child: Column(children: [<br>          Text(<br>            <span class="hljs-string">&quot;有一个包含复杂布局的大型小部件类，您可以使用 Consumer 来仅重新构建依赖于提供者的小部件\n创建小而可重用的小部件有利于组合，使代码更加简洁、性能更高，更易于理解。\n如果您遵循这一原则并创建小而可重用的小部件，那么大部分时间您将自然而然地使用 ConsumerWidget。&quot;</span>,<br>            style: TextStyle(color: Colors.blue, fontSize: <span class="hljs-number">16</span>),<br>          ),<br>          Consumer(builder: (_, ref, __) &#123;<br>            <span class="hljs-keyword">return</span> Text(ref.read(helloWorldProvider));<br>          &#125;)<br>        ]),<br>        filePath: <span class="hljs-string">&quot;lib/third_part/riverpod/provider_with_consumer.dart&quot;</span>,<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述代码中的<code>WidgetWithCodeView</code>是三方库<code>widget_with_codeview</code>用来展示代码的控件。去除后没有影响。</p>
<h4 id="使用ConsumerStatefulWidget"><a href="#使用ConsumerStatefulWidget" class="headerlink" title="使用ConsumerStatefulWidget"></a>使用ConsumerStatefulWidget</h4><p>相对于<code>ConsumerWidget</code>来代替<code>StatelessWidget</code>,<code>使用ConsumerStatefulWidget</code>是用来代替<code>StatefulWidget</code>.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_widget/third_part/riverpod/riverpod_widget.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:widget_with_codeview/widget_with_codeview.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderWithConsumerStatefulWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerStatefulWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  ConsumerState&lt;ProviderWithConsumerStatefulWidget&gt; createState() &#123;<br>    <span class="hljs-keyword">return</span> ProviderWithConsumerStatefulWidgetState();<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderWithConsumerStatefulWidgetState</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerState</span>&lt;<span class="hljs-title">ProviderWithConsumerStatefulWidget</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// 3. if needed, we can read the provider inside initState</span><br>    <span class="hljs-keyword">final</span> helloWorld = ref.read(helloWorldProvider);<br>    <span class="hljs-built_in">print</span>(helloWorld); <span class="hljs-comment">// &quot;Hello world&quot;</span><br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// 4. use ref.watch() to get the value of the provider</span><br>    <span class="hljs-keyword">final</span> helloWorld = ref.watch(helloWorldProvider);<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;ProviderWithConsumerStatefulWidget&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: WidgetWithCodeView(<br>        child: Column(<br>          children: [<br>            Text(<br>              <span class="hljs-string">&quot;ConsumerStatefulWidget可以用来代替StatefulWidget\n当我们从ConsumerState进行子类化时，我们可以在所有小部件生命周期方法中访问ref对象。这是因为ConsumerState声明WidgetRef作为属性，类似于Flutter的State类声明BuildContext作为可以在所有小部件生命周期方法中直接访问的属性。&quot;</span>,<br>              style: TextStyle(color: Colors.blue, fontSize: <span class="hljs-number">16</span>),<br>            ),<br>            Text(helloWorld),<br>          ],<br>        ),<br>        filePath:<br>            <span class="hljs-string">&quot;lib/third_part/riverpod/provider_with_consumerStatefulWidget.dart&quot;</span>,<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>同样的需要使用<code>ConsumerState</code>代替原来的<code>State</code>.需要注意的是,在这里面我们并没有看到<code>WidgetRef</code>,但我们依旧可以在整个页面声明周期内访问<code>WidgetRef</code>对象的实例<code>ref</code>,这是因为<code>ConsumerState</code>将<code>WidgetRef</code>声明为属性。</p>
<h3 id="WidgetRef是什么"><a href="#WidgetRef是什么" class="headerlink" title="WidgetRef是什么"></a>WidgetRef是什么</h3><p>官方文档定义<code>WidgetRef</code>为允许Widgets和Provider交互的对象。可以用来观察(watch)Provider 值的改变，也可以作为<code>Consumer</code>和<code>ConsumerWidget</code>的参数，同样也可以作为<code>ConsumerState</code>的属性。<br>将<code>WidgetRef</code>和<code>BuildContext</code>做一下比较：我们可以通过<code>BuildContext</code>在 Widget tree 中访问祖先节点，比如<code>Theme.of(context)</code> 和 <code>MediaQuery.of(context)</code><br>而<code>WidgetRef</code>可以让我们在 app 中访问任意provider，前提是provider被声明为全局的。这也是设计的初衷。<br>当然，将 provider 声明在类内部，只允许该类访问在编译、运行时也不会报错，但这会影响关注点分离的原则。</p>
<h3 id="八中不同的-Provider"><a href="#八中不同的-Provider" class="headerlink" title="八中不同的 Provider"></a>八中不同的 Provider</h3><ul>
<li>Provider</li>
<li><del>StateProvider</del> (被NotifierProvider代替)</li>
<li><del>StateNotifierProvider</del> (被NotifierProvider代替)</li>
<li>FutureProvider</li>
<li>StreamProvider</li>
<li><del>ChangeNotifierProvider</del> (被NotifierProvider代替)</li>
<li>NotifierProvider (Riverpod 2.0新增)</li>
<li>AsyncNotifierProvider (Riverpod 2.0新增)</li>
</ul>
<p>以后会提到使用<code>riverpod_generator</code>包中的<code>@riverpod</code>注解来代替我们的手动声明provider</p>
<h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p>上面示例中的代码就是用的这一个，更适合提供一些不会变的常量值，比如 Dio 实例、版本号、格式化对象、数据库对象等</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> dateFormatterProvider = Provider&lt;DateFormat&gt;((ref) &#123;<br>  <span class="hljs-keyword">return</span> DateFormat.MMMEd();<br>&#125;);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-comment">// retrieve the formatter</span><br>    <span class="hljs-keyword">final</span> formatter = ref.watch(dateFormatterProvider);<br>    <span class="hljs-comment">// use it</span><br>    <span class="hljs-keyword">return</span> Text(formatter.format(<span class="hljs-built_in">DateTime</span>.now()));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="StateProvider"><a href="#StateProvider" class="headerlink" title="StateProvider"></a>StateProvider</h4><p>可以用来存储一些简单的变量，比如计数器</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><br><span class="hljs-keyword">final</span> globalStateProvider = StateProvider((ref) =&gt; <span class="hljs-number">1</span>);<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateProviderDemoWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-comment">//不推荐</span><br>  <span class="hljs-keyword">final</span> localStateProvider = StateProvider((ref) =&gt; <span class="hljs-number">1</span>);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;StateProviderDemoWidget&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Center(<br>          child: Flex(<br>        direction: Axis.vertical,<br>        children: [<br>          Text(<span class="hljs-string">&quot;globalStateProvider count <span class="hljs-subst">$&#123;ref.watch(globalStateProvider)&#125;</span>&quot;</span>),<br>          Text(<span class="hljs-string">&quot;localStateProvider count <span class="hljs-subst">$&#123;ref.watch(localStateProvider)&#125;</span>&quot;</span>),<br>          Text(<br>            <span class="hljs-string">&quot;StateProvider.state标记为过时，并将在3.0移除&quot;</span>,<br>            style: TextStyle(color: Colors.red, fontSize: <span class="hljs-number">14</span>),<br>          ),<br>          Text(<span class="hljs-string">&quot;声明为全局，则状态一直被保存，直到应用重启。&quot;</span>,<br>              style: TextStyle(color: Colors.blue, fontSize: <span class="hljs-number">14</span>)),<br>          Text(<span class="hljs-string">&quot;声明为类成员，则页面重启则重新初始化。&quot;</span>,<br>              style: TextStyle(color: Colors.blue, fontSize: <span class="hljs-number">14</span>)),<br>          Text(<span class="hljs-string">&quot;StateProvider适用于存储简单的状态变量，如枚举、字符串、布尔值和数字&quot;</span>,<br>              style: TextStyle(color: Colors.blue, fontSize: <span class="hljs-number">14</span>)),<br>          IconButton(<br>            icon: Icon(Icons.plus_one_sharp),<br>            onPressed: () &#123;<br>              ref.read(globalStateProvider.notifier).state++;<br>              ref.read(localStateProvider.notifier).state++;<br>            &#125;,<br>          ),<br>        ],<br>      )),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这里有一些有意思的事情。我们声明了两个 Provider，一个是全局的，一个是类内部的。<br>当我们打开页面点击几次按钮之后，页面内容更新，这时候我们返回上一页再次打开这个页面，会发现<code>globalStateProvider</code>提供的值还是上一次返回时候的值，而<code>localStateProvider</code>提供的值是初始值。因为<code>localStateProvider</code>在页面关闭时就被销毁了，这种情况似乎更符合我们没有使用 riverpod 的习惯。这里可以使用 autoDispose 让<code>globalStateProvider</code>在所有 watcher 被销毁也可以重置。</p>
<h4 id="StateNotifierProvider"><a href="#StateNotifierProvider" class="headerlink" title="StateNotifierProvider"></a>StateNotifierProvider</h4><p>可以用它来监听和导出一个 <code>StateNotifier</code> ,<code>StateNotifierProvider</code> 和 <code>StateNotifier</code> 非常适合管理因事件或用户交互而改变的状态。这里有一个 <code>todolist</code>示例。<br>我们先定义一个 todo 的对象,实现一个 copyWith 方法来复制当前对象。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@immutable</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> Todo(<br>      &#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.description, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.completed&#125;);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> id;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> description;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> completed;<br>  Todo copyWith(&#123;<span class="hljs-built_in">String?</span> id, <span class="hljs-built_in">String?</span> description, <span class="hljs-built_in">bool?</span> completed&#125;) &#123;<br>    <span class="hljs-keyword">return</span> Todo(<br>      id: id ?? <span class="hljs-keyword">this</span>.id,<br>      description: description ?? <span class="hljs-keyword">this</span>.description,<br>      completed: completed ?? <span class="hljs-keyword">this</span>.completed,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们继承<code>StateNotifier</code>实现自己的<code>TodosNotifier</code>类，并完善所需逻辑</p>
<ol>
<li>统计已完成的待办</li>
<li>添加待办</li>
<li>删除待办</li>
<li>完成、取消完成待办</li>
<li>全选，反全选</li>
<li>是否选中全部</li>
</ol>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodosNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StateNotifier</span>&lt;<span class="hljs-title">List</span>&lt;<span class="hljs-title">Todo</span>&gt;&gt; </span>&#123;<br>  TodosNotifier() : <span class="hljs-keyword">super</span>([]);<br><br>  <span class="hljs-keyword">void</span> addTodo(Todo todo) &#123;<br>    state = [...state, todo];<br>  &#125;<br><br>  <span class="hljs-built_in">int</span> completedCount() &#123;<br>    <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state) &#123;<br>      <span class="hljs-keyword">if</span> (todo.completed) &#123;<br>        count++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> removeTodo(<span class="hljs-built_in">String</span> todoId) &#123;<br>    state = [<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state)<br>        <span class="hljs-keyword">if</span> (todo.id != todoId) todo,<br>    ];<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> toggle(<span class="hljs-built_in">String</span> todoID) &#123;<br>    state = [<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state)<br>        <span class="hljs-keyword">if</span> (todo.id == todoID)<br>          todo.copyWith(completed: !todo.completed)<br>        <span class="hljs-keyword">else</span><br>          todo<br>    ];<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> selectAll() &#123;<br>    state = [<span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state) todo.copyWith(completed: <span class="hljs-keyword">true</span>)];<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> unSelectAll() &#123;<br>    state = [<span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state) todo.copyWith(completed: <span class="hljs-keyword">false</span>)];<br>  &#125;<br><br>  <span class="hljs-built_in">bool</span> isSelectAll() &#123;<br>    <span class="hljs-built_in">bool</span> result = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> state) &#123;<br>      <span class="hljs-keyword">if</span> (!todo.completed) &#123;<br>        result = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着声明一个全局的<code>StateNotifierProvider</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> todoProvider =<br>    StateNotifierProvider&lt;TodosNotifier, <span class="hljs-built_in">List</span>&lt;Todo&gt;&gt;((ref) =&gt; TodosNotifier());<br></code></pre></td></tr></table></figure>
<p>最后我们就可以在页面中使用了</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateNotifierProviderWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-built_in">List</span>&lt;Todo&gt; todos = ref.watch(todoProvider);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;State Notifier Provider Widget&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Column(<br>        children: [<br>          Text(<span class="hljs-string">&quot;StateNotifierProvider和StateNotifier非常适合管理可能会因事件或用户交互而发生变化的状态。&quot;</span>),<br>          Text(<span class="hljs-string">&quot;注意StateNotifier中通知更新时是比较的对象内存地址&quot;</span>),<br>          Divider(),<br>          Container(<br>            child: Text(<br>                <span class="hljs-string">&quot;共<span class="hljs-subst">$&#123;todos.length.toString()&#125;</span>,完成-》<span class="hljs-subst">$&#123;ref.read(todoProvider.notifier).completedCount()&#125;</span>&quot;</span>),<br>          ),<br>          CheckboxListTile(<br>            value: ref.read(todoProvider.notifier).isSelectAll(),<br>            onChanged: (value) &#123;<br>              <span class="hljs-keyword">if</span> (value ?? <span class="hljs-keyword">false</span>) &#123;<br>                ref.read(todoProvider.notifier).selectAll();<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                ref.read(todoProvider.notifier).unSelectAll();<br>              &#125;<br>            &#125;,<br>            title: Text(<span class="hljs-string">&quot;全选&quot;</span>),<br>          ),<br>          Expanded(<br>              child: ListView(<br>            shrinkWrap: <span class="hljs-keyword">true</span>,<br>            children: [<br>              <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> todo <span class="hljs-keyword">in</span> todos)<br>                Dismissible(<br>                  key: Key(todo.id),<br>                  child: CheckboxListTile(<br>                    value: todo.completed,<br>                    onChanged: (value) =&gt;<br>                        ref.read(todoProvider.notifier).toggle(todo.id),<br>                    title: Text(todo.description),<br>                  ),<br>                  onDismissed: (direction) =&gt;<br>                      &#123;ref.read(todoProvider.notifier).removeTodo(todo.id)&#125;,<br>                ),<br>            ],<br>          )),<br>        ],<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        child: <span class="hljs-keyword">const</span> Icon(Icons.add),<br>        onPressed: () &#123;<br>          <span class="hljs-keyword">final</span> notifier = ref.read(todoProvider.notifier);<br>          notifier.addTodo(Todo(<br>              id: <span class="hljs-built_in">DateTime</span>.now().microsecond.toString(),<br>              description: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;DateTime.now().microsecondsSinceEpoch&#125;</span>&quot;</span>,<br>              completed: <span class="hljs-keyword">false</span>));<br>        &#125;,<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这样我们就完成了一个简易版的待办页面</p>
<p><img src="/image/riverpod/state_notifier_demo.png" alt="state_notifier_demo"></p>
<h4 id="FutureProvider"><a href="#FutureProvider" class="headerlink" title="FutureProvider"></a>FutureProvider</h4><p>我们经常会遇到一些耗时操作，比如请求服务器接口获取到数据后展示在页面上；比如读取配置文件等。这种情况我们就需要 <code>FutureProvider</code>了。<br>这里以读取 assets 中的配置文件为例:<br>首先声明一个<code>FutureProvider</code>泛型中填入返回值，使用<code>rootBundle.loadString</code>来读取资源文件的内容。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> getConfigFutureProvider =<br>    FutureProvider&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&gt;((ref) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-built_in">String</span> configContant =<br>      <span class="hljs-keyword">await</span> rootBundle.loadString(<span class="hljs-string">&quot;assets/fake_configurations.json&quot;</span>);<br>  <span class="hljs-keyword">final</span> configMap = jsonDecode(configContant) <span class="hljs-keyword">as</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;;<br>  <span class="hljs-keyword">return</span> configMap;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>然后再声明一个用来模拟请求服务端的<code>FutureProvider</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> wordPairProvider = FutureProvider&lt;<span class="hljs-built_in">String</span>&gt;((ref)  <span class="hljs-keyword">async</span>&#123;<br>  <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>  <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">2</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span> - <span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>注意这里的<code>generateWordPairs</code>是三方包<code>english_words: ^4.0.0</code>提供的。在<code>wordPairProvider</code>中我们延迟 2 秒返回了结果，用以模拟网络耗时。<br>在页面中我们可以这么使用:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FutureProviderWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> AsyncValue&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&gt; getConfigResult =<br>        ref.watch(getConfigFutureProvider);<br>    <span class="hljs-keyword">final</span> AsyncValue&lt;<span class="hljs-built_in">String</span>&gt; wordPairResult = ref.watch(wordPairProvider);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;FutureProvider&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: RefreshIndicator(<br>        onRefresh: () =&gt; ref.refresh(wordPairProvider.future),<br>        child: ListView(<br>          children: [<br>            getConfigResult.when(<br>                data: (data) &#123;<br>                  <span class="hljs-keyword">return</span> Text(data.toString());<br>                &#125;,<br>                error: (error, stack) &#123;<br>                  <span class="hljs-keyword">return</span> Text(error.toString());<br>                &#125;,<br>                loading: () =&gt; <span class="hljs-keyword">const</span> CircularProgressIndicator()),<br>            wordPairResult.when(data: (data) &#123;<br>              <span class="hljs-keyword">return</span> Text(data);<br>            &#125;, error: (error, stack) &#123;<br>              <span class="hljs-keyword">return</span> ElevatedButton(<br>                  onPressed: () &#123;<br>                    ref.refresh(wordPairProvider.future);<br>                  &#125;,<br>                  child: Text(<span class="hljs-string">&quot;点击刷新&quot;</span>));<br>            &#125;, loading: () &#123;<br>              <span class="hljs-keyword">return</span> CircularProgressIndicator();<br>            &#125;),<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>注意，<code>ref.watch(FutureProvider)</code>的返回值是AsyncValue类型，我们可以使用模式匹配的方式来更新UI。这里会有三个状态:data,loading,error。<br>我们在页面上添加了一个下拉刷新的控价来刷新模拟网络请求的 provider:<code>ref.refresh(wordPairProvider.future)</code>。</p>
<ul>
<li>FutureProvider功能非常强大，可以用它来</li>
<li>执行和缓存异步操作（如网络请求）</li>
<li>处理异步操作的错误和加载状态</li>
<li>将多个异步值合并为另一个值</li>
<li>重新获取和刷新数据（适用于拉到刷新操作）<br>如果退出页面需要重新进行刷新，我们可以配合autoDispose使用:<code>FutureProvider.autoDispose&lt;String&gt;((ref) async &#123;&#125;</code></li>
</ul>
<h4 id="StreamProvider"><a href="#StreamProvider" class="headerlink" title="StreamProvider"></a>StreamProvider</h4><p>这里例子不大好写，它和 FutureProvider 类似，被 watch 时返回的也是 AsyncValue 类型，这里是一个计时器的示例。<br>同样的，先声明一个<code>StreamProvider</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> streamProvider = StreamProvider.autoDispose&lt;<span class="hljs-built_in">int</span>&gt;((ref) &#123;<br>    ref.onDispose(() &#123;<br>      debugPrint(<span class="hljs-string">&quot;streamProvider autoDispose&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> Stream.periodic(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>), (number) &#123;<br>      <span class="hljs-keyword">return</span> number + <span class="hljs-number">1</span>;<br>    &#125;);<br>  &#125;);<br><br></code></pre></td></tr></table></figure>
<p>然后在页面中使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamProviderWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> AsyncValue&lt;<span class="hljs-built_in">int</span>&gt; streamResult = ref.watch(streamProvider);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;StreamProviderWidget&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Column(<br>        children: [<br>          Text(streamResult.toString()),<br>          streamResult.when(<br>                  data: (data) &#123;<br>                    <span class="hljs-keyword">return</span> Text(data.toString());<br>                  &#125;,<br>                  error: (error, stack) &#123;<br>                    <span class="hljs-keyword">return</span> Text(error.toString());<br>                  &#125;,<br>                  loading: () =&gt; CircularProgressIndicator())<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="ChangeNotifierProvider"><a href="#ChangeNotifierProvider" class="headerlink" title="ChangeNotifierProvider"></a>ChangeNotifierProvider</h4><p>建议使用 NotifierProvider 代替。<br>这里是一个计数器示例。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChangeNotifier</span> </span>&#123;<br>  <span class="hljs-built_in">int</span> _count = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> count =&gt; _count;<br>  <span class="hljs-keyword">void</span> increment() &#123;<br>    _count++;<br>    notifyListeners(); <span class="hljs-comment">// 当计数器值改变时通知所有监听者</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义ChangeNotifierProvider</span><br><span class="hljs-keyword">final</span> counterProvider = ChangeNotifierProvider&lt;CounterNotifier&gt;((ref) &#123;<br>  <span class="hljs-keyword">return</span> CounterNotifier();<br>&#125;);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangeNotifierProviderWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">return</span>  Scaffold(<br>        appBar: AppBar(title: Text(<span class="hljs-string">&#x27;ChangeNotifierProviderWidget&#x27;</span>)),<br>        body: Center(<br>          child: Consumer(builder: (context, ref, _) &#123; <span class="hljs-comment">// 使用Consumer读取并显示状态</span><br>            <span class="hljs-keyword">final</span> counter = ref.watch(counterProvider);<br>            <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&#x27;Count: <span class="hljs-subst">$&#123;counter.count&#125;</span>&#x27;</span>);<br>          &#125;),<br>        ),<br>        floatingActionButton: FloatingActionButton(<br>          onPressed: () &#123;<br>            <span class="hljs-comment">// 在点击按钮时，通过ref调用notifier的方法更新状态</span><br>            ref.read(counterProvider.notifier).increment();<br>          &#125;,<br>          child: Icon(Icons.add),<br>        ),<br>      );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="NotifierProvider"><a href="#NotifierProvider" class="headerlink" title="NotifierProvider"></a>NotifierProvider</h4><p>用来代替 StateProvider 和 ChangeNotifierProvider。<br>同样的，我们先定义一个数据类 Student</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  Student(&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.name, <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id&#125;);<br>  <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-built_in">String</span> id;<br><br>  Student copyWith(&#123;<span class="hljs-built_in">String?</span> copyID, <span class="hljs-built_in">String?</span> copyName&#125;) &#123;<br>    <span class="hljs-keyword">return</span> Student(name: copyName ?? <span class="hljs-keyword">this</span>.name, id: copyID ?? <span class="hljs-keyword">this</span>.id);<br>  &#125;<br>  <span class="hljs-built_in">String</span> toString()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$id</span> : <span class="hljs-subst">$name</span>&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>定义一个继承自 Notifier 的类</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Notifier</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Student build() &#123;<br>    <span class="hljs-keyword">return</span> generateStudent();<br>  &#125;<br><br>  Student generateStudent() &#123;<br>    <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>    <span class="hljs-keyword">final</span> id = Random().nextInt(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">return</span> Student(<br>        name: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span> - <span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>, id: id.toString());<br>  &#125;<br><br>  <span class="hljs-built_in">String</span> toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;state.id&#125;</span> : <span class="hljs-subst">$&#123;state.name&#125;</span>&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> change() &#123;<br>    state = generateStudent();<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> changeNameWithCopy(<span class="hljs-built_in">String</span> name) &#123;<br>    state = state.copyWith(copyName: name);<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> justChangeName(<span class="hljs-built_in">String</span> name) &#123;<br>    state.name = name;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> changeIdWithCopy(<span class="hljs-built_in">String</span> id) &#123;<br>    state = state.copyWith(copyID: id);<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> justChangeId(<span class="hljs-built_in">String</span> id) &#123;<br>    state.id = id;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意，这里的 build 方法是必须的。同时为了解释刷新页面的条件，这里定义了几个改变属性的方法。xxxWithCopy是重新生成了对象，justxxx 则是在原对象上直接修改属性值。<br>然后声明<code>NotifierProvider</code>,这里提供了两种方式，哪一种都可以。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterProvider = NotifierProvider&lt;StudentNotifier, Student&gt;(() &#123;<br>  <span class="hljs-keyword">return</span> StudentNotifier();<br>&#125;);<br><span class="hljs-keyword">final</span> counterProviderOther =<br>    NotifierProvider&lt;StudentNotifier, Student&gt;(StudentNotifier.<span class="hljs-keyword">new</span>);<br></code></pre></td></tr></table></figure>

<p>在页面中我们这样使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterNotifierWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> student = ref.watch(counterProvider);<br>    ref.listen(counterProvider, (oldValue, newValue) &#123;<br>      logger.d(<br>          <span class="hljs-string">&quot;oldValue--&gt; <span class="hljs-subst">$&#123;oldValue?.id.toString()&#125;</span> \n newValue--&gt; <span class="hljs-subst">$&#123;newValue.id&#125;</span>&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;CounterNotifierWidget&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Column(<br>        children: [<br>          Text(<span class="hljs-string">&quot;student <span class="hljs-subst">$&#123;student.id.toString()&#125;</span> : <span class="hljs-subst">$&#123;student.name&#125;</span>  --&gt; <span class="hljs-subst">$&#123;student.toString()&#125;</span>&quot;</span>),<br><br>          ElevatedButton(<br>              onPressed: () &#123;<br>                ref<br>                    .read(counterProvider.notifier)<br>                    .changeIdWithCopy(Random().nextInt(<span class="hljs-number">100</span>).toString());<br>              &#125;,<br>              child: Text(<span class="hljs-string">&quot;changeIdWithCopy&quot;</span>)),<br>          ElevatedButton(<br>              onPressed: () &#123;<br>                <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>                ref.read(counterProvider.notifier).changeNameWithCopy(<br>                    <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span> - -<span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>);<br>              &#125;,<br>              child: Text(<span class="hljs-string">&quot;changeNameWithCopy&quot;</span>)),<br><br>          ElevatedButton(<br>              onPressed: () &#123;<br>                ref<br>                    .read(counterProvider.notifier)<br>                    .justChangeId(Random().nextInt(<span class="hljs-number">100</span>).toString());<br>              &#125;,<br>              child: Text(<span class="hljs-string">&quot;justChangeId&quot;</span>)),<br>          ElevatedButton(<br>              onPressed: () &#123;<br>                <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>                ref<br>                    .read(counterProvider.notifier)<br>                    .justChangeName(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span> - -<span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>);<br>              &#125;,<br>              child: Text(<span class="hljs-string">&quot;justChangeName&quot;</span>)),<br>        ],<br>      ),<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () &#123;<br>          ref.read(counterProvider.notifier).change();<br>        &#125;,<br>        child: Icon(Icons.change_circle),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行之后可以看到，只有当我们调用<code>xxxwithCopy</code>时才会刷新页面。戳到<code>NotifierProviderElement</code>源码中查看<code>updateShouldNotify</code>方法，发现是调用的identical(previous, next)方法来做判断的。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@protected</span><br><span class="hljs-built_in">bool</span> updateShouldNotify(State previous, State next) &#123;<br>  <span class="hljs-keyword">return</span> !identical(previous, next);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="AsyncNotifierProvider"><a href="#AsyncNotifierProvider" class="headerlink" title="AsyncNotifierProvider"></a>AsyncNotifierProvider</h4><p>相比<code>NotifierProvider</code>,它是异步而已.<br>还是先声明一个数据类Student</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span>&#123;<br>  Student(&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.name,<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.id&#125;);<br>  <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-built_in">String</span> id;<br><br>  <span class="hljs-built_in">String</span> toString()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$id</span> - <span class="hljs-subst">$name</span>&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>声明一个继承自AsyncNotifier的类</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentAsyncNotifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AsyncNotifier</span>&lt;<span class="hljs-title">Student</span>&gt;</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  FutureOr&lt;Student&gt; build() <span class="hljs-keyword">async</span> &#123;<br><br>      <span class="hljs-keyword">return</span> getInfo();<br>  &#125;<br><br> Future&lt;Student&gt; getInfo()<span class="hljs-keyword">async</span>&#123;<br>    <br>    <span class="hljs-keyword">await</span>  Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>    <span class="hljs-keyword">return</span> Student(name: <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span> - <span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>, id: Random().nextInt(<span class="hljs-number">100</span>).toString());<br>    <br>  &#125; <br><br>  Future&lt;<span class="hljs-keyword">void</span>&gt; refresh() <span class="hljs-keyword">async</span>&#123;<br>      state = AsyncValue.loading();<br>      state = <span class="hljs-keyword">await</span> AsyncValue.guard(()<span class="hljs-keyword">async</span> &#123;<br>        <span class="hljs-keyword">return</span> getInfo();<br>      &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>声明一个 Provider</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> studentAsyncNotifier = AsyncNotifierProvider&lt;StudentAsyncNotifier, Student&gt;(() &#123;<br>  <span class="hljs-keyword">return</span> StudentAsyncNotifier();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>在页面中使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncNotifierProviderWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br><br>    <span class="hljs-keyword">final</span> asyncValue = ref.watch(studentAsyncNotifier);<br><br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(title: Text(<span class="hljs-string">&quot;AsyncNotifierProviderWidget&quot;</span>),centerTitle: <span class="hljs-keyword">false</span>,),<br>      body: asyncValue.when(data: (data)&#123;<br>       <span class="hljs-keyword">return</span> Center(child: Text(data .toString()),);<br>      &#125;, error: (error,stack)&#123;<br>       <span class="hljs-keyword">return</span> Center(child: Text(error.toString()),);<br>      &#125;, loading: ()&#123;<br>        <span class="hljs-keyword">return</span> Center(child: CircularProgressIndicator());<br>      &#125;),<br>      floatingActionButton: FloatingActionButton(onPressed: ()&#123;<br>        ref.read(studentAsyncNotifier.notifier).refresh();<br>      &#125;,child: Icon(Icons.refresh),),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里需要注意的是：使用AsyncNotifier与autoDispose的正确方式是继承 AutoDisposeAsyncNotifier类而不是使用 autoDispose 修饰符。</p>
<p>以上就是 riverpod 中常见的 Provider 的用法示例，后面会介绍一些修饰符、注解相关的信息。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>riverpod</tag>
      </tags>
  </entry>
  <entry>
    <title>riverpod2中的修饰符及注解</title>
    <url>/2024/03/27/riverpod2%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>原文来自：<a href="https://codewithandrea.com/articles/flutter-state-management-riverpod/">https://codewithandrea.com/articles/flutter-state-management-riverpod/</a></p>
<h3 id="监听、观察、选择、记录、重建"><a href="#监听、观察、选择、记录、重建" class="headerlink" title="监听、观察、选择、记录、重建"></a>监听、观察、选择、记录、重建</h3><h4 id="ref-read-or-ref-watch"><a href="#ref-read-or-ref-watch" class="headerlink" title="ref.read or ref.watch"></a>ref.read or ref.watch</h4><p>在上一篇中，我们使用了 ref.read和 ref.watch，那么这两者在什么情况下使用？<br>一般来讲，如果需要在Provider 值发生改变时更新依赖它的 widget，就使用 watch。比如 我们在 build 函数中使用watch,这确保了如果提供者的值发生更改，我们会重建依赖它的widget.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterStateProvider = StateProvider&lt;<span class="hljs-built_in">int</span>&gt;((_) =&gt; <span class="hljs-number">0</span>);<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>    <span class="hljs-meta">@override</span><br>    Widget build(BuildContext context, WidgetRef ref) &#123;<br>      <span class="hljs-comment">// 1. watch the provider and rebuild when the value changes</span><br>      <span class="hljs-keyword">final</span> counter = ref.watch(counterStateProvider);<br>      <span class="hljs-keyword">return</span> ElevatedButton(<br>        <span class="hljs-comment">// 2. use the value</span><br>        child: Text(<span class="hljs-string">&#x27;Value: <span class="hljs-subst">$counter</span>&#x27;</span>),<br>        <span class="hljs-comment">// 3. change the state inside a button callback</span><br>        onPressed: () =&gt; ref.read(counterStateProvider.notifier).state++,<br>      );<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>如果我们只是读取到 Provider 的值做操作，一般使用 read，比如上面点击 ElevatedButton 时我们获取到 notifier 之后对count 做了++操作<br>需要注意的是：notifier语法仅适用于StateProvider和StateNotifierProvider，其工作方式如下：</p>
<ul>
<li>在StateProvider上调用ref.read(provider.notifier)，以返回底层的StateController，我们可以使用它来修改状态。</li>
<li>在StateNotifierProvider上调用ref.read(provider.notifier)，以返回底层的StateNotifier，以便我们可以调用其方法。</li>
</ul>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>我们有时候也会遇到这种需求：一个对象有多个属性，希望只有特定属性发生变化时才更新页面，这时候我们就可以使用 select 来完成</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>  Student(<span class="hljs-keyword">this</span>.firstName, <span class="hljs-keyword">this</span>.lastName, <span class="hljs-keyword">this</span>.age);<br><br>  <span class="hljs-built_in">String</span> firstName;<br>  <span class="hljs-built_in">String</span> lastName;<br>  <span class="hljs-built_in">int</span> age;<br>  Student copy() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student(firstName, lastName, age);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们只需要在年龄发生改变时更新页面</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> age = ref.watch( provider.select((value) =&gt; value.age) );<br>    <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&quot;<span class="hljs-subst">$age</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><p>除此之外，我们还有 listen， 比如我们希望在 Provider 内容发生变化时弹出一个 SnakeBar提示用户，我们可以这样做:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterStateProvider = StateProvider&lt;<span class="hljs-built_in">int</span>&gt;((_) =&gt; <span class="hljs-number">0</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CounterWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-comment">// if we use a StateProvider&lt;T&gt;, the type of the previous and current </span><br>    <span class="hljs-comment">// values is StateController&lt;T&gt;</span><br>    ref.listen&lt;StateController&lt;<span class="hljs-built_in">int</span>&gt;&gt;(counterStateProvider.state, (previous, current) &#123;<br>      <span class="hljs-comment">// note: this callback executes when the provider value changes,</span><br>      <span class="hljs-comment">// not when the build method is called</span><br>      ScaffoldMessenger.of(context).showSnackBar(<br>        SnackBar(content: Text(<span class="hljs-string">&#x27;Value is <span class="hljs-subst">$&#123;current.state&#125;</span>&#x27;</span>)),<br>      );<br>    &#125;);<br>    <span class="hljs-comment">// watch the provider and rebuild when the value changes</span><br>    <span class="hljs-keyword">final</span> counter = ref.watch(counterStateProvider);<br>    <span class="hljs-keyword">return</span> ElevatedButton(<br>      <span class="hljs-comment">// use the value</span><br>      child: Text(<span class="hljs-string">&#x27;Value: <span class="hljs-subst">$counter</span>&#x27;</span>),<br>      <span class="hljs-comment">// change the state inside a button callback</span><br>      onPressed: () =&gt; ref.read(counterStateProvider.notifier).state++,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>我们需要在 Provider 内容发生改变时打印日志，以方便我们进行调试，但又不想在每个 Provider 中都加上打印代码，应该怎么办？<br>在 Rivepod 中有一个ProviderObserver类，我们可以继承它实现自己的逻辑</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderLogger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProviderObserver</span> </span>&#123;<br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-keyword">void</span> didUpdateProvider(<br>      ProviderBase provider,<br>      <span class="hljs-built_in">Object?</span> previousValue,<br>      <span class="hljs-built_in">Object?</span> newValue,<br>      ProviderContainer container,<br>    ) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[<span class="hljs-subst">$&#123;provider.name ?? provider.runtimeType&#125;</span>] value: <span class="hljs-subst">$newValue</span>&#x27;</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>同样的，需要将它添加到 ProviderScope内的观察者列表中</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>    runApp(<br>      ProviderScope(observers: [ProviderLogger()], child: MyApp()),<br>    );<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>为了方便我们区分是哪一个 Provider 的日志，我们在声明 Provider 时可以提供一个名字</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterStateProvider = StateProvider&lt;<span class="hljs-built_in">int</span>&gt;((ref) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;, name: <span class="hljs-string">&#x27;main_page_counter&#x27;</span>);<br></code></pre></td></tr></table></figure>




<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><h4 id="autoDispose"><a href="#autoDispose" class="headerlink" title="autoDispose"></a>autoDispose</h4><p>上一篇中提到Riverpod 作者强烈建议将 Provider 声明为全局的而不是类内部，这样有一个问题，页面销毁时也就是provider没有任何监听者时并不会被重置。再次进入页面后还是页面销毁之前的值，比如 StateProvider 实现的计数功能。当我们在页面中点击加号，将数字变为 5 后，返回上一个页面后再次打开该页面，会发现页面还是 5。这有时不符合我们的需求，这里我们可以使用autoDispose来实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> autoDisposeProvider = StateProvider.autoDispose&lt;<span class="hljs-built_in">int</span>&gt;(((ref) &#123;<br>  ref.onDispose(() &#123;<br>    debugPrint(<span class="hljs-string">&quot;countProvider onDispose&quot;</span>);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;));<br><br><span class="hljs-keyword">final</span> countProvider = StateProvider&lt;<span class="hljs-built_in">int</span>&gt;((ref) =&gt; <span class="hljs-number">1</span>);<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RiverpodAutoDisposeWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> autoDisposeValue = ref.watch(autoDisposeProvider);<br>    <span class="hljs-keyword">final</span> normalValue = ref.watch(countProvider);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;AutoDispose&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Column(children: [<br>        Text(<span class="hljs-string">&quot;autoDispose:当privder不被使用时，可以被自动释放&quot;</span>),<br>        Text(<span class="hljs-string">&quot;autoDisposeValue-&gt; <span class="hljs-subst">$&#123;autoDisposeValue&#125;</span>&quot;</span>),<br>        Text(<span class="hljs-string">&quot;normalValue-&gt; <span class="hljs-subst">$&#123;normalValue&#125;</span>&quot;</span>),<br>        Row(<br>          children: [<br>            ElevatedButton(<br>                onPressed: (() &#123;<br>                  ref.read(autoDisposeProvider.notifier).state++;<br>                  ref.read(countProvider.notifier).state++;<br>                &#125;),<br>                child: Text(<span class="hljs-string">&quot;增加计数&quot;</span>))<br>          ],<br>        )<br>      ]),<br>    );<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>可以看到当页面被销毁时，被autoDispose修饰的 provider 会被释放并重置。这里的 ref.onDispose会在没有监听者之后调用。</p>
<h4 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h4><p>我们可以使用 ref.keepAlive实现超时缓存。<br>简单粗暴点就是这样：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> tmpProvider = StateProvider.autoDispose&lt;<span class="hljs-built_in">int</span>&gt;((ref)&#123;<br><br>    <span class="hljs-comment">// get the [KeepAliveLink]</span><br>    <span class="hljs-keyword">final</span> link = ref.keepAlive();<br>    <span class="hljs-comment">// start a 30 second timer</span><br>    <span class="hljs-keyword">final</span> timer = Timer(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">30</span>), () &#123;<br>      <span class="hljs-comment">// dispose on timeout</span><br>      link.close();<br>    &#125;);<br>    <span class="hljs-comment">// make sure to cancel the timer when the provider state is disposed</span><br>    <span class="hljs-comment">// (prevents undesired test failures)</span><br>    ref.onDispose(() =&gt; timer.cancel());<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;);<br><br></code></pre></td></tr></table></figure>
<p>我们可以使用<code>extension</code>封装一下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">extension</span> AutoDisposeRefCache <span class="hljs-keyword">on</span> AutoDisposeRef &#123;<br>  <span class="hljs-keyword">void</span> cacheFor(<span class="hljs-built_in">Duration</span> duration) &#123;<br>    <span class="hljs-keyword">final</span> link = keepAlive();<br>    <span class="hljs-keyword">final</span> timer = Timer(duration, () &#123;<br>      link.close();<br>    &#125;);<br>    onDispose(() &#123;<br>      timer.cancel();<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//使用</span><br><span class="hljs-keyword">final</span> timerCachedProvider = Provider.autoDispose&lt;<span class="hljs-built_in">int</span>&gt;((ref) &#123;<br>  ref.cacheFor(<span class="hljs-built_in">Duration</span>(minutes: <span class="hljs-number">5</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="family"><a href="#family" class="headerlink" title="family"></a>family</h4><p>我们可以用它向 Provider 提供参数，比如我们的计数器示例，比如想从指定的数字开始</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> countProviderBase = StateProvider.autoDispose.family&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>&gt; ((ref,start)&#123;<br>  <span class="hljs-keyword">return</span> start;<br>&#125;);<br><span class="hljs-comment">//使用</span><br><span class="hljs-keyword">final</span> startValue =  ref.watch(countProviderBase(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure>

<h4 id="依赖覆盖"><a href="#依赖覆盖" class="headerlink" title="依赖覆盖"></a>依赖覆盖</h4><p>有时候我们希望使用 Provider 存储无法立即获取的对象或者值，比如做本地存储时用的<code>shared_preferences</code>。但是它的初始化是异步的，如果我们直接在 Provider 中使用则会提示</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> spProvider = Provider&lt;SharedPreferences&gt;((ref) &#123;<br>  <span class="hljs-keyword">return</span> SharedPreferences.getInstance();<span class="hljs-comment">//不可以这样使用</span><br>  <span class="hljs-comment">//The return type &#x27;Future&lt;SharedPreferences&gt;&#x27; isn&#x27;t a &#x27;SharedPreferences&#x27;, as required by the closure&#x27;s context.</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<p>这时候我们可以先抛出一个为实现的异常</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> sharedPreferencesProvider = Provider&lt;SharedPreferences&gt;((ref) &#123;<br>    <span class="hljs-keyword">throw</span> UnimplementedError();<br>  &#125;);<br></code></pre></td></tr></table></figure>
<p>然后我们可以在 ProviderScope 组件中进行依赖覆盖</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Future&lt;<span class="hljs-keyword">void</span>&gt; main() <span class="hljs-keyword">async</span> &#123;<br>  WidgetsFlutterBinding.ensureInitialized();<br>  <span class="hljs-keyword">final</span> sharedPreferences = <span class="hljs-keyword">await</span> SharedPreferences.getInstance();<br>  runApp(ProviderScope(<br>    overrides: [<br>      <span class="hljs-comment">// override the previous value with the new object</span><br>      sharedPreferencesProvider.overrideWithValue(sharedPreferences),<br>    ],<br>    child: MyApp(),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样我们就可以在任何地方观察sharedPreferencesProvider对象，而无需使用基于Future的API</p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>我们在使用 Provider 时都需要手动编写，我们是否可以使用 build_runner生成？Riverpod 中已经提供了这种方式，但当前只支持以下几种</p>
<ul>
<li>Provider</li>
<li>FutureProvider</li>
<li>StreamProvider</li>
<li>NotifierProvider</li>
<li>AsyncNotifierProvider</li>
</ul>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-comment"># or flutter_riverpod/hooks_riverpod as per https://riverpod.dev/docs/getting_started</span><br>  <span class="hljs-attr">riverpod:</span> <span class="hljs-string">^2.4.10</span><br>  <span class="hljs-comment"># the annotation package containing @riverpod</span><br>  <span class="hljs-attr">riverpod_annotation:</span> <span class="hljs-string">^2.3.4</span><br><span class="hljs-attr">dev_dependencies:</span><br>  <span class="hljs-comment"># a tool for running code generators</span><br>  <span class="hljs-attr">build_runner:</span><br>  <span class="hljs-comment"># the code generator</span><br>  <span class="hljs-attr">riverpod_generator:</span> <span class="hljs-string">^2.3.9</span><br>  <span class="hljs-comment"># riverpod_lint makes it easier to work with Riverpod</span><br>  <span class="hljs-attr">riverpod_lint:</span> <span class="hljs-string">^2.3.7</span><br>  <span class="hljs-comment"># import custom_lint too as riverpod_lint depends on it</span><br>  <span class="hljs-attr">custom_lint:</span><br></code></pre></td></tr></table></figure>
<p>其中<code>riverpod_lint</code>和<code>custom_lint</code>这两个包是可选的。<br>之后我们需要在<code>watch</code>模式下启动代码生成器<br><code>flutter pub run build_runner watch -d</code>,较新的flutter版本会提示使用<code>dart run build_runner watch -d</code>。</p>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>我们来看个简单的示例，从 Provider 开始<br>没有使用注解生成器之前：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// dio_provider.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/dio.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><span class="hljs-comment">// a provider for the Dio client to be used by the rest of the app</span><br><span class="hljs-keyword">final</span> dioProvider = Provider&lt;Dio&gt;((ref) &#123;<br>  <span class="hljs-keyword">return</span> Dio();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>使用注解生成器之后</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:dio/dio.dart&#x27;</span>;<br><span class="hljs-comment">// 1. import the riverpod_annotation package</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:riverpod_annotation/riverpod_annotation.dart&#x27;</span>;<br><span class="hljs-comment">// 2. add a part file</span><br><span class="hljs-keyword">part</span> <span class="hljs-string">&#x27;dio_provider.g.dart&#x27;</span>;<br><br><br><span class="hljs-comment">//需要执行 flutter pub run build_runner watch -d 来生成对应代码</span><br><span class="hljs-meta">@riverpod</span><br>Dio dio(DioRef ref)&#123;<br>  <span class="hljs-keyword">return</span> Dio();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>会生成<code>dio_provider.g.dart</code>文件，内容如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// GENERATED CODE - DO NOT MODIFY BY HAND</span><br><br><span class="hljs-keyword">part</span> of <span class="hljs-string">&#x27;dio_provider.dart&#x27;</span>;<br><br><span class="hljs-comment">// **************************************************************************</span><br><span class="hljs-comment">// RiverpodGenerator</span><br><span class="hljs-comment">// **************************************************************************</span><br><br><span class="hljs-built_in">String</span> _$dioHash() =&gt; <span class="hljs-string">r&#x27;58eeefbd0832498ca2574c1fe69ed783c58d1d8f&#x27;</span>;<br><br><span class="hljs-comment">/// <span class="language-markdown">See also [dio].</span></span><br><span class="hljs-meta">@ProviderFor</span>(dio)<br><span class="hljs-keyword">final</span> dioProvider = AutoDisposeProvider&lt;Dio&gt;.internal(<br>  dio,<br>  name: <span class="hljs-string">r&#x27;dioProvider&#x27;</span>,<br>  debugGetCreateSourceHash:<br>      <span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">&#x27;dart.vm.product&#x27;</span>) ? <span class="hljs-keyword">null</span> : _$dioHash,<br>  dependencies: <span class="hljs-keyword">null</span>,<br>  allTransitiveDependencies: <span class="hljs-keyword">null</span>,<br>);<br><br><span class="hljs-keyword">typedef</span> DioRef = AutoDisposeProviderRef&lt;Dio&gt;;<br><span class="hljs-comment">// ignore_for_file: type=lint</span><br><span class="hljs-comment">// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member</span><br><br></code></pre></td></tr></table></figure>

<h4 id="autoDispose和-keepAlive"><a href="#autoDispose和-keepAlive" class="headerlink" title="autoDispose和 keepAlive"></a>autoDispose和 keepAlive</h4><p>在使用注解生成代码时，autoDispose 现在默认启用，并已重命名为 keepAlive。如果不想销毁 provider，可以将keepAlive设置为 true</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Riverpod</span>(keepAlive: <span class="hljs-keyword">true</span>)<br><span class="hljs-built_in">int</span> counter(CounterRef ref)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>生成的代码是这样的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> _$counterHash() =&gt; <span class="hljs-string">r&#x27;6b26baf29ab7c65258c6367ad62133458d88a2b3&#x27;</span>;<br><br><span class="hljs-comment">/// <span class="language-markdown">See also [counter].</span></span><br><span class="hljs-meta">@ProviderFor</span>(counter)<br><span class="hljs-keyword">final</span> counterProvider = Provider&lt;<span class="hljs-built_in">int</span>&gt;.internal(<br>  counter,<br>  name: <span class="hljs-string">r&#x27;counterProvider&#x27;</span>,<br>  debugGetCreateSourceHash:<br>      <span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">&#x27;dart.vm.product&#x27;</span>) ? <span class="hljs-keyword">null</span> : _$counterHash,<br>  dependencies: <span class="hljs-keyword">null</span>,<br>  allTransitiveDependencies: <span class="hljs-keyword">null</span>,<br>);<br><br><span class="hljs-keyword">typedef</span> CounterRef = ProviderRef&lt;<span class="hljs-built_in">int</span>&gt;;<br><span class="hljs-comment">// ignore_for_file: type=lint</span><br><span class="hljs-comment">// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member</span><br><br></code></pre></td></tr></table></figure>
<p>可以看到，当 keepAlive 是默认值(true)时，使用的是<code>AutoDisposeProvider</code>,为 false 时，使用的是<code>Provider</code></p>
<h4 id="FutureProvider-和-StreamProvider"><a href="#FutureProvider-和-StreamProvider" class="headerlink" title="FutureProvider 和 StreamProvider"></a>FutureProvider 和 StreamProvider</h4><p>几乎是一样的写法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@riverpod</span><br>Future&lt;<span class="hljs-built_in">String</span>&gt; generateName(GenerateNameRef ref) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">5</span>));<br>    <span class="hljs-keyword">final</span> wordPair = generateWordPairs().first;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wordPair.first&#125;</span>  <span class="hljs-subst">$&#123;wordPair.second&#125;</span>&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@riverpod</span><br>Stream&lt;<span class="hljs-built_in">int</span>&gt; timeCount(TimeCountRef ref)&#123;<br>  <span class="hljs-keyword">return</span> Stream.periodic(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">1</span>),(number)&#123;<br>    <span class="hljs-keyword">return</span> number +<span class="hljs-number">1</span>;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="NotifierProvider"><a href="#NotifierProvider" class="headerlink" title="NotifierProvider"></a>NotifierProvider</h4><p>我们把上一篇中<code>NotifierProvider</code>例子简化一下，还是那个万能的计数器</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//声明一个Notifier对象</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Notifier</span>&lt;<span class="hljs-title">int</span>&gt;</span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">int</span> build() &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br> <span class="hljs-comment">//对 state 进行操作，也可以在外部直接操作</span><br>  <span class="hljs-keyword">void</span> increment()&#123;<br>    state ++;<br>  &#125;<br><br>&#125;<br><span class="hljs-comment">//两种 provider 的声明方式</span><br><span class="hljs-keyword">final</span> counterProvider = NotifierProvider&lt;Counter, <span class="hljs-built_in">int</span>&gt;(() &#123;<br>  <span class="hljs-keyword">return</span> Counter();<br>&#125;);<br><span class="hljs-comment">// final counterProvider = NotifierProvider&lt;Counter, int&gt;(Counter.new);</span><br></code></pre></td></tr></table></figure>
<p>在 widget 中使用</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RiverpodGeneratorWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> count = ref.watch(counterProvider);<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(title: Text(<span class="hljs-string">&quot;RiverpodGeneratorWidget&quot;</span>),centerTitle: <span class="hljs-keyword">true</span>,),<br>      body: Column(children: [<br>        Text(<span class="hljs-string">&quot;count <span class="hljs-subst">$count</span>&quot;</span>)<br>      ],),<br>      floatingActionButton: FloatingActionButton(onPressed: ()&#123;<br>        <span class="hljs-comment">//调用 notifier 中定义的方法</span><br>        ref.read(counterProvider.notifier).increment();<br>        <span class="hljs-comment">//直接获取到 state 进行操作</span><br>        ref.read(counterProvider.notifier).state++;<br>      &#125;,child: Icon(Icons.add),<br>      ),<br>    );<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么我们如是用注解代码生成？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//counter.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:riverpod_annotation/riverpod_annotation.dart&#x27;</span>;<br><span class="hljs-keyword">part</span> <span class="hljs-string">&#x27;counter.g.dart&#x27;</span>;<br><span class="hljs-meta">@riverpod</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">_</span>$<span class="hljs-title">Counter</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">int</span> build() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">void</span> increment()&#123;<br>    state ++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>需要注意的是，这里我们需要继承<code>_$Counter</code>而不是<code>Notifier</code>。<br>因为 <code>Counter</code>中的 <code>build</code> 方法返回值是<code>int</code>类型，生成的代码中也就使用了 <code>int</code>类型。简单来讲就是<code>build</code>方法的返回值类型决定了 <code>state</code> 的类型.</p>
<p>还是需要运行 <code>flutter pub run build_runner watch</code> 或者 <code>dart run build_runner watch</code>,这时会生成<code>counter.g.dart</code>文件，内容如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// GENERATED CODE - DO NOT MODIFY BY HAND</span><br><br><span class="hljs-keyword">part</span> of <span class="hljs-string">&#x27;counter.dart&#x27;</span>;<br><br><span class="hljs-comment">// **************************************************************************</span><br><span class="hljs-comment">// RiverpodGenerator</span><br><span class="hljs-comment">// **************************************************************************</span><br><br><span class="hljs-built_in">String</span> _$counterHash() =&gt; <span class="hljs-string">r&#x27;7015b4a05f8ed24a914f6b3aad12be335d0c73d7&#x27;</span>;<br><br><span class="hljs-comment">/// <span class="language-markdown">See also [Counter].</span></span><br><span class="hljs-meta">@ProviderFor</span>(Counter)<br><span class="hljs-keyword">final</span> counterProvider = AutoDisposeNotifierProvider&lt;Counter, <span class="hljs-built_in">int</span>&gt;.internal(<br>  Counter.<span class="hljs-keyword">new</span>,<br>  name: <span class="hljs-string">r&#x27;counterProvider&#x27;</span>,<br>  debugGetCreateSourceHash:<br>      <span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">&#x27;dart.vm.product&#x27;</span>) ? <span class="hljs-keyword">null</span> : _$counterHash,<br>  dependencies: <span class="hljs-keyword">null</span>,<br>  allTransitiveDependencies: <span class="hljs-keyword">null</span>,<br>);<br><br><span class="hljs-keyword">typedef</span> _$Counter = AutoDisposeNotifier&lt;<span class="hljs-built_in">int</span>&gt;;<br><span class="hljs-comment">// ignore_for_file: type=lint</span><br><span class="hljs-comment">// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member</span><br><br></code></pre></td></tr></table></figure>

<h4 id="AsyncNotifierProvider"><a href="#AsyncNotifierProvider" class="headerlink" title="AsyncNotifierProvider"></a>AsyncNotifierProvider</h4><p>也是同样的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@riverpod</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCounters</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">_</span>$<span class="hljs-title">AsyncCounters</span></span>&#123;<br>  <span class="hljs-meta">@override</span><br>  FutureOr&lt;<span class="hljs-built_in">int</span>&gt; build()&#123;<br>    <span class="hljs-keyword">return</span> Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">3</span>),()&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>生成的代码如下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// GENERATED CODE - DO NOT MODIFY BY HAND</span><br><br><span class="hljs-keyword">part</span> of <span class="hljs-string">&#x27;async_counter.dart&#x27;</span>;<br><br><span class="hljs-comment">// **************************************************************************</span><br><span class="hljs-comment">// RiverpodGenerator</span><br><span class="hljs-comment">// **************************************************************************</span><br><br><span class="hljs-built_in">String</span> _$asyncCountersHash() =&gt; <span class="hljs-string">r&#x27;787b7c6513c7794fa310550d32594b97238e7e3c&#x27;</span>;<br><br><span class="hljs-comment">/// <span class="language-markdown">See also [AsyncCounters].</span></span><br><span class="hljs-meta">@ProviderFor</span>(AsyncCounters)<br><span class="hljs-keyword">final</span> asyncCountersProvider =<br>    AutoDisposeAsyncNotifierProvider&lt;AsyncCounters, <span class="hljs-built_in">int</span>&gt;.internal(<br>  AsyncCounters.<span class="hljs-keyword">new</span>,<br>  name: <span class="hljs-string">r&#x27;asyncCountersProvider&#x27;</span>,<br>  debugGetCreateSourceHash: <span class="hljs-keyword">const</span> <span class="hljs-built_in">bool</span>.fromEnvironment(<span class="hljs-string">&#x27;dart.vm.product&#x27;</span>)<br>      ? <span class="hljs-keyword">null</span><br>      : _$asyncCountersHash,<br>  dependencies: <span class="hljs-keyword">null</span>,<br>  allTransitiveDependencies: <span class="hljs-keyword">null</span>,<br>);<br><br><span class="hljs-keyword">typedef</span> _$AsyncCounters = AutoDisposeAsyncNotifier&lt;<span class="hljs-built_in">int</span>&gt;;<br><span class="hljs-comment">// ignore_for_file: type=lint</span><br><span class="hljs-comment">// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member</span><br><br></code></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Notifier-和-AsyncNotifier：是否值得使用？"><a href="#Notifier-和-AsyncNotifier：是否值得使用？" class="headerlink" title="Notifier 和 AsyncNotifier：是否值得使用？"></a>Notifier 和 AsyncNotifier：是否值得使用？</h4><p>长时间以来，StateNotifier 一直在为我们提供服务，提供了一个存储复杂状态和修改状态逻辑的地方，使其不再依赖于小部件树。</p>
<p>Notifier 和 AsyncNotifier 旨在取代 StateNotifier 并带来一些新的好处：</p>
<p>更容易执行复杂的异步初始化<br>更符合人体工程学的 API：不再需要传递 ref<br>不再需要手动声明提供者（如果使用 Riverpod Generator）<br>对于新项目来说，这些好处是值得的，因为新的类可以帮助您用更少的代码实现更多的功能。</p>
<p>但如果您有很多现有代码使用 StateNotifier，则由您决定是否（或何时）迁移到新的语法。</p>
<p>无论如何，StateNotifier 还会存在一段时间，如果您愿意，可以逐个迁移您的提供者。</p>
<h4 id="使用-generator-还是手动编写-provider"><a href="#使用-generator-还是手动编写-provider" class="headerlink" title="使用 generator 还是手动编写 provider"></a>使用 generator 还是手动编写 provider</h4><p>使用 generator 需要我们执行额外的代码来生成对应的代码文件，并且在编写生成代码时体验不是那么的友好。但另外一方面，能省去我们编写模板的代码的时间。如何使用，看个人喜好。</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>riverpod</tag>
      </tags>
  </entry>
  <entry>
    <title>ss、ssr和v2ray以及bbr</title>
    <url>/2019/05/29/ss%E3%80%81ssr%E5%92%8Cv2ray%E4%BB%A5%E5%8F%8Abbr/</url>
    <content><![CDATA[<p>由于众所周知的原因，为了防止文章被和谐，文中会出现明显(脑残)的解释说明上的错误，懂的自然都懂</p>
<p>使用pip安装ssserve以及对应的配置</p>
<p>使用bbr拥塞控制算法进行加速</p>
<p>使用v2ray脚本安装v2ray</p>
<span id="more"></span>

<h4 id="安装ssserver及配置"><a href="#安装ssserver及配置" class="headerlink" title="安装ssserver及配置"></a>安装ssserver及配置</h4><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>Debian&#x2F;Ubuntu:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">apt-get install python-pip<br>pip install shadowsocks <br></code></pre></td></tr></table></figure>

<p>CentOS:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs she">yum install python-setuptools &amp;&amp; easy_install pip<br>pip install shadowsocks <br></code></pre></td></tr></table></figure>

<p>有时 Ubuntu 会遇到第一个命令安装 python-pip 时找不到包的情况。pip 官方给出了一个安装脚本，可以自动安装 pip。先下载脚本，然后执行即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wget https://bootstrap.pypa.io/get-pip.py python get-pip.py <br></code></pre></td></tr></table></figure>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>创建一个xx.json文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;your server ip&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;server_port&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">8388</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//客户端连接用的端口号</span><br><span class="hljs-attr">&quot;local_port&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">1080</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//本机使用的端口号</span><br><span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;your password&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;method&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;aes-256-cfb&quot;</span><br><span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">300</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>上面的method是加密方式，选择什么样的加密方式自己确定，或者说看你的客户端支持什么样的假面方式，可选如下：</p>
<blockquote>
<p>aes-128-cfb<br>aes-256-cfb<br>chacha20<br>chacha20-ietf<br>aes-128-gcm<br>aes-256-gcm<br>chacha20-ietf-poly1305</p>
</blockquote>
<p>如果想要开启多个端口，把上面的server_port和password改成这样</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;port_password&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-comment">//端口:密码 </span><br>     <span class="hljs-attr">&quot;8381&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;password1&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;8382&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;password2&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;8383&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;password3&quot;</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;8384&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;password4&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure>

<p>如果服务器支持ipv6，启用ipv6的话，把上面的server改成<code>::</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;::&quot;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure>

<p>这时ipv4和ipv6是可以同时使用的。</p>
<p>客户端连接ss的时候，服务器地址填写ipv6的地址，类似于<code>2402:d0c0:0:133::983d</code>即可。</p>
<h5 id="启动ssserve"><a href="#启动ssserve" class="headerlink" title="启动ssserve"></a>启动ssserve</h5><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssserver -c xx.json <br></code></pre></td></tr></table></figure>

<h4 id="ubuntu内核升级及使用bbr进行网络加速"><a href="#ubuntu内核升级及使用bbr进行网络加速" class="headerlink" title="ubuntu内核升级及使用bbr进行网络加速"></a>ubuntu内核升级及使用bbr进行网络加速</h4><p>谷歌新的tcp拥塞控制算法BBR(<strong>Bottleneck Bandwidth and RTT</strong>)</p>
<p>内容出自 <a href="https://www.dz9.net/blog/4246.html">https://www.dz9.net/blog/4246.html</a></p>
<p>众所周知，Ubuntu开启BBR的前提是内核必须等于高于4.9。<code>uname -a</code>查看ubuntu内核系统版本，如果满足条件，跳过下一步</p>
<h5 id="ubuntu内核升级"><a href="#ubuntu内核升级" class="headerlink" title="ubuntu内核升级"></a>ubuntu内核升级</h5><p><code>getconf LONG_BIT</code>查看一下系统是多少位的,</p>
<p>确定系统之后，需要下载必要的升级程序包</p>
<p><a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/">http://kernel.ubuntu.com/~kernel-ppa/mainline/</a></p>
<p>这个网站可以找到最新的程序包，根据自己的需要使用wget命令来下载到服务器；</p>
<p>比如我的服务器是64位，安装4.10.2的内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.10.2/linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb<br></code></pre></td></tr></table></figure>

<p>然后切换到你的文件下载目录，执行下列命令来升级：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo dpkg -i linux-image-4.10.2-041002-generic_4.10.2-041002.201703120131_amd64.deb<br></code></pre></td></tr></table></figure>

<p>最后，执行命令<code>sudo update-grub</code>，更新grub引导装入程序。</p>
<p>一旦各方面都已完成，重启机器，你就可以准备使用了。系统重启后，打开终端窗口，执行命令uname -a，确保你实际上是在运行你更新之后的内核。</p>
<h6 id="开启TCP-BBR"><a href="#开启TCP-BBR" class="headerlink" title="开启TCP BBR"></a>开启TCP BBR</h6><p>修改系统变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf<br>echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf<br></code></pre></td></tr></table></figure>

<p>保存生效</p>
<p><code>sysctl -p</code></p>
<p>执行<br><code>sysctl net.ipv4.tcp_available_congestion_control</code></p>
<p>如果返回结果<br><code>net.ipv4.tcp_available_congestion_control = bbr cubic reno</code><br>那么恭喜你BBR开启成功了！</p>
<p>也可以执行<br><code>lsmod | grep bbr</code><br>来检测 BBR 是否真的开启成功……</p>
<h4 id="v2ray"><a href="#v2ray" class="headerlink" title="v2ray"></a>v2ray</h4><p>一键安装脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">apt-get install curl -y bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/tracyone/v2ray.fun/master/install.sh)&quot;<br></code></pre></td></tr></table></figure>

<p>然后看提示就好了。</p>
<p>或者看官网 <a href="http://www.v2ray.com/">www.v2ray.com</a>   这个需要一些方法才能访问</p>
<p>关键内容如下：</p>
<h5 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h5><p>V2Ray 在以下平台中可用：</p>
<ul>
<li>Windows 7 及之后版本（x86 &#x2F; amd64）；</li>
<li>Mac OS X 10.10 Yosemite 及之后版本（amd64）；</li>
<li>Linux 2.6.23 及之后版本（x86 &#x2F; amd64 &#x2F; arm &#x2F; arm64 &#x2F; mips64 &#x2F; mips）；<ul>
<li>包括但不限于 Debian 7 &#x2F; 8、Ubuntu 12.04 &#x2F; 14.04 及后续版本、CentOS 6 &#x2F; 7、Arch Linux；</li>
</ul>
</li>
<li>FreeBSD (x86 &#x2F; amd64)；</li>
<li>OpenBSD (x86 &#x2F; amd64)；</li>
<li>Dragonfly BSD (amd64)；</li>
</ul>
<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>预编译的压缩包可以在如下几个站点找到：</p>
<ol>
<li>Github Release: <a href="https://github.com/v2ray/v2ray-core/releases">github.com&#x2F;v2ray&#x2F;v2ray-core</a></li>
<li>Github 分流: <a href="https://github.com/v2ray/dist/">github.com&#x2F;v2ray&#x2F;dist</a></li>
<li>Homebrew: <a href="https://github.com/v2ray/homebrew-v2ray">github.com&#x2F;v2ray&#x2F;homebrew-v2ray</a></li>
<li>Arch Linux: <a href="https://www.archlinux.org/packages/community/x86_64/v2ray/">packages&#x2F;community&#x2F;x86_64&#x2F;v2ray&#x2F;</a></li>
<li>Snapcraft: <a href="https://snapcraft.io/v2ray-core">snapcraft.io&#x2F;v2ray-core</a></li>
</ol>
<p>压缩包均为 zip 格式，找到对应平台的压缩包，下载解压即可使用。</p>
<h5 id="验证安装包"><a href="#验证安装包" class="headerlink" title="验证安装包"></a>验证安装包</h5><p>V2Ray 提供两种验证方式：</p>
<ol>
<li>安装包 zip 文件的 SHA1 &#x2F; SHA256 摘要，在每个安装包对应的<code>.dgst</code>文件中可以找到。</li>
<li>可运行程序（v2ray 或 v2ray.exe）的 gpg 签名，文件位于安装包中的 v2ray.sig 或 v2ray.exe.sig。签名公钥可以<a href="https://raw.githubusercontent.com/v2ray/v2ray-core/master/release/verify/official_release.asc">在代码库中</a>找到。</li>
</ol>
<h5 id="Windows-和-Mac-OS-安装方式"><a href="#Windows-和-Mac-OS-安装方式" class="headerlink" title="Windows 和 Mac OS 安装方式"></a>Windows 和 Mac OS 安装方式</h5><p>通过上述方式下载的压缩包，解压之后可看到 v2ray 或 v2ray.exe。直接运行即可。</p>
<h5 id="Linux-发行版仓库"><a href="#Linux-发行版仓库" class="headerlink" title="Linux 发行版仓库"></a>Linux 发行版仓库</h5><p>部分发行版可能已收录 V2Ray 到其官方维护和支持的软件仓库&#x2F;软件源中。出于兼容性、适配性考虑，您可以考虑选用由您发行版开发团队维护的软件包或下文的安装脚本亦或基于已发布的二进制文件或源代码安装。<br>Linux 安装脚本<br>V2Ray 提供了一个在 Linux 中的自动化安装脚本。这个脚本会自动检测有没有安装过 V2Ray，如果没有，则进行完整的安装和配置；如果之前安装过 V2Ray，则只更新 V2Ray 二进制程序而不更新配置。</p>
<p>以下指令假设已在 su 环境下，如果不是，请先运行 sudo su。</p>
<p>运行下面的指令下载并安装 V2Ray。当 yum 或 apt-get 可用的情况下，此脚本会自动安装 unzip 和 daemon。这两个组件是安装 V2Ray 的必要组件。如果你使用的系统不支持 yum 或 apt-get，请自行安装 unzip 和 daemon</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">bash &lt;(curl -L -s https://install.direct/go.sh)<br></code></pre></td></tr></table></figure>
<p>此脚本会自动安装以下文件：</p>
<ul>
<li>&#x2F;usr&#x2F;bin&#x2F;v2ray&#x2F;v2ray：V2Ray 程序；</li>
<li>&#x2F;usr&#x2F;bin&#x2F;v2ray&#x2F;v2ctl：V2Ray 工具；</li>
<li>&#x2F;etc&#x2F;v2ray&#x2F;config.json：配置文件；</li>
<li>&#x2F;usr&#x2F;bin&#x2F;v2ray&#x2F;geoip.dat：IP 数据文件</li>
<li>&#x2F;usr&#x2F;bin&#x2F;v2ray&#x2F;geosite.dat：域名数据文件<br>此脚本会配置自动运行脚本。自动运行脚本会在系统重启之后，自动运行 V2Ray。目前自动运行脚本只支持带有 Systemd 的系统，以及 Debian &#x2F; Ubuntu 全系列。</li>
</ul>
<p>运行脚本位于系统的以下位置：</p>
<ul>
<li><p>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;v2ray.service: Systemd</p>
</li>
<li><p>&#x2F;etc&#x2F;init.d&#x2F;v2ray: SysV</p>
</li>
</ul>
<p>脚本运行完成后，你需要：</p>
<ol>
<li>编辑 &#x2F;etc&#x2F;v2ray&#x2F;config.json 文件来配置你需要的代理方式；</li>
<li>运行 service v2ray start 来启动 V2Ray 进程；</li>
<li>之后可以使用 service v2ray start|stop|status|reload|restart|force-reload 控制 V2Ray 的运行。</li>
</ol>
<h5 id="go-sh-参数"><a href="#go-sh-参数" class="headerlink" title="go.sh 参数"></a>go.sh 参数</h5><p>go.sh 支持如下参数，可在手动安装时根据实际情况调整：</p>
<ul>
<li><p>-p 或 –proxy: 使用代理服务器来下载 V2Ray 的文件，格式与 curl 接受的参数一致，比如”socks5:&#x2F;&#x2F;127.0.0.1:1080” 或 “<a href="http://127.0.0.1:3128&quot;。">http://127.0.0.1:3128&quot;。</a></p>
</li>
<li><p>-f 或 –force: 强制安装。在默认情况下，如果当前系统中已有最新版本的 V2Ray，go.sh 会在检测之后就退出。如果需要强制重装一遍，则需要指定该参数。</p>
</li>
<li><p>–version: 指定需要安装的版本，比如 “v1.13”。默认值为最新版本。</p>
</li>
<li><p>–local: 使用一个本地文件进行安装。如果你已经下载了某个版本的 V2Ray，则可通过这个参数指定一个文件路径来进行安装。<br>示例：</p>
</li>
<li><p>使用地址为 127.0.0.1:1080 的 SOCKS 代理下载并安装最新版本：.&#x2F;go.sh -p socks5:&#x2F;&#x2F;127.0.0.1:1080</p>
</li>
<li><p>安装本地的 v1.13 版本：.&#x2F;go.sh –version v1.13 –local &#x2F;path&#x2F;to&#x2F;v2ray.zip</p>
<h5 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h5><p>V2Ray 提供了两个预编译的 Docker image：</p>
</li>
<li><p>v2ray&#x2F;official <a href="https://hub.docker.com/r/v2ray/official/">https://hub.docker.com/r/v2ray/official/</a> : 包含最新发布的版本，每周跟随新版本更新；</p>
</li>
<li><p>v2ray&#x2F;dev  <a href="https://hub.docker.com/r/v2ray/dev/">https://hub.docker.com/r/v2ray/dev/</a>:  包含由最新的代码编译而成的程序文件，随代码库更新；<br>两个 image 的文件结构相同：</p>
</li>
<li><p>&#x2F;etc&#x2F;v2ray&#x2F;config.json: 配置文件</p>
</li>
<li><p>&#x2F;usr&#x2F;bin&#x2F;v2ray&#x2F;v2ray: V2Ray 主程序</p>
</li>
<li><p>&#x2F;usr&#x2F;bin&#x2F;v2ray&#x2F;v2ctl: V2Ray 辅助工具</p>
</li>
<li><p>&#x2F;usr&#x2F;bin&#x2F;v2ray&#x2F;geoip.dat: IP 数据文件</p>
</li>
<li><p>&#x2F;usr&#x2F;bin&#x2F;v2ray&#x2F;geosite.dat: 域名数据文件</p>
</li>
</ul>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;inbounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1080</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// SOCKS 代理端口，在浏览器中需配置代理并指向这个端口</span><br>    <span class="hljs-attr">&quot;listen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;socks&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;udp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;outbounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vmess&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;vnext&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;server&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 服务器地址，请修改为你自己的服务器 ip 或域名</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10086</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 服务器端口</span><br>        <span class="hljs-attr">&quot;users&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;freedom&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;tag&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;direct&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;routing&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;domainStrategy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IPOnDemand&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;field&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;ip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;geoip:private&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;outboundTag&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;direct&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>上述配置唯一要改的地方就是你的服务器 IP，配置中已注明。上述配置会把除了局域网（比如访问路由器）之外的所有流量转发到你的服务器。</p>
<h5 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h5><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;inbounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10086</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 服务器监听端口，必须和上面的一样</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vmess&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;clients&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;outbounds&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;freedom&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<p>服务器的配置中需要确保 <code>id</code> 和端口与客户端一致，就可以正常连接了。</p>
<h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><ul>
<li>在 Windows 和 macOS 中，配置文件通常是 V2Ray 同目录下的 <code>config.json</code> 文件。直接运行 <code>v2ray</code> 或 <code>v2ray.exe</code> 即可。</li>
<li>在 Linux 中，配置文件通常位于 <code>/etc/v2ray/config.json</code> 文件。运行 <code>v2ray --config=/etc/v2ray/config.json</code>，或使用 systemd 等工具把 V2Ray 作为服务在后台运行。</li>
</ul>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>运维</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime text 2 搭建java运行环境</title>
    <url>/2014/05/18/sublime-text-2-%E6%90%AD%E5%BB%BAjava%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>刚开始学java，在windows下写代码的时候用sublime2写的，捣鼓了一下环境，可以进行一键编译<br>需要的材料：</p>
<ol>
<li>安装好的ST2<br>2）java运行环境<span id="more"></span></li>
</ol>
<h4 id="创建批处理或Bash-Shell脚本文件"><a href="#创建批处理或Bash-Shell脚本文件" class="headerlink" title="创建批处理或Bash Shell脚本文件"></a>创建批处理或Bash Shell脚本文件</h4><p>打开任意的文本编辑器，输入下面的内容，并保存为runJava.bat文件<br>代码如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">@ECHO OFF  <br><span class="hljs-built_in">cd</span> %~dp1  <br>ECHO Compiling %~nx1.......  <br>IF EXIST %~n1.class (  <br>DEL %~n1.class  <br>)  <br>javac %~nx1  <br>IF EXIST %~n1.class (  <br>ECHO -----------OUTPUT-----------  <br>java %~n1  <br>)  <br></code></pre></td></tr></table></figure>

<p>如果是在Windows下编译提示  不是utf-8编码什么的话，则将上诉代码修改如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">@ECHO OFF  <br><span class="hljs-built_in">cd</span> %~dp1  <br>ECHO Compiling %~nx1.......  <br>IF EXIST %~n1.class (  <br>DEL %~n1.class  <br>)  <br>javac -encoding UTF-8 %~nx1  <br>IF EXIST %~n1.class (  <br>ECHO -----------OUTPUT-----------  <br>java %~n1  <br>) <br></code></pre></td></tr></table></figure>
<p><img src="/image/sublime/runJavaBat.png" alt="geocoderSearch"></p>
<p>将这个文件放到JDK的bin文件夹下</p>
<h4 id="在Sublime-Text-2编辑器中配置相应的Java构建环境"><a href="#在Sublime-Text-2编辑器中配置相应的Java构建环境" class="headerlink" title="在Sublime Text 2编辑器中配置相应的Java构建环境"></a>在Sublime Text 2编辑器中配置相应的Java构建环境</h4><p>打开Sublime的包目录，使用菜单Perferences-&gt;Browse Packages<br><img src="/image/sublime/browePackages.png" alt="geocoderSearch"><br>选择Java目录<br><img src="/image/sublime/javacSublimeBuild.png" alt="geocoderSearch"><br>打开JavaC.sublime-build，并修改下面的行<br><img src="/image/sublime/before_modify.png" alt="geocoderSearch"><br><img src="/image/sublime/afterModify.png.png" alt="geocoderSearch"></p>
<p>画红框的是修改完之后的。<br>然后 Ctrl+s 保存一下就好了。<br>写完java代码之后，Ctrl+s 保存一下，然后Ctrl+B 就可以编译运行了。。。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>riverpod1.0+简介</title>
    <url>/2022/01/04/riverpod1-0-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Flutter更新到2.8了，最近打算重拾一下flutter，写点东西练练手。大家都清楚在flutter中状态管理确实挺麻烦的，从一开始的BLoC到provide、Provider，还有getX、Riverpod等等各式各样的状态管理库，我个人倾向于使用riverpod，它更像一个状态管理库；而getX更像一个开发的框架，实在是太大了:当你使用getX的时候，你是在用getX而不是flutter写应用。</p>
<span id="more"></span>

<h2 id="引入riverpod"><a href="#引入riverpod" class="headerlink" title="引入riverpod"></a>引入riverpod</h2><p>demo中没有包含flutter_hook,所以我们选择引入flutter_riverpod即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">environment:</span><br>  <span class="hljs-attr">sdk:</span> <span class="hljs-string">&quot;&gt;=2.15.1 &lt;3.0.0&quot;</span><br>  <span class="hljs-attr">flutter:</span> <span class="hljs-string">&quot;&gt;=2.0.0&quot;</span><br><br><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter:</span><br>    <span class="hljs-attr">sdk:</span> <span class="hljs-string">flutter</span><br>  <span class="hljs-attr">flutter_riverpod:</span> <span class="hljs-string">^1.0.3</span><br></code></pre></td></tr></table></figure>

<h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><p>首先，我们需要使用<code>ProviderScope</code>来包裹整个应用，也就是在main方法中</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(ProviderScope(child: Home()));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们可以声明一个Provider。一般情况下，我们会把各种各样的provider作为全局变量来引用，声明一个provider和声明一个函数没有多大的区别。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> helloWorldProvider = Provider((_) =&gt; <span class="hljs-string">&#x27;Hello world&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>最后我们就可以读取Provider中的数据了。<br>在1.0.0之后的版本中，ConsumerWidget的build方法中提供了<code>WidgetRef</code>对象，用来取代0.14版本中的<code>useProvider</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_riverpod/flutter_riverpod.dart&#x27;</span>;<br><br><span class="hljs-keyword">final</span> helloWorldProvider  = Provider((_)=&gt;<span class="hljs-string">&quot;hello world&quot;</span>);<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(<span class="hljs-keyword">const</span> ProviderScope(child: Home()));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Home</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span></span>&#123;<br>  <span class="hljs-keyword">const</span> Home(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> value = ref.watch(helloWorldProvider);<br><br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: Scaffold(<br>        appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;riverpod demo&quot;</span>),),<br>        body: Center(<br>          child: Text(value),<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h2><h3 id="各种各样的Provider"><a href="#各种各样的Provider" class="headerlink" title="各种各样的Provider"></a>各种各样的Provider</h3><p>具体可以看这里，<a href="https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/flutter_riverpod-library.html">https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/flutter_riverpod-library.html</a></p>
<p>下面列举了一些常用的Provider类型</p>
<ul>
<li><p>Provider</p>
<p><a href="https://pub.dev/documentation/riverpod/latest/riverpod/Provider-class.html">https://pub.dev/documentation/riverpod/latest/riverpod/Provider-class.html</a></p>
</li>
<li><p>StateProvider</p>
</li>
</ul>
<p><a href="https://pub.dev/documentation/riverpod/latest/riverpod/StateProvider-class.html">https://pub.dev/documentation/riverpod/latest/riverpod/StateProvider-class.html</a></p>
<ul>
<li><p>StateNotifierProvider<br><a href="https://pub.dev/documentation/riverpod/latest/riverpod/StateNotifierProvider-class.html">https://pub.dev/documentation/riverpod/latest/riverpod/StateNotifierProvider-class.html</a></p>
</li>
<li><p>FutureProvider<br><a href="https://pub.dev/documentation/riverpod/latest/riverpod/FutureProvider-class.html">https://pub.dev/documentation/riverpod/latest/riverpod/FutureProvider-class.html</a></p>
</li>
<li><p>StreamProvider<br><a href="https://pub.dev/documentation/riverpod/latest/riverpod/StreamProvider-class.html">https://pub.dev/documentation/riverpod/latest/riverpod/StreamProvider-class.html</a></p>
</li>
</ul>
<h3 id="Provider的修饰符"><a href="#Provider的修饰符" class="headerlink" title="Provider的修饰符"></a>Provider的修饰符</h3><h4 id="family"><a href="#family" class="headerlink" title=".family"></a>.family</h4><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>该修饰符适用于适用外部数据来构建provider的情况</p>
<p>一些常用情况</p>
<ul>
<li>和<a href="https://pub.dev/documentation/riverpod/latest/riverpod/FutureProvider-class.html">FutureProvider</a> 组合，来根据id获取消息</li>
<li>把当前Locale对象传给provider，用来进行国际化</li>
<li>在不访问对方属性的前提下连接两个provider</li>
</ul>
<p>在使用family时，会额外的向provider提供一个属性，在provider中我们可以自由的使用该属性来创建某些状态</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> messagesFamily = FutureProvider.family&lt;Message, <span class="hljs-built_in">String</span>&gt;((ref, id) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">return</span> dio.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;http://my_api.dev/messages/<span class="hljs-subst">$id</span>&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这种情况下在使用<code>messagesFamily</code>时会有点语法上的变化，我们需要额外提供一个参数</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Widget build(BuildContext context, WidgetRef ref) &#123;<br>  <span class="hljs-keyword">final</span> response = ref.watch(messagesFamily(<span class="hljs-string">&#x27;id&#x27;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它还支持同时获取不同的属性</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>Widget build(BuildContext context, WidgetRef ref) &#123;<br>  <span class="hljs-keyword">final</span> frenchTitle = ref.watch(titleFamily(<span class="hljs-keyword">const</span> Locale(<span class="hljs-string">&#x27;fr&#x27;</span>)));<br>  <span class="hljs-keyword">final</span> englishTitle = ref.watch(titleFamily(<span class="hljs-keyword">const</span> Locale(<span class="hljs-string">&#x27;en&#x27;</span>)));<br><br>  <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&#x27;fr: <span class="hljs-subst">$frenchTitle</span> en: <span class="hljs-subst">$englishTitle</span>&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="参数限制"><a href="#参数限制" class="headerlink" title="参数限制"></a>参数限制</h5><p>参数不限制类型，但必须实现<code>==</code>和<code>hashCode</code>两个方法；</p>
<p>如果参数不是constant的，比如我们想将输入框内容传给Provider，但是输入框的内容会变化的特别频繁并且不能复用，这种情况可能会导致内存泄露，可以使用<code>.autoDispose</code>修饰符来修复这个问题</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> characters = FutureProvider.autoDispose.family&lt;<span class="hljs-built_in">List</span>&lt;Character&gt;, <span class="hljs-built_in">String</span>&gt;((ref, filter) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">return</span> fetchCharacters(filter: filter);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h5 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h5><p>.family修饰符并没有内置提供过个参数的方法，另外一方面，这个参数可以是任意符合上面提到的限制的类型。<br>比如</p>
<ul>
<li>元组</li>
<li>使用 Freezed 或 built_value 生成的对象</li>
<li>使用 equatable 的对象</li>
</ul>
<p>** freezed **</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@freezed</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyParameter</span> <span class="hljs-title">with</span> <span class="hljs-title">_</span>$<span class="hljs-title">MyParameter</span> </span>&#123;<br>  <span class="hljs-keyword">factory</span> MyParameter(&#123;<br>    <span class="hljs-keyword">required</span> <span class="hljs-built_in">int</span> userId,<br>    <span class="hljs-keyword">required</span> Locale locale,<br>  &#125;) = _MyParameter;<br>&#125;<br><br><span class="hljs-keyword">final</span> exampleProvider = Provider.autoDispose.family&lt;Something, MyParameter&gt;((ref, myParameter) &#123;<br>  <span class="hljs-built_in">print</span>(myParameter.userId);<br>  <span class="hljs-built_in">print</span>(myParameter.locale);<br>  <span class="hljs-comment">// Do something with userId/locale</span><br>&#125;);<br><br><span class="hljs-meta">@override</span><br>Widget build(BuildContext context, WidgetRef ref) &#123;<br>  <span class="hljs-built_in">int</span> userId; <span class="hljs-comment">// Read the user ID from somewhere</span><br>  <span class="hljs-keyword">final</span> locale = Localizations.localeOf(context);<br><br>  <span class="hljs-keyword">final</span> something = ref.watch(<br>    exampleProvider(MyParameter(userId: userId, locale: locale)),<br>  );<br><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Equatable</strong></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyParameter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Equatable</span>  </span>&#123;<br>  MyParameter(&#123;<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.userId,<br>    <span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.locale,<br>  &#125;);<br><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> userId;<br>  <span class="hljs-keyword">final</span> Locale locale;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt; <span class="hljs-keyword">get</span> props =&gt; [userId, locale];<br>&#125;<br><br><span class="hljs-keyword">final</span> exampleProvider = Provider.family&lt;Something, MyParameter&gt;((ref, myParameter) &#123;<br>  <span class="hljs-built_in">print</span>(myParameter.userId);<br>  <span class="hljs-built_in">print</span>(myParameter.locale);<br>  <span class="hljs-comment">// Do something with userId/locale</span><br>&#125;);<br><br><span class="hljs-meta">@override</span><br>Widget build(BuildContext context, WidgetRef ref) &#123;<br>  <span class="hljs-built_in">int</span> userId; <span class="hljs-comment">// Read the user ID from somewhere</span><br>  <span class="hljs-keyword">final</span> locale = Localizations.localeOf(context);<br><br>  <span class="hljs-keyword">final</span> something = ref.watch(<br>    exampleProvider(MyParameter(userId: userId, locale: locale)),<br>  );<br><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="autoDispose"><a href="#autoDispose" class="headerlink" title=".autoDispose"></a>.autoDispose</h4><p>一个通用场景是能够自动释放长时间不适用Provider；</p>
<p>有很多个让我们这么做得理由，比如：</p>
<ul>
<li>在使用Firebase时，关闭连接避免不必要的开销</li>
<li>当用户离开页面再进入页面时重置状态</li>
</ul>
<p>我们可以使用内嵌的<code>.autoDispose</code>修饰符来支持上述场景</p>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><p>想要告诉Riverpod在不再使用provider时将其销毁，只需要在Provider之前加上<code>.autoDispose</code>即可</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> userProvider = StreamProvider.autoDispose&lt;User&gt;((ref) &#123;<br><br>&#125;);<br></code></pre></td></tr></table></figure>

<p>就这样，当<code>userProvider</code>不再使用时将会被自动销毁</p>
<p>注意通用参数是如何在autoDispose之后而不是之前传递的–autoDispose不是一个命名的构造函数。</p>
<p>当然，上面也提到可以和其他修饰符一起</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> userProvider = StreamProvider.autoDispose.family&lt;User, <span class="hljs-built_in">String</span>&gt;((ref, id) &#123;<br><br>&#125;);<br></code></pre></td></tr></table></figure>

<h5 id="ref-maintainState"><a href="#ref-maintainState" class="headerlink" title="ref.maintainState"></a>ref.maintainState</h5><p>用<code>autoDispose</code>标记一个提供者，也会在ref上增加一个额外的属性： <code>maintainState</code>。</p>
<p>该属性是一个布尔值（默认为false），允许提供者告诉Riverpod即使不再被监听，是否应该保留提供者的状态。</p>
<p>一个用例是在一个HTTP请求完成后，将这个标志设置为true:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> myProvider = FutureProvider.autoDispose((ref) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">final</span> response = <span class="hljs-keyword">await</span> dio.<span class="hljs-keyword">get</span>(...);<br>  ref.maintainState = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">return</span> response;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这样，如果请求失败，用户离开屏幕后又重新进入，那么请求将被再次执行。但如果请求成功完成，状态将被保留，重新进入屏幕将不会触发新的请求。</p>
<h5 id="示例：取消http请求"><a href="#示例：取消http请求" class="headerlink" title="示例：取消http请求"></a>示例：取消http请求</h5><p>autoDispose修改器可以与FutureProvider和ref.onDispose相结合，以便在不再需要HTTP请求时轻松取消。</p>
<p>要求：</p>
<ul>
<li>当用户进入一个屏幕时，启动一个HTTP请求</li>
<li>如果用户在请求完成前离开屏幕，则取消HTTP请求</li>
<li>如果请求成功，离开并重新进入屏幕不会启动一个新的请求</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> myProvider = FutureProvider.autoDispose((ref) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-comment">// An object from package:dio that allows cancelling http requests</span><br>  <span class="hljs-keyword">final</span> cancelToken = CancelToken();<br>  <span class="hljs-comment">// When the provider is destroyed, cancel the http request</span><br>  ref.onDispose(() =&gt; cancelToken.cancel());<br><br>  <span class="hljs-comment">// Fetch our data and pass our `cancelToken` for cancellation to work</span><br>  <span class="hljs-keyword">final</span> response = <span class="hljs-keyword">await</span> dio.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;path&#x27;</span>, cancelToken: cancelToken);<br>  <span class="hljs-comment">// If the request completed successfully, keep the state</span><br>  ref.maintainState = <span class="hljs-keyword">true</span>;<br>  <span class="hljs-keyword">return</span> response;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h5 id="参数类型’AutoDisposeProvider’不能分配给参数类型’AlwaysAliveProviderBase’。"><a href="#参数类型’AutoDisposeProvider’不能分配给参数类型’AlwaysAliveProviderBase’。" class="headerlink" title="参数类型’AutoDisposeProvider’不能分配给参数类型’AlwaysAliveProviderBase’。"></a>参数类型’AutoDisposeProvider’不能分配给参数类型’AlwaysAliveProviderBase’。</h5><p>当使用.autoDispose时，你可能会发现自己的应用程序无法编译，出现类似的错误。</p>
<blockquote>
<p>The argument type ‘AutoDisposeProvider’ can’t be assigned to the parameter type ‘AlwaysAliveProviderBase’</p>
</blockquote>
<p>可能是因为你试图在一个没有标记为.autoDispose的提供者中监听一个标记为.autoDispose的提供者，例如：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> firstProvider = Provider.autoDispose((ref) =&gt; <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">final</span> secondProvider = Provider((ref) &#123;<br>  <span class="hljs-comment">// The argument type &#x27;AutoDisposeProvider&lt;int&gt;&#x27; can&#x27;t be assigned to the</span><br>  <span class="hljs-comment">// parameter type &#x27;AlwaysAliveProviderBase&lt;Object, Null&gt;&#x27;</span><br>  ref.watch(firstProvider);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>这是不可取的，因为它将导致firstProvider永远不会被dispose。我们可以考虑将 <code>secondProvider</code> 标记为 &#96;.autoDispose来修复这个问题：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> firstProvider = Provider.autoDispose((ref) =&gt; <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">final</span> secondProvider = Provider.autoDispose((ref) &#123;<br>  ref.watch(firstProvider);<br>&#125;);<br></code></pre></td></tr></table></figure>



<h2 id="WidgetRef"><a href="#WidgetRef" class="headerlink" title="WidgetRef"></a>WidgetRef</h2><h3 id="获取WidgetRef对象"><a href="#获取WidgetRef对象" class="headerlink" title="获取WidgetRef对象"></a>获取WidgetRef对象</h3><h4 id="从其他Provider对象中获取"><a href="#从其他Provider对象中获取" class="headerlink" title="从其他Provider对象中获取"></a>从其他Provider对象中获取</h4><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> provider = Provider((ref) &#123;<br>  <span class="hljs-comment">// use ref to obtain other providers</span><br>  <span class="hljs-keyword">final</span> repository = ref.watch(repositoryProvider);<br>  <span class="hljs-keyword">return</span> SomeValue(repository);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><code>ref</code>对象可以很安全的在provider之间传递，一个常见的用法就是讲<code>ref</code>传递给 <a href="https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html">StateNotifier</a></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counter = StateNotifierProvider&lt;Counter, <span class="hljs-built_in">int</span>&gt;((ref) &#123;<br>  <span class="hljs-keyword">return</span> Counter(ref);<br>&#125;);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StateNotifier</span>&lt;<span class="hljs-title">int</span>&gt; </span>&#123;<br>  Counter(<span class="hljs-keyword">this</span>.ref): <span class="hljs-keyword">super</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">final</span> Ref ref;<br><br>  <span class="hljs-keyword">void</span> increment() &#123;<br>    <span class="hljs-comment">// Counter can use the &quot;ref&quot; to read other providers</span><br>    <span class="hljs-keyword">final</span> repository = ref.read(repositoryProvider);<br>    repository.post(<span class="hljs-string">&#x27;...&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这么做可以让Counter内部读取provider状态</p>
<h4 id="从Widget对象中获取ref"><a href="#从Widget对象中获取ref" class="headerlink" title="从Widget对象中获取ref"></a>从Widget对象中获取ref</h4><p>一般情况下Widget对象中是没有ref对象中，但riverpod提供了几种解决方案</p>
<ul>
<li>使用ConsumerWidget替换StatelessWidget</li>
</ul>
<p>ConsumerWidget和StatelessWidget基本相同(虽然是继承了StatefulWidget)，只是在build方法中多了一个WidgetRef对象</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> HomeView(&#123;Key? key&#125;): <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-comment">// use ref to listen to a provider</span><br>    <span class="hljs-keyword">final</span> counter = ref.watch(counterProvider);<br>    <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&#x27;<span class="hljs-subst">$counter</span>&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用ConsumerStatefulWidget+ConsumerState 替换 StatefulWidget+State</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerStatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> HomeView(&#123;Key? key&#125;): <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  HomeViewState createState() =&gt; HomeViewState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeViewState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerState</span>&lt;<span class="hljs-title">HomeView</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState() &#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    <span class="hljs-comment">// &quot;ref&quot; can be used in all life-cycles of a StatefulWidget.</span><br>    ref.read(counterProvider);<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-comment">// We can also use &quot;ref&quot; to listen to a provider inside the build method</span><br>    <span class="hljs-keyword">final</span> counter = ref.watch(counterProvider);<br>    <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&#x27;<span class="hljs-subst">$counter</span>&#x27;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>使用 HookConsumerWidget 替换 HookWidget</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HookConsumerWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> HomeView(&#123;Key? key&#125;): <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-comment">// HookConsumerWidget allows using hooks inside the build method</span><br>    <span class="hljs-keyword">final</span> state = useState(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// We can also use the ref parameter to listen to providers.</span><br>    <span class="hljs-keyword">final</span> counter = ref.watch(counterProvider);<br>    <span class="hljs-keyword">return</span> Text(<span class="hljs-string">&#x27;<span class="hljs-subst">$counter</span>&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="WidgetRef对象的方法"><a href="#WidgetRef对象的方法" class="headerlink" title="WidgetRef对象的方法"></a>WidgetRef对象的方法</h3><p>这里的<code>WidgetRef</code>对象在读取Provider中的数据时，提供了<code>read</code>、<code>listen</code>和<code>watch</code>方法。至于什么情况下选用哪个方法，这里有三个建议</p>
<blockquote>
<ul>
<li>当我们需要监听变化并且从Provider中获取数据时，比如当数据变化时我们需要重新构建Widget，这时我们可以使用<code>ref.watch</code></li>
<li>当我们需要监听变化去执行某个动作时，我们可以使用<code>ref.listen</code></li>
<li>当我们仅需要读取数据不关心数据的变化时，比如点击某个按钮时，根据状态来判断下一步动作时，我们可以使用<code>ref.read</code></li>
</ul>
</blockquote>
<ul>
<li>ref.watch<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterProvider = StateProvider((_)=&gt; <span class="hljs-number">0</span>);<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Home</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span></span>&#123;<br>  <span class="hljs-keyword">const</span> Home(&#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> count = ref.watch(counterProvider);<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: Scaffold(<br>        appBar: AppBar(title: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;riverpod demo&quot;</span>),),<br>        body: Center(<br>          child: Column(<br>            children: [<br>              Text(<span class="hljs-string">&#x27;<span class="hljs-subst">$count</span>&#x27;</span>)<br>            ],<br>          ),<br>        ),<br>        floatingActionButton: FloatingActionButton(onPressed: ()=&gt;&#123;<br>          ref.read(counterProvider.state).state++<br>        &#125;,child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;点击&quot;</span>),),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>ref.read</li>
</ul>
<p>使用该方法可以没有任何影响的获取一次provider的状态，但是作者提示我们尽量不要使用该方法，它只是用来解决使用<code>watch|listen</code>不方便的问题，如果可以，尽量使用<code>watch|listen.</code>这里有个使用read方法的示例<a href="https://riverpod.dev/docs/concepts/combining_providers#can-i-read-a-provider-without-listening-to-it">https://riverpod.dev/docs/concepts/combining_providers#can-i-read-a-provider-without-listening-to-it</a></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterProvider = StateNotifierProvider&lt;Counter, <span class="hljs-built_in">int</span>&gt;((ref) =&gt; Counter());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> HomeView(&#123;Key? key&#125;): <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      floatingActionButton: FloatingActionButton(<br>        onPressed: () &#123;<br>          <span class="hljs-comment">// Call `increment()` on the `Counter` class</span><br>          ref.read(counterProvider.notifier).increment();<br>        &#125;,<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>ref.listen</li>
</ul>
<p>和<code>ref.watch</code>相似，我们也可以使用<code>ref.listen</code>来观察provider。他们的区别就是当provider状态变化时，我们可以调用自己定义的方法。该方法需要两个参数，第一个参数是要监听的provider对象，第二个参数是回调方法，</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterProvider = StateNotifierProvider&lt;Counter, <span class="hljs-built_in">int</span>&gt;((ref) =&gt; Counter());<br><br><span class="hljs-keyword">final</span> anotherProvider = Provider((ref) &#123;<br>  ref.listen&lt;<span class="hljs-built_in">int</span>&gt;(counterProvider, (<span class="hljs-built_in">int?</span> previousCount, <span class="hljs-built_in">int</span> newCount) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The counter changed <span class="hljs-subst">$&#123;newCount&#125;</span>&#x27;</span>);<br>  &#125;);<br>  ...<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> counterProvider = StateNotifierProvider&lt;Counter, <span class="hljs-built_in">int</span>&gt;((ref) =&gt; Counter());<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HomeView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ConsumerWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> HomeView(&#123;Key? key&#125;): <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context, WidgetRef ref) &#123;<br>    ref.listen&lt;<span class="hljs-built_in">int</span>&gt;(counterProvider, (<span class="hljs-built_in">int?</span> previousCount, <span class="hljs-built_in">int</span> newCount) &#123;<br>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The counter changed <span class="hljs-subst">$&#123;newCount&#125;</span>&#x27;</span>);<br>    &#125;);<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="决定订阅什么"><a href="#决定订阅什么" class="headerlink" title="决定订阅什么"></a>决定订阅什么</h3><p>比如我们有一个StreamProvider</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> userProvider = StreamProvider&lt;User&gt;(...);<br></code></pre></td></tr></table></figure>

<p>我们可以这么去订阅</p>
<ul>
<li>通过监听provider本身来同步获取当前状态</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Widget build(BuildContext context, WidgetRef ref) &#123;<br>  AsyncValue&lt;User&gt; user = ref.watch(userProvider);<br><br>  <span class="hljs-keyword">return</span> user.when(<br>    loading: () =&gt; <span class="hljs-keyword">const</span> CircularProgressIndicator(),<br>    error: (error, stack) =&gt; <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;Oops&#x27;</span>),<br>    data: (user) =&gt; Text(user.name),<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>通过监听<code>userProvider.stream</code>来获取对应的stream</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Widget build(BuildContext context, WidgetRef ref) &#123;<br>  Stream&lt;User&gt; user = ref.watch(userProvider.stream);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>通过监听<code>userProvider.future</code>来获取一个能得到最新状态的Future</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Widget build(BuildContext context, WidgetRef ref) &#123;<br>  Future&lt;User&gt; user = ref.watch(userProvider.future);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="使用”select”-来决定哪些值变化时进行重建"><a href="#使用”select”-来决定哪些值变化时进行重建" class="headerlink" title="使用”select” 来决定哪些值变化时进行重建"></a>使用”select” 来决定哪些值变化时进行重建</h3><p>比如我们有一个User对象</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>  <span class="hljs-built_in">String</span> <span class="hljs-keyword">get</span> name;<br>  <span class="hljs-built_in">int</span> <span class="hljs-keyword">get</span> age;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是我们在渲染页面时只用到了name属性</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Widget build(BuildContext context, WidgetRef ref) &#123;<br>  User user = ref.watch(userProvider);<br>  <span class="hljs-keyword">return</span> Text(user.name);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种情况下，如果<code>age</code>属性发生了变化，该Widget就会重建，显然这不是我们想要的。这时候我们可以使用<code>select</code>来选择对象的某些属性来监听</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Widget build(BuildContext context, WidgetRef ref) &#123;<br>  <span class="hljs-built_in">String</span> name = ref.watch(userProvider.select((user) =&gt; user.name))<br>  <span class="hljs-keyword">return</span> Text(name);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，<code>select</code>同样适用于<code>listen</code>方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">ref.listen&lt;<span class="hljs-built_in">String</span>&gt;(<br>  userProvider.select((user) =&gt; user.name),<br>  (<span class="hljs-built_in">String?</span> previousName, <span class="hljs-built_in">String</span> newName) &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The user name changed <span class="hljs-subst">$newName</span>&#x27;</span>);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure>

<p>需要注意的是，这里没必要一定返回对象的属性，只要复写了<code>==</code>的值都可以正常工作，比如</p>
<pre><code class="dart">final label = ref.watch(userProvider.select((user) =&gt; &#39;Mr $&#123;user.name&#125;&#39;));
</code></pre>
]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>riverpod</tag>
      </tags>
  </entry>
  <entry>
    <title>《我的安卓爬坑之旅》--融云IM遇到的坑</title>
    <url>/2016/12/01/%E3%80%8A%E6%88%91%E7%9A%84%E5%AE%89%E5%8D%93%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85%E3%80%8B-%E8%9E%8D%E4%BA%91IM%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>这篇博客是关于融云IM使用中遇到的问题，不算是坑，只能说是注意事项吧</p>
<span id="more"></span>
<h4 id="后端向"><a href="#后端向" class="headerlink" title="后端向"></a>后端向</h4><p>  在自己的应用”OurStories”中打算接入IM即时通讯功能，就使用了融云提供的sdk，需要自己写后台获取Token，这个比较简单，官方给出了Demo，按照自己的习惯，把demo里面的方法封装一下就可以使用了。</p>
<h4 id="Token向"><a href="#Token向" class="headerlink" title="Token向"></a>Token向</h4><ol>
<li>获取Token时可以在融云后台（登录自己帐号，控制台）可以设置Token有效期。</li>
<li>在初始情况下开发环境下最多只能有100个测试用户，当达到上限后可以点击添加用户的按钮，每次添加20人上限，生产环境没有上限。</li>
<li>开发环境和生产环境在融云后台是两套独立的环境，拥有不同的<code>App Key</code>和<code>App Secret</code>，当产品上线时不要忘记切换自己服务器和app的配置，另外，app的<code>App Key</code>和服务器端的<code>App Key</code>要一致。<h4 id="前端-Android向"><a href="#前端-Android向" class="headerlink" title="前端 Android向"></a>前端 Android向</h4></li>
<li>由于集成融云的聊天界面个会话列表界面都是Fragment形式，在集成的过程中，包含该Fragment的Activity要继承自<strong>FragmentActivity</strong>，否则在开启聊天界面的时候会报如下异常：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Caused by: android.view.InflateException: Binary XML file line #<span class="hljs-number">6</span>: Binary XML file line #<span class="hljs-number">6</span>: Error inflating <span class="hljs-keyword">class</span> <span class="hljs-title class_">fragment</span> <br>Caused by: android.view.InflateException: Binary XML file line #<span class="hljs-number">6</span>: Error inflating <span class="hljs-keyword">class</span> <span class="hljs-title class_">fragment</span> <br>Caused by: android.app.Fragment$InstantiationException: Trying to instantiate a <span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.rong.imkit.fragment.ConversationFragment that is not a Fragment <br>Caused by: java.lang.ClassCastException <br></code></pre></td></tr></table></figure></li>
<li>融云在初始化的时候建议放在Applicatuon中进行，但是融云会开启3个进程，每个进程都会执行Application的OnCreate方法，建议在初始化自己的配置时检测以下进程，在自己的主进程中初始化自己的配置.</li>
<li>千万不要忘记配置包含融云Fragment的Activity的<code>&lt;intent-filter&gt;</code></li>
<li>融云不同步也不会保存应用下的好友关系，需要自己的服务器保存</li>
<li>注意阅读融云的开发文档，注意每一个细节</li>
<li>有问题先去搜知识库，然后提工单。提工单的时候尽可能详细的描述自己的开发环境，遇到的问题以及异常日志。</li>
<li>非必要情况下，不要自己去反编译出融云的sdk，然后自己使用用其中的代码。</li>
</ol>
]]></content>
      <tags>
        <tag>Android爬坑之旅</tag>
        <tag>Android</tag>
        <tag>融云IM</tag>
      </tags>
  </entry>
  <entry>
    <title>《我的安卓爬坑之旅》-高德地图遇到的坑(2)</title>
    <url>/2017/02/25/%E3%80%8A%E6%88%91%E7%9A%84%E5%AE%89%E5%8D%93%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85%E3%80%8B-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91-2/</url>
    <content><![CDATA[<p>这篇博客是关于高德使用中遇到的问题，或许是因为开发文档中没有说明，或许是因为自己段位不够，反正就是遇到坑了。</p>
<span id="more"></span>
<h4 id="关于定位点和覆盖物"><a href="#关于定位点和覆盖物" class="headerlink" title="关于定位点和覆盖物"></a>关于定位点和覆盖物</h4><p>　　有这么一个业务需求：定位手机所在位置成功后，请求服务器数据，服务器返回手机所在地点指定范围内的的点，然后把这些点添加到地图上。<br>刚开始还没有什么问题，按照官网的demo来做的，到后来数据量多的时候就出现了marker重叠的问题。当然，marker点多的话，重叠也是无法避免的，但是，把定位的标记也给覆盖掉了，这就有点不好了。也没有查到相关的api，demo上添加定位点也是用的marker，估计都是同一级别，按照添加的先后顺序覆盖叠加。<br>后来找到了一个方法 <code>mLocMarker.setToTop();</code>这样可以把某个marker设置到最高的层级显示。还有一个方法是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDisplayLevel</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span> &#123;<br>    <span class="hljs-type">IMarkerAction</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.a.getIMarkerAction();<br>    <span class="hljs-keyword">if</span>(var2 != <span class="hljs-literal">null</span>) &#123;<br>        var2.setDisplayLevel(var1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个是Marker对象中的一个方法，但是从官方下载下来的文档中并没有提到这个方法，自己也没有去使用。了解过的朋友可以在评论区回复我一下，谢谢。</p>
<h4 id="AndroidStudio第二次编译之后地图不显示"><a href="#AndroidStudio第二次编译之后地图不显示" class="headerlink" title="AndroidStudio第二次编译之后地图不显示"></a>AndroidStudio第二次编译之后地图不显示</h4><p>　　AS2.2版本加了 <code>Instant Run</code> 模式，通常情况下这回节省我们很多时间，比如当我们修改了界面布局，想要在手机上看一下效果，没有必要重启整个应用，这个时候就可以使用 <code>Instant Run</code> 模式了，ide内部会进行判断是否需要重启整个应用，如果不需要，只会热重启当前页面。为这个功能点赞啊，有的时候页面藏的比较深，需要多步操作才能打开，这个功能可以节省很多时间。<br><img src="/image/gaode/install_run.png" alt="Install Run"><br>但是啊但是。。。我在Fragment中使用高德地图的时候，使用这个功能会出现地图加载不出来（一片空白），但是定位成功的问题。刚开始的是吓尿了，以为代码出了什么问题，直到我提了工单，看到回复后放心了：<br><img src="/image/gaode/install_run_bug.png" alt="高德工单"></p>
<blockquote>
<p>您好，Instant Run 确实是不支持这种，目前他们也没有给出解决方案，这里有详细的解释<a href="http://stackoverflow.com/questions/33902467/android-studio-2-0-why-does-instant-run-not-work-when-modifying-xml-layout-reso">http://stackoverflow.com/questions/33902467/android-studio-2-0-why-does-instant-run-not-work-when-modifying-xml-layout-reso</a><br>感谢您的致信，欢迎持续关注高德开放平台！</p>
</blockquote>
<h4 id="地图加载完成的回调函数"><a href="#地图加载完成的回调函数" class="headerlink" title="地图加载完成的回调函数"></a>地图加载完成的回调函数</h4><p>因为业务上的原因，需要在地图加载完成后做一些操作，当时官网的开发者文档上没有啊，于是又提了工单，接到回复后又放心了</p>
<blockquote>
<p>您好，AMap 提供了地图加载完成的方法， 可详见：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">aMap.setOnMapLoadedListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AMap</span>.OnMapLoadedListener() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMapLoaded</span><span class="hljs-params">()</span> &#123;<br>			&#125;<br>		&#125;);<br></code></pre></td></tr></table></figure>
<p>感谢您的致信，欢迎持续关注高德开放平台！</p>
<h4 id="步行路径规划当距离比较短时路线不在地图中间位置"><a href="#步行路径规划当距离比较短时路线不在地图中间位置" class="headerlink" title="步行路径规划当距离比较短时路线不在地图中间位置"></a>步行路径规划当距离比较短时路线不在地图中间位置</h4><p>　　由于业务上的原因，自己的位置和目的地的距离较短，需要步行路径规划，但是啊但是，路径可以规划成功，但是把路径添加到地图上的时候，路径没有显示在屏幕中间位置啊，而是诡异的飘到了一边。反复检查了N边代码，没有问题啊，和官网demo一样啊，把坐标点抠出来，改一下官网demo的起始点(就是两个坐标值),然后，也出现了路径飘到一边的情况，于是又去提了万能的工单，看到工单的回复后，我又放心了<br><img src="/image/gaode/walk_route_bug.png" alt="高德工单"></p>
<blockquote>
<p>我：Demo是从官网的demo上改的，就在<code>om.amap.map3d.demo.route</code>包下的<code>WalkRouteActivity</code>这个类里面，改了一下mStartPoint，和 mEndPoint 的值，附件图片是我修改之后的值<br> <code>private LatLonPoint mStartPoint = new LatLonPoint(39.990145, 116.481194);</code><br><code>private LatLonPoint mEndPoint = new LatLonPoint(39.99026006391499, 116.4813472288069);</code><br>从官网下载回来后只改了这两个地方，把key换成了自己的，其他地方的代码没有动。<br>如果可以的话，你们可以试一下，找两个距离非常近的点。<br>答复：<br>您好，这个问题确实是由SDK内部处理不当引起的bug，我们会在下个版本中修复，给您带来不便深表歉意<br>感谢您的致信，欢迎持续关注高德开放平台！</p>
</blockquote>
<p>解决方法：<br>判断两个点的距离，小于500米的时候，取起始点位置连线的中间位置作为地图中间点，强制将地图上的此位置拉到屏幕中间。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android爬坑之旅</tag>
        <tag>Android</tag>
        <tag>高德地图</tag>
      </tags>
  </entry>
  <entry>
    <title>vimtutor</title>
    <url>/2019/05/16/vimtutor/</url>
    <content><![CDATA[<p>安装vim后，执行vimtutor就好了。。。</p>
<pre><code class="hljs"> Vim 是一个具有很多命令的功能非常强大的编辑器。限于篇幅，在本教程当中
 就不详细介绍了。本教程的设计目标是讲述一些必要的基本命令，而掌握好这
 些命令，您就能够很容易地将 Vim 当作一个通用编辑器来使用了。

 完成本教程的内容大约需要25-30分钟，取决于您训练的时间。

 注意：
 每一节的命令操作将会更改本文。推荐您复制本文的一个副本，然后在副本上
 进行训练(如果您是通过&quot;vimtutor&quot;来启动教程的，那么本文就已经是副本了)。

 切记一点：本教程的设计思路是在使用中进行学习的。也就是说，您需要通过
 执行命令来学习它们本身的正确用法。如果您只是阅读而不操作，那么您可能
 会很快遗忘这些命令的！

 好了，现在请确定您的Shift-Lock(大小写锁定键)还没有按下，然后按键盘上
 的字母键 j 足够多次来移动光标，直到第一节的内容能够完全充满屏幕。
</code></pre>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code"><br>			第一讲第一节：移动光标<br><br><br>	     ** 要移动光标，请依照说明分别按下 h、j、k、l 键。 **<br><br>	     ^<br>	     k		    提示： h 的键位于左边，每次按下就会向左移动。<br>       &lt; h	 l &gt;		   l 的键位于右边，每次按下就会向右移动。<br>	     j			   j 键看起来很象一支尖端方向朝下的箭头。<br>	     v<br><br>  1. 请随意在屏幕内移动光标，直至您觉得舒服为止。<br><br>  2. 按下下行键(j)，直到出现光标重复下行。<br><br>---&gt; 现在您应该已经学会如何移动到下一讲吧。<br><br>  3. 现在请使用下行键，将光标移动到第一讲第二节。<br><br>提示：如果您不敢确定您所按下的字母，请按下&lt;ESC&gt;键回到正常(Normal)模式。<br>      然后再次从键盘输入您想要的命令。<br><br>提示：光标键应当也能正常工作的。但是使用hjkl键，在习惯之后您就能够更快<br>      地在屏幕内四处移动光标。真的是这样！<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			第一讲第二节：VIM的进入和退出<br><br><br>  !! 特别提示：敬请阅读本一节的完整内容，然后再执行以下所讲解的命令。<br><br>  1. 按&lt;ESC&gt;键(这是为了确保您处在正常模式)。<br><br>  2. 然后输入：			:q! &lt;回车&gt;<br>     这种方式的退出编辑器会丢弃您进入编辑器以来所做的改动。<br><br>  3. 如果您看到了命令行提示符，请输入能够带您回到本教程的命令，那就是：<br>     vimtutor &lt;回车&gt;<br><br>  4. 如果您自信已经牢牢记住了这些步骤的话，请从步骤1执行到步骤3退出，然<br>     后再次进入编辑器。<br><br>提示： :q! &lt;回车&gt; 会丢弃您所做的任何改动。几讲之后您将学会如何保存改动到文件。<br><br>  5. 将光标下移到第一讲第三节。<br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			第一讲第三节：文本编辑之删除<br><br><br>   ** 在正常(Normal)模式下，可以按下 x 键来删除光标所在位置的字符。**<br><br>  1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。<br><br>  2. 为了修正输入错误，请将光标移至准备删除的字符的位置处。<br><br>  3. 然后按下 x 键将错误字符删除掉。<br><br>  4. 重复步骤2到步骤4，直到句子修正为止。<br><br>---&gt; The ccow jumpedd ovverr thhe mooon.<br><br>  5. 好了，该行已经修正了，下面是第一讲第四节。<br><br>特别提示：在浏览本教程时，不要强行记忆。记住一点：在使用中学习。<br><br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		     第一讲第四节：文本编辑之插入<br><br><br>	 ** 在正常模式下，可以按下 i 键来插入文本。**<br><br>  1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。<br><br>  2. 为了使得第一行内容雷同于第二行，请将光标移至文本第一个准备插入字符<br>     的位置。<br><br>  3. 然后按下 i 键，接着输入必要的文本字符。<br><br>  4. 每个错误修正完毕后，请按下 &lt;ESC&gt; 键返回正常模式。<br>     重复步骤2至步骤4以便修正句子。<br><br>---&gt; There is text misng this .<br>---&gt; There is some text missing from this line.<br><br>  5. 如果您对文本插入操作已经很满意，请接着阅读下面的第一讲第五节。<br><br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		     第一讲第五节：文本编辑之添加<br><br><br>			** 按 A 键以添加文本。 **<br><br>  1. 移动光标到下面第一个标记有 ---&gt; 的一行。<br>     光标放在那一行的哪个字符上并不重要。<br><br>  2. 按 A 键输入必要的添加内容。<br><br>  3. 文本添加完毕后，按 &lt;ESC&gt; 键回到正常模式。<br><br>  4. 移动光标到下面第二个标记有 ---&gt; 的一行。重复步骤2和步骤3以改正这个句子。<br><br>---&gt; There is some text missing from th<br>     There is some text missing from this line.<br>---&gt; There is also some text miss<br>     There is also some text missing here.<br><br>  5. 当您对添加文本操作感到满意时，请继续学习第一讲第六节。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">     第一讲第六节：编辑文件<br>	<br>    ** 使用 :wq 以保存文件并退出。 **<br><br>特别提示：在执行以下步骤之前，请先读完整个小节！<br><br>1. 如您在第一讲第二节中所做的那样退出本教程： :q!<br>   或者，如果您可以访问另一个终端，请在那里执行以下操作。<br><br>2. 在 shell 的提示符下输入命令： vim tutor &lt;回车&gt;<br>   &#x27;vim&#x27;是启动 Vim 编辑器的命令，&#x27;tutor&#x27;是您希望编辑的文件的名字。<br>   请使用一个可以改动的文件。<br><br>3. 使用您在前面的教程中学到的命令插入删除文本。<br><br>4. 保存改动过的文件并退出 Vim，按这些键： :wq  &lt;回车&gt;<br><br>5. 如果您在步骤1中已经退出 vimtutor，请重启 vimtutor 移动到下面的小结一节。<br><br>6. 阅读完以上步骤，弄懂它们的意义，然后在实践中进行练习。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			       第一讲小结<br><br><br>  1. 光标在屏幕文本中的移动既可以用箭头键，也可以使用 hjkl 字母键。<br>	 h (左移)	j (下行)       k (上行)	    l (右移)<br><br>  2. 欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 &lt;回车&gt;<br><br>  3. 欲退出 Vim 编辑器，请输入 &lt;ESC&gt;   :q!   &lt;回车&gt; 放弃所有改动。<br>                      或者输入 &lt;ESC&gt;   :wq   &lt;回车&gt; 保存改动。<br><br>  4. 在正常模式下删除光标所在位置的字符，请按： x<br><br>  5. 欲插入或添加文本，请输入：<br><br>	 i   输入欲插入文本   &lt;ESC&gt;		在光标前插入文本<br>	 A   输入欲添加文本   &lt;ESC&gt;             在一行后添加文本<br><br>特别提示：按下 &lt;ESC&gt; 键会带您回到正常模式或者撤消一个不想输入或部分完整<br>的命令。<br><br>好了，第一讲到此结束。下面接下来继续第二讲的内容。<br><br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			第二讲第一节：删除类命令<br><br><br>	    ** 输入 dw 可以从光标处删除至一个单词的末尾。**<br><br>  1. 请按下 &lt;ESC&gt; 键确保您处于正常模式。<br><br>  2. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。<br><br>  3. 请将光标移至准备要删除的单词的起始处。<br><br>  4. 接着输入 dw 删除掉该单词。<br><br>  特别提示：当您输入时，字母 d 会同时出现在屏幕的最后一行。Vim 在等待您输入<br>  字母 w。如果您看到的是除 d 外的其他字符，那表明您按错了；请按下 &lt;ESC&gt; 键，<br>  然后重新再来。<br><br>---&gt; There are a some words fun that don&#x27;t belong paper in this sentence.<br><br>  5. 重复步骤3和步骤4，直至句子修正完毕。接着继续第二讲第二节内容。<br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		      第二讲第二节：更多删除类命令<br><br><br>		   ** 输入 d$ 从当前光标删除到行末。**<br><br>  1. 请按下 &lt;ESC&gt; 键确保您处于正常模式。<br><br>  2. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。<br><br>  3. 请将光标移动到该行的尾部(也就是在第一个点号‘.’后面)。<br><br>  4. 然后输入 d$ 从光标处删至当前行尾部。<br><br>---&gt; Somebody typed the end of this line twice. end of this line twice.<br><br><br>  5. 请继续学习第二讲第三节就知道是怎么回事了。<br><br><br><br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		     第二讲第三节：关于命令和对象<br><br><br>  许多改变文本的命令都由一个操作符和一个动作构成。<br>  使用删除操作符 d 的删除命令的格式如下：<br><br>	d   motion<br><br>  其中：<br>    d      - 删除操作符。<br>    motion - 操作符的操作对象(在下面列出)。<br><br>  一个简短的动作列表：<br>    w - 从当前光标当前位置直到下一个单词起始处，不包括它的第一个字符。<br>    e - 从当前光标当前位置直到单词末尾，包括最后一个字符。<br>    $ - 从当前光标当前位置直到当前行末。<br><br>  因此输入 de 会从当前光标位置删除到单词末尾。<br><br>特别提示：<br>    对于勇于探索者，请在正常模式下面仅按代表相应动作的键而不使用操作符，您<br>    将看到光标的移动正如上面的对象列表所代表的一样。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		     第二讲第四节：使用计数指定动作<br><br><br>             ** 在动作前输入数字会使它重复那么多次。 **<br><br>  1. 移动光标到下面标记有 ---&gt; 的一行的开始。<br><br>  2. 输入 2w 使光标向前移动两个单词。<br><br>  3. 输入 3e 使光标向前移动到第三个单词的末尾。<br><br>  4. 输入 0 (数字零) 移动光标到行首。<br><br>  5. 重复步骤2和步骤3，尝试不同的数字。<br><br>---&gt; This is just a line with words you can move around in.<br><br>  6. 请继续学习第二讲第五节。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		       第二讲第五节：使用计数以删除更多<br><br><br>	       ** 使用操作符时输入数字可以使它重复那么多次。 **<br><br>  上面已经提到过删除操作符和动作的组合，您可以在组合中动作之前插入一个数字以<br>  删除更多：<br>	 d   number(数字)   motion<br><br>  1. 移动光标到下面标记有 ---&gt; 的一行中第一个大写字母单词上。<br><br>  2. 输入 d2w 以删除两个大写字母单词。<br><br>  3. 重复步骤1和步骤2，使用不同的数字使得用一个命令就能删除全部相邻的大写字母<br>     单词<br><br>---&gt;  this ABC DE line FGHI JK LMN OP of words is Q RS TUV cleaned up.<br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			    第二讲第六节：操作整行<br><br><br>		     ** 输入 dd 可以删除整一个当前行。 **<br><br>  鉴于整行删除的高频度，Vi 的设计者决定要简化整行删除操作，您仅需要在同一行上<br>  击打两次 d 就可以删除掉光标所在的整行了。<br><br>  1. 请将光标移动到本节中下面的短句段落中的第二行。<br>  2. 输入 dd 删除该行。<br>  3. 然后移动到第四行。<br>  4. 接着输入 2dd 删除两行。<br><br>---&gt;  1)  Roses are red,<br>---&gt;  2)  Mud is fun,<br>---&gt;  3)  Violets are blue,<br>---&gt;  4)  I have a car,<br>---&gt;  5)  Clocks tell time,<br>---&gt;  6)  Sugar is sweet<br>---&gt;  7)  And so are you.<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			   第二讲第七节：撤消类命令<br><br><br>	** 输入 u 来撤消最后执行的命令，输入 U 来撤消对整行的修改。 **<br><br>  1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行，并将其置于第一个错误<br>     处。<br>  2. 输入 x 删除第一个不想保留的字母。<br>  3. 然后输入 u 撤消最后执行的(一次)命令。<br>  4. 这次要使用 x 修正本行的所有错误。<br>  5. 现在输入一个大写的 U ，恢复到该行的原始状态。<br>  6. 接着多次输入 u 以撤消 U 以及更前的命令。<br>  7. 然后多次输入 CTRL-R (先按下 CTRL 键不放开，接着按 R 键)，这样就<br>     可以重做被撤消的命令，也就是撤消掉撤消命令。<br><br>---&gt; Fiix the errors oon thhis line and reeplace them witth undo.<br><br>  8. 这些都是非常有用的命令。下面是第二讲的小结了。<br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">	       第二讲小结<br><br><br>1. 欲从当前光标删除至下一个单词，请输入：dw<br>2. 欲从当前光标删除至当前行末尾，请输入：d$<br>3. 欲删除整行，请输入：dd<br><br>4. 欲重复一个动作，请在它前面加上一个数字：2w<br>5. 在正常模式下修改命令的格式是：<br>             operator   [number]   motion<br>   其中：<br>     operator - 操作符，代表要做的事情，比如 d 代表删除<br>     [number] - 可以附加的数字，代表动作重复的次数<br>     motion   - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)，<br>  $ 代表行末等等。<br><br>6. 欲移动光标到行首，请按数字0键：0<br><br>7. 欲撤消以前的操作，请输入：u (小写的u)<br>   欲撤消在一行中所做的改动，请输入：U (大写的U)<br>   欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			   第三讲第一节：置入类命令<br><br><br>		** 输入 p 将最后一次删除的内容置入光标之后。 **<br><br>  1. 请将光标移动到本节中下面第一个标记有 ---&gt; 的一行。<br><br>  2. 输入 dd 将该行删除，这样会将该行保存到 Vim 的一个寄存器中。<br><br>  3. 接着将光标移动到 c) 一行，即准备置入的位置的上方。记住：是上方哦。<br><br>  4. 然后在正常模式下(&lt;ESC&gt;键进入)输入 p 将该行粘贴置入。<br><br>  5. 重复步骤2至步骤4，将所有的行依序放置到正确的位置上。<br><br>---&gt; d) Can you learn too?<br>---&gt; b) Violets are blue,<br>---&gt; c) Intelligence is learned,<br>---&gt; a) Roses are red,<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			   第三讲第二节：替换类命令<br><br><br>	  ** 输入 r 和一个字符替换光标所在位置的字符。**<br><br>  1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。<br><br>  2. 请移动光标到第一个出错的位置。<br><br>  3. 接着输入 r 和要替换成的字符，这样就能将错误替换掉了。<br><br>  4. 重复步骤2和步骤3，直到第一行已经修改完毕。<br><br>---&gt;  Whan this lime was tuoed in, someone presswd some wrojg keys!<br>---&gt;  When this line was typed in, someone pressed some wrong keys!<br><br>  5. 然后我们继续学习第三讲第三节。<br><br>特别提示：切记您要在使用中学习，而不是在记忆中学习。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			第三讲第三节：更改类命令<br><br><br>		 ** 要改变文本直到一个单词的末尾，请输入 ce **<br><br>  1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。<br><br>  2. 接着把光标放在单词 lubw 的字母 u 的位置那里。<br><br>  3. 然后输入 cw 以及正确的单词(在本例中是输入 ine )。<br><br>  4. 最后按 &lt;ESC&gt; 键，然后光标定位到下一个错误第一个准备更改的字母处。<br><br>  5. 重复步骤3和步骤4，直到第一个句子完全雷同第二个句子。<br><br>---&gt; This lubw has a few wptfd that mrrf changing usf the change operator.<br>---&gt; This line has a few words that need changing using the change operator.<br><br>提示：请注意 ce 命令不仅仅是删除了一个单词，它也让您进入插入模式了。<br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		       第三讲第四节：使用c更改更多<br><br><br>	   ** 更改类操作符可以与删除中使用的同样的动作配合使用。 **<br><br>  1. 更改类操作符的工作方式跟删除类是一致的。操作格式是：<br><br>         c    [number]   motion<br><br>  2. 动作参数(motion)也是一样的，比如 w 代表单词，$代表行末等等。<br><br>  3. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。<br><br>  4. 接着将光标移动到第一个错误处。<br><br>  5. 然后输入 c$ 使得该行剩下的部分更正得同第二行一样。最后按 &lt;ESC&gt; 键。<br><br>---&gt; The end of this line needs some help to make it like the second.<br>---&gt; The end of this line needs to be corrected using the  c$  command.<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">				  第三讲小结<br><br><br>  1. 要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除<br>     的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置<br>     于当前光标所在行的下一行。<br><br>  2. 要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字<br>     符即可。<br><br>  3. 更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。<br>     比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当<br>     前光标到行末的内容。<br><br>  4. 更改类命令的格式是：<br><br>	 c   [number]   motion<br><br>现在我们继续学习下一讲。<br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		     第四讲第一节：定位及文件状态<br><br>  ** 输入 CTRL-G 显示当前编辑文件中当前光标所在行位置以及文件状态信息。<br>     输入大写 G 则直接跳转到文件中的某一指定行。**<br><br>  提示：切记要先通读本节内容，之后才可以执行以下步骤!!!<br><br>  1. 按下 CTRL 键不放开然后按 g 键。我们称这个键组合为 CTRL-G。<br>     您会看到页面最底部出现一个状态信息行，显示的内容是当前编辑的文件名<br>     和文件中光标位置。请记住行号，它会在步骤3中用到。<br><br>提示：您也许会在屏幕的右下角看到光标位置，这会在 &#x27;ruler&#x27; 选项设置时发生<br>      (参见 :help &#x27;ruler&#x27;)<br><br>  2. 输入大写 G 可以使得当前光标直接跳转到文件最后一行。<br>     输入 gg 可以使得当前光标直接跳转到文件第一行。<br><br>  3. 输入您曾停留的行号，然后输入大写 G。这样就可以返回到您第一次按下<br>     CTRL-G 时所在的行了。<br><br>  4. 如果您觉得没问题的话，请执行步骤1至步骤3的操作进行练习。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			第四讲第二节：搜索类命令<br><br><br>     ** 输入 / 加上一个字符串可以用以在当前文件中查找该字符串。**<br><br>  1. 在正常模式下输入 / 字符。您此时会注意到该字符和光标都会出现在屏幕底<br>     部，这跟 : 命令是一样的。<br><br>  2. 接着输入 errroor &lt;回车&gt;。那个errroor就是您要查找的字符串。<br><br>  3. 要查找同上一次的字符串，只需要按 n 键。要向相反方向查找同上一次的字<br>     符串，请输入大写 N 即可。<br><br>  4. 如果您想逆向查找字符串，请使用 ? 代替 / 进行。<br><br>  5. 要回到您之前的位置按 CTRL-O (按住 Ctrl 键不放同时按下字母 o)。重复按可以<br>     回退更多步。CTRL-I 会跳转到较新的位置。<br><br>---&gt;  &quot;errroor&quot; is not the way to spell error;  errroor is an error.<br>提示：如果查找已经到达文件末尾，查找会自动从文件头部继续查找，除非<br>      &#x27;wrapscan&#x27; 选项被复位。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code"><br>		   第四讲第三节：配对括号的查找<br><br><br>	      ** 输入 % 可以查找配对的括号 )、]、&#125;。**<br><br>  1. 把光标放在本节下面标记有 --&gt; 那一行中的任何一个 (、[ 或 &#123; 处。<br><br>  2. 接着按 % 字符。<br><br>  3. 此时光标的位置应当是在配对的括号处。<br><br>  4. 再次按 % 就可以跳回配对的第一个括号处。<br><br>  5. 移动光标到另一个 (、)、[、]、&#123; 或 &#125; 处，按 % 查看其所作所为。<br><br>---&gt; This ( is a test line with (&#x27;s, [&#x27;s ] and &#123;&#x27;s &#125; in it. ))<br><br><br>提示：在程序调试时，这个功能用来查找不配对的括号是很有用的。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		      第四讲第四节：替换命令<br><br><br>		** 输入 :s/old/new/g 可以替换 old 为 new。**<br><br>  1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。<br><br>  2. 输入 :s/thee/the &lt;回车&gt; 。请注意该命令只改变光标所在行的第一个匹配<br>     串。<br><br>  3. 输入 :s/thee/the/g	则是替换全行的匹配串，该行中所有的 &quot;thee&quot; 都会被<br>     改变。<br><br>---&gt; thee best time to see thee flowers is in thee spring.<br><br>  4. 要替换两行之间出现的每个匹配串，请<br>     输入   :#,#s/old/new/g   其中 #,# 代表的是替换操作的若干行中<br>                              首尾两行的行号。<br>     输入   :%s/old/new/g     则是替换整个文件中的每个匹配串。<br>     输入   :%s/old/new/gc    会找到整个文件中的每个匹配串，并且对每个匹配串<br>                              提示是否进行替换。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">	       第四讲小结<br><br><br>1. CTRL-G 用于显示当前光标所在位置和文件状态信息。<br>   G 用于将光标跳转至文件最后一行。<br>   先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。<br>   gg 用于将光标跳转至文件第一行。<br><br>2. 输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。<br>   输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。<br>   完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查<br>   找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。<br>   CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。<br><br>3. 如果光标当前位置是括号(、)、[、]、&#123;、&#125;，按 % 会将光标移动到配对的括号上。<br><br>4. 在一行内替换头一个字符串 old 为新的字符串 new，请输入  :s/old/new<br>   在一行内替换所有的字符串 old 为新的字符串 new，请输入  :s/old/new/g<br>   在两行内替换所有的字符串 old 为新的字符串 new，请输入  :#,#s/old/new/g<br>   在文件内替换所有的字符串 old 为新的字符串 new，请输入  :%s/old/new/g<br>   进行全文替换时询问用户确认每个替换需添加 c 标志        :%s/old/new/gc<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		第五讲第一节：在 VIM 内执行外部命令的方法<br><br><br>	   ** 输入 :! 然后紧接着输入一个外部命令可以执行该外部命令。**<br><br>  1. 按下我们所熟悉的 : 命令使光标移动到屏幕底部。这样您就可以输入一行命令了。<br><br>  2. 接着输入感叹号 ! 这个字符，这样就允许您执行外部的 shell 命令了。<br><br>  3. 我们以 ls 命令为例。输入 !ls &lt;回车&gt; 。该命令就会列举出您当前目录的<br>     内容，就如同您在命令行提示符下输入 ls 命令的结果一样。如果 !ls 没起<br>     作用，您可以试试 :!dir 看看。<br><br>提示：所有的外部命令都可以以这种方式执行，包括带命令行参数的那些。<br><br>提示：所有的 : 命令都必须以敲 &lt;回车&gt; 键结束。从今以后我们就不会总是提到这一点<br>      了。<br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		      第五讲第二节：关于保存文件的更多信息<br><br><br>	     ** 要将对文件的改动保存到文件中，请输入 :w FILENAME 。**<br><br>  1. 输入 :!dir 或者 :!ls 获知当前目录的内容。您应当已知道最后还得敲<br>     &lt;回车&gt; 吧。<br><br>  2. 选择一个未被用到的文件名，比如 TEST。<br><br>  3. 接着输入 :w TEST  (此处 TEST 是您所选择的文件名。)<br><br>  4. 该命令会以 TEST 为文件名保存整个文件 (Vim 教程)。为了验证这一点，<br>     请再次输入 :!dir 或 :!ls 查看您的目录列表内容。<br><br>请注意：如果您退出 Vim 然后在以命令 vim TEST 再次启动 Vim，那么该文件内<br>     容应该同您保存时的文件内容是完全一样的。<br><br>  5. 现在您可以删除 TEST 文件了。在 MS-DOS 下，请输入：   :!del TEST<br>                                 在 Unix 下，请输入：     :!rm TEST<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		    第五讲第三节：一个具有选择性的保存命令<br><br><br>	    ** 要保存文件的部分内容，请输入 v motion :w FILENAME **<br><br>  1. 移动光标到本行。<br><br>  2. 接着按 v 键，将光标移动至下面第五个条目上。您会注意到之间的文本被高亮了。<br><br>  3. 然后按 : 字符。您将看到屏幕底部会出现 :&#x27;&lt;,&#x27;&gt; 。<br><br>  4. 现在请输入 w TEST，其中 TEST 是一个未被使用的文件名。确认您看到了<br>     :&#x27;&lt;,&#x27;&gt;w TEST 之后按 &lt;回车&gt; 键。<br><br>  5. 这时 Vim 会把选中的行写入到以 TEST 命名的文件中去。使用 :!dir 或 :!ls<br>     确认文件被正确保存。这次先别删除它！我们在下一讲中会用到它。<br><br>提示：按 v 键使 Vim 进入可视模式进行选取。您可以四处移动光标使选取区域变大或<br>      变小。接着您可以使用一个操作符对选中文本进行操作。例如，按 d 键会删除<br>      选中的文本内容。<br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		   第五讲第四节：提取和合并文件<br><br><br>       ** 要向当前文件中插入另外的文件的内容，请输入 :r FILENAME **<br><br>  1. 请把光标移动到本行上面一行。<br><br>特别提示：执行步骤2之后您将看到第五讲第三节的文字，请届时往下移动<br>          以再次看到本讲内容。<br><br>  2. 接着通过命令 :r TEST 将前面创建的名为 TEST 的文件提取进来。<br>     您所提取进来的文件将从光标所在位置处开始置入。<br><br>  3. 为了确认文件已经提取成功，移动光标回到原来的位置就可以注意有两份第<br>     五讲第三节的内容，一份是原始内容，另外一份是来自文件的副本。<br><br>提示：您还可以读取外部命令的输出。例如， :r !ls 可以读取 ls 命令的输出，并<br>      把它放置在光标下面。<br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">	       第五讲小结<br><br><br>1. :!command 用于执行一个外部命令 command。<br><br>   请看一些实际例子：<br>(MS-DOS)	  (Unix)<br> :!dir		   :!ls		   -  用于显示当前目录的内容。<br> :!del FILENAME   :!rm FILENAME   -  用于删除名为 FILENAME 的文件。<br><br>2. :w FILENAME  可将当前 VIM 中正在编辑的文件保存到名为 FILENAME 的文<br>   件中。<br><br>3. v motion :w FILENAME 可将当前编辑文件中可视模式下选中的内容保存到文件<br>   FILENAME 中。<br><br>4. :r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置<br>   后面。<br><br>5. :r !dir 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			 第六讲第一节：打开类命令<br><br><br>	 ** 输入 o 将在光标的下方打开新的一行并进入插入模式。**<br><br>  1. 请将光标移动到本节中下面标记有 ---&gt; 的那一行。<br><br>  2. 接着输入小写的 o 在光标 *下方* 打开新的一行，这个命令会使您<br>     进入插入模式。<br><br>  3. 然后输入一些文字，之后按 &lt;ESC&gt; 键退出插入模式而进入正常模式。<br><br>---&gt; After typing  o  the cursor is placed on the open line in Insert mode.<br><br>  4. 为了在光标 *上方* 打开新的一行，只需要输入大写的 O 而不是小写的 o<br>     就可以了。请在下行测试一下吧。<br><br>---&gt; Open up a line above this by typing O while the cursor is on this line.<br><br><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			第六讲第二节：附加类命令<br><br><br>		     ** 输入 a 将可在光标之后插入文本。 **<br><br>  1. 请在正常模式下将光标移动到本节中下面标记有 ---&gt; 的第一行的行首。<br><br>  2. 接着输入 e 直到光标位于 li 的末尾。<br><br>  3. 输入小写的 a 则可在光标之后插入文本了。<br><br>  4. 将单词补充完整，就像下一行中的那样。之后按 &lt;ESC&gt; 键退出插入模式回到<br>     正常模式。<br><br>  5. 使用 e 移动光标到下一步不完整的单词，重复步骤3和步骤4。<br><br>---&gt; This li will allow you to pract appendi text to a line.<br>---&gt; This line will allow you to practice appending text to a line.<br><br>提示：a、i 和 A 都会带您进入插入模式，惟一的区别在于字符插入的位置。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		    第六讲第三节：另外一个置换类命令的版本<br><br><br>		      ** 输入大写的 R 可连续替换多个字符。**<br><br>  1. 请将光标移动到本节中下面标记有 ---&gt; 的第一行。移动光标到第一个 xxx 的<br>     起始位置。<br><br>  2. 然后输入大写的 R 开始把第一行中的不同于第二行的剩余字符逐一输入，就<br>     可以全部替换掉原有的字符而使得第一行完全雷同第二行了。<br><br>  3. 接着按 &lt;ESC&gt; 键退出替换模式回到正常模式。您可以注意到尚未替换的文本<br>     仍然保持原状。<br><br>  4. 重复以上步骤，将剩余的 xxx 也替换掉。<br><br>---&gt; Adding 123 to xxx gives you xxx.<br>---&gt; Adding 123 to 456 gives you 579.<br><br>提示：替换模式与插入模式相似，不过每个输入的字符都会删除一个已有的字符。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			  第六讲第四节：复制粘贴文本<br><br><br>		 ** 使用操作符 y 复制文本，使用 p 粘贴文本 **<br><br>  1. 定位到下面标记有 ---&gt; 的一行，将光标移动到 &quot;a)&quot; 之后。<br><br>  2. 接着使用 v 进入可视模式，移动光标到 &quot;first&quot; 的前面。<br><br>  3. 现在输入 y 以抽出(复制)高亮的文本。<br><br>  4. 然后移动光标到下一行的末尾：j$<br><br>  5. 接着输入 p 以放置(粘贴)复制了的文本。然后输入：a second &lt;ESC&gt;。<br><br>  6. 使用可视模式选中 &quot; item.&quot;，用 y 复制，再用 j$ 将光标移动到下一行末尾，<br>     用 p 将文本粘贴到那里。<br><br>---&gt;  a) this is the first item.<br>      b)<br><br>  提示：您还可以把 y 当作操作符来使用；例如 yw 可以用来复制一个单词。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			    第六讲第五节：设置类命令的选项<br><br><br>		  ** 设置可使查找或者替换可忽略大小写的选项 **<br><br>  1. 要查找单词 ignore 可在正常模式下输入 /ignore &lt;回车&gt;。<br>     要重复查找该词，可以重复按 n 键。<br><br>  2. 然后设置 ic 选项(Ignore Case，忽略大小写)，请输入： :set ic<br><br>  3. 现在可以通过键入 n 键再次查找单词 ignore。注意到 Ignore 和 IGNORE 现在<br>     也被找到了。<br><br>  4. 然后设置 hlsearch 和 incsearch 这两个选项，请输入： :set hls is<br><br>  5. 现在可以再次输入查找命令，看看会有什么效果： /ignore &lt;回车&gt;<br><br>  6. 要禁用忽略大小写，请输入： :set noic<br><br>提示：要移除匹配项的高亮显示，请输入：  :nohlsearch<br>提示：如果您想要仅在一次查找时忽略字母大小写，您可以使用 \c：<br>      /ignore\c &lt;回车&gt;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		       第六讲小结<br><br> 1. 输入小写的 o 可以在光标下方打开新的一行并进入插入模式。<br>    输入大写的 O 可以在光标上方打开新的一行。<br><br> 2. 输入小写的 a 可以在光标所在位置之后插入文本。<br>    输入大写的 A 可以在光标所在行的行末之后插入文本。<br><br> 3. e 命令可以使光标移动到单词末尾。<br><br> 4. 操作符 y 复制文本，p 粘贴先前复制的文本。<br><br> 5. 输入大写的 R 将进入替换模式，直至按 &lt;ESC&gt; 键回到正常模式。<br><br> 6. 输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下：<br>   	&#x27;ic&#x27; &#x27;ignorecase&#x27;	查找时忽略字母大小写<br>&#x27;is&#x27; &#x27;incsearch&#x27;	查找短语时显示部分匹配<br>&#x27;hls&#x27; &#x27;hlsearch&#x27;	高亮显示所有的匹配短语<br>    选项名可以用完整版本，也可以用缩略版本。<br><br> 7. 在选项前加上 no 可以关闭选项：  :set noic<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		  第七讲第一节：获取帮助信息<br><br><br>	      ** 使用在线帮助系统 **<br><br> Vim 拥有一个细致全面的在线帮助系统。要启动该帮助系统，请选择如下三种方<br> 法之一：<br>- 按下 &lt;HELP&gt; 键 (如果键盘上有的话)<br>- 按下 &lt;F1&gt; 键 (如果键盘上有的话)<br>- 输入	:help &lt;回车&gt;<br><br> 请阅读帮助窗口中的文字以了解帮助是如何工作的。<br> 输入 CTRL-W CTRL-W   可以使您在窗口之间跳转。<br> 输入 :q &lt;回车&gt; 可以关闭帮助窗口。<br><br> 提供一个正确的参数给&quot;:help&quot;命令，您可以找到关于该主题的帮助。请试验以<br> 下参数(可别忘了按回车键哦)：<br><br>:help w<br>:help c_CTRL-D<br>:help insert-index<br>:help user-manual<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">	  第七讲第二节：创建启动脚本<br><br><br>	  ** 启用 Vim 的特性 **<br><br>Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的<br>特性，您得创建一个 vimrc 文件。<br><br>1. 开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统：<br>      :edit ~/.vimrc		这是 Unix 系统所使用的命令<br>      :edit $VIM/_vimrc	这是 MS-Windows 系统所使用的命令<br><br>2. 接着读取 vimrc 示例文件的内容：<br>      :r $VIMRUNTIME/vimrc_example.vim<br><br>3. 保存文件，命令为：<br>      :write<br><br>下次您启动 Vim 时，编辑器就会有了语法高亮的功能。<br>您可以把您喜欢的各种设置添加到这个 vimrc 文件中。<br>要了解更多信息请输入 :help vimrc-intro<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">			    第七讲第三节：补全功能<br><br><br>	      ** 使用 CTRL-D 和 &lt;TAB&gt; 可以进行命令行补全 **<br><br>  1. 请确保 Vim 不是在以兼容模式运行： :set nocp<br><br>  2. 查看一下当前目录下已经存在哪些文件，输入： :!ls   或者  :!dir<br><br>  3. 现在输入一个目录的起始部分，例如输入： :e<br><br>  4. 接着按 CTRL-D 键，Vim 会显示以 e 开始的命令的列表。<br><br>  5. 然后按 &lt;TAB&gt; 键，Vim 会补全命令为 :edit 。<br><br>  6. 现在添加一个空格，以及一个已有文件的文件名的起始部分，例如： :edit FIL<br><br>  7. 接着按 &lt;TAB&gt; 键，Vim 会补全文件名(如果它是惟一匹配的)。<br><br>提示：补全对于许多命令都有效。您只需尝试按 CTRL-D 和 &lt;TAB&gt;。<br>      它对于 :help 命令非常有用。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code">		  第七讲小结<br><br><br>1. 输入 :help 或者按 &lt;F1&gt; 键或 &lt;Help&gt; 键可以打开帮助窗口。<br><br>2. 输入 :help cmd 可以找到关于 cmd 命令的帮助。<br><br>3. 输入 CTRL-W CTRL-W  可以使您在窗口之间跳转。<br><br>4. 输入 :q 以关闭帮助窗口<br><br>5. 您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。<br><br>6. 当输入 : 命令时，按 CTRL-D 可以查看可能的补全结果。<br>   按 &lt;TAB&gt; 可以使用一个补全。<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs code"><br> vim 教程到此就结束了。本教程只是为了简明地介绍一下 Vim 编辑器，但已足以让您<br> 很容易使用这个编辑器了。毋庸质疑，vim还有很多很多的命令，本教程所介<br> 绍的距离完整的差得很远。所以您要精通的话，还望继续努力哦。下一步您可以阅读<br> Vim 的用户手册，使用的命令是： :help user-manual<br><br> 下面这本书值得推荐用于更进一步的阅读和学习：<br>Vim - Vi Improved - 作者：Steve Oualline<br>出版社：New Riders<br> 这是第一本完全讲解 Vim 的书籍。它对于初学者特别有用。其中包含有大量实例<br> 和图示。<br> 欲知详情，请访问 http://iccf-holland.org/click5.html<br><br> 以下这本书比较老了而且内容更多是关于 Vi 而非 Vim，但是也值得推荐：<br>Learning the Vi Editor - 作者：Linda Lamb<br>出版社：O&#x27;Reilly &amp; Associates Inc.<br> 这是一本不错的书，通过它您几乎能够了解到任何您想要使用 Vi 做的事情。<br> 此书的第六个版本也包含了一些关于 Vim 的信息。<br><br> 本教程是由来自 Calorado School of Mines 的 Michael C. Pierce 和<br> Robert K. Ware 所编写的，其中很多创意由来自 Colorado State University 的<br> Charles Smith 提供。编者的电子邮箱是：bware@mines.colorado.edu<br><br> 本教程已由 Bram Moolenaar 专为 Vim 进行修订。<br><br> 译制者附言：<br> ===========<br>     简体中文教程翻译版之译制者为梁昌泰 &lt;beos@turbolinux.com.cn&gt;，还有<br>     另外一个联系地址：linuxrat@gnuchina.org。<br><br>     繁体中文教程是从简体中文教程翻译版使用 Debian GNU/Linux 中文项目小<br>     组的于广辉先生编写的中文汉字转码器  autoconvert 转换而成的，并对转<br>     换的结果做了一些细节的改动。<br><br> 变更记录：<br> =========<br>     2012年10月01日 赵涛 &lt;alick9188@gmail.com&gt;<br>     将 vimtutor 中译版从 1.5 升级到 1.7。<br><br>     2002年08月30日 梁昌泰 &lt;beos@turbolinux.com.cn&gt;<br>     感谢 RMS@SMTH 的指正，将多处错误修正。<br><br>     2002年04月22日 梁昌泰 &lt;linuxrat@gnuchina.org&gt;<br>     感谢 xuandong@sh163.net 的指正，将两处错别字修正。<br><br>     2002年03月18日 梁昌泰 &lt;linuxrat@gnuchina.org&gt;<br>     根据Bram Moolenaar先生在2002年03月16日的来信要求，将vimtutor1.4中译<br>     版升级到vimtutor1.5。<br><br>     2001年11月15日 梁昌泰 &lt;linuxrat@gnuchina.org&gt;<br>     将vimtutor1.4中译版提交给Bram Moolenaar和Sven Guckes。<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>《我的安卓爬坑之旅》--高德地图遇到的坑</title>
    <url>/2016/12/18/%E3%80%8A%E6%88%91%E7%9A%84%E5%AE%89%E5%8D%93%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85%E3%80%8B-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91-1/</url>
    <content><![CDATA[<p>这篇博客是关于高德使用中遇到的问题，或许是因为开发文档中没有说明，或许是因为自己段位不够，反正就是遇到坑了。</p>
<span id="more"></span>
<p>####生成key</p>
<ol>
<li>生成key的时候，同一个app下，可以填入相同的包名、key名称等。注意不要用错了key</li>
<li>由于高德地图升级的原因，需要将原来没有整理过的key先整理，使其属于某个应用，才可以继续创建其他的key。</li>
</ol>
<p>####文档</p>
<ol>
<li>仅在入门指南中提到了需要加入 <strong><code>&lt;service android:name=&quot;com.amap.api.location.APSService&quot;&gt;&lt;/service&gt;</code></strong><br>开发注意事项里面居然没有提到。最关键的是，没有加入这个service时，定位有时还能成功，只是不能连续定位。我看的时候时从开发注意事项开始看的，完全没有注意到这一点，后来在demo中看到了需要加入这个配置，才能生效。</li>
<li>文档里面只给出了部分关键代码和部分关键类，完全不知道这个类怎么实例化，怎么去调用方法，调用方法的时候需要传入哪种类型的参数。<hr>就我个人看来，看官方api文档还不如去看他们的demo，文档写的真心不算好。
官方部分demo地址[官方demo地址](http://lbs.amap.com/dev/demo) 
官方sdk以及开发文档、demo等相关下载[官方sdk、开发文档以及demo](http://lbs.amap.com/api/android-sdk/download/) 
以后遇到坑再补充吧，估计遇到的都是文档中没有标明但在demo中有示例的那种。</li>
</ol>
]]></content>
      <tags>
        <tag>Android爬坑之旅</tag>
        <tag>Android</tag>
        <tag>高德地图</tag>
      </tags>
  </entry>
  <entry>
    <title>《我的安卓爬坑之旅》-高德地图遇到的坑-3</title>
    <url>/2017/12/19/%E3%80%8A%E6%88%91%E7%9A%84%E5%AE%89%E5%8D%93%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85%E3%80%8B-%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91-3/</url>
    <content><![CDATA[<p>这次是逆地理位置编码出现的坑，在提交工单后，官方回复是badcase，已经收录，后续着手优化。<br>SDK版本号：<code>com.amap.api:location:3.6.1</code>、<code>com.amap.api:map3d:4.1.3</code>、<code>com.amap.api:map3d-native:4.1.3</code>、<code>com.amap.api:search:5.5.0</code>。</p>
<span id="more"></span>
<p>过程如下：<br>2017年12月5号接到用户反馈，定位位置准确，但是显示的中文具体位置不准确，误差大概在千米级别。当时就麻爪了，这可不是误差，这是错误。</p>
<ol>
<li>首先排除网络以及信号问题：<br>根据用户反馈，得知用户所在位置信号良好，周围不存在遮盖物，也不在地下室之类的信号差的地方，不存在定位偏差问题(app上显示的定位和手机位置一致)。<br>网络状况良好，浏览器可以打开网页、app可以进行其他操作。<br>先排除用户使用情况的原因是：接到过多次反馈，是因为用户没有看app提示，或者直接忽略掉提示导致的误报。</li>
<li>排除代码问题</li>
</ol>
<ul>
<li>在测试服上进行同样操作，得到的坐标值正确(手机拿到坐标值在app上显示，然后把坐标拿到高德坐标拾取系统进行定位，显示位置一致)，定位以及展示代码没问题。</li>
<li>拿到坐标值在客户端进行逆地理位置编码(<code>RegeocodeQuery query = new RegeocodeQuery(new LatLonPoint(lat, lon), 200,GeocodeSearch.AMAP); geocoderSearch.getFromLocationAsyn(query);</code>)，得到的地理位置正确，误差在所传参数以内，改变逆地理位置编码的经确定，改变定位位置(北京市内随机取点)，多次操作，定位及展示以及逆地理位置编码均正确。<br>到这，就有点抓狂了，这TM什么问题，到底哪里出问题了。。</li>
<li>全国范围内取点，代码参数和生产环境保持一致，祈祷着或许是因为在新疆这种空旷、建筑物少的地方，误差可能会大些(好几公里没有建筑物，没有明显地标，总不能展示第几课白杨树下吧，23333)。抓到了偏远地区的坐标以及十分空旷地区的坐标，展示以及你地理位置编码均正确。</li>
<li>这时候也冷静下来了，出了问题不一定是自己代码问题吗，有可能是二方、三方代码的锅，只是习惯上养成了出了问题先找自己的原因，找不到再找其他的。找高德，提工单，详细描述问题：<blockquote>
<p>具体情况这样：<br>我把(119.564298,31.995402)这个坐标用客户端调用逆地理位置编码接口:<br>RegeocodeQuery query &#x3D; new RegeocodeQuery(new LatLonPoint(lat, lon), 200,GeocodeSearch.AMAP);<br>geocoderSearch.getFromLocationAsyn(query);<br>在回调函数public void onRegeocodeSearched(RegeocodeResult result, int rCode)中取得结果：result.getRegeocodeAddress().getFormatAddress() 是<strong>江苏省镇江市丹阳市云阳镇北环路6号</strong>。<br>但实际上<strong>江苏省镇江市丹阳市云阳镇北环路6号</strong>这个地址与上述坐标点距离很远(这个是在高德坐标拾取器 <a href="http://lbs.amap.com/console/show/picker">http://lbs.amap.com/console/show/picker</a> 上看到的)。</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>高德回复<br>第二天高德给了回复：<blockquote>
<p>您好，感谢反馈，目前这块的算法确实有一些问题，您的badcase我们已经收录，后续会针对这块做优化。给您造成不便敬请谅解。<br>感谢您的致信，欢迎持续关注高德开放平台！</p>
</blockquote>
</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/image/gaode/geocoderSearch_bug.png" alt="geocoderSearch"></h2><p>以上</p>
]]></content>
      <tags>
        <tag>Android爬坑之旅</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>仓颉-认识仓颉语言</title>
    <url>/2025/06/14/%E4%BB%93%E9%A2%89-%E8%AE%A4%E8%AF%86%E4%BB%93%E9%A2%89%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>昨天在群里看到消息<code>HarmonyOS NEXT Cangjie正式版本测试活动</code>正在招募，作为已经参加仓颉鸿蒙测试版内测快两年的不会仓颉语言的开发人员，当然要参与一波了。<br>不过可惜的是这次是小范围招募，问卷链接也不让转发<br><img src="/image/cangjie/%E4%BB%93%E9%A2%89-%E9%B8%BF%E8%92%99%E6%AD%A3%E5%BC%8F%E7%89%88%E6%8B%9B%E5%8B%9F.png" alt="仓颉-鸿蒙正式版招募"><br>既然已经开始正式版测试活动了，想来距离正式发布也不远了，内测了快两年的仓颉新手开发，现在也应该开始学一下仓颉了。</p>
<blockquote>
<p>Q:为啥之前没有学习仓颉？<br>A:之前在做鸿蒙项目的时候，一直在用ArkTS，仓颉一直在beta版本，我们也没有在项目中使用。所以就没有去学习。</p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>现在官网能下载到的版本是 0.53.18，社区测试版本是0.60.5，并没有太大的差异。<br>另外仓颉相关的官方代码代码仓库已经迁移到了gitcode：<a href="https://gitcode.com/Cangjie%E3%80%82">https://gitcode.com/Cangjie。</a></p>
]]></content>
      <tags>
        <tag>仓颉</tag>
      </tags>
  </entry>
  <entry>
    <title>使用express模拟后台返回数据</title>
    <url>/2018/09/27/%E4%BD%BF%E7%94%A8express%E6%A8%A1%E6%8B%9F%E5%90%8E%E5%8F%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>在研发过程中，有时候会遇到前端写完了，但是后端接口还没有完成的情况。一般情况下我们会写一些假数据来填充UI，这种方式没有办法检测网络请求有没有问题。我们可以自己搭一个服务，请求自己的服务来返回一些模拟数据。比如可以使用node和express模块来做。</p>
<span id="more"></span>
<h4 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h4><p>官网自己查<br>安装node会自动安装npm包管理工具，检查是否有安装node和npm包管理工具，可以通过执行<code>node -v</code> 和 <code>npm -v</code>来查看，如果已经安装则会输出对应的版本号<br><img src="/image/Android/express/node_and_npm.png" alt="node和npm"></p>
<h4 id="安装express"><a href="#安装express" class="headerlink" title="安装express"></a>安装express</h4><p>官网在这里 <a href="http://expressjs.com/zh-cn/">http://expressjs.com/zh-cn/</a></p>
<ol>
<li>全局安装 <code>express-generator</code><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">npm install -g express-generator<br></code></pre></td></tr></table></figure></li>
<li>创建一个测试工程<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">express --view=pug testExpress<br></code></pre></td></tr></table></figure>
成功后会自动在目标位置创建一个名为myapp的项目并生成很多文件<br><img src="/image/Android/express/create_myapp.png" alt="创建myapp"><br>然后根据提示执行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd testExpress &amp;&amp; npm install<br></code></pre></td></tr></table></figure>

<p>之后执行 <code>npm start</code><br>提示 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">myapp@0.0.0 start /Users/huangyuan/myapp</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">node ./bin/www</span><br></code></pre></td></tr></table></figure>

<p>表示启动服务成功，然后在浏览器输入<code>http://127.0.0.1:3000</code>,界面显示<code>Welcome to Express</code>说明服务已经启动成功</p>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>安装完成后整个工程目录结构如下：<br><img src="/image/Android/express/myapp_constructor.png" alt="工程结构"><br>既然是模拟后台的返回数据，我们只需要关注<code>app.js</code>文件和<code>routers</code>文件夹就可以了。<br>在<code>routers</code>文件夹中有<code>index.js</code>和<code>user.js</code>文件，这两个文件在<code>app.js</code>文件中注册并使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> indexRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/index&#x27;</span>);<br><span class="hljs-keyword">var</span> usersRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/users&#x27;</span>);<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, indexRouter);<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/users&#x27;</span>, usersRouter);<br></code></pre></td></tr></table></figure>
<p>意思差不多就是访问根目录，则返回<code>index.js</code>文件中<code>router.get</code>注册为<code>/</code>的方法中<code>res.render</code>的值。<br>同样的，我们访问<code>/users</code>则会返回该文件中<code>data</code>字段的值。</p>
<h4 id="仿写"><a href="#仿写" class="headerlink" title="仿写"></a>仿写</h4><p>仿造上面两个示例，我们可以写点其他的东西。<br>在<code>routes</code>文件夹下新建<code>version.js</code>,内如如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> router = express.<span class="hljs-title class_">Router</span>();<br><span class="hljs-keyword">var</span> data = &#123;<br>  <span class="hljs-string">&#x27;code&#x27;</span>:<span class="hljs-number">0</span>,<br>  <span class="hljs-string">&#x27;message&#x27;</span>:<span class="hljs-string">&#x27;success&#x27;</span>,<br>  <span class="hljs-string">&#x27;version&#x27;</span>:&#123;<br>      <span class="hljs-string">&quot;versionCode&quot;</span>:<span class="hljs-string">&quot;1.0.1&quot;</span>,<br>      <span class="hljs-string">&quot;versionName&quot;</span>:<span class="hljs-string">&quot;机遇&quot;</span><br>  &#125;<br>&#125;<br>router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>) &#123;<br>  res.<span class="hljs-title function_">send</span>(data);<br>&#125;);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = router;<br></code></pre></td></tr></table></figure>

<p>如果我们需要根据请求参数不同返回不同的数据，只要取到请求参数，然后自己构建返回值就好了：在<code>version.js</code>中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/param&#x27;</span>,<span class="hljs-keyword">function</span> (<span class="hljs-params">req,res,next</span>) &#123;<br>   res.<span class="hljs-title function_">send</span>(req.<span class="hljs-property">query</span>.<span class="hljs-property">name</span>)<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>在<code>app.js</code>中注册：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javaScript"><span class="hljs-keyword">var</span> versionRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/version&#x27;</span>)<br>...<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/version&#x27;</span>,versionRouter)<br></code></pre></td></tr></table></figure>

<p>需要注意的是在<code>app.use</code>方法中传入的第一个参数就是我们要访问的路径<br>如果我们请求的路径为 <code>/version/param?name=xuan</code>,那么返回值为<code>xuan</code>,可以参考官方文档Request中的req.query<br>如果我们请求的路径为 <code>/version</code>,那么返回值为data的值</p>
<p>重启服务，然后访问一下，如果返回了正确的json数据，说明配置成功。在修改配置或者添加内容的时候，如果再次访问没有成功或者还是原来的内容，注意看一下控制台是不是被304缓存了。</p>
<p>这样我们只需要在研发阶段把地址指向我们自己的服务，联调时指向测试服务器就可以了。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>使用无障碍服务完成一键拨打微信视频电话</title>
    <url>/2024/08/16/%E4%BD%BF%E7%94%A8%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%9C%8D%E5%8A%A1%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%80%E9%94%AE%E6%8B%A8%E6%89%93%E5%BE%AE%E4%BF%A1%E8%A7%86%E9%A2%91%E7%94%B5%E8%AF%9D%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>无障碍服务适配大家应该多多少少的都遇到过，简单点讲就是给图片、文本等控件加上 <code>android:contentDescription=&quot;&quot;</code>标签，这样在使用无障碍服务(比如手机自带的 talkback)时，可以将<code>contentDescription</code>的内容以声音的方式读出来，方便视障用户使用我们的 app。</p>
<p>这不是本文的重点，重点是在无障碍–&gt;已安装的服务中中发现了一些其他的应用也提供了一些无障碍服务，比如某输入法提供了”智能回复”、”智能应答”等服务，某些应用还提供了类似于一键进行微信视频通话功能，这玩意咋搞的？我们能不能搞？能不能给老人做一个简单的工具，去掉那些花里胡哨的功能，点个按钮就能和我们进行视频通话？<br><strong>不要用无障碍服务做违法的事情！！！不要用无障碍服务做违法的事情！！！不要用无障碍服务做违法的事情！！!</strong></p>
<span id="more"></span>

<p>查了一些资料，我们可以使用<code>AccessibilityService</code>来实现该功能。该服务可以在页面切换或者发生其他变化时回调某些方法，我们可以根据这些回调，获取到页面的节点(控件)信息，来进行点击、长按等操作。</p>
<h2 id="第一步：创建与配置"><a href="#第一步：创建与配置" class="headerlink" title="第一步：创建与配置"></a>第一步：创建与配置</h2><p>我们需要自定义一个继承自<code>AccessibilityService</code>的 service，然后在<code>AndroidManifest.xml</code>文件中注册一下，就想普通的 service 差不多，这里有三个可以被重写方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> android.accessibilityservice.AccessibilityService;<br><span class="hljs-keyword">import</span> android.view.accessibility.AccessibilityEvent;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAccessibilityService</span> <span class="hljs-title">extends</span> <span class="hljs-title">AccessibilityService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> void onAccessibilityEvent(AccessibilityEvent event) &#123;<br>        <span class="hljs-comment">// 处理接收到的辅助功能事件</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> void onInterrupt() &#123;<br>        <span class="hljs-comment">// 处理服务被中断的情况</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void onServiceConnected() &#123;<br>        <span class="hljs-keyword">super</span>.onServiceConnected();<br>        <span class="hljs-comment">// 初始化服务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在清单文件中注册一下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyAccessibilityService&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:permission</span>=<span class="hljs-string">&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.accessibilityservice.AccessibilityService&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.accessibilityservice&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/accessibility_service_config&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>需要注意这里的<code>meta-data</code>标签，其中的<code>name</code>属性值是固定的，<code>resource</code>属性则是我们为无障碍服务提供的配置文件。大致有这么一些属性<br><code>accessibility_service_config.xml</code> 是一个用于配置 <code>AccessibilityService</code> 的 XML 文件，其中包含了许多属性，用于定义服务的行为和特性。以下是这些属性的详细介绍和示例说明：</p>
<h3 id="1-android-description"><a href="#1-android-description" class="headerlink" title="1. android:description"></a>1. <code>android:description</code></h3><p>描述服务的用途，通常是一个字符串资源的引用。这个值会展示在开启无障碍服务时的帮助说明中</p>
<h3 id="2-android-accessibilityEventTypes"><a href="#2-android-accessibilityEventTypes" class="headerlink" title="2. android:accessibilityEventTypes"></a>2. <code>android:accessibilityEventTypes</code></h3><p>定义服务要监听的事件类型。可以是以下之一或多个的组合：</p>
<ul>
<li><code>typeAllMask</code></li>
<li><code>typeViewClicked</code></li>
<li><code>typeViewFocused</code></li>
<li><code>typeViewLongClicked</code></li>
<li><code>typeViewSelected</code></li>
<li><code>typeViewTextChanged</code></li>
<li><code>typeWindowContentChanged</code></li>
<li><code>typeWindowStateChanged</code>。</li>
</ul>
<p>这里我们只需要监听 <code>typeWindowContentChanged</code> 和 <code>typeWindowStateChanged</code> 就足够了</p>
<h3 id="3-android-packageNames"><a href="#3-android-packageNames" class="headerlink" title="3. android:packageNames"></a>3. <code>android:packageNames</code></h3><p>指定服务要监听的应用包名。多个包名可以用逗号分隔。这个没啥好说的</p>
<h3 id="4-android-accessibilityFeedbackType"><a href="#4-android-accessibilityFeedbackType" class="headerlink" title="4. android:accessibilityFeedbackType"></a>4. <code>android:accessibilityFeedbackType</code></h3><p>定义服务的反馈类型，就是如何给用户反馈，可以是以下之一或多个的组合：</p>
<ul>
<li><code>feedbackSpoken</code> ： 适用于需要将信息通过语音读出来的情况，例如屏幕阅读器。</li>
<li><code>feedbackHaptic</code> ： 适用于需要通过振动提醒用户的情况，例如通知用户某个操作成功或失败。</li>
<li><code>feedbackAudible</code> ： 适用于需要通过音效提醒用户的情况，例如提示音。</li>
<li><code>feedbackVisual</code> ： 适用于需要通过视觉效果（如闪烁、颜色变化）提醒用户的情况。</li>
<li><code>feedbackGeneric</code> ： 适用于不特定于某一种反馈类型的情况。</li>
<li><code>feedbackBraille</code> : 适用于需要将信息传递给盲文设备用户的情况。</li>
</ul>
<h3 id="5-android-notificationTimeout"><a href="#5-android-notificationTimeout" class="headerlink" title="5. android:notificationTimeout"></a>5. <code>android:notificationTimeout</code></h3><p>定义服务在处理连续事件之间的最短时间间隔，以毫秒为单位。当辅助功能服务接收到大量的连续事件时，可能会导致性能问题或用户体验不佳。通过设置 <code>notificationTimeout</code>，可以指定一个时间窗口，在这个时间窗口内重复的事件将被合并为一个事件，从而减少处理的频率。</p>
<h3 id="6-android-canRetrieveWindowContent"><a href="#6-android-canRetrieveWindowContent" class="headerlink" title="6. android:canRetrieveWindowContent"></a>6. <code>android:canRetrieveWindowContent</code></h3><p>定义服务是否可以检索窗口内容。设置为 <code>true</code> 表示服务可以访问窗口内容。</p>
<h3 id="7-android-settingsActivity"><a href="#7-android-settingsActivity" class="headerlink" title="7. android:settingsActivity"></a>7. <code>android:settingsActivity</code></h3><p>指定一个设置活动的类名，用户可以通过辅助功能设置页面进入该活动。配置了该属性之后，用户可以在开启无障碍服务页面点击更多设置直接进入到该页面</p>
<h3 id="8-android-canRequestTouchExplorationMode"><a href="#8-android-canRequestTouchExplorationMode" class="headerlink" title="8. android:canRequestTouchExplorationMode"></a>8. <code>android:canRequestTouchExplorationMode</code></h3><p>属性用于指定辅助功能服务是否可以请求触摸探索模式。触摸探索模式是一种特殊的输入模式，通常用于帮助视力障碍用户使用触摸屏设备<br>这里也需要我们在代码中设置一下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onServiceConnected()<br>    <span class="hljs-keyword">val</span> info = AccessibilityServiceInfo()<br>    info.flags = AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE<br>    serviceInfo = info<br>&#125;<br></code></pre></td></tr></table></figure>
<p>并且，在处理事件中我们也需要处理更多的事件</p>
<blockquote>
<p>启用时：应用需要处理更多的辅助功能事件，如 TYPE_TOUCH_EXPLORATION_GESTURE_START 和 TYPE_TOUCH_EXPLORATION_GESTURE_END。这些事件帮助应用确定用户正在进行触摸探索。<br>未启用时：应用只需处理标准的触摸事件。</p>
</blockquote>
<h3 id="9-android-canRequestEnhancedWebAccessibility"><a href="#9-android-canRequestEnhancedWebAccessibility" class="headerlink" title="9. android:canRequestEnhancedWebAccessibility"></a>9. <code>android:canRequestEnhancedWebAccessibility</code></h3><p>定义服务是否可以请求增强的网页辅助功能。</p>
<h3 id="10-android-canRequestFilterKeyEvents"><a href="#10-android-canRequestFilterKeyEvents" class="headerlink" title="10. android:canRequestFilterKeyEvents"></a>10. <code>android:canRequestFilterKeyEvents</code></h3><p>用于指定辅助功能服务是否可以请求过滤键事件（key events）。这对于开发辅助功能服务（如屏幕阅读器或其他辅助工具）非常重要，因为它允许这些服务拦截和处理按键事件，以提供更好的用户体验和辅助功能支持。同样的，不仅要在配置文件中声明，也需要在代码中设置</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onServiceConnected()<br>    <span class="hljs-keyword">val</span> info = AccessibilityServiceInfo()<br>    info.flags = AccessibilityServiceInfo.FLAG_REQUEST_FILTER_KEY_EVENTS<br>    serviceInfo = info<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="11-android-canPerformGestures"><a href="#11-android-canPerformGestures" class="headerlink" title="11. android:canPerformGestures"></a>11. <code>android:canPerformGestures</code></h3><p>定义服务是否可以执行手势。如果为 true，我们可以这样执行手势</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 执行点击手势</span><br><span class="hljs-keyword">private</span> void performClick(float x, float y) &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;<br>        Path clickPath = new Path();<br>        clickPath.moveTo(x, y);<br>        GestureDescription.StrokeDescription clickStroke = new GestureDescription.StrokeDescription(clickPath, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>);<br>        GestureDescription gestureDescription = new GestureDescription.Builder().addStroke(clickStroke).build();<br>        dispatchGesture(gestureDescription, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="12-android-accessibilityFlags"><a href="#12-android-accessibilityFlags" class="headerlink" title="12. android:accessibilityFlags"></a>12. <code>android:accessibilityFlags</code></h3><p>定义服务的辅助功能标志，这些标志定义了服务的行为和特性。通过设置不同的标志，开发者可以控制辅助功能服务如何与系统和应用交互。可以是以下之一或多个的组合：</p>
<ol>
<li><p>**<code>flagIncludeNotImportantViews</code>**：</p>
<ul>
<li><strong>作用</strong>：包括那些通常被认为不重要的视图（如布局视图）在辅助功能事件中。</li>
<li><strong>使用场景</strong>：当需要确保所有视图都被辅助功能服务处理时使用。</li>
</ul>
</li>
<li><p>**<code>flagRequestTouchExplorationMode</code>**：</p>
<ul>
<li><strong>作用</strong>：请求触摸探索模式，这对于视力障碍用户非常有用。</li>
<li><strong>使用场景</strong>：当辅助功能服务需要解释触摸事件并提供反馈时使用。</li>
</ul>
</li>
<li><p>**<code>flagReportViewIds</code>**：</p>
<ul>
<li><strong>作用</strong>：报告视图的资源 ID。</li>
<li><strong>使用场景</strong>：当辅助功能服务需要识别和操作特定视图时使用。</li>
</ul>
</li>
<li><p>**<code>flagRetrieveInteractiveWindows</code>**：</p>
<ul>
<li><strong>作用</strong>：允许辅助功能服务检索交互窗口。</li>
<li><strong>使用场景</strong>：当需要处理多个窗口或弹出窗口时使用。</li>
</ul>
</li>
</ol>
<p>当然我们也可以在代码中设置标志</p>
<p>在你的 <code>AccessibilityService</code> 中，你可以使用 <code>AccessibilityServiceInfo</code> 来设置标志：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onServiceConnected()<br>    <span class="hljs-keyword">val</span> info = AccessibilityServiceInfo()<br>    info.flags = (AccessibilityServiceInfo.FLAG_INCLUDE_NOT_IMPORTANT_VIEWS<br>            or AccessibilityServiceInfo.FLAG_REPORT_VIEW_IDS<br>            or AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS)<br>    serviceInfo = info<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="示例完整配置文件"><a href="#示例完整配置文件" class="headerlink" title="示例完整配置文件"></a>示例完整配置文件</h3><p>下面是我们这次需要用到的配置文件内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">accessibility-service</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:accessibilityEventTypes</span>=<span class="hljs-string">&quot;typeWindowContentChanged|typeWindowStateChanged&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:accessibilityFeedbackType</span>=<span class="hljs-string">&quot;feedbackGeneric&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:accessibilityFlags</span>=<span class="hljs-string">&quot;flagIncludeNotImportantViews|flagReportViewIds&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:canRetrieveWindowContent</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:canRequestTouchExplorationMode</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:canRequestFilterKeyEvents</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:canPerformGestures</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:packageNames</span>=<span class="hljs-string">&quot;com.tencent.mm&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:settingsActivity</span>=<span class="hljs-string">&quot;com.huangyuanlove.auxiliary.SettingActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:description</span>=<span class="hljs-string">&quot;@string/wx_make_call_service_helper&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:notificationTimeout</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过配置这些属性，你可以精确地控制 <code>AccessibilityService</code> 的行为，以满足特定的需求和用例。</p>
<p><img src="/image/accessibility/accessibility_setting_honor.png" alt="荣耀v10开启无障碍服务弹窗提示"><br><img src="/image/accessibility/accessibility_setting_k30.png" alt="红米k30p开启无障碍服务弹窗提示"></p>
<h2 id="第二步：rua代码"><a href="#第二步：rua代码" class="headerlink" title="第二步：rua代码"></a>第二步：rua代码</h2><p>在上面我们已经做好了基础配置，下面开始rua 代码，看看我们应该怎么做。</p>
<h3 id="分析路径流程"><a href="#分析路径流程" class="headerlink" title="分析路径流程"></a>分析路径流程</h3><p>我们先做好微信的前期准备工作：通话双方是好友、微信已经登录。<br>那么我们的使用流程大致时这样的：<br>打开微信<br>点击底部通讯录<br>找到这个好友(可能需要滑动通讯录列表)点击一下进入到好友信息页面<br>点击信息页面的音视频通话<br>在底部弹窗中点击视频通话或者语音通话</p>
<h3 id="简单的-API-调用准备"><a href="#简单的-API-调用准备" class="headerlink" title="简单的 API 调用准备"></a>简单的 API 调用准备</h3><h4 id="onAccessibilityEvent"><a href="#onAccessibilityEvent" class="headerlink" title="onAccessibilityEvent"></a>onAccessibilityEvent</h4><p>当触发了我们在配置文件中指定的事件时，系统会回调<code>AccessibilityService#onAccessibilityEvent(event: AccessibilityEvent)</code>这个方法。<br>我们可以通过<code>event</code>对象获取触发这个事件的包名，触发的事件类型等，</p>
<h4 id="getRootInActiveWindow"><a href="#getRootInActiveWindow" class="headerlink" title="getRootInActiveWindow"></a>getRootInActiveWindow</h4><p>我们可以在<code>AccessibilityService</code>中调用这个方法获取当前页面的根节点，这个节点可以看做是当前视图树的根节点，这样我们就可以遍历整个视图树了。<br>同样的，我们也可以通过<code>AccessibilityNodeInfo</code>实例来获取对应节点的属性，比如是否可以点击(isClickable)、类型(className)、按钮|文本内容(text)、无障碍服务标签内容(contentDescription)等。我们可以根据这些属性来判断是不是我们需要的节点(控件)</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>就像我们平时开发一样，有些事件并不是直接设置在 TextView 或者 Button 上的，可能是设置在它们的父级组件上，比如LinearLayout或者RelativeLayout等。所以当我们获取到对应的节点后，需要判断一下是不是我们需要的节点，如果不是的话，就在找找父级是不是我们需要的节点。<br>当然如果我们知道某个页面某个节点的id，就不需要这么麻烦了，直接根据 id 查找就好了。</p>
<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><p>需要开启无障碍服务才可以进行对应的操作</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isServiceEnabled</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    (context.getSystemService(Context.ACCESSIBILITY_SERVICE) <span class="hljs-keyword">as</span> AccessibilityManager)<br>            .getEnabledAccessibilityServiceList(AccessibilityServiceInfo.FEEDBACK_ALL_MASK)<br>            .filter &#123; it.id == <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;context.packageName&#125;</span>/<span class="hljs-subst">$&#123;MakeWeChatCallService::class.java.name&#125;</span>&quot;</span> &#125;<br>            .let &#123; <span class="hljs-keyword">return</span> it.isNotEmpty() &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//跳转到开启无障碍服务页面</span><br>startActivity(Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS)) <br></code></pre></td></tr></table></figure>


<h3 id="动手开工"><a href="#动手开工" class="headerlink" title="动手开工"></a>动手开工</h3><h4 id="打开微信"><a href="#打开微信" class="headerlink" title="打开微信"></a>打开微信</h4><p>这个很简单哇，知道微信的包名就好了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = packageManager.getLaunchIntentForPackage(WX_PACKAGE_NAME)<br>intent?.let &#123;<br>    startActivity(intent)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当我们打开微信后，标记接下来需要点击通讯录按钮：current_step&#x3D; click_contacts;</p>
<h3 id="点击底部通讯录"><a href="#点击底部通讯录" class="headerlink" title="点击底部通讯录"></a>点击底部通讯录</h3><p>这个就需要用到上面准备好的<code>AccessibilityService</code>了，按照上面的配置，当我们打开微信之后，就开始回调<code>onAccessibilityEvent(event: AccessibilityEvent)</code>这个方法了。</p>
<p>我们假设用户使用的是中文，我们需要找到”通讯录”这个按钮对应的AccessibilityNodeInfo实例，然后调用<code>performAction(AccessibilityNodeInfo.ACTION_CLICK)</code>进行点击就好了。<br>注意，这个的<code>通讯录</code>文本并不是可以点击的，我们打开<code>无障碍服务talkback</code>将框框移动到通讯录这里，就可以看到<code>通讯录</code>和上面的图标是一体的。但我们也不清楚他们到底是怎么实现的，所以我们查找这个文本的父级控件，看是否能点，不能点击就再往上查找。多次尝试之后，发现需要向上查找两次。这里写了一个扩展方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> AccessibilityNodeInfo.<span class="hljs-title">clickNodeByText</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    textList: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    parentCount: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>    <span class="hljs-keyword">var</span> node = getNodeByText(textList)<br>    repeat(parentCount) &#123;<br>        node = node?.parent<br>    &#125;<br>    node?.let &#123;<br>        <span class="hljs-keyword">return</span> it.performAction(AccessibilityNodeInfo.ACTION_CLICK)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的参数<code>parentCount</code>表示需要向上查找几次。<br>我们点击通讯录的时候调用<code>rootInActiveWindow.clickNodeByText(arrayOf(&quot;通讯录&quot;), 2)</code>就可以了.<br>点击成功后，我们标记接下来需要点击联系人：current_step&#x3D;click_contact;</p>
<h3 id="找到好友"><a href="#找到好友" class="headerlink" title="找到好友"></a>找到好友</h3><p>通讯录是个列表，我们猜要不是 ListView，要不是 RecyclerView，我觉得不大可能是 ScrollView。要注意。右侧还有一个字母列表，不要搞错了。<br>我们先从当前可看到的页面查找联系人。<br>这里也搞了个扩展方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> AccessibilityNodeInfo.<span class="hljs-title">getNodeByText</span><span class="hljs-params">(textList: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span>: AccessibilityNodeInfo? &#123;<br>    <span class="hljs-keyword">var</span> node: AccessibilityNodeInfo? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (index &lt; textList.size &amp;&amp; node === <span class="hljs-literal">null</span>) &#123;<br>        node = <span class="hljs-keyword">this</span>.findAccessibilityNodeInfosByText(textList[index]).getOrNull(<span class="hljs-number">0</span>)<br>        index++<br>    &#125;<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure>
<p>查找这个联系人</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> contactNode = rootInActiveWindow.getNodeByText(arrayOf(cantactName))<br></code></pre></td></tr></table></figure>
<p>如果<code>contactNode</code>为空，表示当前可视内容中没有这个联系人，我们需要滑动列表。<br>首先，找到联系人列表的<code>RecyclerView</code>,别问为啥是<code>RecyclerView</code>,试了好多次试出来的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getContactListView</span><span class="hljs-params">()</span></span>: AccessibilityNodeInfo? &#123;<br>    <span class="hljs-keyword">val</span> queue = LinkedList&lt;AccessibilityNodeInfo&gt;()<br>    queue.offer(rootInActiveWindow)<br>    <span class="hljs-keyword">var</span> info: AccessibilityNodeInfo?<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        info = queue.poll()<br>        <span class="hljs-keyword">if</span> (info == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (info.className.equals(<span class="hljs-string">&quot;androidx.recyclerview.widget.RecyclerView&quot;</span>) &amp;&amp; info.isScrollable) &#123;<br>            <span class="hljs-keyword">return</span> info<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until info.childCount) &#123;<br>            queue.offer(info.getChild(i))<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>找到列表控件后滑动一下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> contactListNode = getContactListView()<br>contactListNode?.performAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD)<br></code></pre></td></tr></table></figure>
<p>注意，这里列表的滑动同样会触发<code>onAccessibilityEvent</code>这个方法，我们再重复上面的流程，直到找到这个联系人控件。需要注意的是，这里的联系人显示的名字要是单个英文字母，这会和列表分组上面的单个英文字母相同，导致查找到的控件不是我们想要的</p>
<p>当我们找到这个联系人控件后，进行点击</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> contactNode = rootInActiveWindow.getNodeByText(arrayOf(cantactName))<br>repeat(<span class="hljs-number">6</span>) &#123;<span class="hljs-comment">//别问这里为啥是 6，试出来的，或者可以遍历一下视图树，自己数一下层级</span><br>    contactNode = contactNode?.parent<br>&#125;<br>contactNode?.let &#123;<br>    <span class="hljs-keyword">val</span> result = it.performAction(AccessibilityNodeInfo.ACTION_CLICK)<br>    <span class="hljs-keyword">if</span>(result)&#123;<br>        <span class="hljs-comment">//标记接下来需要在联系人详情页面点击音视频通话</span><br>        current_step= click_video;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="点击音视频通话"><a href="#点击音视频通话" class="headerlink" title="点击音视频通话"></a>点击音视频通话</h3><p>这个就比较简单了，还是调用我们上面写的扩展方法找到按钮，然后点击就行了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> contactNode = rootInActiveWindow.getNodeByText(arrayOf(<span class="hljs-string">&quot;音视频通话&quot;</span>))<br>repeat(<span class="hljs-number">2</span>) &#123;<br>    contactNode = contactNode?.parent<br>&#125;<br>contactNode?.let &#123;<br>    <span class="hljs-keyword">val</span> result = it.performAction(AccessibilityNodeInfo.ACTION_CLICK)<br>    <span class="hljs-keyword">if</span>(result)&#123;<br>        <span class="hljs-comment">//标记接下来需要点击弹窗中的视频通话</span><br>        current_step= click_video_on_dialog;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="点击弹窗中的视频通话"><a href="#点击弹窗中的视频通话" class="headerlink" title="点击弹窗中的视频通话"></a>点击弹窗中的视频通话</h3><p>这个就更简单了</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">rootInActiveWindow.clickNodeByText(arrayOf(<span class="hljs-string">&quot;语音通话&quot;</span>), <span class="hljs-number">3</span>)<br>rootInActiveWindow.clickNodeByText(arrayOf(<span class="hljs-string">&quot;视频通话&quot;</span>), <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>
<p>一个语音通话，一个视频通话。<br>到这里我们就可以进行视频通话了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的流程是最理想的状态，还有一些奇奇怪怪的问题：<br>比如我们视频通话结束后，需要返回到列表页，也就是在通话结束后点击左上角的返回，这个功能没有写。<br>比如打开微信的时候不是在首页，比如在浏览公众号信息怎么办？同样需要找到左上角的返回按钮，一直到首页之后才可以进行点击通讯录的操作。<br>比如联系人的名字就是单个英文字母，上面也提到，这种情况下查找到的会是分组的名称，无法进行点击。<br>或者我们可以从首页点击右上角的搜索，输入联系人名字，然后在搜索列表中点击联系人，进入到聊天页面，然后点击左下角加号，在更多菜单里面点击音视频通话也行。<br>放个最终效果的视频吧</p>
<video width="320" height="240" autoplay muted>
  <source src="image/accessibility/accessibility_video.mp4" type="video/mp4">

<p>Your browser does not support the video tag.<br></video></p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>写在2016年末</title>
    <url>/2016/12/31/%E5%86%99%E5%9C%A82016%E5%B9%B4%E6%9C%AB/</url>
    <content><![CDATA[<p>2016年的最后一天的最后半个小时了，写写这一年的收获总结和2017的计划吧。<br>一个字总结了一下2016年：穷。<br>当然这是开玩笑式的总结，但也是最接近事实的了。</p>
<span id="more"></span>
<h4 id="2016总结"><a href="#2016总结" class="headerlink" title="2016总结"></a>2016总结</h4><p>技术方面：<br>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;自从踏上IT这条不归路开始，就打算做一个全栈攻城狮，从敲下第一行<code>hello world</code>到自己独立用java写一个完整的大作业再到写出实际可用的程序到现在的工作，仔细想想已经五年多了吧。但是这仅仅是个开始，我对自己现在的定位是全栈攻城狮的道路刚刚慢出第一步，现在也就算是个全栈学徒吧。</p>
<table><tr><th>编程技能</th><th>自定级别</th></tr><tr><td>python</td><td>入门</td></tr><tr><td>HTML</td><td>初级</td></tr><tr><td>J2EE</td><td>初级</td></tr><tr><td>JAVA</td><td>中级</td></tr><tr><td>Android</td><td>中级</td></tr><tr><td>Linux</td><td>中级</td></tr></table>

<ul>
<li>在工作中也踩过、填过、挖过很多坑，万幸的是一直坚持了下来，没有放弃，也没有想过要转行的事，就想一直在这个行业发展，努力提高自己的技术。</li>
<li>15年双十二和今年的十二月四号，都参加了<code>开源中国</code>举办的<code>源创汇</code>年终盛典，接触到了很多大牛(虽然他们不曾记得我)，接触到很多以前没有见识过也没有想象过的东西，对自己的成长有很大帮助。</li>
<li>开通了自己的博客(gitpage),把博客从csdn迁移到github上，租用了腾讯云主机，备案了自己的域名，有了自己的简单的网站，可以写一些自己感兴趣的东西(自由的感觉真好，法无禁止皆可为)。</li>
<li>也感谢这一年来小伙伴的帮助，幸好有你们，帮我解决了困难。</li>
<li>当然，在这一年中也有很多事情不是那么顺利，从上家公司离职，从10月到12月，中间休息了两个月，回了一次家，跑去深圳和妹子玩了四五天的样子(几乎是全部时间都泡在图书馆了，沉迷学习无法自拔)，其余时间也就是看看书，打打游戏之类的，总之这两个月的时间大部分都被浪费掉了，没有任何收获。</li>
</ul>
<p>生活上也没啥好说的，业余时间就是宅在家里，看看书，敲敲代码，打打游戏，不喜欢出去逛，貌似好像是在6、7月份的样子，二哥来北京玩，爬了一次八达岭长城，除此之外，就是去了三次漫展，其他的就没有什么了。</p>
<h4 id="2017计划"><a href="#2017计划" class="headerlink" title="2017计划"></a>2017计划</h4><p>首先，最重要的就是提升自己的技术能力：</p>
<ul>
<li>python达到初级水平;html方面学习一下h5;</li>
<li>J2EE方面学习一下ssm框架、nginx;</li>
<li>JAVA和Android方面尽可能的提升自己，尽量在两年内能初步达到高级水平;</li>
<li>Linux方面，熟悉一下vim，了解以下服务器方向的相关知识，毕竟自己只是拿linux做开发，没有把精力放在服务器假设方向。</li>
</ul>
<p>生活方面就尽量改变一下自己宅的属性,尽量多出去走走吧(这个有点难，比提升技术实力还要难)</p>
<hr>
<p>借用一本小说中的一段话吧：</p>
<blockquote>
<pre>  “其实所有的智慧生物都在饮鸩止渴。所有的智慧生物都在通过不断的科技进步，不断的探索未知来满足着自己的探索欲望。这些科技，以及理论还有知识，不是好东西，它们是毒药，它们会让文明形成强烈的依赖症，当所有的未知都被探索完毕的时候，这种鸩毒就会最终发作，并且让这个文明最终陷入到毒发身亡的境地之中。可是最可笑的是，虽然这个道理十分明显，可是包括我在内的所有文明，都无法逃脱这个怪圈。”
    “我……我怎么可以停止呢？就算它们明明是毒药，可是我也要不断的去吃啊。”萧宇喃喃自语着，“如果我的科技不能进步，如果现在就斩断我进步的道路，我现在就会发疯的。这一点是天生注定的，当我还在地球上的时候，当我拿起笔，拿起书本，学习到第一个数学公式，学习到第一个物理定理的时候，这种鸩毒就已经在我的灵魂深处深深的扎下了根，让我终其一生不得解脱。我的毒瘾会越来越大，我所需要的鸩毒分量会越来越多，我只能继续这样维持下去。以后再毒发，总比现在就毒发要好。”
    这个死在旅途之中的文明，让萧宇想到了很多很多，对萧宇的灵魂造成了很深的触动。可是萧宇已经无法停下自己的脚步了。浩瀚广阔的星空，无边无际的宇宙，就像是美丽异常的罂粟花，明知道危险，可是还是有不计其数的文明，包括萧宇在内都踏了进去，并且一个个踊跃异常，生怕自己吸食毒品的速度要比其余的文明慢了一点。
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a></pre></h2><p>以上。</p>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>写在2018元旦之前:2017的总结</title>
    <url>/2017/12/30/%E5%86%99%E5%9C%A82018%E5%85%83%E6%97%A6%E4%B9%8B%E5%89%8D-2017%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2017年已经过去了，现在已经是2018年1月1号了，写写这一年的收获总结和2018的计划吧。<br>一个字总结了一下2018年：穷。我也不知道钱花到哪里去了【无奈、摊手】。<br>当然这是开玩笑式的总结，但也是最接近事实的了。<br>刚刚翻了翻2016年年末写了总结个2017的计划，我先捂会脸。</p>
<span id="more"></span>
<h4 id="先看看完成了哪些吧："><a href="#先看看完成了哪些吧：" class="headerlink" title="先看看完成了哪些吧："></a>先看看完成了哪些吧：</h4><ul>
<li>python达到初级水平:这个勉勉强强算是达到了吧。</li>
<li>J2EE学习ssm和nginx:这个就很惭愧了，一直没看，不是没时间，就是平时大概了解了一下，根本就没有系统的学习过。</li>
<li>Java和Android：这个一直没停下过，毕竟是饭碗，在别人看来差不多已经是高级工程师了，可我觉得我刚刚到中级水平吧(标准不一样嘛)。</li>
<li>Linux：这个也没怎么深入，能在linux平台下做开发、了解常见配置，除了问题能找到解决方案就好。公司开发坏境是windows,就算我想用linux，这个也不大好，只能平时自己玩玩。</li>
</ul>
<p>想想自己2017年都学到了啥，其实我也不知道自己又学到了啥，有些东西都是基础性、底层的东西，表面上看起来没什么提高，实际上现在我也没觉得有啥用户，或许是因为自己还没有到那个层次吧。</p>
<h4 id="表面上学到的东西如下："><a href="#表面上学到的东西如下：" class="headerlink" title="表面上学到的东西如下："></a>表面上学到的东西如下：</h4><ul>
<li>记录了一下在使用高德地图踩的坑(写到博客上了)。</li>
<li>大致看了一下tcp协议，就当是复习了，当时学ccna的时候也没怎么在意。</li>
<li>大致看了一遍《Android开发艺术探索》，可惜IPC还是没学会。</li>
<li>大致看了一下python编程，了解了一下flask和Django。</li>
<li>又大致看了一遍《深入理解JVM虚拟机》，感觉不出来有什么提高，只是聊天吹水的时候又多了点东西。</li>
<li>大致看了一下C++，没深入学习，坚持不下去了。</li>
<li>动手搭建了一下elk，并没有什么卵用，毕竟公司有专门的运维。</li>
<li>动手搭建了一下Jenkins，并没有什么卵用，毕竟公司有专门的运维。</li>
<li>动手搭建了一下git服务，并没有什么卵用，毕竟公司有专门的运维。</li>
<li>写了两个IDEA的插件，写完之后才发现有人写过了，而且还是已经发布了的。</li>
<li>用不同的方式方法、框架、语言把《煎蛋》写了好几遍。</li>
<li>大致学习了一下kotlin。</li>
<li>其他的就是读了几本书、认识了几个朋友。</li>
</ul>
<h4 id="遗憾的事"><a href="#遗憾的事" class="headerlink" title="遗憾的事"></a>遗憾的事</h4><ul>
<li>和妹子异地，没有多陪陪妹子。</li>
<li>没有锻炼，身体素质差的不要不要的，手无缚鸡之力。</li>
<li>自己一直念念不忘的热修复没有动手实践过。</li>
<li>自己一直念念不忘的微信小程序也没有去试试。</li>
<li>自己一直念念不忘的日语也放弃了。</li>
<li>脾气似乎暴躁了许多，竟然喜欢《死亡笔记》中所描述的世界。</li>
</ul>
<h4 id="我可能是公司里在技术上最能作-zuo-一声-的人了，没有之一："><a href="#我可能是公司里在技术上最能作-zuo-一声-的人了，没有之一：" class="headerlink" title="我可能是公司里在技术上最能作(zuo,一声)的人了，没有之一："></a>我可能是公司里在技术上最能作(zuo,一声)的人了，没有之一：</h4><ul>
<li>一开始做运营端app，嫌写<code>findViewById</code>麻烦，说服同事用<code>ButterKnife</code>注解。</li>
<li>后来需要做内部服务端app，觉得用<code>ButterKnife</code>也挺麻烦的，还得写变量(给变量去名字太蛋疼了，界面复杂的话一个界面好几十个控件变量)，上<code>databinding</code>吧，花一周时间把原来的注解全部干掉，换成<code>databinding</code></li>
<li>后来想改网络框架来着，但是一直没时间，开发需求一版接一版，VersionCode一年内已经到40了，只能作罢。</li>
<li>现在一直想上热修复来着，但是还没弄，后端还没弄好，机制还不完善，不过我觉得迟早得上，毕竟有啥技术改动都是内部服务端app先上、先用、趟雷(毕竟内部人员使用，好说话),然后运营端app再上.</li>
<li></li>
</ul>
<h4 id="2018计划"><a href="#2018计划" class="headerlink" title="2018计划"></a>2018计划</h4><ul>
<li>有时间多陪陪妹子。</li>
<li>坚持锻炼。</li>
<li>至少读3本书，要有总结和读后感的那种。</li>
<li>有时间的话，至少参与一次开源翻译计划(Apche-CN)\</li>
<li>人工智能和机器学习挺火的，妹子研究生也是这个方向，学学这一块的东西，至少不要拖妹子后腿吧。</li>
<li>Java和Android方向继续努力，撸源码，多学习。</li>
<li>坚持写博客，不能偷懒了。</li>
<li>修身养性，别这么大脾气了，一点就爆(抱个杯子，泡点枸杞挺不错的)。</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/image/2018_01_01.png" alt="2018"></h2><p>以上</p>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>2018总结</title>
    <url>/2019/01/03/%E5%86%99%E5%9C%A82019%E5%B9%B4%E5%88%9D-2018%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一句话总结一下：2019年争取把2018年没完成的2017年的计划不要推到2020年。</p>
<span id="more"></span>

<h4 id="回头想想2018年都学会了啥："><a href="#回头想想2018年都学会了啥：" class="headerlink" title="回头想想2018年都学会了啥："></a>回头想想2018年都学会了啥：</h4><ol>
<li>$LaTeX$初级</li>
<li>《Android开发艺术探索》刷了一遍，跟着翻了一遍源码，感觉有点进步，最起码会自己撸源码了。</li>
<li>《Android Gradle权威指南》刷了一遍，熟悉了一下Gradle相关的东西</li>
<li>Android hook、ConstraintLayout、Alarm优化、Android O适配NotificationChannel</li>
<li>《Kotlin程序开发入门精要》刷了一遍</li>
<li>《剑指offer》题目在牛客网上刷了一遍，感觉没啥用，只是见的题目多了</li>
<li>《好好说话(马东)》、《好好学习(成甲)》、《极简主义》、《番茄工作法》、《单核工作法图解》</li>
</ol>
<h4 id="还欠着啥"><a href="#还欠着啥" class="headerlink" title="还欠着啥"></a>还欠着啥</h4><p>还欠着7本技术相关的书没看：</p>
<ol>
<li>《Vue.js 实战》</li>
<li>《React进阶之路》</li>
<li>《ES6标准入门》</li>
<li>《RxJava 2.x 实战》</li>
<li>《Android音视频开发》</li>
<li>《Android源码设计模式》</li>
<li>《Android自定义控件开发入门与实战》</li>
</ol>
<h4 id="还想学啥"><a href="#还想学啥" class="headerlink" title="还想学啥"></a>还想学啥</h4><p>当然是flutter和ML和DL了。</p>
<p>ML和DL等着妹子指导，flutter也等着复习一下前端的知识再上手。</p>
<p>19年先把7、6、4撸完，穿插着看完3、1，估计就到国庆了。</p>
<p>再然后就是玩flutter了，两个月的时间，在有前端基础的前提下，差不多能入门吧。这个时候该踩的坑别人都已经踩完了。</p>
<p>都说大前端时代要到来，也不知道19年的行情怎么样。</p>
<p>其他的也没啥打算，能做完上面这些就不错了，一年的计划太长了，赶不上变化，谁知道中间会不会又出什么幺蛾子。。。。</p>
<hr>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>写在2020年初-2019总结</title>
    <url>/2020/01/06/%E5%86%99%E5%9C%A82020%E5%B9%B4%E5%88%9D-2019%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>不出所料、毫不意外的2019年的总结没有在元旦写完，跳票了，一周，还好，今天补上。<br>2020年计划肯定不是把去年的计划改个年份就行了。。。</p>
<span id="more"></span>
<h4 id="2019年干了啥"><a href="#2019年干了啥" class="headerlink" title="2019年干了啥"></a>2019年干了啥</h4><p>还有自己有记录一下，每个月的月末或者月初总结一下上个月干了啥，下个月的目标是啥。<a href="https://book.huangyuanlove.com/">https://book.huangyuanlove.com</a><br>总体上也是把年度目标分解了一下。不过计划赶不上变化，每次计划都和工作冲突。想学的东西也只能自己找时间去学。因为想学的东西和公司要用的东西重合度不怎么高，这就很蛋疼了。</p>
<ul>
<li>熟悉flutter常见控件、flutter_channel、BLoC、Provider</li>
<li>图解设计模式(说实话没啥印象，需要在工程中多实践，只看书没啥效果)</li>
<li>入手树莓派3B+，玩了一周，然后吃灰了</li>
<li>AndroidAnnotation编译时注解框架，和配套博客，<a href="https://github.com/huangyuanlove/AndroidAnnotation">https://github.com/huangyuanlove/AndroidAnnotation</a></li>
<li>看了《Android自定义控件开发入门与实战》 没啥感觉</li>
<li>看了《RxJava2.x实战》没啥感觉</li>
<li>看了《iOS开发第四版》，练手项目”煎蛋”刚开了头</li>
<li>20多篇博客，(也没啥特殊产出，记录了一下自己学过得东西)</li>
</ul>
<p>总结一下2019：看起来挺多，实际上没干啥。。。。。。<br>自控力差，不能推动自己执行计划。。。。。。<br>目前学的东西只是浮于表面，只是会用就行，并没有熟悉底层机制和原理，出了问题只能凭经验去搞。。。。。</p>
<h4 id="2020-目标"><a href="#2020-目标" class="headerlink" title="2020 目标"></a>2020 目标</h4><ul>
<li>iOS基础，先把”煎蛋”写完</li>
<li>数据结构与算法，浙江大学公开课，把习题做一遍，不能手高眼低</li>
<li>LeetCode刷一刷，最起码简单的题要信手拈来</li>
<li>Android音视频、Android源码设计模式(应该会偏源码)</li>
<li>Android和flutter系统架构</li>
</ul>
<p>最后两条需要平时多总结，并不只是去翻源码，需要去记录、分析、总结、反馈</p>
<p>坚持吧。。。。</p>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>写在2022年初--2021总结</title>
    <url>/2022/01/01/%E5%86%99%E5%9C%A82022%E5%B9%B4%E5%88%9D-2021%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2021年，娃娃出生了，嘿嘿嘿<br>今年似乎也没有学啥，但又不知道时间都花在哪里了。<br>浅尝辄止的学习了一些技术</p>
<ul>
<li>vue</li>
<li>react</li>
<li>小程序</li>
<li>鸿蒙</li>
</ul>
<p>翻了一丢丢源码</p>
<ul>
<li>okhttp</li>
<li>retrofit</li>
<li>gson</li>
</ul>
<p>了解了一下Android系统启动流程、应用启动流程。然后就是准备重拾flutter，学习一下跨平台技术</p>
<span id="more"></span>
<h4 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h4><p>深入学习一下fluter和kotlin<br>多刷一些算法题，用的时候是真有用</p>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>写在2021年初-2020总结</title>
    <url>/2021/01/02/%E5%86%99%E5%9C%A82021%E5%B9%B4%E5%88%9D-2020%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2020年，多灾多难的一年，但是在这一年完成了人生的一件大事：举办了婚礼.</p>
<span id="more"></span>

<h4 id="2020年干了啥"><a href="#2020年干了啥" class="headerlink" title="2020年干了啥"></a>2020年干了啥</h4><ul>
<li>了解了以下Android Jetpack</li>
<li>重温数据结构，看了点算法课程</li>
<li>简单的学了iOS开发</li>
<li>简单学习了正则</li>
<li>简单了解鸿蒙应用开发</li>
<li>了解Gradle插件开发</li>
</ul>
<p>《软技能 代码之外的生存指南》</p>
<p>《代码整洁之道》</p>
<p>《Android设计模式之禅》</p>
<p>总体来看，似乎也没干啥</p>
<h4 id="2021年目标"><a href="#2021年目标" class="headerlink" title="2021年目标"></a>2021年目标</h4><ol>
<li>Android系统架构、启动流程、系统服务</li>
<li>算法，一定要刷题</li>
</ol>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>写在2023年初--2022总结</title>
    <url>/2023/01/07/%E5%86%99%E5%9C%A82023%E5%B9%B4%E5%88%9D-2022%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2022年，新冠三年，新冠诊疗方案第十版将其更名为新型冠状病毒感染；<br>这一年中断了每月学习计划，博客也停更了一年，也不是忙，只是懒散，毕竟再忙也不会忙到写点东西的时间都挤不出来的地步。工作中也只是加强了之前学过的东西，熟练度提高了而已。<br>翻遍了过去一年，也只是刷了几道题，学完了极客时间几个课程而已。新的一年有新的计划。不仅要提高自己的技术硬实力，也需要提高软技能。</p>
<h4 id="2023"><a href="#2023" class="headerlink" title="2023"></a>2023</h4><p>还是围绕大前端进行</p>
<ol>
<li>flutter<ol>
<li>掘金小册</li>
<li>B站视频 王叔不秃 <a href="https://space.bilibili.com/589533168">https://space.bilibili.com/589533168</a>?</li>
</ol>
</li>
<li>前端<ol>
<li>极客时间课程</li>
</ol>
</li>
<li>iOS</li>
<li>软技能<ol>
<li>极客时间课程</li>
</ol>
</li>
</ol>
<p>共计60个课程，乐观估计也就只能完成10个，悲观先也就四五个的样子</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><br><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;朱赟的技术管理课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从技术到管理，让你的目标函数达到最优解&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;技术领导力实战笔记&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;通往优秀技术领导者之路&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;硅谷产品实战36讲&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用实例揭示如何打造世界级产品&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从0开始学架构&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;前阿里P9技术专家的实战架构心法&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Java核心技术面试精讲&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;前Oracle首席工程师带你修炼Java内功&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;趣谈网络协议&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;像小说一样的网络协议入门课&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;软件测试52讲&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从小工到专家的实战心法&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;深入拆解Java虚拟机&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Oracle 高级研究员手把手带你入门JVM&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;程序员进阶攻略&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;每个程序员都应该知道的成长法则&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;技术管理实战36讲&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;前百度最佳经理人的战地笔记&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;代码精进之路&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;你写的每一行代码都是你的名片&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;算法面试通关40讲&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;前Facebook工程师带你吃透大厂面试题&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br> <br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;玩转Git三剑客&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;带你深入掌握Git、GitHub和GitLab&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10x程序员工作法&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;掌握主动权，忙到点子上&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;重学前端&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;每天10分钟，重构你的前端知识体系&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;玩转Spring全家桶&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;一站通关Spring、Spring Boot与Spring Cloud&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;软件工程之美&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;重新理解软件工程&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Java并发编程实战&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;全面系统提升你的并发编程能力&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br> <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;iOS开发高手课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从原理到实战，带你解决80%的开发难题&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从0开始做增长&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从0到1的增长实战方法论&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;透视HTTP协议&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;深入理解HTTP协议本质与应用&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;玩转webpack&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;全方位掌握webpack核心技能和优化策略&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TypeScript开发实战&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;系统掌握TypeScript核心技术&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;网络编程实战&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从底层到实战，深度解析网络编程&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;浏览器工作原理与实践&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;透过浏览器看懂前端本质&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br> <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;全栈工程师修炼指南&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从全栈入门到技能实战&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Node.js开发实战&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;带你开发一个完整的Node.js项目&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;说透中台&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从概念到落地一站通关&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;苏杰的产品创新课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;一次从想法到产品的低成本实验&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;移动端自动化测试实战&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;一步一步带你成为测试高手&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;雷蓓蓓的项目管理实战课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;使众人行，如何带领一群人成事&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;性能工程高手课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;得性能者得天下&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;性能测试实战30讲&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;告别野路子，成为真正的性能测试高手&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;说透敏捷&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从原理到实战带你落地敏捷&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;接口测试入门课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从原理到实战，带你进阶接口测试&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Java业务开发常见错误100例&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;全面避坑 + 最佳实践=健壮代码&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;图解 Google V8&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;一门课搞懂 JavaScript 执行逻辑&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SRE实战手册&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从0到1带你搞定系统稳定性&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;互联网人的英语私教课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;让你快速提升英语阅读能力&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;微信小程序全栈开发实战&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;手把手带你实现一款电商小程序&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;软件设计之美&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;多一点设计，少一点问题&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;技术管理案例课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;踩坑复盘+案例分析+精进攻略=高效管理&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用户体验设计实战课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;人人可用的体验创新思维&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;WebAssembly入门课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从0到1实现一个WebAssembly多媒体应用&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;动态规划面试宝典&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;学好动态规划，面试晋升都不怕&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;乔新亮的CTO成长复盘&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;千万年薪CTO是如何炼成的&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;A/B测试从0到1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;从原理到实战，吃透A/B测试&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;代码之丑&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;识别坏味道，重构问题代码&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;体验设计案例课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;用量化方式，重新定义体验设计&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;技术面试官识人手册&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;辨识精英，打造高效能团队&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;性能优化高手课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;一站通关从设计到交付的性能问题&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;如何落地业务建模&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Thoughtworks CTO带你重构建模技能&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;程序员的测试课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;掌握测试，写好高质量代码&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;玩转Vue 3全家桶&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;基础+实战+源码，全方位学透Vue 3&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;深入剖析Java新特性&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;手把手带你吃透Java新特性&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;攻克视频技术&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;高手带路，轻松学习视频原理&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;搞定音频技术&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;深入浅出音频核心原理及应用&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;自动化测试高手课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;新模型+全栈视角\u003d高效进阶&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;遗留系统现代化实战&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;帮你走出遗留系统的泥潭&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;大厂设计进阶实战课&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subtitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;让你突破瓶颈的高薪设计课&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>原CSDN博客</title>
    <url>/2016/10/16/%E5%8E%9FCSDN%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>不打算在csdn上面写博客了,转到gitpage上面,自己用hexo搭建了博客系统.<br>现在把原csdn的博客链接抄在下面</p>
<span id="more"></span>
<p><a href="http://blog.csdn.net/huangyuan_xuan/article/details/52549416">使用openfire搭建IM聊天系统(一)</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/52549416">http://blog.csdn.net/huangyuan_xuan/article/details/52549416</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/52193006">浅谈使用单元素的枚举类型实现单例模式</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/52193006">http://blog.csdn.net/huangyuan_xuan/article/details/52193006</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/51935666">初步编写IDEA\AndroidStudio翻译插件</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/51935666">http://blog.csdn.net/huangyuan_xuan/article/details/51935666</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50881452">多线程 的理解（一）</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50881452">http://blog.csdn.net/huangyuan_xuan/article/details/50881452</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50570461">运行时数据区域</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50570461">http://blog.csdn.net/huangyuan_xuan/article/details/50570461</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50569443">虚拟机字节码执行引擎</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50569443">http://blog.csdn.net/huangyuan_xuan/article/details/50569443</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50550725">虚拟机类加载机制</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50550725">http://blog.csdn.net/huangyuan_xuan/article/details/50550725</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50513881">垃圾收集器与内存分配策略</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50513881">http://blog.csdn.net/huangyuan_xuan/article/details/50513881</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50513861">JDK的一些命令行工具</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50513861">http://blog.csdn.net/huangyuan_xuan/article/details/50513861</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50155345">MongoDB基础</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/50155345">http://blog.csdn.net/huangyuan_xuan/article/details/50155345</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49859151">tomcat图形化界面管理及数据源配置</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49859151">http://blog.csdn.net/huangyuan_xuan/article/details/49859151</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49362701">android 四大图片缓存原理、特性对比</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49362701">http://blog.csdn.net/huangyuan_xuan/article/details/49362701</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49356523">github分支管理</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49356523">http://blog.csdn.net/huangyuan_xuan/article/details/49356523</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49356505">github 远程仓库</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49356505">http://blog.csdn.net/huangyuan_xuan/article/details/49356505</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49336403">github建立本地与远程仓库的连接</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49336403">http://blog.csdn.net/huangyuan_xuan/article/details/49336403</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49162309">Git 本地版本控制</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49162309">http://blog.csdn.net/huangyuan_xuan/article/details/49162309</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49125597">安装github</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49125597">http://blog.csdn.net/huangyuan_xuan/article/details/49125597</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/48915299">ubuntu 14.04 apt-get install 不能自动补全解决办法</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/48915299">http://blog.csdn.net/huangyuan_xuan/article/details/48915299</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/48116365">String的一点小东西</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/48116365">http://blog.csdn.net/huangyuan_xuan/article/details/48116365</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/46632395">wireshark error: There are no interfaces on which a capture can be done.</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/46632395">http://blog.csdn.net/huangyuan_xuan/article/details/46632395</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/46564319">windows下使用cmd（命令行）发送邮件</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/46564319">http://blog.csdn.net/huangyuan_xuan/article/details/46564319</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/45936413">Notepad++ 搭建java编译环境</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/45936413">http://blog.csdn.net/huangyuan_xuan/article/details/45936413</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/44537233">JVM虚拟机</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/44537233">http://blog.csdn.net/huangyuan_xuan/article/details/44537233</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/43817631">servlet向浏览器输出验证码图片</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/43817631">http://blog.csdn.net/huangyuan_xuan/article/details/43817631</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/43759585">ubuntu14.04开热点共享网络</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/43759585">http://blog.csdn.net/huangyuan_xuan/article/details/43759585</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/43739353">UNIX&#x2F;linux的find命令细节</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/43739353">http://blog.csdn.net/huangyuan_xuan/article/details/43739353</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/43490373">编写shell时，提示let：not found</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/43490373">http://blog.csdn.net/huangyuan_xuan/article/details/43490373</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/42804537">cmd命令大全</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/42804537">http://blog.csdn.net/huangyuan_xuan/article/details/42804537</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/41647447">华为 ap ac设备配置命令</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/41647447">http://blog.csdn.net/huangyuan_xuan/article/details/41647447</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/41085629">更改SQLserver的登录方式</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/41085629">http://blog.csdn.net/huangyuan_xuan/article/details/41085629</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949147">汇编FLAG寄存器简介</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949147">http://blog.csdn.net/huangyuan_xuan/article/details/40949147</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949119">汇编指令——转移指令</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949119">http://blog.csdn.net/huangyuan_xuan/article/details/40949119</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949109">汇编指令</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949109">http://blog.csdn.net/huangyuan_xuan/article/details/40949109</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949087">汇编寻址方式</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949087">http://blog.csdn.net/huangyuan_xuan/article/details/40949087</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949075">一段汇编小程序及说明——将数据，代码，栈放入不同的段</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949075">http://blog.csdn.net/huangyuan_xuan/article/details/40949075</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949069">一段简单汇编语言程序及说明</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949069">http://blog.csdn.net/huangyuan_xuan/article/details/40949069</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949063">8086寄存器</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40949063">http://blog.csdn.net/huangyuan_xuan/article/details/40949063</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40857207">oracle创建实例化数据库或者连接别的远程主机数据库提示“无监听程序”的解决办法</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40857207">http://blog.csdn.net/huangyuan_xuan/article/details/40857207</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40821859">安装tomcat提示Faild to install Tomcat7 service 解决办法</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40821859">http://blog.csdn.net/huangyuan_xuan/article/details/40821859</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40821521">mysql事物处理和管理配置</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40821521">http://blog.csdn.net/huangyuan_xuan/article/details/40821521</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40783341">mysql 连接查询</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40783341">http://blog.csdn.net/huangyuan_xuan/article/details/40783341</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40783331">MySQL常用命令</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40783331">http://blog.csdn.net/huangyuan_xuan/article/details/40783331</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40783317">ubuntu下MySQL键值不支持中文解决办法</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/40783317">http://blog.csdn.net/huangyuan_xuan/article/details/40783317</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39992799">Myeclipse新建webservice客户端</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39992799">http://blog.csdn.net/huangyuan_xuan/article/details/39992799</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39992723">MyEclips新建webservice</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39992723">http://blog.csdn.net/huangyuan_xuan/article/details/39992723</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39896009">intellij IDEA更换主题为Darcula后中文项目名称变口（方框）的解决办法</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39896009">http://blog.csdn.net/huangyuan_xuan/article/details/39896009</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39723251">java模拟登录校内成绩查询网站，将获得的HTML代码用jsoup解析</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39723251">http://blog.csdn.net/huangyuan_xuan/article/details/39723251</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39119797">Ubuntu14.04 LTS更新源</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39119797">http://blog.csdn.net/huangyuan_xuan/article/details/39119797</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39118723">ubuntu14.04开机自动挂载windows磁盘的配置方法</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39118723">http://blog.csdn.net/huangyuan_xuan/article/details/39118723</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39081435">java实现MD5和sha1加密</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/39081435">http://blog.csdn.net/huangyuan_xuan/article/details/39081435</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38427607">22 PPP协议</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38427607">http://blog.csdn.net/huangyuan_xuan/article/details/38427607</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38427547">21 串行接口封装</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38427547">http://blog.csdn.net/huangyuan_xuan/article/details/38427547</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38427527">20 internet connection</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38427527">http://blog.csdn.net/huangyuan_xuan/article/details/38427527</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38423675">19 广域网 WAN</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38423675">http://blog.csdn.net/huangyuan_xuan/article/details/38423675</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38405103">java的JDK的安装配置图文详解</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38405103">http://blog.csdn.net/huangyuan_xuan/article/details/38405103</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38387045">18 ACL访问控制列表（access control list）</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38387045">http://blog.csdn.net/huangyuan_xuan/article/details/38387045</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38342675">17 NAT转换</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38342675">http://blog.csdn.net/huangyuan_xuan/article/details/38342675</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38278825">16 DHCP</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/38278825">http://blog.csdn.net/huangyuan_xuan/article/details/38278825</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/37957229">Java常见错误列表</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/37957229">http://blog.csdn.net/huangyuan_xuan/article/details/37957229</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/37937957">LXLE Linux取代Windows XP的11个大招</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/37937957">http://blog.csdn.net/huangyuan_xuan/article/details/37937957</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/37738127">jQuery语法简介</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/37738127">http://blog.csdn.net/huangyuan_xuan/article/details/37738127</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/37728211">cookie简介</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/37728211">http://blog.csdn.net/huangyuan_xuan/article/details/37728211</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/37699891">DOM 简介</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/37699891">http://blog.csdn.net/huangyuan_xuan/article/details/37699891</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/28880287">vim 命令</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/28880287">http://blog.csdn.net/huangyuan_xuan/article/details/28880287</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/28276437">我们大神都这样——提问的智慧</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/28276437">http://blog.csdn.net/huangyuan_xuan/article/details/28276437</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/27972015">初学C语言的人看不懂的关机代码</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/27972015">http://blog.csdn.net/huangyuan_xuan/article/details/27972015</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/27792089">ubuntu连接路由器无线网络，却不能上网</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/27792089">http://blog.csdn.net/huangyuan_xuan/article/details/27792089</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26969041">sublime-text2的中英文对照表（附带个人的配置习惯）</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26969041">http://blog.csdn.net/huangyuan_xuan/article/details/26969041</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26246709">电脑蓝屏代码大全</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26246709">http://blog.csdn.net/huangyuan_xuan/article/details/26246709</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26245513">VC6.0 快捷键整理</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26245513">http://blog.csdn.net/huangyuan_xuan/article/details/26245513</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26245135">玩游戏无法全屏</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26245135">http://blog.csdn.net/huangyuan_xuan/article/details/26245135</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26244991">15 Ospf</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26244991">http://blog.csdn.net/huangyuan_xuan/article/details/26244991</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26244541">14 EIGRP 配置</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26244541">http://blog.csdn.net/huangyuan_xuan/article/details/26244541</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26244439">13 ERGIP</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26244439">http://blog.csdn.net/huangyuan_xuan/article/details/26244439</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26244201">12    rip-2  配置命令</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26244201">http://blog.csdn.net/huangyuan_xuan/article/details/26244201</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26244031">11    rip -1</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26244031">http://blog.csdn.net/huangyuan_xuan/article/details/26244031</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26243735">10动态路由</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26243735">http://blog.csdn.net/huangyuan_xuan/article/details/26243735</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26243487">9静态路由</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26243487">http://blog.csdn.net/huangyuan_xuan/article/details/26243487</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26243293">8网络拓扑结构</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26243293">http://blog.csdn.net/huangyuan_xuan/article/details/26243293</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26243041">7VLSM子网划分</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26243041">http://blog.csdn.net/huangyuan_xuan/article/details/26243041</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26242799">6常用网络相关命令</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26242799">http://blog.csdn.net/huangyuan_xuan/article/details/26242799</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26242589">5数据包发送流程</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26242589">http://blog.csdn.net/huangyuan_xuan/article/details/26242589</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26242183">网线</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26242183">http://blog.csdn.net/huangyuan_xuan/article/details/26242183</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26242101">osi七层网络模型4</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26242101">http://blog.csdn.net/huangyuan_xuan/article/details/26242101</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26242015">osi七层网络模型3</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26242015">http://blog.csdn.net/huangyuan_xuan/article/details/26242015</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26241831">osi七层网络模型2</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26241831">http://blog.csdn.net/huangyuan_xuan/article/details/26241831</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26241631">OSI七层网络模型1</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26241631">http://blog.csdn.net/huangyuan_xuan/article/details/26241631</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26164349">sublime-text2 编译java出错 Decode error - output not utf-8的解决办法</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26164349">http://blog.csdn.net/huangyuan_xuan/article/details/26164349</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26162201">安装虚拟机报错解决办法 TheVMware Authorization Service is not running</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26162201">http://blog.csdn.net/huangyuan_xuan/article/details/26162201</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26162083">我的vim配置</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26162083">http://blog.csdn.net/huangyuan_xuan/article/details/26162083</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26161983">sublime text 2 搭建java运行环境</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26161983">http://blog.csdn.net/huangyuan_xuan/article/details/26161983</a><br><br> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26160973">ubuntu的一点命令</a> <a href="http://blog.csdn.net/huangyuan_xuan/article/details/26160973">http://blog.csdn.net/huangyuan_xuan/article/details/26160973</a><br><br> 以后主要就在gitpage上写博客了.<br> 以上</p>
]]></content>
      <tags>
        <tag>csdn</tag>
      </tags>
  </entry>
  <entry>
    <title>发布开源库到jcenter</title>
    <url>/2019/11/04/%E5%8F%91%E5%B8%83%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%B0jcenter/</url>
    <content><![CDATA[<p>最近学习了一下Annotation和APT，简单的写了个库，想要发布到公共仓库供大家使用(虽然没人用，但就是想尝试一下)，最简单的是通过<a href="https://jitpack.io/">https://jitpack.io/</a>直接从github上抓取release代码打包，并且目前已经支持<a href="https://gitee.com/">https://gitee.com/</a>。但是，发布简单的纯java库或者Android Application库都比较简单，在github仓库中打个tag或者发布一下release，在jitpack上抓取一下就好，教程在这里<a href="https://jitpack.io/docs/#publishing-on-jitpack">https://jitpack.io/docs/#publishing-on-jitpack</a>，对于有多个依赖的Android Lib,抱歉，我是真的没搞定，于是转战<a href="https://bintray.com/">https://bintray.com</a></p>
<span id="more"></span>

<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ol>
<li>首先注册个账号，打开官网首页，点击白色的<code>Sign Up Here</code>而不是那个大绿色的按钮(START YOUR FREE TRIAL)</li>
<li>填完信息后到邮箱激活一下账号、登录。</li>
<li>创建一个仓库，仓库名随意，Type选择Maven，Licenses和Description选填。</li>
<li>复制自己的api key。<br><img src="/image/jcenter/get_jfrog_api_key.png" alt="api key"><br>在首页点击”edit”，在新页面左侧<code>API Key</code>,输入密码，复制一下</li>
</ol>
<h4 id="上传到bintray"><a href="#上传到bintray" class="headerlink" title="上传到bintray"></a>上传到bintray</h4><ol>
<li><p>在AndroidStudio工程和module中配置<br> 在工程的build.gradle中添加<code>classpath &#39;com.novoda:bintray-release:0.9.1&#39;</code><br> 在要上传的lib module中添加</p>
 <figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;java-library&#x27;</span><br>apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.novoda.bintray-release&#x27;</span> <span class="hljs-comment">//添加</span><br>dependencies &#123;<br>    implementation fileTree(<span class="hljs-attr">dir:</span> <span class="hljs-string">&#x27;libs&#x27;</span>, <span class="hljs-attr">include:</span> [<span class="hljs-string">&#x27;*.jar&#x27;</span>])<br>&#125;<br>...<br>...<br><br><span class="hljs-comment">//添加</span><br><span class="hljs-comment">//其他人引用的格式为 groupId:artifactId:publishVersion</span><br>publish &#123;<br>    userOrg = <span class="hljs-string">&#x27;huangyuanlove&#x27;</span> <span class="hljs-comment">//JFrogBintray的用户名</span><br>    repoName = <span class="hljs-string">&#x27;AndroidAnnotation&#x27;</span> <span class="hljs-comment">//上面创建的仓库名</span><br>    groupId = <span class="hljs-string">&#x27;com.huangyuanlove&#x27;</span> <br>    artifactId = <span class="hljs-string">&#x27;view-inject-annotation&#x27;</span><br>    publishVersion = <span class="hljs-string">&#x27;0.0.2&#x27;</span><br>    desc = <span class="hljs-string">&#x27;Make flow layouts simpler&#x27;</span><br>    website = <span class="hljs-string">&#x27;https://github.com/huangyuanlove/AndroidAnnotation&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>执行<code>./gradlew clean build bintrayUpload -PbintrayUser=username -PbintrayKey=apiKey -PdryRun=false</code></p>
</li>
<li><p>等待执行成功，提示successful</p>
</li>
</ol>
<h4 id="发布到jcenter"><a href="#发布到jcenter" class="headerlink" title="发布到jcenter"></a>发布到jcenter</h4><p><img src="/image/jcenter/package_in_repository.png" alt="packages in repository"></p>
<ol>
<li><p>在自己的bintray仓库中找到这个包，进入详情页</p>
<p><img src="/image/jcenter/add_to_jcenter.png" alt="packages in repository"></p>
</li>
<li><p>点击右上角<code>Actions</code>菜单，选择<code>Add to Jcenter</code>，在弹出框点击<code>send</code></p>
</li>
<li><p>审核结果会以站内信的形式通知你，不通过的话会告诉你原因。自己刚开始发布的版本含有<code>preview</code>，审核不通过，建议经过详细测试之后再提交</p>
</li>
</ol>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>jcenter</tag>
      </tags>
  </entry>
  <entry>
    <title>如何获取csdn中个人所有文章标题及链接</title>
    <url>/2016/10/19/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96csdn%E4%B8%AD%E4%B8%AA%E4%BA%BA%E6%89%80%E6%9C%89%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%E5%8F%8A%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>小伙伴问如何把自己csdn上的文章标题和超链接都扒下来,问我是不是一个个点开之后抄过去的…当然不是,做为一个爱(sha)好(dou)广(dong)泛(dian)的程序员,怎么会用这么麻烦的方法.</p>
<span id="more"></span>
<p>　　本来打算写java模拟登录之后获取网页源码,然后再用jsoup去解析,得到自己需要的数据.原来就这么干过,好像是写学校的绩点计算器来着吧,就是输入帐号密码就能查到自己的成绩和绩点的那种.<br>翻出来代码看了看太麻烦了,想到自己最近在看python,就想着用python来解决,但是问题又来了,python不熟啊,就算写出来了也得看网页源码,找到规律才行,讲道理的说挺烦这东西的.<br>最后,还是用js来解决,毕竟这种事也干过,也不是多麻烦.<br>登录自己的帐号,找到文章列表,打开控制台窗口,忘了说一下自己的环境了<code>ubuntu</code>,<code>chrom</code>,找到文章标题和超链接的部分,如下图:<br><img src="/image/csdn_home.png" alt="csdn个人博客列表"><br>发现所有的文章标题和超链接结构如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs HTML"> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;link_title&quot;</span>&gt;</span><br> 	<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/huangyuan_xuan/article/details/51935666&quot;</span>&gt;</span><br>        初步编写IDEA\AndroidStudio翻译插件            <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>另外,界面中还引入了jQuery这个三方库,这就更简单了:<br>找到开发者工具的控制台(console),写入下面两行代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> aTags = $(<span class="hljs-string">&quot;.link_title &gt; a&quot;</span>)<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">50</span>;i++)<br>&#123;<br>	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;[&quot;</span> + aTags[i].<span class="hljs-property">text</span>.<span class="hljs-title function_">trim</span>() + <span class="hljs-string">&quot;](&quot;</span> + aTags[i].<span class="hljs-property">href</span> +<span class="hljs-string">&quot;) &quot;</span>+ aTags[i].<span class="hljs-property">href</span>) +<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span><br>	&#125;<br></code></pre></td></tr></table></figure>
<p>ok,执行结果如下<br><img src="/image/csdn_blog_title.png" alt="csdn个人博客标题和超链接"><br>　　在控制台写的代码第一行是使用jQuery库找到所有文章的超链接集合,第二行是按照<code>markdown</code>超链接的语法打印出来文章标题和超链接,至于循环中的<code>50</code>这个数字,一页最多只有50篇文章,我偷懒了,建议使用<code>aTags.length</code></p>
<hr>
以上
]]></content>
      <tags>
        <tag>csdn</tag>
      </tags>
  </entry>
  <entry>
    <title>安装git与连接github</title>
    <url>/2019/01/27/%E5%AE%89%E8%A3%85git%E4%B8%8E%E8%BF%9E%E6%8E%A5github/</url>
    <content><![CDATA[<p>这可能是有史以来我写过的最啰嗦的博客了。</p>
<span id="more"></span>


<h4 id="1-安装github"><a href="#1-安装github" class="headerlink" title="1. 安装github"></a>1. 安装github</h4><h5 id="1-1-在linux上安装github"><a href="#1-1-在linux上安装github" class="headerlink" title="1.1  在linux上安装github"></a>1.1  在linux上安装github</h5><p>首先可以试着在shell中输入<code>git</code>，若提示没有该命令，则可以使用<code>sudo apt-get install git</code> 来安装，</p>
<h5 id="1-2-在windows上安装github"><a href="#1-2-在windows上安装github" class="headerlink" title="1.2  在windows上安装github"></a>1.2  在windows上安装github</h5><p>可以在[<a href="https://git-scm.com/downloads]https://git-scm.com/downloads">https://git-scm.com/downloads]https://git-scm.com/downloads</a>) 下载，然后默认安装就可以了，安装后在空白处右键，会有<code>git GUI here</code>和<code>git bash here</code>。</p>
<h4 id="配置本地和远程git仓库"><a href="#配置本地和远程git仓库" class="headerlink" title="配置本地和远程git仓库"></a>配置本地和远程git仓库</h4><h5 id="2-1-配置本地环境"><a href="#2-1-配置本地环境" class="headerlink" title="2.1  配置本地环境"></a>2.1  配置本地环境</h5><p>打开 git shell ,配置用户名和邮箱(这里的用户名邮箱与下文中的连接github或者其他三方git服务没有任何关系)    </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure>

<p>#####2.2  配置远程仓库<br>以github为例，其他git服务也类似<br>申请好账号之后，点击右上角自己的头像在弹出菜单中选择<code>settings</code>，看起来像下面这样：<br><img src="/image/git/githubHomePage.png" alt="githubHomePage"><br>在新界面中的左侧列表中选择<code>SSH keys</code>，点击右上角的 <code>Add SSH key</code>，看起来像下面这样<br><img src="/image/git/githubSSHKEY.png" alt="githubSSHkey"><br>然后我们回到shell中，继续生成密钥等工作<br>github官网有详细教程，链接地址请点<a href="https://help.github.com/articles/generating-ssh-keys/#platform-windows">https://help.github.com/articles/generating-ssh-keys/#platform-windows</a> ，github网站访问速度慢的可以继续看下去，去github官网看的请跳过本章</p>
<h5 id="2-3-生成ssh-keys"><a href="#2-3-生成ssh-keys" class="headerlink" title="2.3  生成ssh keys"></a>2.3  生成ssh keys</h5><p>首先检测有没有已经生成好的ssh key，windows用户可以查看 <code>C:\Users\username\.ssh</code>文件夹下有没有<code>id_rsa.pub</code>文件，linux用户可以在shell中输入<code>ls -al ~/.ssh</code>，若有，请跳过本步骤。<br>在git shell 中输入下面第一条命令，linux用户注意不用加 <code>sudo</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;<br>Creates a new ssh key, using the provided email as a label<br>Generating public/private rsa key pair.<br></code></pre></td></tr></table></figure>
<p>建议使用默认位置，直接回车就好，接下来会提示是否需要密码，不需要的话直接回车确认，需要的话输入密码，然后确认密码，然后会提示你密钥已经生成。</p>
<h5 id="2-5-将ssh-key添加到你的github账户中"><a href="#2-5-将ssh-key添加到你的github账户中" class="headerlink" title="2.5 将ssh key添加到你的github账户中"></a>2.5 将ssh key添加到你的github账户中</h5><p>回到我们打开的添加SSHKEY网页，点击<code>Add SSH Key</code>，在<code>Title</code>中添加说明，用记事本之类的编辑器打开生成的<code>id_rsa.pub</code>（位于.ssh文件中），复制其中的内容到<code>Key</code>中，然后点击<code>Add Key</code></p>
<h5 id="2-6-测试连接"><a href="#2-6-测试连接" class="headerlink" title="2.6 测试连接"></a>2.6 测试连接</h5><p>打开 git shell 输入<code>ssh -T git@github.com</code>，若提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">The authenticity of host &#x27;github.com (207.97.227.239)&#x27; can&#x27;t be established.<br><span class="hljs-meta prompt_"># </span><span class="language-bash">RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:<span class="hljs-built_in">df</span>:a6:48.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Are you sure you want to <span class="hljs-built_in">continue</span> connecting (<span class="hljs-built_in">yes</span>/no)?</span><br>输入`yes`，如果你看到了如下提示<br>Hi username! You&#x27;ve successfully authenticated, but GitHub does not<br><span class="hljs-meta prompt_"># </span><span class="language-bash">provide shell access.</span><br></code></pre></td></tr></table></figure>
<p>说明连接成功，若有问题，请点击<a href="https://help.github.com/categories/ssh/">这里</a>.</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>运维</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>利用PathMeasure实现路径动画</title>
    <url>/2019/01/04/%E5%88%A9%E7%94%A8PathMeasure%E5%AE%9E%E7%8E%B0%E8%B7%AF%E5%BE%84%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<p>我们可以利用路径动画实现很多好玩的东西，比如上面图中的类似支付宝支付完成的动画。<br>主要用到了<code>PathMeasure</code>,<code>ValueAnumator</code>这两个类</p>
<span id="more"></span>

<h4 id="PathMeasure"><a href="#PathMeasure" class="headerlink" title="PathMeasure"></a>PathMeasure</h4><p>类似于一个计算器，可以计算一些和路径相关的东西。<br>两种初始化方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">PathMeasure</span> <span class="hljs-variable">pathMeasure</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMeasure</span>();<br>pathMeasure.setPath(path,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">PathMeasure</span> <span class="hljs-variable">pathMeasure</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMeasure</span>(path,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>

<h5 id="getLength"><a href="#getLength" class="headerlink" title="getLength()"></a>getLength()</h5><p>用来获取路径长度，并且获取到的是当前曲线的长度，而不是整个Path的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onDraw(canvas);<br>    canvas.translate(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>);<br>    path.addRect(-<span class="hljs-number">50</span>,-<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,Path.Direction.CW);<br>    path.addRect(-<span class="hljs-number">100</span>,-<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,Path.Direction.CW);<br>    path.addRect(-<span class="hljs-number">120</span>,-<span class="hljs-number">120</span>,<span class="hljs-number">120</span>,<span class="hljs-number">120</span>,Path.Direction.CW);<br><br>    canvas.drawPath(path, paint);<br>    pathMeasure.setPath(path,<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">do</span>&#123;<br>    	Log.e(<span class="hljs-string">&quot;huangyuan&quot;</span>,pathMeasure.getLength()+<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<span class="hljs-keyword">while</span> (pathMeasure.nextContour());<br><br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>2019-01-04 21:58:28.408 5231-5231&#x2F;huangyuanlove.com.customwidget E&#x2F;huangyuan: 400.0<br>2019-01-04 21:58:28.408 5231-5231&#x2F;huangyuanlove.com.customwidget E&#x2F;huangyuan: 800.0<br>2019-01-04 21:58:28.408 5231-5231&#x2F;huangyuanlove.com.customwidget E&#x2F;huangyuan: 960.0</p>
</blockquote>
<p>pathMeasure.nextContour()得到的曲线的顺序与添加到Path中的顺序相同</p>
<h5 id="getSegment"><a href="#getSegment" class="headerlink" title="getSegment()"></a>getSegment()</h5><p>函数定义</p>
<blockquote>
<p>public boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)</p>
</blockquote>
<p>懒得翻译，自己看吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Given a start and stop distance, return in dst the intervening</span><br><span class="hljs-comment">    * segment(s). If the segment is zero-length, return false, else return</span><br><span class="hljs-comment">    * true. startD and stopD are pinned to legal values (0..getLength()).</span><br><span class="hljs-comment">    * If startD &gt;= stopD then return false (and leave dst untouched).</span><br><span class="hljs-comment">    * Begin the segment with a moveTo if startWithMoveTo is true.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>我们可以这么用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onDraw(canvas);<br>    canvas.translate(<span class="hljs-number">150</span>, <span class="hljs-number">150</span>);<br>    path.addRect(-<span class="hljs-number">50</span>,-<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,Path.Direction.CW);<br>    <span class="hljs-type">Path</span> <span class="hljs-variable">dst</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>    pathMeasure.setPath(path,<span class="hljs-literal">false</span>);<br>    pathMeasure.getSegment(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,dst,<span class="hljs-literal">true</span>);<br>    canvas.drawPath(dst,paint);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>得到：<br><img src="/image/Android/PathMeasure/dst.png" alt="getSegment" title="getSegment"><br>如果dst路径不为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">dst</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>dst.lineTo(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>
<p>得到<br><img src="/image/Android/PathMeasure/dst_not_null.png" alt="dst路径不空" title="dst路径不空"><br>如果dst路径不空，<code>startWithMoveTo</code>为false，得到<br><img src="/image/Android/PathMeasure/starWithMoveToFalse.png" alt="starWithMoveToFalse，" title="starWithMoveToFalse"></p>
<h5 id="路径加载动画"><a href="#路径加载动画" class="headerlink" title="路径加载动画"></a>路径加载动画</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestPathMeasure</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> &#123;<br>       <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);<br>       init();<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//禁用硬件加速</span><br>       setLayerType(LAYER_TYPE_SOFTWARE,<span class="hljs-literal">null</span>);<br>       paint = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Paint</span>(Paint.ANTI_ALIAS_FLAG);<br>       paint.setColor(Color.BLACK);<br>       paint.setStrokeWidth(<span class="hljs-number">4</span>);<br>       paint.setStyle(Paint.Style.STROKE);<br>       dstPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>       circlePath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>       circlePath.addCircle(<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">50</span>,Path.Direction.CW);<br>       pathMeasure = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMeasure</span>(circlePath,<span class="hljs-literal">true</span>);<br><br><br>       <span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">valueAnimator</span> <span class="hljs-operator">=</span> ValueAnimator.ofFloat(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>       valueAnimator.setRepeatCount(ValueAnimator.INFINITE);<br><br><br>       valueAnimator.addUpdateListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span> &#123;<br>               currentAnimValue = (<span class="hljs-type">float</span>) animation.getAnimatedValue();<br>               invalidate();<br>           &#125;<br>       &#125;);<br>       valueAnimator.setDuration(<span class="hljs-number">2000</span>);<br>       valueAnimator.start();<br><br>   &#125;<br><br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>       <span class="hljs-built_in">super</span>.onDraw(canvas);<br><br><br>       <span class="hljs-type">float</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> pathMeasure.getLength();<br><br>       <span class="hljs-type">float</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> pathMeasure.getLength() * currentAnimValue;<br><br>       <span class="hljs-type">float</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (stop- ((<span class="hljs-number">0.5</span>- Math.abs(currentAnimValue-<span class="hljs-number">0.5</span>))*length));<br><br>       dstPath.reset();<br>       pathMeasure.getSegment(start,stop,dstPath,<span class="hljs-literal">true</span>);<br>       canvas.drawPath(dstPath,paint);<br>   &#125;<br><br></code></pre></td></tr></table></figure>

<p>我们可以在路径动画上加个箭头，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPathMeasure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Paint paint;<br>    <span class="hljs-keyword">private</span> Path path;<br>    <span class="hljs-keyword">private</span> Path dstPath;<br>    <span class="hljs-keyword">private</span> Path circlePath;<br>    <span class="hljs-keyword">private</span> PathMeasure pathMeasure;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> currentAnimValue;<br><br>    <span class="hljs-keyword">private</span> Bitmap icChevronRight;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span>[] pos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">float</span>[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span>[] tan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">float</span>[<span class="hljs-number">2</span>];<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestPathMeasure</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context);<br>        init(context);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestPathMeasure</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs);<br>        init(context);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestPathMeasure</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);<br>        init(context);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-comment">//禁用硬件加速</span><br>        setLayerType(LAYER_TYPE_SOFTWARE, <span class="hljs-literal">null</span>);<br>        paint = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Paint</span>(Paint.ANTI_ALIAS_FLAG);<br>        paint.setColor(Color.BLACK);<br>        paint.setStrokeWidth(<span class="hljs-number">4</span>);<br>        paint.setStyle(Paint.Style.STROKE);<br>        dstPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>        circlePath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>        circlePath.addCircle(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">150</span>, Path.Direction.CW);<br>        pathMeasure = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMeasure</span>(circlePath, <span class="hljs-literal">true</span>);<br>        BitmapFactory.<span class="hljs-type">Options</span> <span class="hljs-variable">options</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BitmapFactory</span>.Options();<br><br>        icChevronRight = BitmapFactory.decodeResource(context.getResources(), R.drawable.right);<br><br><br>        <span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">valueAnimator</span> <span class="hljs-operator">=</span> ValueAnimator.ofFloat(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        valueAnimator.setRepeatCount(ValueAnimator.INFINITE);<br><br><br>        valueAnimator.addUpdateListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span> &#123;<br>                currentAnimValue = (<span class="hljs-type">float</span>) animation.getAnimatedValue();<br>                invalidate();<br>            &#125;<br>        &#125;);<br>        valueAnimator.setDuration(<span class="hljs-number">2000</span>);<br>        valueAnimator.start();<br><br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDraw(canvas);<br><br><br>        <span class="hljs-type">float</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> pathMeasure.getLength();<br><br>        <span class="hljs-type">float</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> pathMeasure.getLength() * currentAnimValue;<br><br>        <span class="hljs-type">float</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (stop - ((<span class="hljs-number">0.5</span> - Math.abs(currentAnimValue - <span class="hljs-number">0.5</span>)) * length));<br><br>        dstPath.reset();<br>        pathMeasure.getSegment(start, stop, dstPath, <span class="hljs-literal">true</span>);<br>        canvas.drawPath(dstPath, paint);<br><br><br>        pathMeasure.getPosTan(stop, pos, tan);<br>        <span class="hljs-type">float</span> <span class="hljs-variable">degrees</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (Math.atan2(tan[<span class="hljs-number">1</span>], tan[<span class="hljs-number">0</span>]) * <span class="hljs-number">180</span> / Math.PI);<br><br>        <span class="hljs-type">Matrix</span> <span class="hljs-variable">matrix</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Matrix</span>();<br><span class="hljs-comment">//        matrix.postRotate(degrees,icChevronRight.getWidth()/2,icChevronRight.getHeight()/2);</span><br><span class="hljs-comment">//        matrix.postTranslate(pos[0] -icChevronRight.getWidth()/2,pos[1]-icChevronRight.getHeight()/2);</span><br><br>        pathMeasure.getMatrix(stop, matrix, PathMeasure.POSITION_MATRIX_FLAG | PathMeasure.TANGENT_MATRIX_FLAG);<br>        matrix.preTranslate(-icChevronRight.getWidth() / <span class="hljs-number">2</span>, -icChevronRight.getHeight() / <span class="hljs-number">2</span>);<br>        canvas.drawBitmap(icChevronRight, matrix, paint);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里主要用到了Matrix和getPosTan(),用来得到路径上某一长度的位置以及该位置的正切值。函数原型如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Pins distance to 0 &lt;= distance &lt;= getLength(), and then computes the</span><br><span class="hljs-comment"> * corresponding position and tangent. Returns false if there is no path,</span><br><span class="hljs-comment"> * or a zero-length path was specified, in which case position and tangent</span><br><span class="hljs-comment"> * are unchanged.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> distance The distance along the current contour to sample</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pos If not null, returns the sampled position (x==[0], y==[1])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> tan If not null, returns the sampled tangent (x==[0], y==[1])</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> false if there was no path associated with this measure object</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getPosTan</span><span class="hljs-params">(<span class="hljs-type">float</span> distance, <span class="hljs-type">float</span> pos[], <span class="hljs-type">float</span> tan[])</span> <br></code></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li>float distance: 距离Path起点的长度，取值范围0&lt;&#x3D;distance&lt;&#x3D;getLength</li>
<li>float[] pos:该点的坐标值，pos[0]表示x坐标，pos[y]表示y坐标</li>
<li>float[] tan:该点的正切值。</li>
</ul>
<p>在上面的代码中需要注意的是</p>
<ul>
<li>pos、tan数组在使用时必须先使用new关键词分配存储空间，而PathMeasure.getPosTan函数只会向数组中的元素赋值。</li>
<li>通过Math.atan2(tan[1],tan[0])得到的是弧度值，而不是角度</li>
<li>先利用matrix.postRotate将图片旋转指定角度，然后用matix.postTranslate将图片移动到当前路径最前端(注释掉的那两句)</li>
</ul>
<p>pathMeasure有个getMatrix函数，是对我们自己实现的那种方式的封装，我们只需要将图片移动一下就好了</p>
<h4 id="山寨支付宝支付成功动画"><a href="#山寨支付宝支付成功动画" class="headerlink" title="山寨支付宝支付成功动画"></a>山寨支付宝支付成功动画</h4><p>就是先画一个圆，然后圆形里面画个对勾。。。。。很简陋的一种实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliPaySuccess</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Paint paint;<br>    <span class="hljs-keyword">private</span> Path dstPath;<br>    <span class="hljs-keyword">private</span> Path circlePath;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">centerX</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">centerY</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">250</span>;<br>    <span class="hljs-keyword">private</span> PathMeasure pathMeasure;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> currentAnimValue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> switchLine;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AliPaySuccess</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AliPaySuccess</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AliPaySuccess</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        setLayerType(LAYER_TYPE_SOFTWARE, <span class="hljs-literal">null</span>);<br>        paint = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Paint</span>(Paint.ANTI_ALIAS_FLAG);<br>        paint.setColor(Color.BLACK);<br>        paint.setStrokeWidth(<span class="hljs-number">4</span>);<br>        paint.setStyle(Paint.Style.STROKE);<br>        dstPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>        circlePath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>        circlePath.addCircle(centerX,centerY,radius,Path.Direction.CW);<br>        circlePath.moveTo(centerX-radius/<span class="hljs-number">2</span>,centerY);<br>        circlePath.lineTo(centerX,centerY+radius/<span class="hljs-number">2</span>);<br>        circlePath.lineTo(centerX+radius/<span class="hljs-number">2</span>,centerY-radius/<span class="hljs-number">3</span>);<br>        pathMeasure = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMeasure</span>(circlePath,<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">animator</span> <span class="hljs-operator">=</span> ValueAnimator.ofFloat(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>);<br>        animator.addUpdateListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span> &#123;<br>                currentAnimValue = (<span class="hljs-type">float</span>) animation.getAnimatedValue();<br>                invalidate();<br>            &#125;<br>        &#125;);<br>        animator.setDuration(<span class="hljs-number">2000</span>);<br>        animator.setInterpolator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccelerateInterpolator</span>());<br>        animator.start();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDraw(canvas);<br>        <span class="hljs-keyword">if</span>(currentAnimValue&lt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-type">float</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> pathMeasure.getLength()*currentAnimValue;<br>            pathMeasure.getSegment(<span class="hljs-number">0</span>,stop,dstPath,<span class="hljs-literal">true</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentAnimValue &gt;<span class="hljs-number">1</span> &amp;&amp; !switchLine)&#123;<br>            pathMeasure.getSegment(<span class="hljs-number">0</span>,pathMeasure.getLength(),dstPath,<span class="hljs-literal">true</span>);<br>            switchLine = <span class="hljs-literal">true</span>;<br>            pathMeasure.nextContour();<br>        &#125;<span class="hljs-keyword">else</span>   &#123;<br>            <span class="hljs-type">float</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> pathMeasure.getLength()*(currentAnimValue-<span class="hljs-number">1</span>);<br>            pathMeasure.getSegment(<span class="hljs-number">0</span>,stop,dstPath,<span class="hljs-literal">true</span>);<br>        &#125;<br>        canvas.drawPath(dstPath,paint);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ol>
<li><p>首先初始化各种参数：画笔、路径和动画</p>
<p> 初始化路径时，先添加了外面的圆形，然后是里面的对勾。设置动画从0～2，0-1时画圆，1-2时画对勾。</p>
</li>
<li><p>重写onDraw，判断当前的动画值，在0-1时画圆，当动画值第一次大于1时，切换到对号那条线上。</p>
<p>这里的<code>currentAnimValue</code>不一定会有等于1的时候，至少我执行了十几遍也没出现一次。所以取的是第一次大于时切换。</p>
</li>
<li><p>这里面的数值和颜色之类的属性都是直接写死的，应该通过xml文件读取。</p>
</li>
</ol>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>对应用中Alarm优化</title>
    <url>/2018/10/31/%E5%AF%B9%E5%BA%94%E7%94%A8%E4%B8%ADAlarm%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>起因：华为应用市场反馈Alarm唤醒次数过多，需要优化。<br>未优化之前通过华为的DevEco进行功耗测试，在Mate 9上每小时唤醒71次，在p10上每小时唤醒62，妥妥的手机没办法进入休眠状态，而他们的标准是每个应用每小时唤醒不超过20次。<br><img src="/image/Android/alarm/%E6%9C%AA%E4%BC%98%E5%8C%96.png" alt="测试结果"></p>
<span id="more"></span>

<h4 id="查找使用Alarm的代码"><a href="#查找使用Alarm的代码" class="headerlink" title="查找使用Alarm的代码"></a>查找使用Alarm的代码</h4><ol>
<li>Alarm的使用需要AlarmManager，而AlarmManager的获取是通过getSystemService(ALARM_SERVICE)获取到的，找到了某个类中中的doMyJob方法，其中每隔5分钟唤醒一次设备。其他的Alarm服务间隔时间比较长，有的是一天唤醒一次，有的是定时上午九点唤醒，这些闹钟全部加起来一小时也不会超过15次。</li>
<li>使用 adb shell dumpsys alarm | grep “包名” 查看系统中的存在哪些Alarm并通过项目包名过滤掉不是自己工程的Alarm，发现了 <code> *walarm*:包名.service_alive_alarm_filter</code>,查看相关代码发现每隔十分钟唤醒一次设备，一方面是为了保活，一方面是为了检查计步传感器是否开启，因为有些设备在息屏之后会关闭计步传感器，这时候我们需要切换到自己的计步算法，通过加速度传感器来计算运动步数。</li>
<li>调整这两个Alarm的唤醒频率， 提交到DevEco进行测试，结果如下：<br><img src="/image/Android/alarm/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96.png" alt="测试结果"></li>
</ol>
<h4 id="查找三方使用的Alarm"><a href="#查找三方使用的Alarm" class="headerlink" title="查找三方使用的Alarm"></a>查找三方使用的Alarm</h4><ol>
<li>仔细查看使用adb shell找到的alarm，发现了这货 <code>*walarm*:AlarmNioTaskSchedule.包名</code>，如果是我们自己在工程里面设置的Alarm，一般是以自己的项目包名命名的，接着查dump出来的信息，找到了两个唤醒间隔时间非常短的Alarm，粗略估计每个的唤醒间隔在4分钟半。下面日志中when就是alarm唤醒的时间点<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs log">ELAPSED_WAKEUP #0: Alarm&#123;a359f35 type 2 when 1911290944 包名&#125;<br>      operation=PendingIntent&#123;7551fca: PendingIntentRecord&#123;eb70106 包名 startService&#125;&#125;<br>ELAPSED_WAKEUP #1: Alarm&#123;80150f type 2 when 1911660925 包名&#125;<br>      operation=PendingIntent&#123;58db99c: PendingIntentRecord&#123;35972a0 包名 broadcastIntent&#125;&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>通过PendingIntent和PendingIntentRecord的编号，结合  adb shell dumpsys activity intents | grep “包名”<br>找到设置该Alarm的包名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs log">#4: PendingIntentRecord&#123;eb70106 包名 startService&#125;<br>      uid=10415 packageName=包名 type=startService flags=0x0<br>      requestIntent=act=com.qiyukf.desk.ACTION.KEEP_ALIVE cmp=包名/com.qiyukf.nimlib.service.NimService (has extras)<br> <br>#8: PendingIntentRecord&#123;35972a0 包名 broadcastIntent&#125;<br>      uid=10415 packageName=包名 type=broadcastIntent flags=0x0<br>      requestIntent=act=com.qiyukf.nim.ACTION.ALARM.REPEATING cmp=包名/com.qiyukf.nimlib.service.NimReceiver<br></code></pre></td></tr></table></figure>
<p>由于是三方的包，没办法修改代码来完成，只能用其他方法。<br>翻看设置Alarm的源码发现：由于设置Alarm的时候需要调用set或者setRepeating方法，最终都会调用setImpl方法，最后通过进程间通信，调IAlarmManager的set方法。<br>IAlarmManager的实现类是AlarmManagerService,只需要替换掉这个类的实例，在调用它的set方法时，替换掉alarm的时间间隔<br>就可以减少一部分alarm的唤醒。<br>由于hook的时间越早越好，于是选在Application初始化的时候进行hook，在Application的onCreate方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//替换IAlarmService</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">AlarmManager</span> <span class="hljs-variable">alarm</span> <span class="hljs-operator">=</span> (AlarmManager) getSystemService(ALARM_SERVICE);<br>    Class&lt;?&gt; alarmManagerClass = alarm.getClass();<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">mService</span> <span class="hljs-operator">=</span> alarmManagerClass.getDeclaredField(<span class="hljs-string">&quot;mService&quot;</span>);<br>    mService.setAccessible(<span class="hljs-literal">true</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">mSerViceInstant</span> <span class="hljs-operator">=</span> mService.get(alarm);<br><br>    <span class="hljs-type">AlarmManagerInvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlarmManagerInvocationHandler</span>(mSerViceInstant);<br>    Class&lt;?&gt; IActivityManagerIntercept = Class.forName(<span class="hljs-string">&quot;android.app.IAlarmManager&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[]&#123;IActivityManagerIntercept&#125;, handler);<br>    mService.set(alarm, proxy);<br><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    Log.e(<span class="hljs-string">&quot;alarm_manager&quot;</span>, <span class="hljs-string">&quot;替换出错&quot;</span>);<br>    e.printStackTrace();<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlarmManagerInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object iAlarmManagerObject;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">AlarmManagerInvocationHandler</span><span class="hljs-params">(Object iAlarmManagerObject)</span> &#123;<br>        <span class="hljs-built_in">this</span>.iAlarmManagerObject = iAlarmManagerObject;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br><br>        Log.i(<span class="hljs-string">&quot;alarm_manager&quot;</span>, method.getName());<br>        <span class="hljs-comment">//小于五小时间隔的设置为五小时</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;set&quot;</span>.equals(method.getName())) &#123;<br>            Log.e(<span class="hljs-string">&quot;alarm_manager&quot;</span>, <span class="hljs-string">&quot;调用了mService.set()&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minAlarmInterval</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">alarmManagerTimeType</span> <span class="hljs-operator">=</span> Integer.valueOf(args[<span class="hljs-number">1</span>].toString());<br>                <span class="hljs-type">long</span> <span class="hljs-variable">alarmManagerAtTime</span> <span class="hljs-operator">=</span> Long.valueOf(args[<span class="hljs-number">2</span>].toString());<br>                Log.e(<span class="hljs-string">&quot;alarm_manager_interval&quot;</span>, <span class="hljs-string">&quot;alarmManagerTimeType:&quot;</span> +alarmManagerTimeType);<br>                Log.e(<span class="hljs-string">&quot;alarm_manager_interval&quot;</span>, <span class="hljs-string">&quot;alarmManagerAtTime:&quot;</span> +alarmManagerAtTime);<br>                <span class="hljs-keyword">switch</span> (alarmManagerTimeType) &#123;<br>                    <span class="hljs-keyword">case</span> AlarmManager.RTC_WAKEUP:<br>                    <span class="hljs-keyword">case</span> AlarmManager.RTC:<br>                        Log.e(<span class="hljs-string">&quot;alarm_manager_interval&quot;</span>, <span class="hljs-string">&quot;currentTimeMillis--RTC:&quot;</span> +System.currentTimeMillis());<br>                         interval = alarmManagerAtTime - System.currentTimeMillis();<br>                            <span class="hljs-keyword">if</span>(interval &lt; minAlarmInterval)&#123;<br>                                interval = minAlarmInterval;<br>                                args[<span class="hljs-number">2</span>] = System.currentTimeMillis() + interval;<br>                            &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> AlarmManager.ELAPSED_REALTIME:<br>                    <span class="hljs-keyword">case</span> AlarmManager.ELAPSED_REALTIME_WAKEUP:<br>                        Log.e(<span class="hljs-string">&quot;alarm_manager_interval&quot;</span>, <span class="hljs-string">&quot;currentTimeMillis--ELAPSED_REALTIME:&quot;</span> +SystemClock.elapsedRealtime());<br>                        interval = alarmManagerAtTime - SystemClock.elapsedRealtime();<br>                        <span class="hljs-keyword">if</span>(interval &lt; minAlarmInterval)&#123;<br>                            interval = minAlarmInterval;<br>                            args[<span class="hljs-number">2</span>] = SystemClock.elapsedRealtime() + interval;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                Log.e(<span class="hljs-string">&quot;alarm_manager_interval&quot;</span>,interval+<span class="hljs-string">&quot;--&gt;&quot;</span> + interval/<span class="hljs-number">1000</span>/<span class="hljs-number">60</span> );<br><br><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> method.invoke(iAlarmManagerObject, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>打包提交DevEco进行测试，结果如下：<br><img src="/image/Android/alarm/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BC%98%E5%8C%96.png" alt="测试结果"></p>
<h4 id="当前结果"><a href="#当前结果" class="headerlink" title="当前结果"></a>当前结果</h4><p>从最初的60-70次优化到现在的19-23次，但还是不符合华为的标准每小时小于20次，原因在于有一个Alarm没有找到所属的程序包，不知道是在哪里设置的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs log">RTC_WAKEUP #0: Alarm&#123;c5091d9 type 0 when 1534851817125 包名&#125;<br>      tag=*walarm*:AlarmTaskSchedule.包名<br>      operation=PendingIntent&#123;194679e: PendingIntentRecord&#123;e513b24 包名 broadcastIntent&#125;&#125;<br>*walarm*:AlarmTaskSchedule.包名<br></code></pre></td></tr></table></figure>
<p>这个Alarm粗略估计每小时唤醒次数在15-20次之间，既然通过hook底层代码的方法没有拦截下它，估计是通过jni在更加底层进行的操作，目前还在排查</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建git服务</title>
    <url>/2017/04/15/%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>公司的版本控制要从SVN迁移到git，正式的开发环境还没有搭建好，于是自己做了一个简单git服务。<br>环境：<br>本机: win10，服务器：ubuntu 16.04 LTS,ip:192.168.1.103</p>
<span id="more"></span>
<p>本地安装git环境，配置用户名和邮箱之类的信息，然后生成秘钥，生成方式见 <a href="http://blog.csdn.net/huangyuan_xuan/article/details/49125597%E3%80%82">http://blog.csdn.net/huangyuan_xuan/article/details/49125597。</a><br>服务器：</p>
<ol>
<li>安装git,ssh服务<br><code>sudo apt install git ssh</code></li>
<li>新增用户，用户名为git<br><code>adduser git</code></li>
<li>初始化git仓库，我放在&#x2F;home&#x2F;git&#x2F;repository<br><code>cd /home/git/repository</code><br><code>git init --bare test.git</code><br><code>--base</code>参数是初始化裸仓库。<br>执行<code>tree</code>命令可以查看目录结构如下：<br><img src="/image/git/git_init_tree.png" alt="git_init_tree"> </li>
<li>添加秘钥<br>将本地生成的<code>id_rsa.pub</code>文件里面的内容追加到<code>/home/git/.ssh/authorized_keys</code>文件中。<br>可以先将秘钥文件上传到服务器，然后在服务器上操作文件，添加内容。</li>
<li>修改权限<br>将 &#x2F;home&#x2F;git 所有者更改为git用户<br><code>chown -R git:git /home/git</code><br>用户home目录755权限<br><code>chmod 755 /home/git</code><br>.ssh目录700权限<br><code>chmod 700 .ssh</code><br>authorized_keys 600权限<br><code>chmod 600 .ssh/authorized_keys</code></li>
<li>修改ssh配置文件<br>配置文件是<code>/etc/ssh/sshd_config</code>，取消这行 <code>AuthorizedKeysFile    %h/.ssh/authorized_keys</code> 前面的注释</li>
<li>重启<code>ssh</code>服务<br><code>sudo service ssh restart</code></li>
<li>可选项：为了安全 禁止git用户shell登录，需要修改&#x2F;etc&#x2F;passwd<br>将 git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash<br>改为 git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</li>
</ol>
<p>回到本地，进行克隆<br><code>git clone git@192.168.1.103:/home/git/code/test.git</code><br>或者<br><code>git clone git@192.168.1.103:code/test.git</code><br>如果ssh不是默认的22端口，则在ip后添加端口。</p>
]]></content>
      <tags>
        <tag>运维</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装owncloud</title>
    <url>/2019/08/03/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85owncloud/</url>
    <content><![CDATA[<p>买了个新玩具：树莓派3b+，挺好玩。</p>
<ol>
<li>一个开发板(包含cpu、内存、网卡、usb接口)。</li>
<li>一张扩展卡(内存卡，就是之前手机上用的那种TF拓展卡，用来装系统，开发板上有专门的卡槽用来安装扩展卡)。</li>
<li>一根网线(其实开发板上是有无线网卡的，据说配置起来听麻烦，就用网线上，插上就能用)</li>
<li>一根HDMI视频线，毕竟安装系统的时候可能会用到</li>
<li>其他配件，比如散热风扇、外壳、摄像头什么的随意，毕竟不是必须的</li>
</ol>
<span id="more"></span>

<h3 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h3><ol>
<li>系统： 可以在<a href="https://www.raspberrypi.org/downloads/">https://www.raspberrypi.org/downloads/</a> 查看，我是习惯了ubuntu，下载的是 <a href="https://ubuntu.com/download/iot/raspberry-pi-2-3">https://ubuntu.com/download/iot/raspberry-pi-2-3</a> 这个系统，</li>
<li>需要的软件：专门的格式化工具SDFormatter格式化内存卡；windows系统下安装烧写镜像的工具：Win32DiskImager</li>
<li>将下载的系统写到tf卡上，将卡插入开发版，通电，启动的比较慢，可以在屏幕上看到一些输出，根据自己的需要配置一下就好。</li>
</ol>
<h3 id="安装-owncloud"><a href="#安装-owncloud" class="headerlink" title="安装 owncloud"></a>安装 owncloud</h3><h4 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h4><ol>
<li>php环境及必须的组件</li>
</ol>
<blockquote>
<p>安装Apache 网页服务器</p>
<p><strong>$ sudo apt-get install apache2</strong></p>
</blockquote>
<blockquote>
<p>安装Mysql 数据库</p>
<p><strong>$ sudo apt-get install mysql-server mysql-client</strong></p>
</blockquote>
<blockquote>
<p>安装PHP</p>
<p><strong>$ sudo apt-get install php7.2-mysql php7.2-curl php7.2-json php7.2-cgi libapache2-mod-php7.2 php7.2</strong></p>
<p><strong>$ sudo apt-get install php7.2-gd php7.2-intl php7.2-imagick</strong></p>
</blockquote>
<blockquote>
<p>安装phpmyadmin并设置mysql的密码</p>
<p><strong>$ sudo apt-get install phpmyadmin</strong></p>
</blockquote>
<p>根据返回的消息提示进行操作就好，遇到问题可自行搜索解决，解决不了，可以退出了。</p>
<h4 id="检查php环境是否可用"><a href="#检查php环境是否可用" class="headerlink" title="检查php环境是否可用"></a>检查php环境是否可用</h4><p>在 <code>/var/www/html/</code>下新建一个php文件，比如<code>test.php</code>，输入 </p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?</span> php<br>    <span class="hljs-title function_ invoke__">phpinfo</span>();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>保存一下，重启apache服务，<code>sudo /etc/init.d/apache2 restart</code>，访问 <code>http://ip/test.php</code>，如果能看到php版本，则说明环境没问题。如果看不到，请自行解决；解决不了，可以退出了。</p>
<h4 id="下载owncloud源码并部署"><a href="#下载owncloud源码并部署" class="headerlink" title="下载owncloud源码并部署"></a>下载owncloud源码并部署</h4><blockquote>
<p> 下载安装包。</p>
<p> <strong>$ wget</strong> <strong><a href="https://download.owncloud.org/community/owncloud-10.0.9.tar.bz2">https://download.owncloud.org/community/owncloud-10.0.9.tar.bz2</a></strong></p>
<p> 解压安装包</p>
<p> <strong>$ tar -xvf owncloud-10.0.9.tar.bz2</strong></p>
<p> 将所有解压后的文件移到 &#x2F;var&#x2F;www&#x2F;html</p>
<p> <strong>$ sudo mv owncloud&#x2F;*  &#x2F;var&#x2F;www&#x2F;html</strong></p>
<p> 修改Apache的配置文件apache2.conf：</p>
<p> <strong>$ sudo nano &#x2F;etc&#x2F;apache2&#x2F;apache2.conf</strong></p>
<p> 向下查找到<code>AllowOverride</code>，将None修改为All</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Directory</span> /<span class="hljs-attr">var</span>/<span class="hljs-attr">www</span>/&gt;</span><br>	Options Indexes FollowSysmLinks<br>	AllowOverride All<br>	Require all granted<br><span class="hljs-tag">&lt;/<span class="hljs-name">Directory</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p> 创建data文件夹，用于保存数据</p>
<p> <strong>$cd &#x2F;var&#x2F;www&#x2F;html</strong></p>
<p> <strong>$sudo mkdir data</strong></p>
<p> 修改Owncloud文件夹的文件权限：</p>
<p> <strong>$sudo chown -R www-data:www-data &#x2F;var&#x2F;www&#x2F;html&#x2F;</strong></p>
<p> <strong>$sudo chmod 777 &#x2F;var&#x2F;www&#x2F;html&#x2F;config&#x2F;</strong></p>
<p> 在MySql上创建一个数据库，保存来自OwnCloud的数据。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">$ sudo mysql -u root -p<br>create database owncloud;<br>GRANT ALL ON owncloud.*TO username@localhost IDENTIFIED BY &#x27;password&#x27;;<br>flush privileges;<br>exit<br></code></pre></td></tr></table></figure>

<p> 重启Apache服务器</p>
<p> <strong>$</strong> <strong>sudo &#x2F;etc&#x2F;init.d&#x2F;apache2 restart</strong></p>
</blockquote>
<h4 id="访问owncloud并配置"><a href="#访问owncloud并配置" class="headerlink" title="访问owncloud并配置"></a>访问owncloud并配置</h4><p>在浏览器上输入树莓派的IP地址</p>
<p><img src="/image/raspberry_pi/owncloud_page_config.png" alt="owncloud index"></p>
<p>点击配置完成后，等待的时间可能会稍微长一点，可以另开一个tab访问一下试试。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li><p>如果选择的存放数据的地方，是挂载到linux的nfts格式的硬盘，会出现无法修改其权限的问题，解决方案可以搜一下<code>linux无法修改ntfs权限</code>，网上解决方案大部分是修改 &#x2F;etc&#x2F;fstab来实现挂载时指定权限。我是把ntfs格式修改成ext4就好了。。。。。。</p>
</li>
<li><p>owncloud8之后，直接将文件放在用户的共享文件夹下，会发现在网页上并不能看到该文件。</p>
<p>第一种是执行Owncloud的CLI命令。具体位置是在Owncloud根目录，有个文件叫OCC，实际调用的是console.php，是个PHP脚本。通过命令 PHP OCC fils:scan –all即可重新扫描文件目录下的所有文件了。代价是所有文件的ID会重置，导致同步的桌面客户端会认为都是新文件，继而全部重新下载。</p>
<p>存放共享文件数据的数据库是<code>oc_filecache</code>表，我们可以先truncate掉这张表，之后重新登录OwnCloud，Owncloud系统会自动重新填充数据。</p>
</li>
</ol>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式--上</title>
    <url>/2020/09/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%B8%8A/</url>
    <content><![CDATA[<p>如果你有一个问题，你想到可以用正则来解决，那么你有两个问题了。</p>
<p>Some people, when confronted with a problem, think “I know,i’ll use regular expressions.” Now they have two problems</p>
<span id="more"></span>

<h3 id="写正则过程"><a href="#写正则过程" class="headerlink" title="写正则过程"></a>写正则过程</h3><ol>
<li><p>先分解</p>
<p>这个问题可以分成几个子问题，是否可以用多个正则来完成(密码强度校验，一个校验大小写，一个校验数字标点，一个校验强度)</p>
</li>
<li><p>解决子问题</p>
<p>某个位置上可能有多个字符？那就用字符组。某个位置上可能有多个字符串？那就用多选结构。出现的次数不确定？那就用量词。对出现的位置有要求？那就用锚点锁定位置</p>
</li>
<li><p>套皮</p>
<p>也就是把如何解决子问题转化为正则表达式</p>
</li>
<li><p>调试</p>
<p>复杂⼀点的正则表达式不能⼀次写对，这是很正常的</p>
</li>
</ol>
<p>测试网页：<a href="https://regex101.com/">https://regex101.com/</a></p>
<h3 id="正则功能s"><a href="#正则功能s" class="headerlink" title="正则功能s"></a>正则功能s</h3>
<pre>
<code class="mermaid" >
graph TB

A(正则功能)
A1(校验数据的有效性)
A2(查找符合要求的文本内容)
A3(对文本进行切割,替换等操作)
A-->A1
A-->A2
A-->A3

</code>
</pre>



<h3 id="正则元字符"><a href="#正则元字符" class="headerlink" title="正则元字符"></a>正则元字符</h3>
<pre>
<code class="mermaid" >
graph LR
A(正则元字符)
A-->B(特殊单字符)
B-->B1(.任意字符)
B-->B2(\d 任意数字\D 任意非数字)
B-->B3(\w 任意字母数字下划线 \W任意非字母谁下划线)
B-->B4(\s任意空白符  \S 任意非空白符)
A-->C(空白符)
C-->C1(\r 回车符)
C-->C2(\n 换行符)
C-->C3(\f 换页符)
C-->C4(\t 制表符)
C-->C5(\v 垂直制表符)
C-->C6(\s 任意空白符)
A-->D(范围)
D-->D1("|或,如ab|bc 代表ab或bc")
D-->D2("[...]多选一，括号中任意单个元素")
D-->D3("[a-z]匹配a到z之间的任意单个元素(按ASCII表，包含a,z)")
D-->D4("[^...]取反，不能是括号中的任意单个元素")
A-->E(量词)
E-->E1(*含义: 0到多次)
E-->E2(+含义: 1到多次)
E-->E3(?含义: 0到1次)
E-->E4("{m}含义: 出现m次")
E-->E5("{m,}含义: 出现至少m次")
E-->E6("{m,n}含义: m到n次")
A-->F(断言)
F-->F1(单词边界)
F-->F2(行的开始/结束)
F-->F3(环视)
</code>
</pre>

<p>示例：</p>
<ol>
<li>匹配某个网络资源：以 http:&#x2F;&#x2F; 或者https:&#x2F;&#x2F; 或者ftp:&#x2F;&#x2F;开头</li>
<li>第一位固定为1，第二位可能是3-9，第三位到第11位可以是任意数字</li>
</ol>
<h3 id="量词与贪婪"><a href="#量词与贪婪" class="headerlink" title="量词与贪婪"></a>量词与贪婪</h3><p>举例：<br>有字符串”aaabb”，有正则表达式”a+”，问有多少个匹配结果<br>有字符串”aaabb”，有正则表达式”a*”，问有多少个匹配结果</p>
<h4 id="贪婪匹配-Greedy"><a href="#贪婪匹配-Greedy" class="headerlink" title="贪婪匹配(Greedy)"></a>贪婪匹配(Greedy)</h4><p>有字符串”aaabb”，有正则表达式”a*”，问有多少个匹配结果 的匹配过程</p>
<table>
<thead>
<tr>
<th>匹配</th>
<th>开始</th>
<th>结束</th>
<th>说明</th>
<th>匹配内容</th>
</tr>
</thead>
<tbody><tr>
<td>第一次</td>
<td>0</td>
<td>3</td>
<td>到第一个字母b发现不满足，输出aaa</td>
<td>aaa</td>
</tr>
<tr>
<td>第二次</td>
<td>3</td>
<td>3</td>
<td>匹配剩下的bb，发现匹配不上，输出空字符串</td>
<td>空字符串</td>
</tr>
<tr>
<td>第三次</td>
<td>4</td>
<td>4</td>
<td>匹配剩下的b，发现匹配不上，输出空字符串</td>
<td>空字符串</td>
</tr>
<tr>
<td>第四次</td>
<td>5</td>
<td>5</td>
<td>匹配剩下空字符串，发现匹配不上，输出空字符串</td>
<td>空字符串</td>
</tr>
</tbody></table>
<h4 id="非贪婪模式-Lazy"><a href="#非贪婪模式-Lazy" class="headerlink" title="非贪婪模式(Lazy)"></a>非贪婪模式(Lazy)</h4><p>有字符串”aaabb”，有正则表达式”a*?”，问有多少个匹配结果<br>9个结果</p>
<p>在python2.7中只能匹配到空串，在java8中只能匹配到空串，  在python3.7.7中可以匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>re.findall(<span class="hljs-string">r&quot;a*?&quot;</span>,<span class="hljs-string">&quot;aaabb&quot;</span>)<br>[<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>re.findall(<span class="hljs-string">r&quot;a*?&quot;</span>,<span class="hljs-string">&quot;aaabb&quot;</span>)<br>[<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>]<br></code></pre></td></tr></table></figure>



<p>示例：查找双引号之间的单词</p>
<p>字符串如下 “the little cat” is a toy,it looks “a little bad”</p>
<p>贪婪：”.*”</p>
<p>非贪婪:”.*?”</p>
<h4 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h4><p>一般不怎么用</p>
<p>示例：</p>
<p>we found “the little cat” is in the hat, we like “the little cat”</p>
<p>其中双引号中的单词看成一个单词，即the little cat 是一个单词</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4>
<pre>
<code class="mermaid" >
graph LR
A("贪婪、非贪婪、独占")
A-->A1(贪婪匹配)
A1-->A11("表示次数的量词，默认是贪婪的<br/>满足要求的情况下，尽可能按最长去匹配")
A1-->A12("回溯：后面匹配不上，会吐出已匹配的再尝试")
A-->A2(非贪婪匹配)
A2-->A21("量词元字符后加?(英文问号),<br/>满足要求的情况下，尽可能按最短去进行匹配")
A2-->A22("回溯：后面匹配不上，会匹配更长再接着尝试")
A-->A3(独占模式)
A3-->A31("量词元字符后加+(英文加号)<br/>满足要求的情况下，尽可能按最长去匹配")
A3-->A32(不会发生回溯,匹配不上即失败)
</code>
</pre>





<h3 id="分组与引用"><a href="#分组与引用" class="headerlink" title="分组与引用"></a>分组与引用</h3><p>匹配身份证号：15位或18位数字</p>
<h4 id="分组与编号"><a href="#分组与编号" class="headerlink" title="分组与编号"></a>分组与编号</h4><p>括号在正则中可以用于分组，被括号括起来的部分“子表达式”会被保存成一个子组。第几个括号就是第几个分组	</p>
<h4 id="不保存子组"><a href="#不保存子组" class="headerlink" title="不保存子组"></a>不保存子组</h4><p>可以在括号里面使用 ?: 不保存子组。</p>
<h4 id="括号嵌套"><a href="#括号嵌套" class="headerlink" title="括号嵌套"></a>括号嵌套</h4><p>我们只需要数左括号（开括号）是第几个，就可以确定是第几个子组</p>
<p>假设时间格式是 2020-05-10 20:23:05 。</p>
<p>((\d{4})-(\d{2})-(\d{2})) ((\d{2}):(\d{2}):(\d{2}))</p>
<p>日期分组编号是 1，时间分组编号是 5，年月日对应的分组编号分别是 2，3，4，时分秒的分组编号分别是 6，7，8。</p>
<h4 id="命名分组"><a href="#命名分组" class="headerlink" title="命名分组"></a>命名分组</h4><p>由于编号得数在第几个位置，后续如果发现正则有问题，改动了括号的个数，还可能导致编号发生变化，因此一些编程语言提供了命名分组（named grouping），这样和数字相比更容易辨识，不容易出错。命名分组的格式为(<code>?P&lt;分组名&gt;正则</code>)。</p>
<h4 id="分组引用"><a href="#分组引用" class="headerlink" title="分组引用"></a>分组引用</h4><p>在知道了分组引用的编号 （number）后，大部分情况下，我们就可以使用 “反斜扛 + 编号”，即 \number 的方式来进行引用</p>
<h4 id="分组引用在查找中使用"><a href="#分组引用在查找中使用" class="headerlink" title="分组引用在查找中使用"></a>分组引用在查找中使用</h4><p>前面出现的单词再次出现：(\w+)\1</p>
<p><a href="https://regex101.com/r/Adg1Og/4">https://regex101.com/r/Adg1Og/4</a></p>
<h4 id="分组引用在替换中使用"><a href="#分组引用在替换中使用" class="headerlink" title="分组引用在替换中使用"></a>分组引用在替换中使用</h4><p>我们可以使用反向引用，在得到的结果中，去拼出来我们想要的结果</p>
<p><a href="https://regex101.com/r/Adg1Og/5">https://regex101.com/r/Adg1Og/5</a></p>

<pre>
<code class="mermaid" >
graph LR
A("正则分组")
A-->A1("功能")
A1-->A11("将某部分子表达式看成一个整体，在后续查找或替换引用分组")
A-->A2("分组编号")
A2-->A21(第几个括号就是第几个分组)
A2-->A22("非捕获分组使用(?:正则)")
A2-->A23("括号嵌套只需要看左括号的序号")
A2-->A24("命名分组(?P[名称]正则)")
A-->A3("分组引用")
A3-->A31("查找：查找重复出现的部分")
A3-->A32("替换：对原有内容格式进行改写")
A-->A4("文本编辑")
</code>
</pre>

<h3 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h3><h4 id="不区分大小写模式（Case-Insensitive）"><a href="#不区分大小写模式（Case-Insensitive）" class="headerlink" title="不区分大小写模式（Case-Insensitive）"></a>不区分大小写模式（Case-Insensitive）</h4><p>示例：如要查找单词 cat，我们并不需要关心单词是 CAT、Cat，还是 cat</p>
<p>reg &#x3D; <code>[Cc][Aa][Tt]</code></p>
<p>当我们把模式修饰符放在整个正则前面时，就表示整个正则表达式都是不区分大小写的。模式修饰符是通过 (? 模式标识) 的方式来表示的。  我们只需要把模式修饰符放在对应的正则前，就可以使用指定的模式了。</p>
<p>由于不分大小写的英文是 Case-Insensitive，那么对应的模式标识就是 I 的小写字母 i，所以不区分大小写的 cat 就可以写成 (?i)cat。</p>
<p>text&#x3D;<code>cat\n CAT\nCat</code></p>
<p>我们也可以用它来尝试匹配两个连续出现的 cat，如下图所示，你会发现，即便是第一个 cat 和第二个 cat 大小写不一致，也可以匹配上。</p>
<p><a href="https://regex101.com/r/x1lg4P/1">https://regex101.com/r/x1lg4P/1</a></p>
<p>如果我们想要前面匹配上的结果，和第二次重复时的大小写一致，那该怎么做呢？我们只需要用括号把**修饰符和正则 cat **部分括起来，加括号相当于作用范围的限定，让不区分大小写只作用于这个括号里的内容</p>
<p><a href="https://regex101.com/r/x1lg4P/2">https://regex101.com/r/x1lg4P/2</a></p>
<p>需要注意的是，这里正则写成了 ((?i)cat) \1，而不是 ((?i)(cat)) \1。也就是说，我们给修饰符和 cat 整体加了个括号，而原来 cat 部分的括号去掉了。如果 cat 保留原来的括号，即 ((?i)(cat)) \1，这样正则中就会有两个子组，虽然结果也是对的，但这其实没必要</p>
<p>如果用正则匹配，实现部分区分大小写，另一部分不区分大小写，这该如何操作呢？就比如说我现在想要，the cat 中的 the 不区分大小写，cat 区分大小写</p>
<p>也就是 ((?i)the) cat</p>
<p><a href="https://regex101.com/r/x1lg4P/3">https://regex101.com/r/x1lg4P/3</a></p>
<h4 id="单行模式"><a href="#单行模式" class="headerlink" title="单行模式"></a>单行模式</h4><p>单行的英文表示是 Single Line，单行模式对应的修饰符是 (?s)</p>
<p><a href="https://regex101.com/r/Adg1Og/1">https://regex101.com/r/Adg1Og/1</a></p>
<h4 id="多行匹配模式（Multiline）"><a href="#多行匹配模式（Multiline）" class="headerlink" title="多行匹配模式（Multiline）"></a>多行匹配模式（Multiline）</h4><p>通常情况下，^匹配整个字符串的开头，$ 匹配整个字符串的结尾。多行匹配模式改变的就是 ^ 和 $ 的匹配行为</p>
<p><a href="https://regex101.com/r/Adg1Og/2">https://regex101.com/r/Adg1Og/2</a></p>
<p>多行模式的作用在于，使 ^ 和 $ 能匹配上每行的开头或结尾，我们可以使用模式修饰符号 (?m) 来指定这个模式。</p>
<p><a href="https://regex101.com/r/Adg1Og/3">https://regex101.com/r/Adg1Og/3</a></p>
<h4 id="注释模式（Comment）"><a href="#注释模式（Comment）" class="headerlink" title="注释模式（Comment）"></a>注释模式（Comment）</h4><p>正则中注释模式是使用 (?#comment) 来表示。</p>

<pre>
<code class="mermaid" >
graph LR
A(正则匹配模式<br>Match Mode)
A-->A1(不区分大小写模式<br>Case-Insensitive)
A1-->A11("作用：正则不区分英文字母的大小写")
A1-->A12("修饰符：(?i)")
A-->A2(点号通配模式<br>Dot All)
A2-->A21("作用：英文的点号可以匹配任意字符，包括换行")
A2-->A22("修饰符：(?s)")
A-->A3(多行模式<br>Multiline)
A3-->A31("作用：^或$默认是匹配整个字符串的开头或结尾<br>多行模式使得他们能匹配每行的开头或结尾")
A3-->A32("修饰符：(?m)")
A-->A4(注释模式<br>Comment)
A4-->A41("作用：添加注释")
A4-->A42("修饰符：(?#comment)")
</code>
</pre>

<p>问题：</p>
<p>提取html中head标签中的所有内容</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>简单来说，断言是指对匹配到的文本位置有要求。比如，去查找一个单词，我们要查找 tom，但其它的单词，比如 tomorrow 中也包含了 tom。</p>
<h4 id="单词边界（Word-Boundary）"><a href="#单词边界（Word-Boundary）" class="headerlink" title="单词边界（Word Boundary）"></a>单词边界（Word Boundary）</h4><p>我们想要把下面文本中的 tom 替换成 jerry。注意一下，在文本中出现了 tomorrow 这个单词，tomorrow 也是以 tom 开头的。</p>
<blockquote>
<p>tom asked me if I would go fishing with him tomorrow.</p>
</blockquote>
<p>利用前面学到的知识，我们如果直接替换，会出现下面这种结果。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex">替换前：tom asked me if I would go fishing with him tomorrow.<br>替换后：jerry asked me if I would go fishing with him jerryorrow.<br></code></pre></td></tr></table></figure>

<p>单词的组成一般可以用元字符 \w+ 来表示，\w 包括了大小写字母、下划线和数字（即 [A-Za-z0-9_]）。那如果我们能找出单词的边界，也就是当出现了\w 表示的范围以外的字符，比如引号、空格、标点、换行等这些符号，我们就可以在正则中使用\b 来表示单词的边界。 \b 中的 b 可以理解为是边界（Boundary）这个单词的首字母。</p>
<table>
<thead>
<tr>
<th></th>
<th>tom</th>
<th>\btom</th>
<th>tom\b</th>
<th>\btom\b</th>
</tr>
</thead>
<tbody><tr>
<td>tom</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>tomorrow</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>atom</td>
<td>√</td>
<td>×</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>atomic</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h4 id="行的开始或结束"><a href="#行的开始或结束" class="headerlink" title="行的开始或结束"></a>行的开始或结束</h4><p>可以参考<strong>空白符</strong>和<strong>匹配模式</strong></p>
<h4 id="环视（-Look-Around）"><a href="#环视（-Look-Around）" class="headerlink" title="环视（ Look Around）"></a>环视（ Look Around）</h4><p>比如我们要提取六位数字的邮政编码，不能简单的写<code>\d&#123;6&#125;</code>，这样的话，11位数字的手机号码也能匹配，也就是说，除了文本本身组成符合这 6 位数的规则外，这 6 位数左边或右边都不能是数字。正则是通过环视来解决这个问题的</p>
<table>
<thead>
<tr>
<th>正则</th>
<th>名称</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>(?&lt;=Y)</code></td>
<td>肯定逆序环视<br>positive-lookbehind</td>
<td>左边是Y</td>
<td><code>(?&lt;=\d)th</code>:左边是数字的th，能匹配9th</td>
</tr>
<tr>
<td><code>(?&lt;!Y)</code></td>
<td>否定逆序环视<br>negative-lookbehind</td>
<td>左边不是Y</td>
<td><code>(?&lt;!\d)th</code>:左边不是数字的th，能匹配health</td>
</tr>
<tr>
<td><code>(?=Y)</code></td>
<td>肯定顺序环视<br>positive-lookhead</td>
<td>右边是Y</td>
<td><code>six(?=\d)</code>:右边是数字的siz，能匹配six6</td>
</tr>
<tr>
<td><code>(?!Y)</code></td>
<td>否定逆序环视<br>negative-lookhead</td>
<td>右边不是Y</td>
<td><code>hi(?!\d)</code>:右边不是数字的hi，能匹配high</td>
</tr>
</tbody></table>
<h4 id="环视与子组"><a href="#环视与子组" class="headerlink" title="环视与子组"></a>环视与子组</h4><p>环视中虽然也有括号，但不会保存成子组。保存成子组的一般是匹配到的文本内容，后续用于替换等操作，而环视是表示对文本左右环境的要求，即环视只匹配位置，不匹配文本内容</p>

<pre>
<code class="mermaid" >
graph LR
A(断言)--> A1(单词边界)
A1-->A11(\b匹配单词边界)
A-->A2(行的开始/结束)
A2-->A21("^匹配行的开始<br>多行模式时，可以匹配任意行开头")
A2-->A22("$匹配行的结束<br>多行模式时，可以匹配任意行结尾")
A2-->A23("\A仅匹配整个字符串的开始<br/>不支持多行模式")
A2-->A24("\Z仅匹配整个字符串结束<br/>不支持多行模式")
A-->A3(环视)
A3-->A31("(?=Y)X:匹配前面是Y的X")
A3-->A32("(?!Y)X:匹配前面不是Y的X")
A3-->A33("X(?=Y):匹配后面是Y的X")
A3-->A34("X(?!Y):匹配后面不是Y的X")
</code>
</pre>

<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的桌面小部件</title>
    <url>/2017/03/20/%E7%AE%80%E5%8D%95%E7%9A%84%E6%A1%8C%E9%9D%A2%E5%B0%8F%E9%83%A8%E4%BB%B6/</url>
    <content><![CDATA[<p>实现一个简单的桌面小部件，响应点击事件，更新等功能。</p>
<ol>
<li>定义小部件界面</li>
<li>定义小部件配置信息</li>
<li>定义小部件的实现类</li>
<li>声明小部件<br>在AndroidStudio中只需要在<code>main\java</code>下新建一个<code>widget</code>,就可以了，IDE会自动在<code>res\layout</code>添加布局文件，在<code>res\xml</code>下新建配置信息文件。然后就可以进行具体实现了。</li>
</ol>
<span id="more"></span>

<p><img src="/image/new_widget.png" alt="AS下新建widget"></p>
<h3 id="定义小部件界面"><a href="#定义小部件界面" class="headerlink" title="定义小部件界面"></a>定义小部件界面</h3><p>RemoteView目前并不能支持所有的View，现在支持的类型如下：</p>
<ul>
<li>Layout<ul>
<li>FrameLayout</li>
<li>LinearLayout</li>
<li>RelativeLayout</li>
<li>GridLayout</li>
</ul>
</li>
<li>View<ul>
<li>AnalogClock</li>
<li>Button</li>
<li>Chronometer</li>
<li>ImageButton</li>
<li>ImageView</li>
<li>ProgressBar</li>
<li>TextView</li>
<li>ViewFlipper</li>
<li>ListView</li>
<li>GridView</li>
<li>StackView</li>
<li>AdapterViewFlipper</li>
<li>ViewStub</li>
</ul>
</li>
</ul>
<p>这个没什么好说的，按照写界面布局的方式写就好了，但是不建议写过于复杂的布局。</p>
<h3 id="定义小部件配置信息"><a href="#定义小部件配置信息" class="headerlink" title="定义小部件配置信息"></a>定义小部件配置信息</h3><p>下面的代码就是IDE自动成的配置信息文件，不喜欢IDE代劳的同学可以自己创建。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appwidget-provider</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:initialKeyguardLayout</span>=<span class="hljs-string">&quot;@layout/test_remote_view_widget&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:initialLayout</span>=<span class="hljs-string">&quot;@layout/test_remote_view_widget&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:minHeight</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:minWidth</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:previewImage</span>=<span class="hljs-string">&quot;@drawable/example_appwidget_preview&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:resizeMode</span>=<span class="hljs-string">&quot;horizontal|vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:updatePeriodMillis</span>=<span class="hljs-string">&quot;86400000&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:widgetCategory</span>=<span class="hljs-string">&quot;home_screen&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">appwidget-provider</span>&gt;</span> <br></code></pre></td></tr></table></figure>
<p><code>initialLayout</code>：布局文件<br><code>previewImage</code>： 预览的图片<br><code>updatePeriodMillis</code>：刷新周期，单位毫秒</p>
<h3 id="定义小部件的实现类"><a href="#定义小部件的实现类" class="headerlink" title="定义小部件的实现类"></a>定义小部件的实现类</h3><p>实现的功能是当点击这个小部件的时候改变文字内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRemoteViewWidget</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppWidgetProvider</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CLICK_ACTION</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.huangyuan.testwidget.TAP_CLICK_ACTION&quot;</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onReceive(context, intent);<br>        Toast.makeText(context,<span class="hljs-string">&quot;onReceive:&quot;</span> + intent.getAction(),Toast.LENGTH_SHORT).show();<br>        <span class="hljs-keyword">if</span>(intent.getAction().equals(CLICK_ACTION))&#123;<br>            <span class="hljs-type">AppWidgetManager</span> <span class="hljs-variable">appWidgetManager</span> <span class="hljs-operator">=</span> AppWidgetManager.getInstance(context);<br>            <span class="hljs-type">RemoteViews</span> <span class="hljs-variable">remoteViews</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteViews</span>(context.getPackageName(),R.layout.test_remote_view_widget);<br>            remoteViews.setTextViewText(R.id.appwidget_text,<span class="hljs-string">&quot;点击&quot;</span>);<br>            appWidgetManager.updateAppWidget(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentName</span>(context,TestRemoteViewWidget.class),remoteViews);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUpdate</span><span class="hljs-params">(Context context, AppWidgetManager appWidgetManager, <span class="hljs-type">int</span>[] appWidgetIds)</span> &#123;<br>        Toast.makeText(context,<span class="hljs-string">&quot;onUpdate&quot;</span> ,Toast.LENGTH_SHORT).show();<br>        <span class="hljs-type">RemoteViews</span> <span class="hljs-variable">remoteViews</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteViews</span>(context.getPackageName(),R.layout.test_remote_view_widget);<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">clickIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        clickIntent.setAction(CLICK_ACTION);<br>        <span class="hljs-type">PendingIntent</span> <span class="hljs-variable">pendingIntent</span> <span class="hljs-operator">=</span> PendingIntent.getBroadcast(context,<span class="hljs-number">0</span>,clickIntent,<span class="hljs-number">0</span>);<br>        remoteViews.setOnClickPendingIntent(R.id.appwidget_text,pendingIntent);<br>        appWidgetManager.updateAppWidget(appWidgetIds,remoteViews);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中还有其他方法：</p>
<ul>
<li>onEnabled:当该窗口小部件第一次添加到桌面时调用该方法，可添加多次，但只在第一次调用</li>
<li>onUpdate:小部件被添加时或者每次小部件更新时都会调用一次该方法，小部件的更新时机由<code>updatePeriodMillis</code>指定。</li>
<li>onDeleted:每删除一次桌面小部件就调用一次。</li>
<li>onDisabled:当最后一个该类型的桌面小部件被删除时调用该方法，追时最后一个。<br>需要注意的是，更新remoteView时，不能直接访问里面的View,需要通过RemoteView所提供的一系列方法更新View。</li>
<li>更新文本： remoteViews.setTextViewText();</li>
<li>更新图片： remoteViews.setImageViewResource();remoteViews.setImageViewBitmap();</li>
<li>添加单击事件：remoteViews.setOnClickPendingIntent();</li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>网站免费升级https</title>
    <url>/2018/04/01/%E7%BD%91%E7%AB%99%E5%85%8D%E8%B4%B9%E5%8D%87%E7%BA%A7https/</url>
    <content><![CDATA[<p>昨天跟着酷壳网左耳朵耗子的文章把自己在亚马逊主机上的网站变成https的安全访问了，证书不是自签名的，也不是花钱购买的。据说https的网站在搜索引擎中的rank值会比http的更高一些。升级完成后的浏览器截图如下：<br><img src="/image/https/https1.png" alt="浏览器"><br>下面是这次升级的记录。</p>
<span id="more"></span>
<p>为网站开启https安装证书非常简单，我用的是 <a href="https://letsencrypt.org/">Let’s Encrypt </a>这个免费的解决方案。</p>
<ol>
<li>打开<a href="https://certbot.eff.org/">https://certbot.eff.org/</a>这个网页</li>
<li>在Software 和 System选项里面选择你所使用的软件、系统，我用的nginx+ubuntu16.04<br> <img src="/image/https/https4.png" alt="网站截图"></li>
<li>然后会跳转到一个新的网页，照着做就是了。<br>就以nginx+ubuntu16.04为例：<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install software-properties-common</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo add-apt-repository ppa:certbot/certbot</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo apt-get install python-certbot-nginx</span> <br></code></pre></td></tr></table></figure>
安装成功后执行 <code>$ sudo certbot --nginx</code><br>让你输入你的邮箱，然后是同意用户协议，然后是是否公开你的邮箱。<br> <img src="/image/https/https2.png" alt="邮箱、用户协议"><br>接着会列出来nginx下所有配置的服务名称，输入你想要开启https的服务名称所对应的编号，如果想为多个服务开启https，中间以空格分隔。然后nginx重新加载一个配置或者重启一下。<br><img src="/image/https/https3.png" alt="开启https的服务名称"><br>我个人服务器上的nginx配置的<code>server_name</code>是<code>tomcat.huangyuanlove.com</code>,域名是在万网买的，然后在万网控制台添加一个A解析，把<code>tomcat.huangyuanlove.com</code>指向服务器的ip即可。<br>但是 <strong>Let’s Encrypt 的证书90天就过期了</strong>。所以还需要加上自动更新，使用<code>crontab -e</code>命令假如如下的定时作业(每个月强制更新一下)<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs sehll">0 0 1 * * /usr/bin/certbot renew --force-renewal<br>5 0 1 * * /usr/sbin/service nginx restart<br></code></pre></td></tr></table></figure>
需要注意的是，如果网站中有使用http的地方都要改成https,要不然一些资源文件如图片、js、css等非https的请求连接都会被ban掉。</li>
</ol>
<hr>
<p>关于ubuntu安装和配置nginx，我也是在官网找的教程，网址在这里<a href="https://www.nginx.com/resources/wiki/start/index.html">https://www.nginx.com/resources/wiki/start/index.html</a>,就知道你们不想看，安装命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install nginx<br></code></pre></td></tr></table></figure>
<p>安装完成后，nginx配置文件在<code>/etc/nginx/nginx.conf</code>,在http标签中添加server：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs configuration">server&#123;<br>        listen    80;<br>        server_name    localhost;<br>        location / &#123;<br>            root    html;<br>            index index.html index.htm;<br>        &#125;<br>        error_page 500 502 503 504 /50x.html;<br>        location = /50x.html&#123;<br>            root    html;<br>        &#125;<br>&#125;<br>server&#123;<br>        server_name    tomcat.huangyuanlove.com;<br>        location / &#123;<br>            proxy_pass http://xxx.xxx.xxx/;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>给自己的添加https证书后，<code>Certbot</code>会修改你的nginx中的server配置，修改的内容如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">listen <span class="hljs-number">443</span> ssl https2; <span class="hljs-comment"># managed by Certbot</span><br>   ssl_certificate <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>tomcat.huangyuanlove.com/fullchain.pem; <span class="hljs-comment"># managed by Certbot</span><br>   ssl_certificate_key <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>tomcat.huangyuanlove.com/privkey.pem; <span class="hljs-comment"># managed by Certbot</span><br>   include <span class="hljs-regexp">/etc/</span>letsencrypt/options-ssl-nginx.conf; <span class="hljs-comment"># managed by Certbot</span><br>   ssl_dhparam <span class="hljs-regexp">/etc/</span>letsencrypt/ssl-dhparams.pem; <span class="hljs-comment"># managed by Certbot</span><br></code></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">server&#123;<br>    <span class="hljs-keyword">if</span> ($host = tomcat.huangyuanlove.com) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">301</span> https:<span class="hljs-regexp">//</span>$host$request_uri;<br>    &#125; <span class="hljs-comment"># managed by Certbot</span><br>    <span class="hljs-keyword">listen</span>    <span class="hljs-number">80</span>;<br>    server_name    tomcat.huangyuanlove.com;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">404</span>; <span class="hljs-comment"># managed by Certbot</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>基本上就是这样了，没有别的了。</p>
<hr>
<p>以上，嗯，对了，12306你什么时候按照这个教程做一下你的证书？</p>
]]></content>
      <tags>
        <tag>乱七八糟</tag>
        <tag>网站https</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义View--贝塞尔曲线、Shader</title>
    <url>/2019/01/20/%E8%87%AA%E5%AE%9A%E4%B9%89View-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E3%80%81Shader/</url>
    <content><![CDATA[<p>贝塞尔曲线可以将Path中的moveTo、LineTo等连接的生硬路径变得平滑，也能实现很多好看的效果。</p>
<ol>
<li><p>一阶贝塞曲线</p>
<p>$B(t)&#x3D;P_0(1-t)+tP_1,t\in[0,1]$</p>
<p><img src="/image/Android/customview/B%C3%A9zier_curve_1.gif" alt="一阶贝塞曲线"></p>
</li>
<li><p>二阶贝塞尔曲线</p>
<p>$B(t)&#x3D;P_0(1-t)^2+2t(1-t)P_1+  t^2P_2,t\in[0,1]$</p>
<p><img src="/image/Android/customview/B%C3%A9zier_curve_2.gif" alt="二阶贝塞曲线"></p>
</li>
<li><p>三阶贝塞尔曲线</p>
<p>$B(t)&#x3D;P_0(1-t)^3+3P_1t(1-t)^2+  3P_2t^2(1-t)+P_3t^3,t\in[0,1]$</p>
<p><img src="/image/Android/customview/B%C3%A9zier_curve_3.gif" alt="三阶贝塞曲线"></p>
</li>
</ol>
<span id="more"></span>

<h4 id="贝塞尔曲线的应用"><a href="#贝塞尔曲线的应用" class="headerlink" title="贝塞尔曲线的应用"></a>贝塞尔曲线的应用</h4><h5 id="手势追踪，改变moveTo、LineTo生硬路径现象"><a href="#手势追踪，改变moveTo、LineTo生硬路径现象" class="headerlink" title="手势追踪，改变moveTo、LineTo生硬路径现象"></a>手势追踪，改变moveTo、LineTo生硬路径现象</h5><p>传统手势划线，重写onTouchEvent方法，在ACTION_MOVE事件中划线就好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>            path.moveTo(event.getX(),event.getY());<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>            path.lineTo(event.getX(),event.getY());<br>            postInvalidate();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样的话，画出来的线条在转弯处比较生硬，我们可以使用贝塞尔曲线来优化一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>            path.moveTo(event.getX(), event.getY());<br>            preX = event.getX();<br>            preY = event.getY();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>            <span class="hljs-type">float</span> <span class="hljs-variable">endX</span> <span class="hljs-operator">=</span> (preX + event.getX()) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">float</span> <span class="hljs-variable">endY</span> <span class="hljs-operator">=</span> (preY + event.getY()) / <span class="hljs-number">2</span>;<br>            path.quadTo(preX,preY,endX,endY);<br>            preX = event.getX();<br>            preY = event.getY();<br>            postInvalidate();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="波浪效果"><a href="#波浪效果" class="headerlink" title="波浪效果"></a>波浪效果</h5><p><img src="/image/Android/customview/wave_anim.gif" alt="波浪效果"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//贝塞尔曲线实现波纹效果</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaveAnimationView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">private</span> Paint paint;<br>    <span class="hljs-keyword">private</span> Path path;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">itemWaveLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1080</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> dx;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaveAnimationView</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaveAnimationView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaveAnimationView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>        paint = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Paint</span>();<br>        paint.setColor(Color.GREEN);<br>        paint.setStyle(Paint.Style.FILL);<br>        startAnim();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDraw(canvas);<br>        path.reset();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">originY</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">halfWaveLen</span> <span class="hljs-operator">=</span> itemWaveLength/<span class="hljs-number">2</span>;<br>        path.moveTo(-itemWaveLength+dx,originY);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -itemWaveLength;i&lt;getWidth()+itemWaveLength;i+=itemWaveLength)&#123;<br>            path.rQuadTo(halfWaveLen/<span class="hljs-number">2</span>,-<span class="hljs-number">100</span>,halfWaveLen,<span class="hljs-number">0</span>);<br>            path.rQuadTo(halfWaveLen/<span class="hljs-number">2</span>,<span class="hljs-number">100</span>,halfWaveLen,<span class="hljs-number">0</span>);<br>        &#125;<br>        path.lineTo(getWidth(),getHeight());<br>        path.lineTo(<span class="hljs-number">0</span>,getHeight());<br>        path.close();<br>        canvas.drawPath(path,paint);<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startAnim</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">animator</span> <span class="hljs-operator">=</span> ValueAnimator.ofInt(<span class="hljs-number">0</span>,itemWaveLength);<br>        animator.setDuration(<span class="hljs-number">2000</span>);<br>        animator.setRepeatCount(ValueAnimator.INFINITE);<br>        animator.setInterpolator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearInterpolator</span>());<br>        animator.addUpdateListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span> &#123;<br>                dx = (<span class="hljs-type">int</span>) animation.getAnimatedValue();<br>                postInvalidate();<br>            &#125;<br>        &#125;);<br>        animator.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先放代码，再一点点解释。</p>
<p>首先init里面初始化需要用到的变量。然后在onDraw方法中，整个横向上画满波浪</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">path.reset();<br><span class="hljs-type">int</span> <span class="hljs-variable">originY</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">halfWaveLen</span> <span class="hljs-operator">=</span> itemWaveLength/<span class="hljs-number">2</span>;<br>path.moveTo(-itemWaveLength+dx,originY);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> -itemWaveLength;i&lt;getWidth()+itemWaveLength;i+=itemWaveLength)&#123;<br>    path.rQuadTo(halfWaveLen/<span class="hljs-number">2</span>,-<span class="hljs-number">100</span>,halfWaveLen,<span class="hljs-number">0</span>);<br>    path.rQuadTo(halfWaveLen/<span class="hljs-number">2</span>,<span class="hljs-number">100</span>,halfWaveLen,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后将波浪底部填满</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">path.lineTo(getWidth(),getHeight());<br>path.lineTo(<span class="hljs-number">0</span>,getHeight());<br>path.close();<br>canvas.drawPath(path,paint);<br></code></pre></td></tr></table></figure>

<p>之后将画面移动起来就好了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startAnim</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">animator</span> <span class="hljs-operator">=</span> ValueAnimator.ofInt(<span class="hljs-number">0</span>,itemWaveLength);<br>    animator.setDuration(<span class="hljs-number">2000</span>);<br>    animator.setRepeatCount(ValueAnimator.INFINITE);<br>    animator.setInterpolator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinearInterpolator</span>());<br>    animator.addUpdateListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ValueAnimator</span>.AnimatorUpdateListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span> &#123;<br>            dx = (<span class="hljs-type">int</span>) animation.getAnimatedValue();<br>            postInvalidate();<br>        &#125;<br>    &#125;);<br>    animator.start();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="望远镜效果-点击哪里则哪里出现图像"><a href="#望远镜效果-点击哪里则哪里出现图像" class="headerlink" title="望远镜效果(点击哪里则哪里出现图像)"></a>望远镜效果(点击哪里则哪里出现图像)</h4><p><img src="/image/Android/customview/shader.gif" alt="望远镜效果"></p>
<p>先上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShadowLayerView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Paint paint;<br>    <span class="hljs-keyword">private</span> Bitmap bitmap;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> preX;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> preY;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShadowLayerView</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShadowLayerView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ShadowLayerView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        paint = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Paint</span>();<br>        bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);<br>        setLayerType(LAYER_TYPE_SOFTWARE, <span class="hljs-literal">null</span>);<br>        paint.setColor(Color.BLACK);<br>        paint.setTextSize(<span class="hljs-number">125</span>);<br>        paint.setShader(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BitmapShader</span>(bitmap, Shader.TileMode.REPEAT, Shader.TileMode.MIRROR));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDraw(canvas);<br>        paint.clearShadowLayer();<br>        <span class="hljs-keyword">if</span> (preY != -<span class="hljs-number">1</span> &amp;&amp; preX != -<span class="hljs-number">1</span>) &#123;<br>            canvas.drawCircle(preX, preY, <span class="hljs-number">150</span>, paint);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>                preX = (<span class="hljs-type">int</span>) event.getX();<br>                preY = (<span class="hljs-type">int</span>) event.getY();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>                preX = (<span class="hljs-type">int</span>) event.getX();<br>                preY = (<span class="hljs-type">int</span>) event.getY();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>                preX = -<span class="hljs-number">1</span>;<br>                preY=-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        postInvalidate();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>init中初始化需要的变量及图片资源，paint.setShader是为了让图片铺满整个屏幕(可以省略)。</p>
<p>在onTouchEvent中保存了当前点击以及移动时的坐标，在结束点击的时候将坐标点重置为-1。</p>
<p>在onDraw方法中，当坐标不是(-1,-1)时，则以点击的坐标为圆心，画一个圆圈，把圆圈部分显示出来。</p>
<p>当然，刮奖效果也可以用这种方式实现，只需要保存一下移动的坐标(结合上面的手势追踪)，把路径画出来就好了。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解,打造自己的框架(上篇)</title>
    <url>/2019/11/23/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3-%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A1%86%E6%9E%B6-%E4%B8%8A%E7%AF%87/</url>
    <content><![CDATA[<p>该系列介绍自定义注解，完成如下功能。</p>
<ul>
<li><input disabled="" type="checkbox"> @BindView 代替  findViewById </li>
<li><input disabled="" type="checkbox"> @ClickResponder 代替 setOnClickListener</li>
<li><input disabled="" type="checkbox"> @LongClickResponder 代替 setOnLongClickListener</li>
<li><input disabled="" type="checkbox"> @IntentValue 代替 getIntent().getXXX</li>
<li><input disabled="" type="checkbox"> @UriValue 代替 getQueryParameter</li>
<li><input disabled="" type="checkbox"> @BroadcastResponder 代替 registerReceiver</li>
<li><input disabled="" type="checkbox"> @RouterModule、@RouterPath 来进行反依赖传递调用</li>
</ul>
<p>使用编译时注解，生成辅助类来完成这些操作，尽量少的使用的反射功能。<br>该系列源码在<a href="https://github.com/huangyuanlove/AndroidAnnotation">https://github.com/huangyuanlove/AndroidAnnotation</a></p>
<p><strong>本章先介绍一丢丢注解相关的东西，并且实现运行时注解</strong></p>
<span id="more"></span>

<h4 id="常见的注解："><a href="#常见的注解：" class="headerlink" title="常见的注解："></a>常见的注解：</h4><p>@Override：被标记的方法一定是重写的父类方法，反之不一定；</p>
<p>@Deprecated：被标记的方法为过时方法，调用该方法时编辑器会有警告</p>
<p>@SuppressWarnings 指示编译器去忽略注解中声明的警告。</p>
<p>元注解 ：作用在其他注解的注解</p>
<p>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。值有三种类型(RetentionPolicy.SOURCE;RetentionPolicy.CLASS;RetentionPolicy.RUNTIME)</p>
<p>@Target - 标记这个注解应该是哪种 Java 成员。常见的值ElementType.TYPE(作用于类)、ElementType.FIELD(作用于字段)、ElementType.METHOD(作用于方法)等</p>
<p><strong>更多关于注解的东西自己搜一下，搜不到的话不要往下看了</strong></p>
<h4 id="太长不看系列总结"><a href="#太长不看系列总结" class="headerlink" title="太长不看系列总结"></a>太长不看系列总结</h4><ol>
<li>声明注解</li>
<li>解析运行时注解<br> 2.1 获取类的属性和方法<br> 2.2 找到添加注解的属性或者方法<br> 2.3 做自定义注解需要做的事情</li>
<li>解析编译时注解(需要编写注解处理器)<br> 3.1 注册注解处理器(@AutoService)<br> 3.2 拿到注解的属性和方法<br> 3.3 生成辅助文件的内容(通常会使用javapoet)<br> 3.4 写入文件<br> 3.5 编写提供给用户调用的方法</li>
</ol>
<h4 id="注解的声明"><a href="#注解的声明" class="headerlink" title="注解的声明"></a>注解的声明</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><span class="hljs-comment">//该注解可以标记字段</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">//该注解可以在运行时通过反射拿到</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用来代替findViewById</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BindView &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> ; <span class="hljs-comment">//这里可以声明默认值   int value() default -1;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用来代替setOnClickListener</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> OnClick &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用来代替ssetOnLongClickListener</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> OnLongClick &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">result</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>java中的反射真是个毁誉参半的东西，至于怎么用，自己搜一下吧。使用反射调用非静态方法时，第一个参数是方法所在类的实例；调用静态方法时，第一个参数传null即可。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>新建Activity，随便写点布局、控件什么的。</p>
<p>使用方式和Butterknife差不多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BindView(value = R.id.test_runtime_annotation)</span><br>Button testRuntimeAnnotation;<br><br><span class="hljs-meta">@OnLongClick(id = R.id.test_runtime_annotation)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRuntimeAnnotationOnLongClick</span><span class="hljs-params">(View v)</span> &#123;<br>    Toast.makeText(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;测试运行时注解：onLongClick&quot;</span>, Toast.LENGTH_LONG).show();<br>&#125;<br><br><span class="hljs-meta">@OnClick(id = R.id.test_runtime_annotation)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setTestRuntimeAnnotationOnClick</span><span class="hljs-params">(View v)</span> &#123;<br>    Toast.makeText(<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;测试运行时注解:onClick&quot;</span>, Toast.LENGTH_LONG).show();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们需要在onCreate中对注解进行操作，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initAnnotation</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//反射获取所有声明的字段</span><br>    Field fields[] = <span class="hljs-built_in">this</span>.getClass().getDeclaredFields();<br><br>    <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//判断字段是否有BindView注解</span><br>        <span class="hljs-type">BindView</span> <span class="hljs-variable">bindView</span> <span class="hljs-operator">=</span> field.getAnnotation(BindView.class);<br>        <span class="hljs-keyword">if</span> (bindView != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//对字段赋值</span><br>                field.set(<span class="hljs-built_in">this</span>, findViewById(bindView.value()));<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>	<span class="hljs-comment">//反射获取所有方法</span><br>    Method methods[] = <span class="hljs-built_in">this</span>.getClass().getDeclaredMethods();<br>    <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>        method.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//判断方法是否有OnLongClick注解</span><br>        <span class="hljs-type">OnLongClick</span> <span class="hljs-variable">onLongClick</span> <span class="hljs-operator">=</span> method.getAnnotation(OnLongClick.class);<br>        <span class="hljs-keyword">if</span> (onLongClick != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//对该方法的注解值对应的控件 设置OnLongClickListener</span><br>            findViewById(onLongClick.id()).setOnLongClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnLongClickListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onLongClick</span><span class="hljs-params">(View v)</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//方法调用</span><br>                        method.invoke(v.getContext(), v);<br><br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> onLongClick.result();<br><br>                &#125;<br>            &#125;);<br>        &#125;<br>         <span class="hljs-comment">//判断方法是否有OnClick注解</span><br>        <span class="hljs-type">OnClick</span> <span class="hljs-variable">onClick</span> <span class="hljs-operator">=</span> method.getAnnotation(OnClick.class);<br>        <span class="hljs-keyword">if</span> (onClick != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//对该方法的注解值对应的控件 设置OnClickListener</span><br>            findViewById(onClick.id()).setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//方法调用</span><br>                        method.invoke(v.getContext(), v);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面就简单的实现了o’nClick,onLongClick,BindView注解，只不过使用的运行时注解，通过反射来对字段和注解进行操作。如果量大的话，反射会消耗性能，我们可以通过注解在编译期间生成辅助类来进行操作，比如 <a href="https://github.com/permissions-dispatcher/PermissionsDispatcher"><strong>PermissionsDispatcher</strong></a></p>
<p>下一篇介绍一下这种方式，需要用到 <a href="https://github.com/square/javapoet">javapoet </a> 这么个东西</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解，打造自己的框架-下下下篇</title>
    <url>/2019/12/10/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A1%86%E6%9E%B6-%E4%B8%8B%E4%B8%8B%E4%B8%8B%E7%AF%87/</url>
    <content><![CDATA[<p>该系列介绍自定义注解，完成如下功能。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> @BindView 代替  findViewById </li>
<li><input checked="" disabled="" type="checkbox"> @ClickResponder 代替 setOnClickListener</li>
<li><input checked="" disabled="" type="checkbox"> @LongClickResponder 代替 setOnLongClickListener</li>
<li><input checked="" disabled="" type="checkbox"> @IntentValue 代替 getIntent().getXXX</li>
<li><input checked="" disabled="" type="checkbox"> @UriValue 代替 getQueryParameter</li>
<li><input checked="" disabled="" type="checkbox"> @BroadcastResponder 代替 registerReceiver</li>
<li><input disabled="" type="checkbox"> @RouterModule、@RouterPath 来进行反依赖传递调用<br>该系列源码在<a href="https://github.com/huangyuanlove/AndroidAnnotation">https://github.com/huangyuanlove/AndroidAnnotation</a><br>前几篇介绍了<code>@BindView</code>、<code>@ClickResponder</code>、<code>@LongClickResponder</code>、<code>@IntentValue</code> 、<code>@UriValue</code>的实现，这一篇介绍一下<code>BroadcastResponder </code>的实现。</li>
</ul>
<span id="more"></span>

<p>其实本来不想写这个的，因为有太多的选择可以在一定程度上代替广播接收器(接收非系统广播，也就是跨页面传值)，比如EventBus，RxBus等。<br>想想项目中可能会用到，就写一写吧。</p>
<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>广播分为本地广播和全局广播，本地广播使用<code>LocalBroadcastManager.getInstance(Context context).sendBroadcast()</code>来发送，全局广播使用<code>Context.sendBroadcast()</code>发送。</p>
<p>同样在注册广播接收器时，本地广播使用<code>LocalBroadcastManager.getInstance(Context context).registerReceiver</code>来注册，全局广播使用<code>Context.registerReceiver()</code>来注册。</p>
<p>需要注意的是，需要再适当的时机，解注册广播接收器，所以我们生成的辅助代码需要保存一下接收器。以便使用者可以去解注册。</p>
<h4 id="声明注解"><a href="#声明注解" class="headerlink" title="声明注解"></a>声明注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BroadcastResponder &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">LOCAL_BROADCAST</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">GLOBAL_BROADCAST</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>    String[] action();<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> LOCAL_BROADCAST;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里需要区分一下注册的是哪种广播，默认是本地广播。</p>
<h4 id="处理注解逻辑"><a href="#处理注解逻辑" class="headerlink" title="处理注解逻辑"></a>处理注解逻辑</h4><p>我们还是使用上一篇中的注解处理器，需要添加属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;TypeElement, List&lt;Element&gt;&gt; broadCastResponderMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>

<p>添加一下注解支持</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">set.add(BroadcastResponder.class.getCanonicalName());<br></code></pre></td></tr></table></figure>

<p>同样在<code>process</code>中处理注解逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">broadCastResponderMap.clear();<br>Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; broadCastResponderSet = roundEnvironment.getElementsAnnotatedWith(BroadcastResponder.class);<br>collectBroadCastResponderMapInfo(broadCastResponderSet);<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">collectBroadCastResponderMapInfo</span><span class="hljs-params">(Set&lt;? extends Element&gt; elements)</span> &#123;<br>  <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>    <span class="hljs-type">TypeElement</span> <span class="hljs-variable">typeElement</span> <span class="hljs-operator">=</span> (TypeElement) element.getEnclosingElement();<br>    List&lt;Element&gt; elementList = broadCastResponderMap.get(typeElement);<br>    <span class="hljs-keyword">if</span> (elementList == <span class="hljs-literal">null</span>) &#123;<br>      elementList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      broadCastResponderMap.put(typeElement, elementList);<br>    &#125;<br>    elementList.add(element);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>generateCode()</code>方法中调用<code>generateBroadcastResponderCode();</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateBroadcastResponderCode</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">for</span> (TypeElement typeElement : broadCastResponderMap.keySet()) &#123;<br><br>    MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> generateRegisterReceiverMethodBuilder(typeElement);<br><br><br>    <span class="hljs-type">ClassName</span> <span class="hljs-variable">broadcastReceiverClassName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;android.content.BroadcastReceiver&quot;</span>);<br>    <span class="hljs-type">ClassName</span> <span class="hljs-variable">contextClassName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;android.content.Context&quot;</span>);<br>    <span class="hljs-type">ClassName</span> <span class="hljs-variable">intentClassName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;android.content.Intent&quot;</span>);<br>    <span class="hljs-type">ClassName</span> <span class="hljs-variable">localBroadcastManagerClassName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;androidx.localbroadcastmanager.content.LocalBroadcastManager&quot;</span>);<br><br><br>    List&lt;Element&gt; elements = broadCastResponderMap.get(typeElement);<br><br>    HashMap&lt;String, String&gt; localBroadCast = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    HashMap&lt;String, String&gt; globalBroadCast = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>      <span class="hljs-type">ExecutableElement</span> <span class="hljs-variable">executableElement</span> <span class="hljs-operator">=</span> (ExecutableElement) element;<br>      <span class="hljs-type">BroadcastResponder</span> <span class="hljs-variable">broadcastResponder</span> <span class="hljs-operator">=</span> executableElement.getAnnotation(BroadcastResponder.class);<br>      <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> broadcastResponder.type();<br>      String[] actions = broadcastResponder.action();<br>      <span class="hljs-keyword">for</span> (String action : actions) &#123;<br><br>        <span class="hljs-keyword">if</span> (BroadcastResponder.LOCAL_BROADCAST == type) &#123;<br>          methodBuilder.addStatement(<span class="hljs-string">&quot;localBroadcastFilter.addAction(($S))&quot;</span>, action);<br>          localBroadCast.put(action, element.getSimpleName().toString());<br><br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (BroadcastResponder.GLOBAL_BROADCAST == type) &#123;<br>          globalBroadCast.put(action, element.getSimpleName().toString());<br>          methodBuilder.addStatement(<span class="hljs-string">&quot;globalBroadcastFilter.addAction(($S))&quot;</span>, action);<br>        &#125;<br><br>      &#125;<br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (globalBroadCast.size() &gt; <span class="hljs-number">0</span>) &#123;<br>      CodeBlock.<span class="hljs-type">Builder</span> <span class="hljs-variable">caseBlockBuilder</span> <span class="hljs-operator">=</span> CodeBlock.builder().beginControlFlow(<span class="hljs-string">&quot;switch (intent.getAction())&quot;</span>);<br>      <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : globalBroadCast.entrySet()) &#123;<br>        caseBlockBuilder.add(<span class="hljs-string">&quot;case $S:\n&quot;</span>, entry.getKey())<br>          .addStatement(<span class="hljs-string">&quot;target.$L(context,intent)&quot;</span>, entry.getValue())<br>          .addStatement(<span class="hljs-string">&quot;break&quot;</span>);<br>      &#125;<br><br><br>      caseBlockBuilder.endControlFlow();<br>      <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">broadcastReceiverMethod</span> <span class="hljs-operator">=</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;onReceive&quot;</span>)<br>        .addModifiers(Modifier.PUBLIC)<br>        .addParameter(contextClassName, <span class="hljs-string">&quot;context&quot;</span>)<br>        .addParameter(intentClassName, <span class="hljs-string">&quot;intent&quot;</span>)<br>        .addCode(caseBlockBuilder.build())<br>        .returns(<span class="hljs-keyword">void</span>.class)<br>        .build();<br>      <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">innerTypeSpec</span> <span class="hljs-operator">=</span> TypeSpec.anonymousClassBuilder(<span class="hljs-string">&quot;&quot;</span>)<br>        .addSuperinterface(broadcastReceiverClassName)<br>        .addMethod(broadcastReceiverMethod)<br>        .build();<br>      methodBuilder.addStatement(<span class="hljs-string">&quot;$T globalBroadcastReceiver = $L&quot;</span>, broadcastReceiverClassName, innerTypeSpec);<br>      methodBuilder.addStatement(<span class="hljs-string">&quot;target.registerReceiver(globalBroadcastReceiver,globalBroadcastFilter)&quot;</span>);<br>      methodBuilder.addStatement(<span class="hljs-string">&quot;hashMap.put($L,globalBroadcastReceiver)&quot;</span>, BroadcastResponder.GLOBAL_BROADCAST);<br>    &#125;<br><br><br>    <span class="hljs-keyword">if</span> (localBroadCast.size() &gt; <span class="hljs-number">0</span>) &#123;<br>      CodeBlock.<span class="hljs-type">Builder</span> <span class="hljs-variable">caseBlockBuilder</span> <span class="hljs-operator">=</span> CodeBlock.builder().beginControlFlow(<span class="hljs-string">&quot;switch (intent.getAction())&quot;</span>);<br>      <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : localBroadCast.entrySet()) &#123;<br>        caseBlockBuilder.add(<span class="hljs-string">&quot;case $S:\n&quot;</span>, entry.getKey())<br>          .addStatement(<span class="hljs-string">&quot;target.$L(context,intent)&quot;</span>, entry.getValue())<br>          .addStatement(<span class="hljs-string">&quot;break&quot;</span>);<br>      &#125;<br><br><br>      caseBlockBuilder.endControlFlow();<br><br><br>      <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">broadcastReceiverMethod</span> <span class="hljs-operator">=</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;onReceive&quot;</span>)<br>        .addModifiers(Modifier.PUBLIC)<br>        .addParameter(contextClassName, <span class="hljs-string">&quot;context&quot;</span>)<br>        .addParameter(intentClassName, <span class="hljs-string">&quot;intent&quot;</span>)<br>        .addCode(caseBlockBuilder.build())<br>        .returns(<span class="hljs-keyword">void</span>.class)<br>        .build();<br>      <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">innerTypeSpec</span> <span class="hljs-operator">=</span> TypeSpec.anonymousClassBuilder(<span class="hljs-string">&quot;&quot;</span>)<br>        .addSuperinterface(broadcastReceiverClassName)<br>        .addMethod(broadcastReceiverMethod)<br>        .build();<br>      methodBuilder.addStatement(<span class="hljs-string">&quot;$T localBroadcastReceiver = $L&quot;</span>, broadcastReceiverClassName, innerTypeSpec);<br>      methodBuilder.addStatement(<span class="hljs-string">&quot;$T.getInstance(target).registerReceiver(localBroadcastReceiver,localBroadcastFilter)&quot;</span>, localBroadcastManagerClassName);<br>      methodBuilder.addStatement(<span class="hljs-string">&quot;hashMap.put($L,localBroadcastReceiver)&quot;</span>, BroadcastResponder.LOCAL_BROADCAST);<br>    &#125;<br><br>    methodBuilder.addStatement(<span class="hljs-string">&quot;return hashMap&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> MethodSpec.Builder <span class="hljs-title function_">generateRegisterReceiverMethodBuilder</span><span class="hljs-params">(TypeElement typeElement)</span> &#123;<br><br>  <span class="hljs-type">TypeSpecWrapper</span> <span class="hljs-variable">typeSpecWrapper</span> <span class="hljs-operator">=</span> generateTypeSpecWrapper(typeElement);<br>  MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> typeSpecWrapper.getMethodBuilder(<span class="hljs-string">&quot;registerReceiver&quot;</span>);<br>  <span class="hljs-type">ClassName</span> <span class="hljs-variable">intentFilterClassName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;android.content.IntentFilter&quot;</span>);<br>  <span class="hljs-type">ClassName</span> <span class="hljs-variable">broadcastReceiverClassName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;android.content.BroadcastReceiver&quot;</span>);<br><br><br>  <span class="hljs-keyword">if</span> (methodBuilder == <span class="hljs-literal">null</span>) &#123;<br><br><br>    <span class="hljs-type">TypeName</span> <span class="hljs-variable">methodReturns</span> <span class="hljs-operator">=</span> ParameterizedTypeName.get(<br>      ClassName.get(HashMap.class),<br>      ClassName.get(Integer.class),<br>      broadcastReceiverClassName<br>    );<br><br><br>    methodBuilder = MethodSpec.methodBuilder(<span class="hljs-string">&quot;registerReceiver&quot;</span>)<br>      .addParameter(ClassName.get(typeElement.asType()), <span class="hljs-string">&quot;target&quot;</span>)<br>      .addModifiers(Modifier.PUBLIC, Modifier.STATIC)<br>      .addStatement(<span class="hljs-string">&quot;HashMap&lt;Integer,BroadcastReceiver&gt; hashMap = new HashMap&lt;&gt;()&quot;</span>)<br><br>      .addStatement(<span class="hljs-string">&quot;$T localBroadcastFilter = new $T()&quot;</span>, intentFilterClassName, intentFilterClassName)<br>      .addStatement(<span class="hljs-string">&quot;$T globalBroadcastFilter = new $T()&quot;</span>, intentFilterClassName, intentFilterClassName)<br>      .returns(methodReturns);<br>    typeSpecWrapper.putMethodBuilder(methodBuilder);<br>  &#125;<br>  <span class="hljs-keyword">return</span> methodBuilder;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="给使用者提供调用方法"><a href="#给使用者提供调用方法" class="headerlink" title="给使用者提供调用方法"></a>给使用者提供调用方法</h4><p>还是在api模块中的<code>ViewInjector</code>类中添加如下方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Method&gt; BROADCAST_MAP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HashMap&lt;Integer, BroadcastReceiver&gt; <span class="hljs-title function_">registerReceiver</span><span class="hljs-params">(Activity activity)</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> findRegisterReceiverMethodForClass(activity.getClass());<br>    <span class="hljs-keyword">return</span> (HashMap&lt;Integer,BroadcastReceiver&gt;)method.invoke(<span class="hljs-literal">null</span>,activity);<br>  &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title function_">findRegisterReceiverMethodForClass</span><span class="hljs-params">(Class&lt;?&gt; cls)</span> &#123;<br>  <span class="hljs-type">Method</span> <span class="hljs-variable">registerReceiver</span> <span class="hljs-operator">=</span> BROADCAST_MAP.get(cls);<br>  <span class="hljs-keyword">if</span> (registerReceiver == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      Class&lt;?&gt; bindingClass = Class.forName(cls.getName() + <span class="hljs-string">&quot;$ViewInjector&quot;</span>);<br>      registerReceiver=   bindingClass.getDeclaredMethod(<span class="hljs-string">&quot;registerReceiver&quot;</span>,cls);<br>      BROADCAST_MAP.put(cls, registerReceiver);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> registerReceiver;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>首先，在需要注册广播接收器的类中注册一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, BroadcastReceiver&gt; broadcastReceiverHashMap = ViewInjector.registerReceiver(<span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure>
<p>使用<code>@BroadcastResponder</code>注解处理广播的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@BroadcastResponder(action = &#123;&quot;com.huangyuanblog&quot;,&quot;com.huangyuanblog.www&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceiveBroadcast</span><span class="hljs-params">(Context context, Intent intent)</span>&#123;<br>  Toast.makeText(context,intent.getAction(),Toast.LENGTH_SHORT).show();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后在合适的时机(onDestroy或者onStop)中解注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-built_in">super</span>.onDestroy();<br>  <span class="hljs-keyword">if</span>(broadcastReceiverHashMap!=<span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-keyword">if</span>(broadcastReceiverHashMap.get(BroadcastResponder.GLOBAL_BROADCAST) !=<span class="hljs-literal">null</span>)&#123;<br>      unregisterReceiver(broadcastReceiverHashMap.get(BroadcastResponder.GLOBAL_BROADCAST));<br>    &#125;<br>    <span class="hljs-keyword">if</span>(broadcastReceiverHashMap.get(BroadcastResponder.LOCAL_BROADCAST) !=<span class="hljs-literal">null</span>)&#123;<br>    LocalBroadcastManager.getInstance(<span class="hljs-built_in">this</span>).unregisterReceiver(broadcastReceiverHashMap.get(BroadcastResponder.LOCAL_BROADCAST));<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>写这种自定义注解难度并不大，麻烦的地方在于需要考虑好给调用者提供一个什么样的接口，然后怎么实现注解的功能(需要生成什么样的辅助代码)</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解，打造自己的框架-下下篇</title>
    <url>/2019/12/09/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A1%86%E6%9E%B6-%E4%B8%8B%E4%B8%8B%E7%AF%87/</url>
    <content><![CDATA[<p>该系列介绍自定义注解，完成如下功能。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> @BindView 代替  findViewById </li>
<li><input checked="" disabled="" type="checkbox"> @ClickResponder 代替 setOnClickListener</li>
<li><input checked="" disabled="" type="checkbox"> @LongClickResponder 代替 setOnLongClickListener</li>
<li><input checked="" disabled="" type="checkbox"> @IntentValue 代替 getIntent().getXXX</li>
<li><input checked="" disabled="" type="checkbox"> @UriValue 代替 getQueryParameter</li>
<li><input disabled="" type="checkbox"> @BroadcastResponder 代替 registerReceiver</li>
<li><input disabled="" type="checkbox"> @RouterModule、@RouterPath 来进行反依赖传递调用<br>该系列源码在<a href="https://github.com/huangyuanlove/AndroidAnnotation">https://github.com/huangyuanlove/AndroidAnnotation</a><br>前几篇介绍了<code>@BindView</code>、<code>@ClickResponder</code>、<code>@LongClickResponder</code>的实现，这一篇介绍一下<code>@IntentValue</code> 和<code>@UriValue</code>的实现。</li>
</ul>
<span id="more"></span>

<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>我们知道执行<code>Intent.putExtra()</code>方法时，实际上是把数据塞进Bundle中的，并且该方法有不同的重载类型，方便开发这存储不同的数据。当我们从中取数据时，需要调用不同的方法来获取不同类型的数据，这就需要我们在生成辅助代码时，根据注解字段的类型来调用不同的方法。</p>
<p>而Uri中的能传递的参数只有有限的几种类型，最常见的就是String和int</p>
<h4 id="声明注解"><a href="#声明注解" class="headerlink" title="声明注解"></a>声明注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> IntentValue &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_TYPE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">PARCELABLE_OBJECT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">PARCELABLE_ARRAY_OBJECT</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">PARCELABLE_ARRAYLIST_OBJECT</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">SERIALIZABLE_OBJECT</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><br><br>    String <span class="hljs-title function_">key</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> DEFAULT_TYPE;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这里在注解类中声明了几种类型，来配合注解使用，主要是为了在生成辅助代码时简单，因为<code>javax.lang.model.type.TypeKind</code>只声明了有限的几种类型，其余的需要我们自己取判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> UriValue &#123;<br>    String <span class="hljs-title function_">key</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="处理注解逻辑"><a href="#处理注解逻辑" class="headerlink" title="处理注解逻辑"></a>处理注解逻辑</h4><p>我们还是使用上一篇中的注解处理器，需要添加两个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;TypeElement, List&lt;Element&gt;&gt; intentValueMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> Map&lt;TypeElement, List&lt;Element&gt;&gt; uriValueMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>

<p>在 <code>getSupportedAnnotationTypes</code>方法中添加支持</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">set.add(IntentValue.class.getCanonicalName());<br>set.add(UriValue.class.getCanonicalName());<br></code></pre></td></tr></table></figure>

<p>在<code>process</code>方法中加入我们的注解处理逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">intentValueMap.clear();<br>uriValueMap.clear();<br><br>Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; intentValueSet = roundEnvironment.getElementsAnnotatedWith(IntentValue.class);<br>Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; uriValueSet = roundEnvironment.getElementsAnnotatedWith(UriValue.class);<br><br>collectIntentValueInfo(intentValueSet);<br>collectUriValueMapInfo(uriValueSet);<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">collectIntentValueInfo</span><span class="hljs-params">(Set&lt;? extends Element&gt; elements)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>            <span class="hljs-type">TypeElement</span> <span class="hljs-variable">typeElement</span> <span class="hljs-operator">=</span> (TypeElement) element.getEnclosingElement();<br>            List&lt;Element&gt; elementList = intentValueMap.get(typeElement);<br>            <span class="hljs-keyword">if</span> (elementList == <span class="hljs-literal">null</span>) &#123;<br>                elementList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                intentValueMap.put(typeElement, elementList);<br>            &#125;<br>            elementList.add(element);<br>        &#125;<br>    &#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">collectUriValueMapInfo</span><span class="hljs-params">(Set&lt;? extends Element&gt; elements)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>        <span class="hljs-type">TypeElement</span> <span class="hljs-variable">typeElement</span> <span class="hljs-operator">=</span> (TypeElement) element.getEnclosingElement();<br>        List&lt;Element&gt; elementList = uriValueMap.get(typeElement);<br>        <span class="hljs-keyword">if</span> (elementList == <span class="hljs-literal">null</span>) &#123;<br>            elementList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            uriValueMap.put(typeElement, elementList);<br>        &#125;<br>        elementList.add(element);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的这些收集信息的工作都差不多，把我们需要的数据存放在map中。</p>
<p>在<code>generateCode()</code>方法中调用</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">generateIntentValueCode</span>();<br><span class="hljs-built_in">generateUriValueCode</span>();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateIntentValueCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (TypeElement typeElement : intentValueMap.keySet()) &#123;<br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> generateParseBundleMethodCode(typeElement);<br><br>        List&lt;Element&gt; elements = intentValueMap.get(typeElement);<br>        <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>            processorIntentValue(element, methodBuilder);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateUriValueCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (TypeElement typeElement : uriValueMap.keySet()) &#123;<br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> generateParseUriMethodCode(typeElement);<br><br>        List&lt;Element&gt; elements = uriValueMap.get(typeElement);<br>        <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>            processorUriValue(element, methodBuilder);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们先来看一下比较简单的处理Uri参数的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processorUriValue</span><span class="hljs-params">(Element element, MethodSpec.Builder methodBuilder)</span> &#123;<br>    <span class="hljs-type">VariableElement</span> <span class="hljs-variable">variableElement</span> <span class="hljs-operator">=</span> (VariableElement) element;<br>    <br>    <span class="hljs-comment">//注解的字段名字</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">varName</span> <span class="hljs-operator">=</span> variableElement.getSimpleName().toString();<br><br>    <span class="hljs-type">UriValue</span> <span class="hljs-variable">uriValue</span> <span class="hljs-operator">=</span> variableElement.getAnnotation(UriValue.class);<br><br>    <span class="hljs-comment">//获取到注解的key，从Uri中获取对应的值</span><br>    methodBuilder.addStatement(<span class="hljs-string">&quot;temp = uri.getQueryParameter($S)&quot;</span>, uriValue.key());<br>    <br>    <span class="hljs-comment">//如果是String类型，直接赋值</span><br>    <span class="hljs-keyword">if</span> (element.asType().toString().equals(<span class="hljs-string">&quot;java.lang.String&quot;</span>)) &#123;<br>        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L=temp&quot;</span>,varName);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//其他类型需要转换一下，然后再赋值</span><br>        <span class="hljs-keyword">switch</span> (element.asType().getKind())&#123;<br>            <span class="hljs-keyword">case</span> BOOLEAN:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L=Boolean.valueOf(temp)&quot;</span>,varName);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> INT:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L= Integer.valueOf(temp)&quot;</span>,varName);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> DOUBLE:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L= Double.valueOf(temp)&quot;</span>,varName);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> FLOAT:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L= Float.valueOf(temp)&quot;</span>,varName);<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> LONG:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L= Long.valueOf(temp)&quot;</span>,varName);<br>                <span class="hljs-keyword">break</span>;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>基于同样的方式，我们来处理一下IntentValue，因为Bundle中可以存储的数据类型较多，方法比较长，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processorIntentValue</span><span class="hljs-params">(Element element, MethodSpec.Builder methodBuilder)</span> &#123;<br>    <span class="hljs-type">VariableElement</span> <span class="hljs-variable">variableElement</span> <span class="hljs-operator">=</span> (VariableElement) element;<br>    <br>    <span class="hljs-comment">//注解字段的名字</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">varName</span> <span class="hljs-operator">=</span> variableElement.getSimpleName().toString();<br>    <span class="hljs-comment">//注解字段的类型名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">varType</span> <span class="hljs-operator">=</span> variableElement.asType().toString();<br><br><br>    <span class="hljs-type">IntentValue</span> <span class="hljs-variable">intentValue</span> <span class="hljs-operator">=</span> variableElement.getAnnotation(IntentValue.class);<br><br><br>    methodBuilder.beginControlFlow(<span class="hljs-string">&quot;if(bundle.containsKey($S))&quot;</span>, intentValue.key());<br><br>    <span class="hljs-keyword">if</span> (intentValue.type() == IntentValue.DEFAULT_TYPE) &#123;<br><br><span class="hljs-comment">//基本数据类型可以直接判断，不需要类型名</span><br>        <span class="hljs-keyword">switch</span> (element.asType().getKind()) &#123;<br>            <span class="hljs-keyword">case</span> BOOLEAN:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getBoolean($S)&quot;</span>, varName, intentValue.key());<br>                <span class="hljs-keyword">break</span>;<br><br><br>            <span class="hljs-keyword">case</span> SHORT:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getShort($S)&quot;</span>, varName, intentValue.key());<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> BYTE:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getByte($S)&quot;</span>, varName, intentValue.key());<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> INT:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getInt($S)&quot;</span>, varName, intentValue.key());<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> CHAR:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getChar($S)&quot;</span>, varName, intentValue.key());<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> LONG:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getLong($S)&quot;</span>, varName, intentValue.key());<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> FLOAT:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getFloat($S)&quot;</span>, varName, intentValue.key());<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> DOUBLE:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getDouble($S)&quot;</span>, varName, intentValue.key());<br>                <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-comment">//ARRAY类型分好多中，需要类型的名字具体判断</span><br>            <span class="hljs-keyword">case</span> ARRAY:<br>                <span class="hljs-keyword">switch</span> (element.asType().toString()) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;byte[]&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getByteArray($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;short[]&quot;</span>:<br><br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getShortArray($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;boolean[]&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getBooleanArray($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;int[]&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getIntArray($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;long[]&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getLongArray($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;char[]&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getCharArray($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;java.lang.CharSequence[]&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getCharSequenceArray($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;float[]&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getFloatArray($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;double[]&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getDoubleArray($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;java.lang.String[]&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getStringArray($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = ($L) bundle.getParcelableArray($S)&quot;</span>, varName, varType, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br><br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-comment">//其余的会被当做`DECLARED`类型</span><br>            <span class="hljs-keyword">case</span> DECLARED:<br>                <span class="hljs-keyword">switch</span> (element.asType().toString()) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;java.util.ArrayList&lt;java.lang.Integer&gt;&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getIntegerArrayList($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;java.lang.CharSequence&quot;</span>:<br><br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getCharSequence($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;java.util.ArrayList&lt;java.lang.CharSequence&gt;&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getCharSequenceArrayList($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;java.lang.String&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getString($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;java.util.ArrayList&lt;java.lang.String&gt;&quot;</span>:<br>                        methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = bundle.getStringArrayList($S)&quot;</span>, varName, intentValue.key());<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">default</span>:<br><br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//这里的就是方便通过类型或者类型名来判断的，通过我们自己定义的类型来做判断</span><br>        <span class="hljs-keyword">switch</span> (intentValue.type()) &#123;<br>            <span class="hljs-keyword">case</span> IntentValue.SERIALIZABLE_OBJECT:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L  = ($L) bundle.getSerializable($S)&quot;</span>, varName, varType, intentValue.key());<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> IntentValue.PARCELABLE_OBJECT:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L  = bundle.getParcelable($S)&quot;</span>, varName, intentValue.key());<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> IntentValue.PARCELABLE_ARRAY_OBJECT:<br><br>                methodBuilder.addStatement(<span class="hljs-string">&quot; android.os.Parcelable[] temp = bundle.getParcelableArray($S)&quot;</span>, intentValue.key());<br>                methodBuilder.beginControlFlow(<span class="hljs-string">&quot;if(temp!=null &amp;&amp; temp.length&gt;0)&quot;</span>);<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = new $L[temp.length]&quot;</span>, varName, varType.substring(<span class="hljs-number">0</span>, varType.length() - <span class="hljs-number">2</span>));<br>                methodBuilder.beginControlFlow(<span class="hljs-string">&quot;for(int i = 0 ; i &lt; temp.length;i++)&quot;</span>);<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L[i] = ($L) temp[i]&quot;</span>, varName, varType.substring(<span class="hljs-number">0</span>, varType.length() - <span class="hljs-number">2</span>));<br>                methodBuilder.endControlFlow();<br>                methodBuilder.endControlFlow();<br><br><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> IntentValue.PARCELABLE_ARRAYLIST_OBJECT:<br>                methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L  = bundle.getParcelableArrayList($S)&quot;</span>, varName, intentValue.key());<br><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    methodBuilder.endControlFlow();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="给使用者提供调用方法"><a href="#给使用者提供调用方法" class="headerlink" title="给使用者提供调用方法"></a>给使用者提供调用方法</h4><p>还是在api模块中的<code>ViewInjector</code>类中添加如下方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Method&gt; BUNDLES = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseBundle</span><span class="hljs-params">(Activity activity)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> findParseBundleMethodForClass(activity.getClass(),activity.getClass());<br>        method.invoke(<span class="hljs-literal">null</span>,activity,activity.getIntent()==<span class="hljs-literal">null</span>?<span class="hljs-literal">null</span>:activity.getIntent().getExtras());<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseBundle</span><span class="hljs-params">(Fragment fragment)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span>findParseBundleMethodForClass(fragment.getClass(),fragment.getClass());<br>        method .invoke(<span class="hljs-literal">null</span>,fragment,fragment.getArguments());<br><br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title function_">findParseBundleMethodForClass</span><span class="hljs-params">(Class&lt;?&gt; cls,Class clazz)</span> &#123;<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">parseBundle</span> <span class="hljs-operator">=</span> BUNDLES.get(cls);<br>    <span class="hljs-keyword">if</span> (parseBundle == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; bindingClass = Class.forName(cls.getName() + <span class="hljs-string">&quot;$ViewInjector&quot;</span>);<br>            parseBundle=   bindingClass.getDeclaredMethod(<span class="hljs-string">&quot;parseBundle&quot;</span>,clazz, Bundle.class);<br>            BUNDLES.put(cls, parseBundle);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> parseBundle;<br>&#125;<br><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Method&gt; URIS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseUri</span><span class="hljs-params">(Activity activity)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> findParseUriMethodForClass(activity.getClass(),activity.getClass());<br>        method.invoke(<span class="hljs-literal">null</span>,activity,activity.getIntent()==<span class="hljs-literal">null</span>?<span class="hljs-literal">null</span>:activity.getIntent().getData());<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title function_">findParseUriMethodForClass</span><span class="hljs-params">(Class&lt;?&gt; cls,Class clazz)</span> &#123;<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">parseUri</span> <span class="hljs-operator">=</span> URIS.get(cls);<br>    <span class="hljs-keyword">if</span> (parseUri == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; bindingClass = Class.forName(cls.getName() + <span class="hljs-string">&quot;$ViewInjector&quot;</span>);<br>            parseUri=  bindingClass.getDeclaredMethod(<span class="hljs-string">&quot;parseUri&quot;</span>,clazz, Uri.class);<br>            URIS.put(cls, parseUri);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> parseUri;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>只需要在对应的类中调用<code>ViewInjector.parseBundle(this);</code>和<code>ViewInjector.parseUri(this);</code>方法就好了</p>
<p>其实应该把UriValue当成练手让大家自己写的。。。。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解，打造自己的框架-下篇</title>
    <url>/2019/12/04/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A1%86%E6%9E%B6-%E4%B8%8B%E7%AF%87/</url>
    <content><![CDATA[<p>该系列介绍自定义注解，完成如下功能。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> @BindView 代替  findViewById </li>
<li><input checked="" disabled="" type="checkbox"> @ClickResponder 代替 setOnClickListener</li>
<li><input checked="" disabled="" type="checkbox"> @LongClickResponder 代替 setOnLongClickListener</li>
<li><input disabled="" type="checkbox"> @IntentValue 代替 getIntent().getXXX</li>
<li><input disabled="" type="checkbox"> @UriValue 代替 getQueryParameter</li>
<li><input disabled="" type="checkbox"> @BroadcastResponder 代替 registerReceiver</li>
<li><input disabled="" type="checkbox"> @RouterModule、@RouterPath 来进行反依赖传递调用</li>
</ul>
<p>该系列源码在<a href="https://github.com/huangyuanlove/AndroidAnnotation">https://github.com/huangyuanlove/AndroidAnnotation</a></p>
<p>前两篇介绍了一丢丢自定义注解过程中使用到的东西，现在我们正式开始写框架。</p>
<span id="more"></span>

<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>一般来讲，注解类框架(在Android)会分成三个部分，</p>
<ul>
<li><p>annotation模块(java lib)</p>
<p>用来存放注解类的，对应gradle引用<code>annotationProcessor xxxx</code></p>
</li>
<li><p>compiler模块(java lib)</p>
<p>用来存放生成辅助类的，对应gradle引用<code>implementation  xxxx</code></p>
</li>
<li><p>api模块(Android lib)</p>
<p>用来提供给使用者的接口，对应gradle引用<code>implementation  xxxx</code>，这个模块中会存在大量的反射调用，主要是调用生成的辅助类中的方法。</p>
</li>
<li><p>example(lib)模块和app(application)模块</p>
<p>用来存放demo的，一般会区分在lib和application中的使用</p>
</li>
</ul>
<p>也有一些框架会把api模块和compiler模块放在一块，无所谓了。。。。</p>
<p>首先来创建新的工程，然后创建对应的模块，注意：<strong>annotation和compiler模块是java lib，不要创建成Android lib</strong></p>
<p><strong>我们先来实现一下<code>BindView </code>和<code>ClickResponder </code>这两个注解</strong></p>
<h4 id="声明注解"><a href="#声明注解" class="headerlink" title="声明注解"></a>声明注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BindView &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">id</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//在Android lib中生成的R文件中资源id不是final类型的，所以我们换个思路，</span><br>    <span class="hljs-comment">//通过`getResources().getIdentifier()`来实现</span><br>    String <span class="hljs-title function_">idStr</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> ClickResponder &#123;<br>    <span class="hljs-type">int</span>[] id() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    String[] idStr() <span class="hljs-keyword">default</span> &#123;<span class="hljs-string">&quot;&quot;</span>&#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="声明注解处理器"><a href="#声明注解处理器" class="headerlink" title="声明注解处理器"></a>声明注解处理器</h4><p>声明一个processer类继承<code>avax.annotation.processing.AbstractProcessor</code>类，对这个类使用<code>@AutoService(Processor.class)</code>注解。<br>我们需要实现四个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewInjectProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span>&#123;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 每个Annotation Processor必须有一个空的构造函数。</span><br><span class="hljs-comment">     * 编译期间，init()会自动被注解处理工具调用，并传入ProcessingEnvironment参数，</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnvironment);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于指定该处理器支持哪些注解</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getSupportedAnnotationTypes();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于指定支持的java版本，</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title function_">getSupportedSourceVersion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SourceVersion.latestSupported();<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Annotation Processor扫描出的结果会存储进roundEnvironment中，可以在这里获取到注解内容，编写你的操作逻辑。</span><br><span class="hljs-comment">     * 注意:process()函数中不能直接进行异常抛出,并且该方法会执行多次</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="处理注解逻辑"><a href="#处理注解逻辑" class="headerlink" title="处理注解逻辑"></a>处理注解逻辑</h4><p>声明几个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Elements elementUtils;<br><span class="hljs-keyword">private</span> Map&lt;TypeElement, List&lt;Element&gt;&gt; bindViewMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> Map&lt;TypeElement, List&lt;Element&gt;&gt; clickResponderMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>

<p>在<code>init</code>方法中初始化用到的字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnv)</span> &#123;<br>    <span class="hljs-built_in">super</span>.init(processingEnv);<br>    elementUtils = processingEnv.getElementUtils();<br>&#125;<br></code></pre></td></tr></table></figure>


<p>在<code>getSupportedSourceVersion</code>方法中返回支持的java版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title function_">getSupportedSourceVersion</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> SourceVersion.RELEASE_7;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>在 <code>getSupportedAnnotationTypes</code>方法中返回支持的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>    set.add(BindView.class.getCanonicalName());<br>    set.add(ClickResponder.class.getCanonicalName());<br>    <span class="hljs-keyword">return</span> set;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里为了方便以后在辅助类中添加各种方法，定义了<code>TypeSpecWrapper</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeSpecWrapper</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TypeSpec.Builder typeSpecBuilder;<br>    <span class="hljs-keyword">private</span> String packageName;<br>    <span class="hljs-keyword">private</span> HashMap&lt;String, MethodSpec.Builder&gt; methodBuildMap;<br><br>    <span class="hljs-keyword">public</span> TypeSpec <span class="hljs-title function_">build</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String,MethodSpec.Builder&gt; entry:methodBuildMap.entrySet())&#123;<br>            typeSpecBuilder.addMethod(entry.getValue().build());<br>        &#125;<br>        <span class="hljs-keyword">return</span> typeSpecBuilder.build();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TypeSpec.Builder <span class="hljs-title function_">setTypeSpecBuilder</span><span class="hljs-params">(TypeSpec.Builder builder)</span>&#123;<br>        <span class="hljs-built_in">this</span>.typeSpecBuilder = builder;<br>        <span class="hljs-keyword">return</span> builder;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> MethodSpec.Builder <span class="hljs-title function_">putMethodBuilder</span><span class="hljs-params">(MethodSpec.Builder builder)</span>&#123;<br><br>        <span class="hljs-keyword">return</span> methodBuildMap.put(builder.build().name,builder);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> MethodSpec.Builder <span class="hljs-title function_">getMethodBuilder</span><span class="hljs-params">(String methodName)</span>&#123;<br>        <span class="hljs-keyword">return</span> methodBuildMap.get(methodName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeTo</span><span class="hljs-params">(Filer filer)</span>&#123;<br>        <span class="hljs-type">JavaFile</span> <span class="hljs-variable">javaFile</span> <span class="hljs-operator">=</span> JavaFile.builder(packageName, build())<br>                .build();<br>        <span class="hljs-keyword">try</span> &#123;<br>            javaFile.writeTo(filer);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Map&lt;String, MethodSpec.Builder&gt; getMethodBuildMap()&#123;<br>        <span class="hljs-keyword">return</span>  methodBuildMap;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> TypeSpec.Builder <span class="hljs-title function_">getTypeSpecBuilder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> typeSpecBuilder;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TypeSpecWrapper</span><span class="hljs-params">(TypeSpec.Builder typeSpecBuilder,String packageName)</span>&#123;<br>        <span class="hljs-built_in">this</span>.typeSpecBuilder = typeSpecBuilder;<br>        <span class="hljs-built_in">this</span>.packageName = packageName;<br>        methodBuildMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在<code>process</code>中生成辅助类并写入文件,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> &#123;<br>bindViewMap.clear();<br>clickResponderMap.clear();<br>Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; bindViewSet = roundEnvironment.getElementsAnnotatedWith(BindView.class);<br>Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; onClickSet = roundEnvironment.getElementsAnnotatedWith(ClickResponder.class);<br><br><span class="hljs-comment">//收集BindView对应的信息</span><br>collectBindViewInfo(bindViewSet);<br><span class="hljs-comment">//收集ClickResponder对应的信息</span><br>collectClickResponderInfo(onClickSet);<br><span class="hljs-comment">//生成辅助类代码</span><br>generateCode();<br><span class="hljs-comment">//将生成代码写入文件</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;TypeElement, TypeSpecWrapper&gt; entry : typeSpecWrapperMap.entrySet()) &#123;<br>          entry.getValue().writeTo(processingEnv.getFiler());<br>      &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为会有多个类使用同一个注解，这里需要根据使用该注解的类名来保存对应的注解信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">collectBindViewInfo</span><span class="hljs-params">(Set&lt;? extends Element&gt; elements)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>        <span class="hljs-type">TypeElement</span> <span class="hljs-variable">typeElement</span> <span class="hljs-operator">=</span> (TypeElement) element.getEnclosingElement();<br>        List&lt;Element&gt; elementList = bindViewMap.get(typeElement);<br>        <span class="hljs-keyword">if</span> (elementList == <span class="hljs-literal">null</span>) &#123;<br>            elementList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            bindViewMap.put(typeElement, elementList);<br>        &#125;<br>        elementList.add(element);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">collectClickResponderInfo</span><span class="hljs-params">(Set&lt;? extends Element&gt; elements)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>        <span class="hljs-type">TypeElement</span> <span class="hljs-variable">typeElement</span> <span class="hljs-operator">=</span> (TypeElement) element.getEnclosingElement();<br>        List&lt;Element&gt; elementList = clickResponderMap.get(typeElement);<br>        <span class="hljs-keyword">if</span> (elementList == <span class="hljs-literal">null</span>) &#123;<br>            elementList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            clickResponderMap.put(typeElement, elementList);<br>        &#125;<br>        elementList.add(element);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>生成辅助类的内容，这里为了简单，将<code>BindView</code>、<code>ClickResponder</code>以及之后的<code>LongClickResponderCode</code>注解处理都放在了<code>bind</code>方法中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateCode</span><span class="hljs-params">()</span> &#123;<br>    generateBindViewCode();<br>    generateClickResponderCode();<br> &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateBindViewCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (TypeElement typeElement : bindViewMap.keySet()) &#123;<br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> generateBindMethodBuilder(typeElement);<br><br>        List&lt;Element&gt; elements = bindViewMap.get(typeElement);<br>        <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>            processorBindView(element, methodBuilder);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateClickResponderCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (TypeElement typeElement : clickResponderMap.keySet()) &#123;<br>        MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> generateBindMethodBuilder(typeElement);<br><br>        List&lt;Element&gt; elements = clickResponderMap.get(typeElement);<br>        <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>            processorClickResponder(element, methodBuilder);<br><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<p>生成对应的辅助类，类名为使用该注解的类名+<code>$ViewInjector</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> TypeSpecWrapper <span class="hljs-title function_">generateTypeSpecWrapper</span><span class="hljs-params">(TypeElement typeElement)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">pkgName</span> <span class="hljs-operator">=</span> getPackageName(typeElement);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">clsName</span> <span class="hljs-operator">=</span> getClassName(typeElement, pkgName) + <span class="hljs-string">&quot;$ViewInjector&quot;</span>;<br>    TypeSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">typeSpecBuilder</span> <span class="hljs-operator">=</span> TypeSpec.classBuilder(clsName)<br>            .addModifiers(Modifier.PUBLIC);<br><br>    <span class="hljs-type">TypeSpecWrapper</span> <span class="hljs-variable">typeSpecWrapper</span> <span class="hljs-operator">=</span> typeSpecWrapperMap.get(typeElement);<br>    <span class="hljs-keyword">if</span> (typeSpecWrapper == <span class="hljs-literal">null</span>) &#123;<br>        typeSpecWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeSpecWrapper</span>(typeSpecBuilder, pkgName);<br>        typeSpecWrapperMap.put(typeElement, typeSpecWrapper);<br>    &#125;<br>    <span class="hljs-keyword">return</span> typeSpecWrapper;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>生成辅助类的<code>bind</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> MethodSpec.Builder <span class="hljs-title function_">generateBindMethodBuilder</span><span class="hljs-params">(TypeElement typeElement)</span> &#123;<br>    <span class="hljs-type">TypeSpecWrapper</span> <span class="hljs-variable">typeSpecWrapper</span> <span class="hljs-operator">=</span> generateTypeSpecWrapper(typeElement);<br>    MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">methodBuilder</span> <span class="hljs-operator">=</span> typeSpecWrapper.getMethodBuilder(<span class="hljs-string">&quot;bind&quot;</span>);<br>    <span class="hljs-keyword">if</span> (methodBuilder == <span class="hljs-literal">null</span>) &#123;<br>        methodBuilder = MethodSpec.methodBuilder(<span class="hljs-string">&quot;bind&quot;</span>)<br>                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)<br>                .addParameter(ClassName.get(typeElement.asType()), <span class="hljs-string">&quot;target&quot;</span>, Modifier.FINAL)<br>                .addParameter(ClassName.get(<span class="hljs-string">&quot;android.view&quot;</span>, <span class="hljs-string">&quot;View&quot;</span>), <span class="hljs-string">&quot;view&quot;</span>)<br>                .addStatement(<span class="hljs-string">&quot;int resourceID = 0&quot;</span>);<br>        typeSpecWrapper.putMethodBuilder(methodBuilder);<br>    &#125;<br>    <span class="hljs-keyword">return</span> methodBuilder;<br><br>&#125;<br></code></pre></td></tr></table></figure>





<p>对于<code>BindView</code>来讲，就是通过<code>findViewById</code>来获取到对应的控件，然后赋值给对应的字段。<br>这里我们为了能在lib中使用，对于没有传入id的属性，通过<code>getIdentifier</code>方法来获取到对应的资源id。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processorBindView</span><span class="hljs-params">(Element element, MethodSpec.Builder methodBuilder)</span> &#123;<br>    <span class="hljs-type">VariableElement</span> <span class="hljs-variable">variableElement</span> <span class="hljs-operator">=</span> (VariableElement) element;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">varName</span> <span class="hljs-operator">=</span> variableElement.getSimpleName().toString();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">varType</span> <span class="hljs-operator">=</span> variableElement.asType().toString();<br>    <span class="hljs-type">BindView</span> <span class="hljs-variable">bindView</span> <span class="hljs-operator">=</span> variableElement.getAnnotation(BindView.class);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> bindView.id();<br>    <span class="hljs-comment">//使用注解没有传入id的属性值，则使用isStr值来获取对应的资源id。</span><br>    <span class="hljs-comment">//严谨来讲，这里需要判断一下isStr是不是空串，如果是空串，则直接抛出异常，终止编译</span><br>    <span class="hljs-keyword">if</span> (params &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> bindView.idStr();<br>        methodBuilder.addStatement(<span class="hljs-string">&quot;resourceID = view.getResources().getIdentifier($S,$S, view.getContext().getPackageName())&quot;</span>, idStr, <span class="hljs-string">&quot;id&quot;</span>);<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        methodBuilder.addStatement(<span class="hljs-string">&quot;resourceID = ($L)&quot;</span>, params);<br>    &#125;<br>    methodBuilder.addStatement(<span class="hljs-string">&quot;target.$L = ($L) view.findViewById(resourceID)&quot;</span>, varName, varType);<br><br>&#125;<br></code></pre></td></tr></table></figure>


<p>对于<code>ClickResponder</code>来讲，就是通过<code>setOnClickListener</code>对对应的控件设置点击方法。由于可能存在多个控件使用同一个响应点击的方法，这里传入的都是资源数组<br>同样我们为了能在lib中使用，对于没有传入id的属性，通过<code>getIdentifier</code>方法来获取到对应的资源id。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processorClickResponder</span><span class="hljs-params">(Element element, MethodSpec.Builder methodBuilder)</span> &#123;<br>    <span class="hljs-type">ExecutableElement</span> <span class="hljs-variable">executableElement</span> <span class="hljs-operator">=</span> (ExecutableElement) element;<br>    <span class="hljs-type">ClickResponder</span> <span class="hljs-variable">clickView</span> <span class="hljs-operator">=</span> executableElement.getAnnotation(ClickResponder.class);<br>    <span class="hljs-type">int</span>[] ids = clickView.id();<br>    String[] idStrs = clickView.idStr();<br><br><br>    <span class="hljs-keyword">if</span> (ids.length &gt; <span class="hljs-number">0</span>) &#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id : ids) &#123;<br>            <span class="hljs-keyword">if</span> (id == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">innerMethodSpec</span> <span class="hljs-operator">=</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;onClick&quot;</span>)<br>                    .addAnnotation(Override.class)<br>                    .addModifiers(Modifier.PUBLIC)<br>                    .returns(<span class="hljs-keyword">void</span>.class)<br>                    .addParameter(ClassName.get(<span class="hljs-string">&quot;android.view&quot;</span>, <span class="hljs-string">&quot;View&quot;</span>), <span class="hljs-string">&quot;v&quot;</span>)<br>                    .addStatement(<span class="hljs-string">&quot;target.$L($L)&quot;</span>, executableElement.getSimpleName().toString(), <span class="hljs-string">&quot;v&quot;</span>)<br>                    .build();<br>            <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">innerTypeSpec</span> <span class="hljs-operator">=</span> TypeSpec.anonymousClassBuilder(<span class="hljs-string">&quot;&quot;</span>)<br>                    .addSuperinterface(ClassName.bestGuess(<span class="hljs-string">&quot;View.OnClickListener&quot;</span>))<br>                    .addMethod(innerMethodSpec)<br>                    .build();<br>            methodBuilder.addStatement(<span class="hljs-string">&quot;view.findViewById($L).setOnClickListener($L)&quot;</span>, id, innerTypeSpec);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (idStrs.length &gt; <span class="hljs-number">0</span>) &#123;<br><br>        <span class="hljs-keyword">for</span> (String idStr : idStrs) &#123;<br>            <span class="hljs-keyword">if</span> (idStr == <span class="hljs-literal">null</span> || idStr.length() &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">MethodSpec</span> <span class="hljs-variable">innerMethodSpec</span> <span class="hljs-operator">=</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;onClick&quot;</span>)<br>                    .addAnnotation(Override.class)<br>                    .addModifiers(Modifier.PUBLIC)<br>                    .returns(<span class="hljs-keyword">void</span>.class)<br>                    .addParameter(ClassName.get(<span class="hljs-string">&quot;android.view&quot;</span>, <span class="hljs-string">&quot;View&quot;</span>), <span class="hljs-string">&quot;v&quot;</span>)<br>                    .addStatement(<span class="hljs-string">&quot;target.$L($L)&quot;</span>, executableElement.getSimpleName().toString(), <span class="hljs-string">&quot;v&quot;</span>)<br>                    .build();<br>            <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">innerTypeSpec</span> <span class="hljs-operator">=</span> TypeSpec.anonymousClassBuilder(<span class="hljs-string">&quot;&quot;</span>)<br>                    .addSuperinterface(ClassName.bestGuess(<span class="hljs-string">&quot;View.OnClickListener&quot;</span>))<br>                    .addMethod(innerMethodSpec)<br>                    .build();<br><br>            methodBuilder.addStatement(<span class="hljs-string">&quot;resourceID = view.getResources().getIdentifier($S,$S, view.getContext().getPackageName())&quot;</span>, idStr, <span class="hljs-string">&quot;id&quot;</span>);<br><br>            methodBuilder.addStatement(<span class="hljs-string">&quot;view.findViewById($L).setOnClickListener($L)&quot;</span>, <span class="hljs-string">&quot;resourceID&quot;</span>, innerTypeSpec);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="给使用者提供调用方法"><a href="#给使用者提供调用方法" class="headerlink" title="给使用者提供调用方法"></a>给使用者提供调用方法</h4><p>在<code>api</code>模块中定义提供给使用者的方法。<br>新建一个<code>ViewInjector</code>类，调用者通过调用这个类中的方法，完成调用生成辅助类的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ViewInjector</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, Method&gt; BINDINGS = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(Activity activity)</span> &#123;<br>        bind(activity, activity.getWindow().getDecorView());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(Object target, View view)</span> &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> findBindMethodForClass(target);<br>        <span class="hljs-keyword">try</span> &#123;<br>            constructor.invoke(<span class="hljs-literal">null</span>,target, view);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title function_">findBindMethodForClass</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> BINDINGS.get(target.getClass());<br>        <span class="hljs-keyword">if</span> (constructor == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Class&lt;?&gt; bindingClass = Class.forName(target.getClass().getName() + <span class="hljs-string">&quot;$ViewInjector&quot;</span>);<br>                constructor = bindingClass.getMethod(<span class="hljs-string">&quot;bind&quot;</span>,target.getClass(), View.class);<br>                BINDINGS.put(target.getClass(), constructor);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> constructor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在我们项目的主模块(application模块)中新建一个Activity，就可以愉快的使用了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestViewInjectActivityTwo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-meta">@BindView(id = R.id.test_view_inject_one)</span><br>    <span class="hljs-keyword">protected</span> Button buttonOne;<br>    <span class="hljs-meta">@BindView(idStr = &quot;test_view_inject_two&quot;)</span><br>    <span class="hljs-keyword">protected</span> Button buttonTwo;<br>    。<br>    。<br>    。<br>    <span class="hljs-meta">@ClickResponder(id = &#123;R.id.test_view_inject_one&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClickButtonOne</span><span class="hljs-params">(View v)</span> &#123;<br>        Toast.makeText(TestViewInjectActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;test_view_inject_one&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br><br>    <span class="hljs-meta">@ClickResponder(idStr = &#123;&quot;test_view_inject_two&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClickButtonTwo</span><span class="hljs-params">(View v)</span> &#123;<br>        Toast.makeText(TestViewInjectActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;test_view_inject_two&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>执行一下<code>assembleDebug</code>任务，就可以找到<code>TestViewInjectActivityTwo$ViewInjector</code>类了(一般是在对用模块中的<code>build/generated/source/apt/debug</code>)文件夹下，当然，<code>assembleRelease</code>会在<code>build/generated/source/apt/release</code>文件夹下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestViewInjectActivity$ViewInjector</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> TestViewInjectActivity target, View view)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">resourceID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    resourceID = (<span class="hljs-number">2131165388</span>);<br>    target.buttonOne = (android.widget.Button) view.findViewById(resourceID);<br>    resourceID = view.getResources().getIdentifier(<span class="hljs-string">&quot;test_view_inject_two&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>, view.getContext().getPackageName());<br>    target.buttonTwo = (android.widget.Button) view.findViewById(resourceID);<br><br>    view.findViewById(<span class="hljs-number">2131165388</span>).setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        target.onClickButtonOne(v);<br>      &#125;<br>    &#125;);<br>    resourceID = view.getResources().getIdentifier(<span class="hljs-string">&quot;test_view_inject_two&quot;</span>,<span class="hljs-string">&quot;id&quot;</span>, view.getContext().getPackageName());<br>    view.findViewById(resourceID).setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        target.onClickButtonTwo(v);<br>      &#125;<br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>其实生成的代码还是有优化空间的，比如对于一个既用了BindView又用了ClickResponder的控件，对应的findViewById会执行两次，这里可以优化一下.</p>
<p>可以自己写一下<code>LongClickResponder</code>注解呀，代码在<a href="https://github.com/huangyuanlove/AndroidAnnotation">https://github.com/huangyuanlove/AndroidAnnotation</a></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解，打造自己的框架-最终篇</title>
    <url>/2019/12/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A1%86%E6%9E%B6-%E6%9C%80%E7%BB%88%E7%AF%87/</url>
    <content><![CDATA[<p>该系列介绍自定义注解，完成如下功能。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> @BindView 代替  findViewById </li>
<li><input checked="" disabled="" type="checkbox"> @ClickResponder 代替 setOnClickListener</li>
<li><input checked="" disabled="" type="checkbox"> @LongClickResponder 代替 setOnLongClickListener</li>
<li><input checked="" disabled="" type="checkbox"> @IntentValue 代替 getIntent().getXXX</li>
<li><input checked="" disabled="" type="checkbox"> @UriValue 代替 getQueryParameter</li>
<li><input checked="" disabled="" type="checkbox"> @BroadcastResponder 代替 registerReceiver</li>
<li><input checked="" disabled="" type="checkbox"> @RouterModule、@RouterPath 来进行反依赖传递调用<br>该系列源码在<a href="https://github.com/huangyuanlove/AndroidAnnotation">https://github.com/huangyuanlove/AndroidAnnotation</a><br>前几篇介绍了<code>@BindView</code>、<code>@ClickResponder</code>、<code>@LongClickResponder</code>、<code>@IntentValue</code>、<code>@UriValue</code>的实现，这一篇介绍一下<code>@RouterModule</code> 和<code>@RouterPath</code>的实现。<span id="more"></span></li>
</ul>
<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>在某些情况下，我们不得不为了某些情形而在代码层面妥协，写出了一坨又一坨的反人类代码。比如接手了一个古老的工程，A模块依赖B模块，但是现在的需求需要在B里面打开A页面，或者调用A的方法来做复杂的计算等等，于是就催生了这个注解。。。</p>
<h4 id="声明注解"><a href="#声明注解" class="headerlink" title="声明注解"></a>声明注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RouterModule &#123;<br>    String <span class="hljs-title function_">host</span><span class="hljs-params">()</span>;<br><br>    String <span class="hljs-title function_">schema</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;App&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.CLASS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RouterPath &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="处理注解逻辑"><a href="#处理注解逻辑" class="headerlink" title="处理注解逻辑"></a>处理注解逻辑</h4><p>这里我们新建一个处理器，专门用来处理这种逻辑，也重新生成另外一个辅助类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouterProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractProcessor</span> &#123;<br>    <span class="hljs-keyword">private</span> Elements elementUtils;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Element, TypeSpecWrapper&gt; typeSpecWrapperMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title function_">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> &#123;<br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>        set.add(RouterModule.class.getCanonicalName());<br>        set.add(RouterPath.class.getCanonicalName());<br><br>        <span class="hljs-keyword">return</span> set;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title function_">getSupportedSourceVersion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SourceVersion.RELEASE_7;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ProcessingEnvironment processingEnv)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnv);<br>        elementUtils = processingEnv.getElementUtils();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;<br><br>        typeSpecWrapperMap.clear();<br><br>        Set&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; routerModuleSet = roundEnv.getElementsAnnotatedWith(RouterModule.class);<br><br>        <span class="hljs-keyword">for</span> (Element element : routerModuleSet) &#123;<br>            <span class="hljs-type">RouterModule</span> <span class="hljs-variable">routerModule</span> <span class="hljs-operator">=</span> element.getAnnotation(RouterModule.class);<br>            <span class="hljs-type">TypeSpecWrapper</span> <span class="hljs-variable">typeSpecWrapper</span> <span class="hljs-operator">=</span> typeSpecWrapperMap.get(element);<br>            <span class="hljs-keyword">if</span> (typeSpecWrapper == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">packageName</span> <span class="hljs-operator">=</span> elementUtils.getPackageOf(element).getQualifiedName().toString();<br>                <span class="hljs-type">ClassName</span> <span class="hljs-variable">hashMapClassName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;java.util.HashMap&quot;</span>);<br>                <span class="hljs-type">ClassName</span> <span class="hljs-variable">methodClassName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;java.lang.reflect.Method&quot;</span>);<br>                <span class="hljs-type">ClassName</span> <span class="hljs-variable">stringClassName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>                <span class="hljs-type">ParameterizedTypeName</span> <span class="hljs-variable">routerMapClassName</span> <span class="hljs-operator">=</span> ParameterizedTypeName.get(hashMapClassName, stringClassName, methodClassName);<br><br>                <span class="hljs-type">ClassName</span> <span class="hljs-variable">targetClassName</span> <span class="hljs-operator">=</span> ClassName.get(packageName, element.getSimpleName().toString());<br><br>                TypeSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">typeSpecBuilder</span> <span class="hljs-operator">=</span> TypeSpec.classBuilder(routerModule.schema() + routerModule.host() + <span class="hljs-string">&quot;$$Router&quot;</span>)<br>                        .addField(routerMapClassName, <span class="hljs-string">&quot;routerMap&quot;</span>, Modifier.PRIVATE)<br>                        .addField(targetClassName, <span class="hljs-string">&quot;target&quot;</span>);<br>                typeSpecWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeSpecWrapper</span>(typeSpecBuilder, <span class="hljs-string">&quot;com.huangyuanlove.router&quot;</span>);<br>                typeSpecWrapperMap.put(element, typeSpecWrapper);<br><br><br>                MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">constructorBuilder</span> <span class="hljs-operator">=</span> typeSpecWrapper.getMethodBuilder(MethodSpec.constructorBuilder().toString());<br>                <span class="hljs-keyword">if</span> (constructorBuilder == <span class="hljs-literal">null</span>) &#123;<br>                    constructorBuilder = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC).addException(Exception.class);<br>                &#125;<br>                constructorBuilder.addStatement(<span class="hljs-string">&quot;this.target =  new $T()&quot;</span>, targetClassName)<br>                        .addStatement(<span class="hljs-string">&quot;this.routerMap = new $T()&quot;</span>, routerMapClassName);<br><br><br>                List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Element</span>&gt; lists = element.getEnclosedElements();<br>                <span class="hljs-keyword">for</span> (Element element1 : lists) &#123;<br>                    <span class="hljs-type">ExecutableElement</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> (ExecutableElement) element1;<br><br>                    <span class="hljs-type">RouterPath</span> <span class="hljs-variable">routerPath</span> <span class="hljs-operator">=</span> temp.getAnnotation(RouterPath.class);<br>                    <span class="hljs-keyword">if</span> (routerPath != <span class="hljs-literal">null</span>) &#123;<br>                        constructorBuilder.addStatement(<span class="hljs-string">&quot;this.routerMap.put($S,target.getClass().getMethod($S,$L))&quot;</span>, routerPath.value(), element1.getSimpleName().toString(), paramsClassString(temp));<br>                    &#125;<br><br>                &#125;<br><br>                typeSpecWrapper.putMethodBuilder(constructorBuilder);<br><br>                <span class="hljs-type">ClassName</span> <span class="hljs-variable">paramWrapperName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;com.huangyuanlove.view_inject_api.router.RouterParamWrapper&quot;</span>);<br>                <span class="hljs-type">ClassName</span> <span class="hljs-variable">routerDelegateName</span> <span class="hljs-operator">=</span> ClassName.bestGuess(<span class="hljs-string">&quot;com.huangyuanlove.view_inject_api.router.RouterDelegate&quot;</span>);<br><br>                MethodSpec.<span class="hljs-type">Builder</span> <span class="hljs-variable">invokeBuilder</span> <span class="hljs-operator">=</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;invoke&quot;</span>)<br>                        .addModifiers(Modifier.PUBLIC)<br>                        .addException(Exception.class)<br>                        .addParameter(String.class, <span class="hljs-string">&quot;path&quot;</span>)<br>                        .addParameter(paramWrapperName, <span class="hljs-string">&quot;paramWrapper&quot;</span>)<br>                        .addStatement(<span class="hljs-string">&quot;$T method = this.routerMap.get($L)&quot;</span>, methodClassName, <span class="hljs-string">&quot;path&quot;</span>)<br>                        .beginControlFlow(<span class="hljs-string">&quot;if(method == null)&quot;</span>)<br>                        .addStatement(<span class="hljs-string">&quot; throw new Exception(\&quot;can not find method which map \&quot; +path)&quot;</span>)<br>                        .endControlFlow()<br>                        .addStatement(<span class="hljs-string">&quot;return $T.invoke(method,target,paramWrapper)&quot;</span>, routerDelegateName)<br>                        .returns(Object.class);<br><br>                typeSpecWrapper.putMethodBuilder(invokeBuilder);<br><br>            &#125;<br><br>        &#125;<br><br><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Element, TypeSpecWrapper&gt; entry : typeSpecWrapperMap.entrySet()) &#123;<br><br>            entry.getValue().writeTo(processingEnv.getFiler());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">paramsClassString</span><span class="hljs-params">(ExecutableElement temp)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">VariableElement</span>&gt; parameters = temp.getParameters();<br><br>        <span class="hljs-keyword">if</span> (parameters == <span class="hljs-literal">null</span> || parameters.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        String[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[parameters.size()];<br><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; parameters.size(); i++) &#123;<br>            result[i] = parameters.get(i).asType().toString() + <span class="hljs-string">&quot;.class&quot;</span>;<br>            sb.append(parameters.get(i).asType().toString() + <span class="hljs-string">&quot;.class&quot;</span>);<br>            sb.append(<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>).toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要就是收集注解信息，生成注解类，在调用对应注解路径时，调用<code>api</code>模块中对应的代理类<code>RouterDelegate</code>，最终由使用者调用<code>Router</code>中的<code>RouterBuilder</code>来调用对应路径注解的方法。</p>
<h4 id="给使用者提供调用方法"><a href="#给使用者提供调用方法" class="headerlink" title="给使用者提供调用方法"></a>给使用者提供调用方法</h4><p>在<code>api</code>模块中，新建<code>RouterParamWrapper</code>作为我们注解参数的包装类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouterParamWrapper</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object []paramArray;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RouterParamWrapper</span><span class="hljs-params">(Object [] paramArray)</span> &#123;<br>        <span class="hljs-built_in">this</span>.paramArray = paramArray;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object[] getParamArray() &#123;<br>        <span class="hljs-keyword">return</span> paramArray;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>api</code>模块中，新建<code>RouterDelegate</code>作为我们注解的代理类，实际上也就是一个中间层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouterDelegate</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Method method, Object target, RouterParamWrapper paramWrapper)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>       <span class="hljs-keyword">return</span>  method.invoke(target,paramWrapper.getParamArray());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后提供给调用者一个调用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> &#123;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">interface</span>  <span class="hljs-title class_">InvokeResultListener</span>&lt;T&gt;&#123;<br>        <span class="hljs-keyword">void</span>  <span class="hljs-title function_">onError</span><span class="hljs-params">(Exception e)</span>;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">( T result)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PACKAGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.huangyuanlove.router&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RouterBuilder <span class="hljs-title function_">to</span><span class="hljs-params">(String path)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RouterBuilder</span>(path);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouterBuilder</span>&#123;<br>        <span class="hljs-keyword">private</span> String path;<br>        <span class="hljs-keyword">private</span> Object[] paramArray;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">RouterBuilder</span><span class="hljs-params">(String path)</span> &#123;<br>            <span class="hljs-built_in">this</span>.path = path;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> RouterBuilder <span class="hljs-title function_">addParam</span><span class="hljs-params">(Object ... paramArray)</span>&#123;<br>            <span class="hljs-built_in">this</span>. paramArray = paramArray;<br>            <span class="hljs-keyword">return</span>  <span class="hljs-built_in">this</span>;<br><br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">done</span><span class="hljs-params">()</span>&#123;<br>            done(<span class="hljs-literal">null</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">done</span><span class="hljs-params">(InvokeResultListener listener)</span>&#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span>  <span class="hljs-operator">=</span> Uri.parse(path);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">schema</span> <span class="hljs-operator">=</span> uri.getScheme();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> uri.getHost();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> uri.getPath();<br><br>                <span class="hljs-type">Class</span> <span class="hljs-variable">routerInject</span> <span class="hljs-operator">=</span> Class.forName(PACKAGE_NAME +<span class="hljs-string">&quot;.&quot;</span> + schema + host +<span class="hljs-string">&quot;$$Router&quot;</span>);<br>                <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span>  routerInject.getConstructor();<br>                constructor.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-type">RouterParamWrapper</span> <span class="hljs-variable">paramWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RouterParamWrapper</span>(paramArray);<br><br>                <span class="hljs-type">Method</span> <span class="hljs-variable">invokeMethod</span> <span class="hljs-operator">=</span> routerInject.getMethod(<span class="hljs-string">&quot;invoke&quot;</span>,String.class,RouterParamWrapper.class);<br>                invokeMethod.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invokeMethod.invoke(constructor.newInstance(),path,paramWrapper);<br>                <span class="hljs-keyword">if</span>(listener!=<span class="hljs-literal">null</span>)&#123;<br>                    listener.onSuccess(result);<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br><br>                <span class="hljs-keyword">if</span>(listener!=<span class="hljs-literal">null</span>)&#123;<br>                    listener.onError(e);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样使用者调用<code>Router.to(String path).addParam(Object ... param).done</code>就可以调用了。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>我们可以在一个模块中提供一个功能类，用来暴露出提供给其他模块使用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RouterModule(schema = &quot;App&quot;,host = &quot;main&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainProvider</span> &#123;<br><br>    <span class="hljs-meta">@RouterPath(value = &quot;/toMain&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startMain</span><span class="hljs-params">(Activity context, <span class="hljs-type">int</span> id)</span>&#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(context, MainActivity.class);<br>        intent.putExtra(<span class="hljs-string">&quot;id&quot;</span>,id);<br>        context.startActivity(intent);<br>    &#125;<br><br>    <span class="hljs-meta">@RouterPath(value = &quot;/toMainWithResult&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startMain</span><span class="hljs-params">(Activity context, String title,<span class="hljs-type">int</span> requestCode)</span>&#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(context, MainActivity.class);<br>        intent.putExtra(<span class="hljs-string">&quot;title&quot;</span>,title);<br>        context.startActivity(intent);<br>    &#125;<br><br>    <span class="hljs-meta">@RouterPath(value = &quot;/getInt&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIntValue</span><span class="hljs-params">(String s)</span>&#123;<br>        <span class="hljs-keyword">return</span> s.length();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们就可以在其他模块中使用<code>Router</code>进行任意调用了，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ClickResponder(idStr = &quot;toAppMainActivity&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">toAppMainActivity</span><span class="hljs-params">(View v)</span>&#123;<br><br>    Router.to(<span class="hljs-string">&quot;App://main/toMain&quot;</span>).addParam(<span class="hljs-built_in">this</span>,<span class="hljs-number">123</span>).done(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>.InvokeResultListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Exception e)</span> &#123;<br>            Toast.makeText(EXT_MainActivity.<span class="hljs-built_in">this</span>,e.toString(),Toast.LENGTH_SHORT).show();<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(Object o)</span> &#123;<br><br>        &#125;<br>    &#125;);<br><br>&#125;<br><br><span class="hljs-meta">@ClickResponder(idStr = &quot;invoke_main_method&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeMainMethod</span><span class="hljs-params">(View v)</span>&#123;<br><br>    Router.to(<span class="hljs-string">&quot;App://main/getInt&quot;</span>).addParam(<span class="hljs-string">&quot;12345678&quot;</span>).done(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>.InvokeResultListener&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Exception e)</span> &#123;<br>            Toast.makeText(EXT_MainActivity.<span class="hljs-built_in">this</span>,e.toString(),Toast.LENGTH_SHORT).show();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(Integer result)</span> &#123;<br>            Toast.makeText(EXT_MainActivity.<span class="hljs-built_in">this</span>,result+<span class="hljs-string">&quot;&quot;</span>,Toast.LENGTH_SHORT).show();<br><br>        &#125;<br>    &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实我也不想搞出来这种东西，但毕竟是时间紧、任务重，先这么用着吧。</p>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>终于把注解这一块写完了，也算是对自己写注解的一个总结吧。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解，打造自己的框架 (中篇)</title>
    <url>/2019/12/01/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%EF%BC%8C%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%A1%86%E6%9E%B6-%E4%B8%AD%E7%AF%87/</url>
    <content><![CDATA[<p>该系列介绍自定义注解，完成如下功能。</p>
<ul>
<li><input disabled="" type="checkbox"> @BindView 代替  findViewById </li>
<li><input disabled="" type="checkbox"> @ClickResponder 代替 setOnClickListener</li>
<li><input disabled="" type="checkbox"> @LongClickResponder 代替 setOnLongClickListener</li>
<li><input disabled="" type="checkbox"> @IntentValue 代替 getIntent().getXXX</li>
<li><input disabled="" type="checkbox"> @UriValue 代替 getQueryParameter</li>
<li><input disabled="" type="checkbox"> @BroadcastResponder 代替 registerReceiver</li>
<li><input disabled="" type="checkbox"> @RouterModule、@RouterPath 来进行反依赖传递调用<br>该系列源码在<a href="https://github.com/huangyuanlove/AndroidAnnotation">https://github.com/huangyuanlove/AndroidAnnotation</a><br>使用编译时注解，生成辅助类来完成这些操作，尽量少的使用的反射功能。</li>
</ul>
<p><strong>本章先介绍   <a href="https://github.com/square/javapoet">javapoet </a> 和一丢丢反射相关的东西</strong></p>
<span id="more"></span>

<h4 id="javapoet"><a href="#javapoet" class="headerlink" title="javapoet"></a>javapoet</h4><p>用来辅助生成java代码的库，<a href="https://github.com/square/javapoet">可以看这里</a>，有特别详细的示例。大致过了一遍，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestJavaPoet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TypeSpec</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> clazz(builtinTypeField(),          <span class="hljs-comment">// int</span><br>                arrayTypeField(),            <span class="hljs-comment">// int[]</span><br>                refTypeField(),              <span class="hljs-comment">// File</span><br>                typeField(),                 <span class="hljs-comment">// T</span><br>                parameterizedTypeField(),    <span class="hljs-comment">// List&lt;String&gt;</span><br>                wildcardTypeField(),         <span class="hljs-comment">// List&lt;? extends String&gt;</span><br>                constructor(),               <span class="hljs-comment">// 构造函数</span><br>                method(code()));             <span class="hljs-comment">// 普通方法</span><br>        <span class="hljs-type">JavaFile</span> <span class="hljs-variable">javaFile</span> <span class="hljs-operator">=</span> JavaFile.builder(<span class="hljs-string">&quot;com.huangyuanlove.view_inject_compiler.test&quot;</span>, clazz).build();<br><br>        System.out.println(javaFile.toString());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * `public abstract class Clazz&lt;T&gt; extends String implements Serializable, Comparable&lt;String&gt;, Comparable&lt;? extends String&gt; &#123;</span><br><span class="hljs-comment">     * ...</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TypeSpec <span class="hljs-title function_">clazz</span><span class="hljs-params">(FieldSpec builtinTypeField, FieldSpec arrayTypeField, FieldSpec refTypeField,</span><br><span class="hljs-params">                                 FieldSpec typeField, FieldSpec parameterizedTypeField, FieldSpec wildcardTypeField,</span><br><span class="hljs-params">                                 MethodSpec constructor, MethodSpec methodSpec)</span> &#123;<br>        <span class="hljs-keyword">return</span> TypeSpec.classBuilder(<span class="hljs-string">&quot;Clazz&quot;</span>)<br>                <span class="hljs-comment">// 限定符</span><br>                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)<br>                <span class="hljs-comment">// 泛型</span><br>                .addTypeVariable(TypeVariableName.get(<span class="hljs-string">&quot;T&quot;</span>))<br><br>                <span class="hljs-comment">// 继承与接口</span><br>                .superclass(String.class)<br>                .addSuperinterface(Serializable.class)<br>                .addSuperinterface(ParameterizedTypeName.get(Comparable.class, String.class))<br>                .addSuperinterface(ParameterizedTypeName.get(ClassName.get(Map.class),<br>                        TypeVariableName.get(<span class="hljs-string">&quot;T&quot;</span>),<br>                        WildcardTypeName.subtypeOf(String.class)))<br><br>                <span class="hljs-comment">// 初始化块</span><br>                .addStaticBlock(CodeBlock.builder().build())<br>                .addInitializerBlock(CodeBlock.builder().build())<br><br>                <span class="hljs-comment">// 属性</span><br>                .addField(builtinTypeField)<br>                .addField(arrayTypeField)<br>                .addField(refTypeField)<br>                .addField(typeField)<br>                .addField(parameterizedTypeField)<br>                .addField(wildcardTypeField)<br><br>                <span class="hljs-comment">// 方法 （构造函数也在此定义）</span><br>                .addMethod(constructor)<br>                .addMethod(methodSpec)<br><br>                <span class="hljs-comment">// 内部类</span><br>                .addType(TypeSpec.classBuilder(<span class="hljs-string">&quot;InnerClass&quot;</span>).build())<br><br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 内置类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FieldSpec <span class="hljs-title function_">builtinTypeField</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// private int mInt;</span><br>        <span class="hljs-keyword">return</span> FieldSpec.builder(<span class="hljs-type">int</span>.class, <span class="hljs-string">&quot;mInt&quot;</span>, Modifier.PRIVATE).build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数组类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FieldSpec <span class="hljs-title function_">arrayTypeField</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// private int[] mArr;</span><br>        <span class="hljs-keyword">return</span> FieldSpec.builder(<span class="hljs-type">int</span>[].class, <span class="hljs-string">&quot;mArr&quot;</span>, Modifier.PRIVATE).build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 需要导入 import 的类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FieldSpec <span class="hljs-title function_">refTypeField</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// private File mRef;</span><br>        <span class="hljs-keyword">return</span> FieldSpec.builder(File.class, <span class="hljs-string">&quot;mRef&quot;</span>, Modifier.PRIVATE).build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 泛型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FieldSpec <span class="hljs-title function_">typeField</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// private File mT;</span><br>        <span class="hljs-keyword">return</span> FieldSpec.builder(TypeVariableName.get(<span class="hljs-string">&quot;T&quot;</span>), <span class="hljs-string">&quot;mT&quot;</span>, Modifier.PRIVATE).build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 参数化类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FieldSpec <span class="hljs-title function_">parameterizedTypeField</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// private List&lt;String&gt; mParameterizedField;</span><br>        <span class="hljs-keyword">return</span> FieldSpec.builder(ParameterizedTypeName.get(List.class, String.class),<br>                <span class="hljs-string">&quot;mParameterizedField&quot;</span>,<br>                Modifier.PRIVATE)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通配符参数化类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FieldSpec <span class="hljs-title function_">wildcardTypeField</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// private List&lt;? extends String&gt; mWildcardField;</span><br>        <span class="hljs-keyword">return</span> FieldSpec.builder(ParameterizedTypeName.get(ClassName.get(List.class),<br>                WildcardTypeName.subtypeOf(String.class)),<br>                <span class="hljs-string">&quot;mWildcardField&quot;</span>,<br>                Modifier.PRIVATE)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MethodSpec <span class="hljs-title function_">constructor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MethodSpec.constructorBuilder()<br>                .addModifiers(Modifier.PUBLIC)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * `<span class="hljs-doctag">@Override</span></span><br><span class="hljs-comment">     * public &lt;T&gt; Integer method(String string, T t, Map&lt;Integer, ? extends T&gt; map) throws IOException, RuntimeException &#123;</span><br><span class="hljs-comment">     * ...</span><br><span class="hljs-comment">     * &#125;`</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MethodSpec <span class="hljs-title function_">method</span><span class="hljs-params">(CodeBlock codeBlock)</span> &#123;<br>        <span class="hljs-keyword">return</span> MethodSpec.methodBuilder(<span class="hljs-string">&quot;method&quot;</span>)<br>                .addAnnotation(Override.class)<br>                .addTypeVariable(TypeVariableName.get(<span class="hljs-string">&quot;T&quot;</span>))<br>                .addModifiers(Modifier.PUBLIC)<br>                .returns(<span class="hljs-type">int</span>.class)<br>                .addParameter(String.class, <span class="hljs-string">&quot;string&quot;</span>)<br>                .addParameter(TypeVariableName.get(<span class="hljs-string">&quot;T&quot;</span>), <span class="hljs-string">&quot;t&quot;</span>)<br>                .addParameter(ParameterizedTypeName.get(ClassName.get(Map.class),<br>                        ClassName.get(Integer.class),<br>                        WildcardTypeName.subtypeOf(TypeVariableName.get(<span class="hljs-string">&quot;T&quot;</span>))),<br>                        <span class="hljs-string">&quot;map&quot;</span>)<br>                .addException(IOException.class)<br>                .addException(RuntimeException.class)<br>                .addCode(codeBlock)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ‘method’ 方法中的具体语句</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CodeBlock <span class="hljs-title function_">code</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> CodeBlock.builder()<br>                .addStatement(<span class="hljs-string">&quot;int foo = 1&quot;</span>)<br>                .addStatement(<span class="hljs-string">&quot;$T bar = $S&quot;</span>, String.class, <span class="hljs-string">&quot;a string&quot;</span>)<br><br>                <span class="hljs-comment">// Object obj = new HashMap&lt;Integer, ? extends T&gt;(5);</span><br>                .addStatement(<span class="hljs-string">&quot;$T obj = new $T(5)&quot;</span>,<br>                        Object.class, ParameterizedTypeName.get(ClassName.get(HashMap.class),<br>                                ClassName.get(Integer.class),<br>                                WildcardTypeName.subtypeOf(TypeVariableName.get(<span class="hljs-string">&quot;T&quot;</span>))))<br><br>                <span class="hljs-comment">// method(new Runnable(String param) &#123;</span><br>                <span class="hljs-comment">//   @Override</span><br>                <span class="hljs-comment">//   void run() &#123;</span><br>                <span class="hljs-comment">//   &#125;</span><br>                <span class="hljs-comment">// &#125;);</span><br>                .addStatement(<span class="hljs-string">&quot;baz($L)&quot;</span>, TypeSpec.anonymousClassBuilder(<span class="hljs-string">&quot;$T param&quot;</span>, String.class)<br>                        .superclass(Runnable.class)<br>                        .addMethod(MethodSpec.methodBuilder(<span class="hljs-string">&quot;run&quot;</span>)<br>                                .addAnnotation(Override.class)<br>                                .returns(TypeName.VOID)<br>                                .build())<br>                        .build())<br><br>                <span class="hljs-comment">// for</span><br>                .beginControlFlow(<span class="hljs-string">&quot;for (int i = 0; i &lt; 5; i++)&quot;</span>)<br>                .endControlFlow()<br><br>                <span class="hljs-comment">// while</span><br>                .beginControlFlow(<span class="hljs-string">&quot;while (false)&quot;</span>)<br>                .endControlFlow()<br><br>                <span class="hljs-comment">// do... while</span><br>                .beginControlFlow(<span class="hljs-string">&quot;do&quot;</span>)<br>                .endControlFlow(<span class="hljs-string">&quot;while (false)&quot;</span>)<br><br>                <span class="hljs-comment">// if... else if... else...</span><br>                .beginControlFlow(<span class="hljs-string">&quot;if (false)&quot;</span>)<br>                .nextControlFlow(<span class="hljs-string">&quot;else if (false)&quot;</span>)<br>                .nextControlFlow(<span class="hljs-string">&quot;else&quot;</span>)<br>                .endControlFlow()<br><br>                <span class="hljs-comment">// try... catch... finally</span><br>                .beginControlFlow(<span class="hljs-string">&quot;try&quot;</span>)<br>                .nextControlFlow(<span class="hljs-string">&quot;catch ($T e)&quot;</span>, Exception.class)<br>                .addStatement(<span class="hljs-string">&quot;e.printStackTrace()&quot;</span>)<br>                .nextControlFlow(<span class="hljs-string">&quot;finally&quot;</span>)<br>                .endControlFlow()<br><br>                .addStatement(<span class="hljs-string">&quot;return 0&quot;</span>)<br>                .build();<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>这样就省去了我们自己手动评价代码块的麻烦，提高效率，并且也比较容易查错。</p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>这玩意说起来可就长了，这里只做示例</p>
<p>一个Person类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huangyuanlove;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;getAddress without param&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getAddress</span><span class="hljs-params">(String zipCode)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;getAddress with param:&quot;</span> + zipCode;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>玩一下反射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huangyuanlove;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//如果没有对应类的依赖的话(不能直接import),可以用Class.forName</span><br>            <span class="hljs-comment">//Class personClass = Class.forName(&quot;com.huangyuanlove.Person&quot;);</span><br>            Class&lt;Person&gt; personClass = Person.class;<br><br>            <span class="hljs-comment">//调用私有无参构造方法创建对象</span><br>            Constructor&lt;Person&gt; personConstructor = personClass.getDeclaredConstructor();<br>            personConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> personConstructor.newInstance();<br>            <span class="hljs-comment">//反射获取公共方法并调用</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">getAddressWithoutParamMethod</span> <span class="hljs-operator">=</span> personClass.getMethod(<span class="hljs-string">&quot;getAddress&quot;</span>);<br>            System.out.println( getAddressWithoutParamMethod.invoke(person));<br><br>            <span class="hljs-comment">//反射获取私有方法并调用</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">getAddressMethod</span> <span class="hljs-operator">=</span> personClass.getDeclaredMethod(<span class="hljs-string">&quot;getAddress&quot;</span>, String.class);<br>            getAddressMethod.setAccessible(<span class="hljs-literal">true</span>);<br>            System.out.println(getAddressMethod.invoke(person, <span class="hljs-string">&quot;zipCode&quot;</span>));<br><br>            <span class="hljs-comment">//反射获取私有字段并赋值</span><br>            <span class="hljs-type">Field</span> <span class="hljs-variable">ageField</span> <span class="hljs-operator">=</span>  personClass.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);<br>            ageField.setAccessible(<span class="hljs-literal">true</span>);<br>            ageField.set(person,<span class="hljs-number">11</span>);<br>            System.out.println(person.getAge());<br><br>            <span class="hljs-comment">//反射获取私有静态方法并调用</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">sayHiMethod</span> <span class="hljs-operator">=</span> personClass.getDeclaredMethod(<span class="hljs-string">&quot;saySomething&quot;</span>,String.class);<br>            sayHiMethod.setAccessible(<span class="hljs-literal">true</span>);<br>            sayHiMethod.invoke(<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;reflect&quot;</span>);<br><br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>适配Android高版本系统常见问题</title>
    <url>/2019/04/17/%E9%80%82%E9%85%8DAndroid%E9%AB%98%E7%89%88%E6%9C%AC%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Android P,Q 版本适配常见问题</p>
<p>项目地址 <a href="https://github.com/huangyuanlove/AdaptationAndroidP">https://github.com/huangyuanlove/AdaptationAndroidP</a></p>
<ol>
<li>文件操作</li>
<li>拍照选择图片</li>
<li>存储访问框架(SAF)</li>
<li>通知</li>
<li>权限申请</li>
<li>快捷方式</li>
</ol>
<span id="more"></span>

<p>Android P,Q 版本适配常见问题</p>
<p>项目地址 <a href="https://github.com/huangyuanlove/AdaptationAndroidP">https://github.com/huangyuanlove/AdaptationAndroidP</a></p>
<h4 id="文件操作-FileOperationActivity"><a href="#文件操作-FileOperationActivity" class="headerlink" title="文件操作(FileOperationActivity)"></a>文件操作(FileOperationActivity)</h4><p>先看几个常用的文件路径，这里说明一下，应用的id是<code>com.huangyuanlove.adaptationhighversion</code></p>
<ul>
<li><p><strong>getFilesDir()</strong></p>
<p>得到的路径是 <code>/data/user/0/com.huangyuanlove.adaptationhighversion/files</code>,读写该文件夹下的文件<strong>不需要</strong>申请文件读写权限。卸载应用时<strong>会被删除</strong>。对用户<strong>不可见</strong>，我们在AndroidStudio中使用<code>Device File Explorer</code>查看是在<code>/data/data/com.huangyuanlove.adaptationhighversion/files</code></p>
</li>
<li><p><strong>getCacheDir()</strong><br>得到的路径是<code>/data/user/0/com.huangyuanlove.adaptationhighversion/cache</code>，读写该文件夹下的文件<strong>不需要</strong>申请文件读写权限。卸载应用时<strong>会被删除</strong>。对用户<strong>不可见</strong>，我们在AndroidStudio中使用<code>Device File Explorer</code>查看是在<code>/data/data/com.huangyuanlove.adaptationhighversion/cache</code></p>
</li>
<li><p>getExternalCacheDir()</p>
<p>得到的路径是<code>/storage/emulated/0/Android/data/com.huangyuanlove.adaptationhighversion/cache</code></p>
<p>读写该文件夹下的文件<strong>不需要</strong>申请文件读写权限。卸载应用时<strong>会被删除</strong>。对用户<strong>可见</strong>，无法使用<code>Device File Explorer</code>查看，因为<code>/storage/emulated</code>下的文件没有操作权限，可以用过<code>adb shell</code>切换进去查看，路径为<code>/storage/emulated/0/Android/data/com.huangyuanlove.adaptationhighversion/cache</code>。用户使用手机的文件管理器查看时路径为<code>/Android/data/com.huangyuanlove.adaptationhighversion/cache</code></p>
</li>
<li><p>getExternalFilesDir(null)</p>
<p>得到的路径是<code>/storage/emulated/0/Android/data/com.huangyuanlove.adaptationhighversion/files</code>,</p>
<p>读写该文件夹下的文件<strong>不需要</strong>申请文件读写权限。卸载应用时<strong>会被删除</strong>。对用户<strong>可见</strong>，无法使用<code>Device File Explorer</code>查看，因为<code>/storage/emulated</code>下的文件没有操作权限，可以用过<code>adb shell</code>切换进去查看，路径为<code>/storage/emulated/0/Android/data/com.huangyuanlove.adaptationhighversion/file</code>。用户使用手机的文件管理器查看时路径为<code>/Android/data/com.huangyuanlove.adaptationhighversion/file</code></p>
</li>
<li><p>Environment.getExternalStorageDirectory();</p>
<p>得到的路径是<code>/storage/emulated/0</code></p>
<p>读写该文件夹下的文件<strong>需要</strong>申请文件读写权限。卸载应用时不会被删除。对用户<strong>可见</strong>，也就是外部存储的根路径。</p>
</li>
<li><p>Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);</p>
<p>得到的路径是<code>/storage/emulated/0/Download</code></p>
<p>该方法的参数可以查看<code>Environment</code>类来详细了解。读写该文件夹下的文件<strong>不需要</strong>申请文件读写权限。卸载应用时不会被删除。对用户可以，上述就是外部存储根路径下的Download文件夹。</p>
</li>
</ul>
<p>P版本应用在sd卡根目录保存的应用数据卸载时不会被清除，但是Q版本这部分数据实际保存的是应用的沙箱目录 下，卸载的时候回全部被清除;<br>应用不想卸载删除的文件通过SAF或者是MediaProvider的接口保存在公共目录，不要放在应用的沙箱目录，公共目录文件卸载删除默认会弹框提示，对应弹框的第一 个勾选，默认保留，勾选删除，<strong>谷歌后续的版本计划把这 个勾选去掉，意味着应用保存到公共集合目录的文件卸载 的时候不会提示用户删除</strong>;<br>对于应用的沙箱文件，应用如果不想卸载的时候被删除，需要应用在manifest文件增加:<application android:fragileUserData="true" />，这样卸载应用的时候，系统弹出的对话框中才会有第二个勾选框出现(不增加该属性是不会有第二个勾选出现)，默认删除，勾选保留。</p>
<p><img src="/image/Android/adaptation/uninstall_apk_dialog.png" alt="卸载app提示"></p>
<h4 id="拍照、选择图片-TakePhotoOrChoosePhotoActivity"><a href="#拍照、选择图片-TakePhotoOrChoosePhotoActivity" class="headerlink" title="拍照、选择图片(TakePhotoOrChoosePhotoActivity)"></a>拍照、选择图片(TakePhotoOrChoosePhotoActivity)</h4><p>在Android6.0动态申请权限，Android7.0严格模式之后，拍照出现了问题，要么是没有权限存储图片，要么是返回的uri是空的，或者抛出如下异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">android.os.FileUriExposedException: file:<span class="hljs-comment">///storage/emulated/0/test.txt exposed beyond app through Intent.getData()</span><br>java.lang.SecurityException: Permission Denial: reading com.android.providers.media.MediaProvider uri<br></code></pre></td></tr></table></figure>

<p>出现上面的问题是因为Android7.0提高私有目录的安全性，防止应用信息的泄漏，从 Android 7.0 开始，应用私有目录的访问权限被做限制。具体表现为，开发人员不能够再简单地通过 file:&#x2F;&#x2F; URI 访问其他应用的私有目录文件或者让其他应用访问自己的私有目录文件。对于面向 Android 7.0 的应用，Android 框架执行的 StrictMode API 政策禁止在您的应用外部公开 file:&#x2F;&#x2F; URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。</p>
<p>我们可以通过配置FileProvider方式来避免这种问题。</p>
<p>配置方式网上一堆，这里不再抄一遍了：</p>
<p><a href="https://www.jianshu.com/p/ac5fe346a5b7">https://www.jianshu.com/p/ac5fe346a5b7</a></p>
<p><a href="https://www.jianshu.com/p/121bbb07cb07">https://www.jianshu.com/p/121bbb07cb07</a></p>
<p>在项目中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//指定Uri，拍照返回的data为空</span><br><span class="hljs-type">String</span> <span class="hljs-variable">tempImagePath</span> <span class="hljs-operator">=</span> getFilesDir().getPath();<br>tempImageFile = File.createTempFile(<span class="hljs-string">&quot;image_&quot;</span>, <span class="hljs-string">&quot;.jpg&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(tempImagePath));<br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(MediaStore.ACTION_IMAGE_CAPTURE);<br><br><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="hljs-number">24</span>) &#123;<br>  intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);<br>  intent.putExtra(MediaStore.EXTRA_OUTPUT,<br>  FileProvider.getUriForFile(TakePhotoOrChoosePhotoActivity.<span class="hljs-built_in">this</span>,<br>                                        <span class="hljs-string">&quot;com.huangyuanlove.adaptationhighversion.fileprovider&quot;</span>, tempImageFile));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(tempImageFile));<br>&#125;<br>startActivityForResult(intent, TAKE_PHOTO_CODE);<br></code></pre></td></tr></table></figure>

<p>当拍照返回之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">bitmap = BitmapFactory.decodeFile(tempImageFile.getPath());<br>showImage.setImageBitmap(bitmap);<br></code></pre></td></tr></table></figure>

<p>选择图片的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">albumIntent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Intent.ACTION_PICK);<br>albumIntent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="hljs-string">&quot;image/*&quot;</span>);<br>startActivityForResult(albumIntent, CHOOSE_PHOTO_CODE);<br></code></pre></td></tr></table></figure>

<p>选择图片返回的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-type">Uri</span> <span class="hljs-variable">selectedImage</span> <span class="hljs-operator">=</span> data.getData();<br>  String[] filePathColumn = &#123;MediaStore.Images.Media.DATA&#125;;<br><br>  <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> getContentResolver().query(selectedImage,<br>                                             filePathColumn, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>  cursor.moveToFirst();<br>  <span class="hljs-type">int</span> <span class="hljs-variable">columnIndex</span> <span class="hljs-operator">=</span> cursor.getColumnIndex(filePathColumn[<span class="hljs-number">0</span>]);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">picturePath</span> <span class="hljs-operator">=</span> cursor.getString(columnIndex);<br>  cursor.close();<br><br>  bitmap = BitmapFactory.decodeFile(picturePath);<br>  showImage.setImageBitmap(bitmap);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="存储访问框架-SAFActivity"><a href="#存储访问框架-SAFActivity" class="headerlink" title="存储访问框架(SAFActivity)"></a>存储访问框架(SAFActivity)</h4><p>官方有最佳实践：<a href="https://developer.android.com/guide/topics/providers/document-provider?hl=zh-cn">https://developer.android.com/guide/topics/providers/document-provider?hl=zh-cn</a></p>
<h4 id="通知管理-NotificationActivity"><a href="#通知管理-NotificationActivity" class="headerlink" title="通知管理(NotificationActivity)"></a>通知管理(NotificationActivity)</h4><p>主要是8.0之后的NotificationChannel问题，可以参考这个 </p>
<p><a href="http://blog.huangyuanlove.com/2018/12/27/Android-O-%E9%80%82%E9%85%8DNotificationChannel/">http://blog.huangyuanlove.com/2018/12/27/Android-O-%E9%80%82%E9%85%8DNotificationChannel/</a></p>
<h4 id="权限申请-MainActivity"><a href="#权限申请-MainActivity" class="headerlink" title="权限申请(MainActivity)"></a>权限申请(MainActivity)</h4><p>6.0之后的动态权限申请问题。大部分应用是在基类中一次性申请所有可能用到的权限，而不关心当前界面是否需要这个权限。</p>
<p>比如应用中需要用到相机、访问存储空间、读写通讯录、录音权限，则在BaseActivity中去申请这四种高危权限，这种做法对开发人员来说比较简单粗暴，不需要关心每次点击事件是否有权限。但对于用户来讲，刚打开应用就申请这么多权限，体验是不好的。推荐做法还是在需要时去申请权限。</p>
<p>比如更换头像时，点击按钮之后才会去申请相机权限，而不是打开资料设置界面的时候去申请。并且建议只申请用到的权限，而不是一次性全部申请。</p>
<p>这里需要注意的是，国产手机中对于权限的判定和在设置里面看到的权限可能不一致。</p>
<ol>
<li><p>当我们点击了拍照按钮之后，首先检查权限：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">checkSelfPermission(Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED<br></code></pre></td></tr></table></figure>

<p>这里需要判断一下版本，大于6.0(Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.M)才需要去判断。</p>
<p>有权限直接到拍照界面，没有权限则申请权限：</p>
</li>
<li><p>申请权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">requestPermissions(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;Manifest.permission.CAMERA&#125;, REQUEST_PERMISSION_CAMERA);<br></code></pre></td></tr></table></figure>
</li>
<li><p>权限申请返回结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">   <br><span class="hljs-meta">@RequiresApi(api = Build.VERSION_CODES.M)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onRequestPermissionsResult</span><span class="hljs-params">(<span class="hljs-type">int</span> requestCode, <span class="hljs-meta">@NonNull</span> String[] permissions, <span class="hljs-meta">@NonNull</span> <span class="hljs-type">int</span>[] grantResults)</span> &#123;<br>  <span class="hljs-built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);<br>  <span class="hljs-keyword">if</span> (permissions.length &lt;= <span class="hljs-number">0</span> || grantResults.length &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">switch</span> (requestCode) &#123;<br>    <span class="hljs-keyword">case</span> REQUEST_PERMISSION_CAMERA:<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">permission</span> <span class="hljs-operator">=</span> permissions[<span class="hljs-number">0</span>];<br><br>      <span class="hljs-keyword">if</span> (grantResults.length &gt; <span class="hljs-number">0</span> &amp;&amp; grantResults[<span class="hljs-number">0</span>] ==<br>    			PackageManager.PERMISSION_GRANTED) &#123;<br>        Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;授予拍照权限成功&quot;</span>, Toast.LENGTH_SHORT).show();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (shouldShowRequestPermissionRationale(permissions[<span class="hljs-number">0</span>])) &#123;<br>          <span class="hljs-comment">//用户只点击了禁止，没有选择不再提示</span><br>          Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;用户禁止了&quot;</span> + permission + <span class="hljs-string">&quot;权限&quot;</span>, Toast.LENGTH_SHORT).show();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//解释原因，并且引导用户至设置页手动授权</span><br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">AlertDialog</span>.Builder(<span class="hljs-built_in">this</span>)<br>            .setMessage(<span class="hljs-string">&quot;【用户选择了不在提示按钮，或者系统默认不在提示（如MIUI）。&quot;</span> +<br>                        <span class="hljs-string">&quot;引导用户到应用设置页去手动授权,注意提示用户具体需要哪些权限】\r\n&quot;</span> +<br>                        <span class="hljs-string">&quot;获取相关权限失败:xxxxxx,将导致部分功能无法正常使用，需要到设置页面手动授权&quot;</span>)<br>            .setPositiveButton(<span class="hljs-string">&quot;去授权&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.OnClickListener() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(DialogInterface dialog, <span class="hljs-type">int</span> which)</span> &#123;<br>                <span class="hljs-comment">//引导用户至设置页手动授权</span><br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);<br>                <span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> Uri.fromParts(<span class="hljs-string">&quot;package&quot;</span>, getApplicationContext().getPackageName(), <span class="hljs-literal">null</span>);<br>                intent.setData(uri);<br>                startActivity(intent);<br>              &#125;<br>            &#125;)<br>            .setNegativeButton(<span class="hljs-string">&quot;取消&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.OnClickListener() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(DialogInterface dialog, <span class="hljs-type">int</span> which)</span> &#123;<br>                <span class="hljs-comment">//引导用户手动授权，权限请求失败</span><br>                Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;引导授权失败:&quot;</span> + permission, Toast.LENGTH_LONG).show();<br>              &#125;<br>            &#125;).setOnCancelListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogInterface</span>.OnCancelListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCancel</span><span class="hljs-params">(DialogInterface dialog)</span> &#123;<br>              <span class="hljs-comment">//引导用户手动授权，权限请求失败</span><br>              Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;引导授权失败:&quot;</span> + permission, Toast.LENGTH_LONG).show();<br>            &#125;<br>          &#125;).show();<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里需要注意的是，官方文档说第一申请权限的时候不会有”禁止后不再询问”的复选框，但是在很多国内rom上第一次就会有这个提示。当用户勾选了”禁止后不再询问”，这时候我们申请权限会立刻调用<code>onRequestPermissionsResult</code>方法，并且<code>shouldShowRequestPermissionRationale</code>返回false。这时候我们需要引导用户到设置界面开启权限。</p>
</li>
</ol>
<h4 id="快捷方式-ShortCutActivity"><a href="#快捷方式-ShortCutActivity" class="headerlink" title="快捷方式(ShortCutActivity)"></a>快捷方式(ShortCutActivity)</h4><p>Android 7.1之后提供了快捷方式的API，在长按应用图标后会弹出定义的快捷方式(个数有限)。但在国产rom中有可能会把这个功能干掉。</p>
<p>快捷方式有分为动态注册和静态注册(配置文件)，动态注册的快捷方式可以动态删除，静态注册的快捷方式不可动态删除。</p>
<ol>
<li><p>静态注册</p>
<p>在res文件夹下新建xml文件夹，在其中新建<code>shortcuts.xml</code>,内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">shortcuts</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">shortcut</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutDisabledMessage</span>=<span class="hljs-string">&quot;@string/permission_deny&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutId</span>=<span class="hljs-string">&quot;camera&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutLongLabel</span>=<span class="hljs-string">&quot;@string/take_photo_or_choose_image&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutShortLabel</span>=<span class="hljs-string">&quot;@string/camera&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:action</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:targetClass</span>=<span class="hljs-string">&quot;com.huangyuanlove.adaptationhighversion.TakePhotoOrChoosePhotoActivity&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:targetPackage</span>=<span class="hljs-string">&quot;com.huangyuanlove.adaptationhighversion&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">shortcut</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">shortcut</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutDisabledMessage</span>=<span class="hljs-string">&quot;@string/permission_deny&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutId</span>=<span class="hljs-string">&quot;about_file&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutLongLabel</span>=<span class="hljs-string">&quot;@string/file_example&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutShortLabel</span>=<span class="hljs-string">&quot;@string/file&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:action</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:targetClass</span>=<span class="hljs-string">&quot;com.huangyuanlove.adaptationhighversion.FileOperationActivity&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:targetPackage</span>=<span class="hljs-string">&quot;com.huangyuanlove.adaptationhighversion&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">shortcut</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">shortcut</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutDisabledMessage</span>=<span class="hljs-string">&quot;@string/permission_deny&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutId</span>=<span class="hljs-string">&quot;notification_example&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutLongLabel</span>=<span class="hljs-string">&quot;@string/notification_example&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutShortLabel</span>=<span class="hljs-string">&quot;@string/notification&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:action</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:targetClass</span>=<span class="hljs-string">&quot;com.huangyuanlove.adaptationhighversion.NotificationActivity&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:targetPackage</span>=<span class="hljs-string">&quot;com.huangyuanlove.adaptationhighversion&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">shortcut</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">shortcut</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutDisabledMessage</span>=<span class="hljs-string">&quot;@string/permission_deny&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutId</span>=<span class="hljs-string">&quot;saf_example&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutLongLabel</span>=<span class="hljs-string">&quot;@string/saf_example&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:shortcutShortLabel</span>=<span class="hljs-string">&quot;@string/saf&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:action</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:targetClass</span>=<span class="hljs-string">&quot;com.huangyuanlove.adaptationhighversion.SAFActivity&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:targetPackage</span>=<span class="hljs-string">&quot;com.huangyuanlove.adaptationhighversion&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">shortcut</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">shortcuts</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里需要注意的是<code>shortcutDisabledMessage</code>、<code>shortcutLongLabel</code>、<code>shortcutShortLabel</code>属性值只能使用引用，不能直接硬编码。<code>shortcutLongLabel</code>是在长按图标时弹出的快捷方式名称，<code>shortcutShortLabel</code>是讲该快捷方式拖放到桌面后显示的名称。<code>shortcutId</code>是该快捷方式的唯一标识符。</p>
<p>然后在<code>AndroidManifest.xml</code>文件中配置一下，找到一个Activity，其<code>intent-filter</code>被设置为<code>android.intent.action.MAIN</code>和<code>android.intent.category.LAUNCHER</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">             <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.app.shortcuts&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/shortcuts&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>动态注册</p>
</li>
</ol>
<p>算了，看代码吧</p>
<p>添加新的快捷方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addShortcut</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N_MR1) &#123;<br>            <span class="hljs-type">ShortcutManager</span> <span class="hljs-variable">shortcutManager</span> <span class="hljs-operator">=</span> getSystemService(ShortcutManager.class);<br>            <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(ShortCutActivity.<span class="hljs-built_in">this</span>,ShortCutActivity.class);<br>            intent.setAction(Intent.ACTION_VIEW);<br>            <span class="hljs-type">ShortcutInfo</span> <span class="hljs-variable">shortcut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShortcutInfo</span>.Builder(ShortCutActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;shortcut&quot;</span>)<br>                    .setIcon(Icon.createWithResource(<span class="hljs-built_in">this</span>, R.mipmap.ic_launcher))<br>                    .setShortLabel( getString( R.string.shortcut))<br>                    .setLongLabel(getString(R.string.shortcut_example))<br>                    .setIntent(intent)<br>                    .build();<br>            shortcutManager.addDynamicShortcuts(Arrays.asList( <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShortcutInfo</span>[]&#123; shortcut&#125;));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>更新快捷方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateShortcut</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N_MR1) &#123;<br>            <span class="hljs-type">ShortcutManager</span> <span class="hljs-variable">shortcutManager</span> <span class="hljs-operator">=</span> getSystemService(ShortcutManager.class);<br>            <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(ShortCutActivity.<span class="hljs-built_in">this</span>,ShortCutActivity.class);<br>            intent.setAction(Intent.ACTION_VIEW);<br>            <span class="hljs-type">ShortcutInfo</span> <span class="hljs-variable">shortcut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShortcutInfo</span>.Builder(ShortCutActivity.<span class="hljs-built_in">this</span>, <span class="hljs-string">&quot;shortcut&quot;</span>)<br>                    .setIcon(Icon.createWithResource(<span class="hljs-built_in">this</span>, R.mipmap.ic_launcher))<br>                    .setShortLabel( getString( R.string.shortcut) +<span class="hljs-string">&quot;new&quot;</span>)<br>                    .setLongLabel(getString(R.string.shortcut_example) +<span class="hljs-string">&quot;new&quot;</span>)<br>                    .setIntent(intent)<br>                    .build();<br>            shortcutManager.updateShortcuts(Arrays.asList( <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShortcutInfo</span>[]&#123; shortcut&#125;));<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>删除快捷方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeShortcut</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N_MR1) &#123;<br>            <span class="hljs-type">ShortcutManager</span> <span class="hljs-variable">shortcutManager</span> <span class="hljs-operator">=</span> getSystemService(ShortcutManager.class);<br><br>            <span class="hljs-comment">//动态添加并且在桌面创建了快捷方式，删除之前，先disable一下.  或者判断</span><br>            List&lt;ShortcutInfo&gt; shortcutInfos = shortcutManager.getPinnedShortcuts();<br>            <br>            <span class="hljs-keyword">for</span>(ShortcutInfo si : shortcutInfos)&#123;<br>                <span class="hljs-keyword">if</span>(si.getId().equals(<span class="hljs-string">&quot;shortcut&quot;</span>))&#123;<br>                    shortcutManager.disableShortcuts(Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;shortcut&quot;</span>&#125;));<br>                &#125;<br>            &#125;<br>            shortcutManager.removeDynamicShortcuts(Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;shortcut&quot;</span>&#125;));<br><br>            Toast.makeText(ShortCutActivity.<span class="hljs-built_in">this</span>,<span class="hljs-string">&quot;共&quot;</span> + shortcutInfos.size() +<span class="hljs-string">&quot;个桌面快捷方式&quot;</span>,Toast.LENGTH_SHORT).show();<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>被添加到桌面的快捷方式无法删除(可以从长按菜单中删除，但是桌面上图标无法删除，依然有效)，所以我们需要先查询一个桌面快捷方式有没有我们要删除的，如果有，先设置为不可以，由用户手动删除。设置为不可用时可以添加点击提示语(disableShortcuts的重载方法)</p>
<p>持续更新</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>适配全面屏手机</title>
    <url>/2018/11/12/%E9%80%82%E9%85%8D%E5%85%A8%E9%9D%A2%E5%B1%8F%E6%89%8B%E6%9C%BA/</url>
    <content><![CDATA[<p>放个图感受一下，上面的图是折叠屏，并非是全面屏，全面屏是手机业界对于超高屏占比手机设计的一个宽泛的定义。全面屏手机屏幕的宽高比例比较特殊，不再是以前的16:9了。比如三星的Galaxy S8屏幕分辨率是：2960×1440，对应的屏幕比例为:18.5:9。VIVO X20手机屏幕分辨率是2160x1080，对应的屏幕比例:18:9。由于全面屏手机的高宽比比之前大，如果不适配的话，Android默认为最大的宽高比是1.86，小于全面屏手机的宽高比，因此，在全面屏手机上打开部分App时，上下就会留有空间，显示为黑条。</p>
<p>本文关于适配问题参考 <a href="https://blog.csdn.net/weelyy/article/details/79284332">https://blog.csdn.net/weelyy/article/details/79284332</a></p>
<span id="more"></span>

<h4 id="显示问题"><a href="#显示问题" class="headerlink" title="显示问题"></a>显示问题</h4><img src="/image/Android/maxAspect/max_aspect.png" height="500" width="240" />
<img src="/image/Android/maxAspect/max_aspect1.jpg" height="500" width="240" />


<p>第一张图是在小米mix3上显示的问题，不得不说用户也是紧跟潮流，刚出新手机就直接入手。<br>下面一张图是在华为荣耀10上显示的问题，可以明显的看出，在屏幕底部都有一块黑色区域，不同的是华为荣耀10上有全屏显示的提示，点击之后可以强制全屏显示，不会留下黑框。</p>
<h4 id="在AndroidManifest-xml声明max-aspect值"><a href="#在AndroidManifest-xml声明max-aspect值" class="headerlink" title="在AndroidManifest.xml声明max_aspect值"></a>在AndroidManifest.xml声明max_aspect值</h4><p>针对此问题，Android官方提供了适配方案，即提高App所支持的最大屏幕纵横比，实现起来也比较简单，在AndroidManifest.xml中做如下配置即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.max_aspect&quot;</span>  <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;ratio_float&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中ratio_float为浮点数，官方建议为2.1或更大，因为18.5：9&#x3D;2.055555555……，如果日后出现纵横比更大的手机，此值将需要设为更大。在我司项目中设置的值为4.1，当设置该值为2.1时，在华为荣耀10上未生效。  因此，建议开发者在自己App AndroidManifest的Application标签下面增加下面一段代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.max_aspect&quot;</span> <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;2.1&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>另外，在AndroidManifest中针对Activity标签添加<code>android:resizeableActivity = ”true”</code>，也可以实现全屏显示，但此设置只针对Activity生效，且增加了此属性该activity也会支持分屏显示。</p>
<p>当然max_aspect值也可以在代码中动态设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMaxAspect</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ApplicationInfo</span> <span class="hljs-variable">applicationInfo</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            applicationInfo = getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);<br>        &#125; <span class="hljs-keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(applicationInfo == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot; get application info = null, has no meta data! &quot;</span>);<br>        &#125;<br>        applicationInfo.metaData.putString(<span class="hljs-string">&quot;android.max_aspect&quot;</span>, <span class="hljs-string">&quot;2.1&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>具体情况可以参考谷歌官方文档</p>
<p><a href="https://android-developers.googleblog.com/2017/03/update-your-app-to-take-advantage-of.html">https://android-developers.googleblog.com/2017/03/update-your-app-to-take-advantage-of.html</a></p>
<h4 id="更换资源文件"><a href="#更换资源文件" class="headerlink" title="更换资源文件"></a>更换资源文件</h4><p>在较大高宽比的手机上，由于屏幕比例的改变(从16:9变成了18:9)，对于一些铺满全屏的图片(如开屏广告页或者引导页)会出现图片拉伸的情况，如果可以接受，就不用管了。接受不了就需要适配，针对这种问题，我们以分辨率为2160X1080，像素密度为480dpi的VIVO X20Plus手机为例，可以在资源目录下面增加一个文件夹，drawable-h642dp-port-xxhdpi，并将GUI切好的分辨率为2160X1080资源图片放在这个目录下，系统就能自动使用这种图片，便不会出现拉伸的问题。关于<code>h&lt;N&gt;dp</code>的详细用法，google开发者文档也有详细介绍：</p>
<p><a href="https://developer.android.com/guide/practices/screens_support">https://developer.android.com/guide/practices/screens_support</a></p>
<h4 id="关于折叠屏"><a href="#关于折叠屏" class="headerlink" title="关于折叠屏"></a>关于折叠屏</h4><p>北京时间 11 月 8 日，三星在旧金山向开发者发布了一款可折叠屏幕手机。并表示，新技术需要开发者调整其 App，以确保在手机被摊开成平板电脑时，能够运行流畅。三星的这款手机，还处于原型机的状态，正式发布日期尚未确定。这种折叠的技术，三星将其称之为 Infinity Flex Display。不过 Google 也有其应对的策略，在今年的 Android Dev Summit 上，Google 就已经宣布将要对折叠屏提供“Screen Continuity（屏幕连续性）”的原生系统支持，并将这项技术称之为：<strong>Foldables</strong>。利用这种柔性显示技术，App 可以做到折叠屏设备上的适配工作。</p>
<p>具体情况可以参考<a href="https://mp.weixin.qq.com/s/yz5dxQyG3jvhUuDRrdNzbg">https://mp.weixin.qq.com/s/yz5dxQyG3jvhUuDRrdNzbg</a></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>Android爬坑之旅</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>通过简单的自定义view来看View的工作流程</title>
    <url>/2017/03/18/%E9%80%9A%E8%BF%87%E7%AE%80%E5%8D%95%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89view%E6%9D%A5%E7%9C%8BView%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>通过简单的自定义View(画个圆)，来了解一下View的工作流程以及自定义View应该注意的地方。</p>
<span id="more"></span>
<h3 id="一、自定义View的分类"><a href="#一、自定义View的分类" class="headerlink" title="一、自定义View的分类"></a>一、自定义View的分类</h3><h4 id="1-1-继承View重写onDraw方法"><a href="#1-1-继承View重写onDraw方法" class="headerlink" title="1.1 继承View重写onDraw方法"></a>1.1 继承View重写onDraw方法</h4><p>这种方法主要用于实现一些不规则的效果，比如动态或者静态显示一些不规则的图形，采用这种方式需要自己支持<code>wrap_content</code>,并且<code>padding</code>需要自己处理.</p>
<h4 id="1-2-继承ViewGroup派生特殊的Layout"><a href="#1-2-继承ViewGroup派生特殊的Layout" class="headerlink" title="1.2 继承ViewGroup派生特殊的Layout"></a>1.2 继承ViewGroup派生特殊的Layout</h4><p>这种方式主要用于实现自定义布局，如流式布局。采用这种方式需要合适的处理ViewGroup的测量、布局这两个过程，并同时处理子元素的测量和布局过程。</p>
<h4 id="1-3-继承特定的View-如TextView"><a href="#1-3-继承特定的View-如TextView" class="headerlink" title="1.3 继承特定的View(如TextView)"></a>1.3 继承特定的View(如TextView)</h4><p>这种方法一般用于扩展某种已有的<code>View</code>的功能，比如<code>TextView</code>，这种方法比较容易实现，不需要自己支持<code>wrap_content</code>和<code>padding</code>。</p>
<h4 id="1-4-继承特定的ViewGroup"><a href="#1-4-继承特定的ViewGroup" class="headerlink" title="1.4 继承特定的ViewGroup"></a>1.4 继承特定的ViewGroup</h4><p>采用这种方式不需要自己处理<code>ViewGroup</code>的测量和布局这两个过程。</p>
<h3 id="二、值得注意的地方"><a href="#二、值得注意的地方" class="headerlink" title="二、值得注意的地方"></a>二、值得注意的地方</h3><h4 id="2-1-让View支持wrap-content"><a href="#2-1-让View支持wrap-content" class="headerlink" title="2.1 让View支持wrap_content"></a>2.1 让View支持wrap_content</h4><p>这是因为直接继承View或者ViewGroup的控件，如果不在<code>onMeasure</code>中对<code>wrap_content</code>做特殊处理，那么当外界在适用<code>wrap_content</code>时就无法达到预期的效果。</p>
<h4 id="2-2-如果有必要，让View支持padding"><a href="#2-2-如果有必要，让View支持padding" class="headerlink" title="2.2 如果有必要，让View支持padding"></a>2.2 如果有必要，让View支持padding</h4><p>这是因为如果直接继承View，如果不在draw方法中处理padding，那么padding属性是无法起作用的。另外，直接继承自ViewGroup的控件需要在<code>onMeasure</code>和<code>onLayout</code>中考虑padding和子元素的margin对其造成的影响，不然将导致padding和子元素的margin失效。</p>
<h4 id="2-3-尽量不要在View中使用Handler，没必要"><a href="#2-3-尽量不要在View中使用Handler，没必要" class="headerlink" title="2.3 尽量不要在View中使用Handler，没必要"></a>2.3 尽量不要在View中使用Handler，没必要</h4><p>因为View内部本身就提供了post系列的方法， 完全可以替代Handler的作用，当然除非你很明确要使用Handler来发送消息</p>
<h4 id="2-4-及时停止动画和线程"><a href="#2-4-及时停止动画和线程" class="headerlink" title="2.4 及时停止动画和线程"></a>2.4 及时停止动画和线程</h4><p>如果需要停止线程或者动画，可以在<code>onDetachedFromWindow</code>方法中处理，当包含此View的Activity退出或者当前View被remove时，View的<code>onDetachedFromWindow</code>方法会被调用，和此方法对应的是<code>onAttachedToWindow</code>，当包含此View的Activity启动时，View的<code>onAttachedToWindow</code>方法会被调用。</p>
<h4 id="2-5-View带有滑动嵌套情形时，需要处理好滑动冲突"><a href="#2-5-View带有滑动嵌套情形时，需要处理好滑动冲突" class="headerlink" title="2.5 View带有滑动嵌套情形时，需要处理好滑动冲突"></a>2.5 View带有滑动嵌套情形时，需要处理好滑动冲突</h4><p>如果有滑动冲突的话，那么要合适的处理滑动冲突，否则将会严重影响View的效果。</p>
<h3 id="三、自定义View"><a href="#三、自定义View" class="headerlink" title="三、自定义View"></a>三、自定义View</h3><h4 id="3-1-继承View重写onDraw方法"><a href="#3-1-继承View重写onDraw方法" class="headerlink" title="3.1 继承View重写onDraw方法"></a>3.1 继承View重写onDraw方法</h4><p>首先来看一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCustomCircleView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">View</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> Color.RED;<br>    <span class="hljs-keyword">private</span> Paint paint;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestCustomCircleView</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestCustomCircleView</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs);<br>        init();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestCustomCircleView</span><span class="hljs-params">(Context context, AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);<br>        init();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        paint = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Paint</span>();<br>        paint.setColor(color);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDraw(canvas);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> getWidth();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> getHeight();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> Math.min(width,height)/<span class="hljs-number">2</span>;<br>        canvas.drawCircle(width/<span class="hljs-number">2</span>,height/<span class="hljs-number">2</span>,radius,paint);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的代码只是一种初级的实现，当我们进行使用的时候，只支持margin属性，并不支持padding属性。对<code>onDraw</code>方法进行修改，只要在绘制的时候考虑一下padding即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDraw</span><span class="hljs-params">(Canvas canvas)</span> &#123;<br>       <span class="hljs-built_in">super</span>.onDraw(canvas);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">paddingLeft</span> <span class="hljs-operator">=</span> getPaddingLeft();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">paddingRight</span> <span class="hljs-operator">=</span> getPaddingRight();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">paddingTop</span> <span class="hljs-operator">=</span> getPaddingTop();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">paddingBottom</span> <span class="hljs-operator">=</span> getPaddingBottom();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> getWidth() - paddingLeft - paddingRight;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> getHeight() - paddingBottom - paddingTop;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> Math.min(width, height) / <span class="hljs-number">2</span>;<br>       canvas.drawCircle(paddingLeft + width / <span class="hljs-number">2</span>, paddingTop + height / <span class="hljs-number">2</span>, radius, paint);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>但是现在还不能支持<code>warp_content</code>属性，现在使用<code>wrap_content</code>和使用<code>match_parent</code>没有任何区别：对于直接继承自View的控件，如果不对<code>wrap_content</code>做特殊处理，那么使用<code>wrap_content</code>就相当于使用<code>match_parent</code>.这里就需要我们重写<code>onMeasure</code>方法，当宽高属性为<code>wrap_content</code>时，取一个默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">desiredWidth</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">desiredHeight</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">widthMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(widthMeasureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">widthSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(widthMeasureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">heightMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(heightMeasureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">heightSize</span> <span class="hljs-operator">=</span> MeasureSpec.getSize(heightMeasureSpec);<br><br>    <span class="hljs-type">int</span> width;<br>    <span class="hljs-type">int</span> height;<br><br>    <span class="hljs-comment">//宽度</span><br>    <span class="hljs-keyword">if</span> (widthMode == MeasureSpec.AT_MOST) &#123;<br>        width = Math.min(desiredWidth, widthSize);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;<br>        width = widthSize;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        width = desiredWidth;<br>    &#125;<br>    <span class="hljs-comment">//高度</span><br>    <span class="hljs-keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;<br>        height = Math.min(desiredHeight, heightSize);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;<br>        height = heightSize;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        height = desiredHeight;<br>    &#125;<br>    setMeasuredDimension(width, height);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样，当我们使用wrap_content时，就是使用默认的100px的值。</p>
<h3 id="四、使用自定义属性"><a href="#四、使用自定义属性" class="headerlink" title="四、使用自定义属性"></a>四、使用自定义属性</h3><h4 id="4-1-创建自定义的配置文件"><a href="#4-1-创建自定义的配置文件" class="headerlink" title="4.1 创建自定义的配置文件"></a>4.1 创建自定义的配置文件</h4><p>在values目录下面创建自定义属性的XML，比如attrs.xml，也可以选择类似于attrs_circle_view.xml等这种以attrs_开头的文件名，当然这个文件名并没有什么限制，可以随便取名字。我们选择创建attrs.xml文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;TestCustomCircleView&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;circle_color&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;color&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="4-2-在构造方法中解析自定义的属性值并做相应的处理"><a href="#4-2-在构造方法中解析自定义的属性值并做相应的处理" class="headerlink" title="4.2 在构造方法中解析自定义的属性值并做相应的处理"></a>4.2 在构造方法中解析自定义的属性值并做相应的处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TestCustomCircleView</span><span class="hljs-params">(Context context, AttributeSet attrs, <span class="hljs-type">int</span> defStyleAttr)</span> &#123;<br>    <span class="hljs-built_in">super</span>(context, attrs, defStyleAttr);<br>    <span class="hljs-type">TypedArray</span> <span class="hljs-variable">typedArray</span> <span class="hljs-operator">=</span> context.obtainStyledAttributes(attrs, R.styleable.TestCustomCircleView);<br>    color = typedArray.getColor(R.styleable.TestCustomCircleView_circle_color,Color.RED);<br>    typedArray.recycle();<br>    init();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先加载自定义属性集合，接着解析属性集合中<code>TestCustomCircleView_circle_color</code>，如果没有指定属性值，则使用<code>Color.RED</code>作为默认值。</p>
<h4 id="4-3-在布局文件中使用自定义属性"><a href="#4-3-在布局文件中使用自定义属性" class="headerlink" title="4.3 在布局文件中使用自定义属性"></a>4.3 在布局文件中使用自定义属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">com.example.huangyuan.custom.TestCustomCircleView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:circle_color</span>=<span class="hljs-string">&quot;@color/grey&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>面试总结</title>
    <url>/2018/06/03/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>最近的面试过程中遇到的面试题，涉及的方面比较广泛，大致分成了一下几个方面：<br>操作系统、Java、Android、计算机网络、其他(kotlin、react、安全之类的)。</p>
<span id="more"></span>

<h3 id="操作系统相关："><a href="#操作系统相关：" class="headerlink" title="操作系统相关："></a>操作系统相关：</h3><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><blockquote>
<ul>
<li>进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元 </li>
<li>同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。</li>
<li>进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束</li>
<li>线程是轻量级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的</li>
<li>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源</li>
<li>线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志</li>
</ul>
</blockquote>
<h4 id="线程调度算法"><a href="#线程调度算法" class="headerlink" title="线程调度算法"></a>线程调度算法</h4><blockquote>
<ul>
<li>SCHED_OTHER：普通任务调度策略。</li>
<li>SCHED_FIFO：实时任务调度策略，先到先服务。一旦占用cpu则一直运行，直到有更高优先级任务到达或自己放弃。</li>
<li>SCHED_RR：实时任务调度策略，时间片轮转。当任务的时间片用完，系统将重新分配时间片，并置于就绪队列尾。放在队列尾<br>具体涉及到N多内容，自行搜索</li>
</ul>
</blockquote>
<h4 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h4><p>为提高内存利用率，解决内存供不应求的问题，更加合理的使用内存，人们创造了分页式内存抽象。同时有一个虚拟内存的概念，是指将内存中暂时不需要的部分写入硬盘，看上去硬盘扩展了内存的容量，所以叫做“虚拟”内存。使用虚拟内存，应用程序可以使用比实际物理内存更大的内存空间。可以认为这个更大的内存空间就在硬盘上，只有将某一部分需要被用到时，才被写入真实内存；当它暂时不再被用到时，又被写回硬盘。分页式内存管理将物理内存分为等大的小块，每块大小通常为1K、2K、4K等，称为页帧；逻辑内存（使用虚拟内存技术扩大的内存，可认为其位于硬盘上）也被分为等大的小块，称为页；且页和页帧的大小一定是一样的，它是写入真实内存和写回硬盘最小单位。</p>
<blockquote>
<p>** Optimal算法（最优算法） **<br>　　从内存中移除永远都不再需要的页面或者说是未来最长时间内不再被访问的页面，如果这样的页面存在，则选择最长时间不需要访问的页面。采用最佳置换算法，可以保证较低的页面更新频率。从理论上讲，由于无法预知哪一个页面是未来最长时间内不再被访问的，因而该算法无法实现，但是可用来衡量其他算法。</p>
</blockquote>
<blockquote>
<p>** FIFO（First-In First-Out，先进先出）算法 **<br>    该算法总是淘汰最早进入内存的页面，即选择在内存中停留时间最久的页面予以淘汰。<br>　　这个算法的实现简单，只需要将进程已调入内存中的页面，按照先后顺序连接成一个队列，设置一个替换指针，总是指向最老的页面。<br>　　但是该算法与进程实际的规律并不相适应，因为在进程中，有些页面经常被访问，比如：含有全局变量、常用函数、例程等的页面，FIFO不能保证这些页面不会被淘汰。<br>　　正是由于没有考虑页面的重要性的问题，FIFO算法很容易将重要的页换出内存。</p>
</blockquote>
<blockquote>
<p>** Second Chance（第二次机会）算法 **<br>　　为了避免FIFO算法将重要的页换出内存，Second Chance算法提供了一些改进。Second Chance算法在将页面换出内存前检查其使用位，如果其使用位为1，证明此页最近有被使用，猜测它还可能被使用，于是不把它置换出内存，但是把其使用位置为0，随后检查下一个页面，直到发现某页的使用位为0，将此页置换出内存。</p>
</blockquote>
<blockquote>
<p>** LRU（Least Recent Used, 最近最少使用）算法 **<br>　　在之前的FIFO算法中，依据的是各个页面调入内存的时间，这并不能反映页面的真实使用情况。而LRU（Latest Recently Used）是根据页面调入内存之后的使用情况。由于无法预测页面未来的情况，所以只能利用“最近的过去”来作为预测未来的方法，LRU选择的是最近最久未使用的页面予以淘汰。<br>　　该算法赋予每个页面一个访问字段，用来记录一个页面从上次被访问以来所经历的时间t，当需要淘汰一个页面的时候，选择现有页面中t的值最大的页面进行淘汰。<br>　　LRU是一种优秀的页面置换算法，但是需要硬件的支持，为了了解一个进程在内存中各个页面各有多少时间未被进程访问，以及如何快速地知道哪一个页面是最近最久未使用的页面，需要 寄存器+栈 来支持。</p>
</blockquote>
<h3 id="java相关："><a href="#java相关：" class="headerlink" title="java相关："></a>java相关：</h3><h4 id="synchronized-和Lock的区别-以及实现原理"><a href="#synchronized-和Lock的区别-以及实现原理" class="headerlink" title="synchronized 和Lock的区别 以及实现原理"></a>synchronized 和Lock的区别 以及实现原理</h4><blockquote>
<p>  教科书式的应试回答：<br>    主要相同点：Lock能完成synchronized所实现的所有功能<br>    主要不同点：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。</p>
</blockquote>
<p>| 类别 | synchronized | lock |<br>|: - :| :-: | : -: |<br>| 存在层次 | Java的关键字，在jvm层面上 | 是一个类|<br>| 锁的释放 | 1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁	| 在finally中必须释放锁，不然容易造成线程死锁 |<br>| 锁的获取 | 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待	| 分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待|<br>| 锁状态 | 无法判断	| 可以判断|<br>| 锁类型 | 可重入 不可中断 非公平 | 可重入 可判断 可公平（两者皆可）|<br>|性能 | 少量同步 | 大量同步|</p>
<p>关于同步类(java.util.concurrent包下)的介绍可以看这个 <a href="http://blog.huangyuanlove.com/2018/03/20/Java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/#more">http://blog.huangyuanlove.com/2018/03/20/Java%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/#more</a><br>关于Lock的底层实现可以看这篇：<a href="https://blog.csdn.net/Luxia_24/article/details/52403033">https://blog.csdn.net/Luxia_24/article/details/52403033</a><br>关于synchronized可以看这篇 <a href="https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1">https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1</a></p>
<h4 id="Map、Set、List区别"><a href="#Map、Set、List区别" class="headerlink" title="Map、Set、List区别"></a>Map、Set、List区别</h4><p>这个自己翻一下源码看一下就好<br>Map-&gt; HashMap(存入数据的过程，hash冲突了怎么办),TreeMap,LinkedHashMap<br>Set-&gt; 使用Map实现的，set中存放的数据对应map中的key，value是内部的一个object字段<br>list-&gt; ArrayList(数组),LinkedList(链表)区别，优缺点</p>
<h4 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h4><p>这个主要是问内存区域，垃圾回收算法，可以参考这里：<br>JVM-内存分配与回收策略 <a href="http://blog.huangyuanlove.com/2017/04/07/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/">http://blog.huangyuanlove.com/2017/04/07/JVM-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</a><br>JVM-垃圾收集算法与实现  <a href="http://blog.huangyuanlove.com/2017/03/30/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/">http://blog.huangyuanlove.com/2017/03/30/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</a><br>JVM垃圾回收-对象已死？ <a href="http://blog.huangyuanlove.com/2017/03/29/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%EF%BC%9F/">http://blog.huangyuanlove.com/2017/03/29/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%EF%BC%9F/</a><br>JVM内存区域 <a href="http://blog.huangyuanlove.com/2017/03/27/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/">http://blog.huangyuanlove.com/2017/03/27/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</a></p>
<h4 id="捕获子线程异常"><a href="#捕获子线程异常" class="headerlink" title="捕获子线程异常"></a>捕获子线程异常</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>().setUncaughtExceptionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>               <br>           &#125;<br>       &#125;);<br>Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br><br>           &#125;<br>       &#125;);<br></code></pre></td></tr></table></figure>
<p>如果一个线程没有显式的设置它的UncaughtExceptionHandler，JVM就会检查该线程所在的线程组是否设置了UncaughtExceptionHandler，如果已经设置，就是用该UncaughtExceptionHandler；否则查看是否在Thread层面通过静态方法setDefaultUncaughtExceptionHandler()设置了UncaughtExceptionHandler，如果已经设置就是用该UncaughtExceptionHandler；如果上述都没有找到，JVM会在对应的console中打印异常的堆栈信息。<br>具体情况可以看一下Java并发编程的艺术</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>这是个大坑，看源码吧ThreadPoolExecutor.java，还有就是常见线程池的比较。</p>
<h4 id="单例模式-线程安全"><a href="#单例模式-线程安全" class="headerlink" title="单例模式 线程安全"></a>单例模式 线程安全</h4><p>单例的模式的N种写法，像什么double check、懒汉模式、静态内部类，还有就是枚举方式。这里会引出来<code>volatile</code>关键字，然后就是线程安全的问题。</p>
<h3 id="Android相关："><a href="#Android相关：" class="headerlink" title="Android相关："></a>Android相关：</h3><h4 id="多进程写sp的问题"><a href="#多进程写sp的问题" class="headerlink" title="多进程写sp的问题"></a>多进程写sp的问题</h4><p>还是线程安全的问题，因为SP不支持两个进程同事去执行写操作，否则会导致一定几率的数据丢失，这是因为SP底层通过读写xml文件来实现的，并发写显然是有问题的</p>
<h4 id="sp底层实现"><a href="#sp底层实现" class="headerlink" title="sp底层实现"></a>sp底层实现</h4><p>读写xml文件</p>
<h4 id="Activity和Fragment生命周期-生命周期函数是谁调用的"><a href="#Activity和Fragment生命周期-生命周期函数是谁调用的" class="headerlink" title="Activity和Fragment生命周期,生命周期函数是谁调用的"></a>Activity和Fragment生命周期,生命周期函数是谁调用的</h4><p>声明周期函数是由ActivityThread调度的，具体逻辑封装在Instrumentation类里面。具体读一下这两个类就好。</p>
<h4 id="Activity启动模式，启动过程"><a href="#Activity启动模式，启动过程" class="headerlink" title="Activity启动模式，启动过程"></a>Activity启动模式，启动过程</h4><p>单独开了一篇博客<a href="http://blog.huangyuanlove.com/2018/07/26/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/#more">http://blog.huangyuanlove.com/2018/07/26/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/#more</a></p>
<h4 id="View点击事件分发流程"><a href="#View点击事件分发流程" class="headerlink" title="View点击事件分发流程"></a>View点击事件分发流程</h4><p>View事件分发：<a href="http://blog.huangyuanlove.com/2018/07/29/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/#more">http://blog.huangyuanlove.com/2018/07/29/View事件分发/#more</a></p>
<h4 id="View绘制过程"><a href="#View绘制过程" class="headerlink" title="View绘制过程"></a>View绘制过程</h4><p>View绘制过程：<a href="http://blog.huangyuanlove.com//2018/07/29/View%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B/#more">http://blog.huangyuanlove.com//2018/07/29/View绘制过程/#more</a></p>
<h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><p>Android的消息机制:  <a href="http://blog.huangyuanlove.com/2017/03/23/Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/#more">http://blog.huangyuanlove.com/2017/03/23/Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/#more</a></p>
<h4 id="省电优化"><a href="#省电优化" class="headerlink" title="省电优化"></a>省电优化</h4><p>不打扰系统休眠（不监听电量变化等，三方的可以hook  oop  hook住oncreat）<br>不做不必要的动作（界面后台要停止动画）</p>
<h4 id="广播的底层实现（binder）"><a href="#广播的底层实现（binder）" class="headerlink" title="广播的底层实现（binder）"></a>广播的底层实现（binder）</h4><p>Android 广播 ：<a href="http://blog.huangyuanlove.com/2018/07/31/Android%E5%B9%BF%E6%92%AD/">http://blog.huangyuanlove.com/2018/07/31/Android%E5%B9%BF%E6%92%AD/</a></p>
<h3 id="计算机网络相关："><a href="#计算机网络相关：" class="headerlink" title="计算机网络相关："></a>计算机网络相关：</h3><h4 id="websocket为什么能保持长连接"><a href="#websocket为什么能保持长连接" class="headerlink" title="websocket为什么能保持长连接"></a>websocket为什么能保持长连接</h4><h4 id="http、tcp-x2F-udp、tcp怎么解决拥塞、滑动窗口、udp"><a href="#http、tcp-x2F-udp、tcp怎么解决拥塞、滑动窗口、udp" class="headerlink" title="http、tcp&#x2F;udp、tcp怎么解决拥塞、滑动窗口、udp"></a>http、tcp&#x2F;udp、tcp怎么解决拥塞、滑动窗口、udp</h4><p>这个可以看谢希仁的《计算机网络》第六版，tcp:<a href="http://blog.huangyuanlove.com/2017/07/03/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/#more">http://blog.huangyuanlove.com/2017/07/03/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/#more</a> 这里简单的记录了一下比较重要的东西。</p>
<h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><p>加固原理 加的什么壳<br>kt var  val区别  when中的 is  in</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>项目重构记录</title>
    <url>/2018/05/24/%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>总结一下在新公司一个月来学到的东西吧。公司的项目采用Native+RN进行开发，前两周简单的了解了一下项目结构，写了一些自动打包的脚本。后两周大致学习了一下RN，然后就是调整项目结构，做重构。</p>
<span id="more"></span>
<p>一些简单的记录，</p>
<h5 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h5><ol>
<li>主工程module下的插件是 <blockquote>
<p>apply plugin: ‘com.android.application’</p>
</blockquote>
</li>
</ol>
<p>library中的插件是</p>
<blockquote>
<p>apply plugin: ‘com.android.library’</p>
</blockquote>
<ol start="2">
<li><p>在library module中，生成的R文件中的变量没有被final修饰，所以在<code>switch case</code>中需要改一下写法，比如改成<code>if else</code>。</p>
</li>
<li><p>ButterKnife中注解@bind中要求参数是final类型，所以在library中这个注解也不好用，作者给出了解决方案。</p>
</li>
<li><p>library module中不能有applicationId。</p>
</li>
</ol>
<h5 id="改动记录"><a href="#改动记录" class="headerlink" title="改动记录"></a>改动记录</h5><p>涉及到源代码的部分没有公开。</p>
<ol>
<li>将原项目中所有library依赖移动到<code>BaseApp</code>文件夹下,统一由一个git子模块引用。，所以需要在工程根目录下的<code>setting.gradle</code>中修改<code>include</code>路径<blockquote>
<p>include  ‘:base’</p>
</blockquote>
</li>
</ol>
<p>改为</p>
<blockquote>
<p>include  ‘:BaseApp:base’</p>
</blockquote>
<p>library中依赖的其他library也需要做修改(路径前添加<code>:BaseApp</code> )，如<code>RiskControlSdk</code>中<code>dependencies</code>中</p>
<blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">releaseCompile project(<span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;BaseComponents&#x27;</span>, <span class="hljs-attr">configuration:</span> <span class="hljs-string">&#x27;release&#x27;</span>)<br>debugCompile project(<span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;:BaseComponents&#x27;</span>, <span class="hljs-attr">configuration:</span> <span class="hljs-string">&#x27;debug&#x27;</span>)<br></code></pre></td></tr></table></figure>
</blockquote>
<p>改为</p>
<blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">releaseCompile project(<span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;:BaseApp:BaseComponents&#x27;</span>, <span class="hljs-attr">configuration:</span> <span class="hljs-string">&#x27;release&#x27;</span>)<br>debugCompile project(<span class="hljs-attr">path:</span> <span class="hljs-string">&#x27;:BaseApp:BaseComponents&#x27;</span>, <span class="hljs-attr">configuration:</span> <span class="hljs-string">&#x27;debug&#x27;</span>)<br></code></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li><p>原app module(现base)中用到<code>butterknife</code>，在@bind注解要求参数是final类型，但是在library项目中，生成的R文件中的id不是final。<br><code>butterknife</code>作者给出类解决办法:升级<code>butterknife</code>到8.8.1，在library中的<code>build.gradle</code>添加<code>apply plugin: &#39;com.jakewharton.butterknife&#39;</code>插件，用于生成<code>R2</code>文件，将原来的<code>R.id.xxx</code>改为<code>R2.id.xxx</code>。同理，在<code>switch case</code>中用R.id的地方也要做相应修改。参考 <a href="https://github.com/JakeWharton/butterknife">https://github.com/JakeWharton/butterknife</a></p>
</li>
<li><p>将gradle依赖、某些appkey在根目录下的<code>config.gradle</code>中配置<br>在项目根目录下新建<code>config.gradle</code>文件，用来存放公共配置，如</p>
</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">ext &#123;<br>	url = <span class="hljs-string">&quot;https://test.test.com&quot;</span><br>	UMENG_APPKEY = <span class="hljs-string">&quot;*****&quot;</span><br>	UMENG_MESSAGE_SECRET = <span class="hljs-string">&quot;*******&quot;</span><br>	WEIXIN_APP_ID = <span class="hljs-string">&quot;******&quot;</span><br>	WEIXIN_APP_SECRET = <span class="hljs-string">&quot;********&quot;</span><br>	android = [<br>		<span class="hljs-symbol">compileSdkVersion:</span> <span class="hljs-number">25</span>,<br>		<span class="hljs-symbol">buildToolsVersion:</span> <span class="hljs-string">&quot;25.0.2&quot;</span>,<br>		<span class="hljs-attr">applicationId    :</span> <span class="hljs-string">&quot;xxxxx&quot;</span>,<br>		<span class="hljs-attr">minSdkVersion    :</span> <span class="hljs-number">16</span>,<br>		<span class="hljs-attr">targetSdkVersion :</span> <span class="hljs-number">22</span>,<br>		<span class="hljs-attr">versionCode      :</span> <span class="hljs-number">120</span>,<br>		<span class="hljs-attr">versionName      :</span> <span class="hljs-string">&quot;1.2.0&quot;</span>,<br>	]<br>	dependencies = [<br>		<span class="hljs-string">&quot;appcompat-v7&quot;</span>                : <span class="hljs-string">&quot;com.android.support:appcompat-v7:25.0.0&quot;</span>,<br>		<span class="hljs-string">&quot;support-v4&quot;</span>                  : <span class="hljs-string">&#x27;com.android.support:support-v4:25.0.0&#x27;</span>,<br>		<span class="hljs-string">&quot;support-v13&quot;</span>                 : <span class="hljs-string">&#x27;com.android.support:support-v13:23.4.0&#x27;</span>,<br>		<span class="hljs-string">&quot;support-annotations&quot;</span>         : <span class="hljs-string">&#x27;com.android.support:support-annotations:23.4.0&#x27;</span>,<br>		<span class="hljs-string">&quot;butterknife&quot;</span>                 : <span class="hljs-string">&quot;com.jakewharton:butterknife:8.8.1&quot;</span>,<br>		<span class="hljs-string">&quot;xutils&quot;</span>                      : <span class="hljs-string">&#x27;org.xutils:xutils:3.5.0&#x27;</span>,<br>		<span class="hljs-string">&quot;junit&quot;</span>                       : <span class="hljs-string">&#x27;junit:junit:4.12&#x27;</span>,<br>		<span class="hljs-string">&quot;react-native&quot;</span>                : <span class="hljs-string">&quot;com.facebook.react:react-native:0.49.5&quot;</span>,<br>		<span class="hljs-string">&quot;subsampling-scale-image-view&quot;</span>: <span class="hljs-string">&#x27;com.davemorrissey.labs:subsampling-scale-image-view:3.5.0&#x27;</span>,<br>		<span class="hljs-string">&quot;eventbus&quot;</span>                    : <span class="hljs-string">&#x27;de.greenrobot:eventbus:2.4.0&#x27;</span>,<br>		<span class="hljs-string">&quot;okio&quot;</span>                        : <span class="hljs-string">&#x27;com.squareup.okio:okio:1.8.0&#x27;</span>,<br>		<span class="hljs-string">&quot;universal-image-loader&quot;</span>      : <span class="hljs-string">&#x27;com.nostra13.universalimageloader:universal-image-loader:1.9.5&#x27;</span>,<br>		<span class="hljs-string">&quot;multidex&quot;</span>                    : <span class="hljs-string">&#x27;com.android.support:multidex:1.0.1&#x27;</span>,<br>		<span class="hljs-string">&quot;nohttp&quot;</span>:<span class="hljs-string">&#x27;com.yanzhenjie.nohttp:nohttp:1.1.4&#x27;</span>,<br>	]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用时注意事项：</p>
<ol>
<li>现在library中的所有appkey(三方)相关的，都由工程根目录下的配置文件<code>config.gradle</code>提供，然后添加到该module的<code>BuildConfig.java</code>文件中，代码中从<code>BuildConfig.java</code>文件中引用</li>
</ol>
<p>在<code>config.gradle</code>文件中添加一个三方key值 </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">ext&#123;<br>	UMENG_APPKEY = <span class="hljs-string">&quot;************&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在module中的<code>build.grale</code>引用</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> UMENG_APPKEY = rootProject.ext.UMENG_APPKEY<br></code></pre></td></tr></table></figure>

<p>加入到该module的<code>BuildConfig.java</code>文件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">defaultConfig&#123;<br>	buildConfigField <span class="hljs-string">&quot;String&quot;</span>, <span class="hljs-string">&quot;umeng_analytics_key&quot;</span>, <span class="hljs-string">&quot;\&quot;&quot;</span> + UMENG_APPKEY + <span class="hljs-string">&quot;\&quot;&quot;</span><br>	&#125;<br></code></pre></td></tr></table></figure>

<p>代码中引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">BuildConfig.umeng_analytics_key<br></code></pre></td></tr></table></figure>
<p>这里需要注意的是，import该文件的时候，是从该module的<code>manifest.xml</code>中的跟标签的<code>package</code>属性所指向的包名导入的，如</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">	<span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.huangyuanlove.test&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>则<code>BuildConfig.java</code>文件的导入路径为 <code>import com.huangyuanlove.test;</code><br>2. 所有使用gradle依赖的三方全部放在根目录的<code>config.gradle</code>文件夹下，其他module引用时可参考下面的配置。如</p>
<p>需要添加一个新的依赖，在根目录下的 <code>config.gradle</code>文件中</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">ext&#123;<br>	dependencies=[<br>		<span class="hljs-string">&quot;newDependency&quot;</span>:<span class="hljs-string">&quot;dependency&quot;</span>,<br>	]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在其他module中引用</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">def</span> dependency = rootProject.ext.dependencies<br>dependencies &#123;<br>	compile dependency[<span class="hljs-string">&quot;newDependency&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-canvas-刮刮乐</title>
    <url>/2024/08/24/%E9%B8%BF%E8%92%99-canvas-%E5%88%AE%E5%88%AE%E4%B9%90/</url>
    <content><![CDATA[<p>Android 中 canvas 能画出来的东西鸿蒙的 canvas 还画不了，不大可能吧？有个朋友问鸿蒙应用中想实现刮刮乐效果，应该咋画？这个问题，你能在 Android 上用 canvas 画出来，在鸿蒙里面用 canvas 画不出来？还是 api 不熟悉吧？</p>
<span id="more"></span>

<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>这个就比较简单了。你先这样这样，然后再那样那样就行了。<br>好吧， 正式点，和Android没什么区别：<br>底层放一张图片或者其他什么控件都行。上面叠一层灰色canvas，手指滑动时记录一下路径，将路径上的颜色去除就行了。和手写签名唯一的区别：签名是按路径添加，刮刮乐是按路径移除。<br>会了的就不用往下看了，太长不想看的直接拖到最后看源码</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>和<code>Android</code>中的<code>PorterDuff.Mode</code>类似，在鸿蒙中也提供了11种不同的画布复合模式：</p>
<ol>
<li>source-over: (Default) Draws a new drawing on top of an existing canvas context. 在现有的画布上方绘制新的图形。也是默认行为。</li>
<li>source-in: The new drawing is drawn only where the new drawing overlaps the target canvas.Everything else is transparent.新的图形只在与目标画布重叠的区域绘制，其他区域为透明。</li>
<li>source-out: Draws a new drawing where it does not overlap with the existing canvas content. 在不与现有画布内容重叠的区域绘制新的图形。</li>
<li>source-atop: The new drawing is drawn only where it overlaps the content of the existing canvas. 新的图形只在与现有画布内容重叠的区域绘制。</li>
<li>destination-over: Draws a new graphic behind the existing canvas content. 在现有画布内容后面绘制新的图形。</li>
<li>destination-in: Existing canvas content remains where the new drawing overlaps the existing canvas content.Everything else is transparent.仅在新的图形与现有画布内容重叠的区域保留现有画布内容，其他区域为透明。</li>
<li>destination-out: Existing content remains where the new drawing does not overlap. 仅在新的图形不与现有画布内容重叠的区域保留现有内容。</li>
<li>destination-atop: The existing canvas retains only the part that overlaps with the new drawing,which is drawn behind the canvas content. 现有画布仅保留与新的图形重叠的部分，并位于画布内容后面绘制。</li>
<li>lighter: The color of two overlapping shapes is determined by adding the color values. 两个重叠形状的颜色通过相加颜色值来确定。</li>
<li>copy: Only new graphics are displayed. 仅显示新的图形。</li>
<li>xor: In the image, those overlaps and other places outside of the normal drawing are transparent. 在图像中，重叠部分和正常绘制范围之外的其他区域为透明。</li>
</ol>
<p>看简介也可能是一脸懵，我们直接上代码看效果。先画一个红色的圆，之后设置<code>globalCompositeOperation</code>为不同的值，再画一个蓝色的正方形，直接看效果。<br>具体点将，就是红色圆形半径为画布的四分之一，圆心也在画布的四分之一处。蓝色正方形边长是圆形直径，左上角与圆心重合。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CompositeOperationView</span>&#123;<br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">compositeOperation</span>:<span class="hljs-built_in">string</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">//获取画布宽高</span><br>      <span class="hljs-keyword">let</span> canvasWidth = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">width</span><br>      <span class="hljs-keyword">let</span> canvasHeight = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">height</span><br><br>      <span class="hljs-comment">//计算圆心</span><br>      <span class="hljs-keyword">let</span> circleX = canvasWidth/<span class="hljs-number">4</span><br>      <span class="hljs-keyword">let</span> circleY = canvasHeight/<span class="hljs-number">4</span>;<br>      <span class="hljs-keyword">let</span> circleCenter = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(circleX,circleY)<br><br>      <span class="hljs-comment">//画红色圆形</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#FF0000&quot;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(circleCenter,circleCenter,circleCenter,<span class="hljs-number">0</span>,<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>()<br><br>      <span class="hljs-comment">//设置画布复合操作方式</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">compositeOperation</span><br><br>      <span class="hljs-comment">//画蓝色正方形</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#0000FF&quot;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fillRect</span>(circleCenter, circleCenter, circleCenter*<span class="hljs-number">2</span>, circleCenter*<span class="hljs-number">2</span>)<br><br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span>&#123;<span class="hljs-title class_">CompositeOperationView</span>&#125;<br></code></pre></td></tr></table></figure>

<p>这里一共有11种复合操作方式，为了方便对比，我们把这11种方式都画在同一个屏幕上。<br>因此，在<code>CompositeOperationView</code>中，我们将<code>compositeOperation</code>使用<code>@Prop</code>修饰，由父级控件传进来。  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CanvasCompositeOperationPage</span>&#123;<br>  <span class="hljs-attr">compositeOperation</span>:<span class="hljs-built_in">string</span>[]=[<span class="hljs-string">&quot;source-over&quot;</span>,<span class="hljs-string">&quot;source-in&quot;</span>,<span class="hljs-string">&quot;source-out&quot;</span>,<span class="hljs-string">&quot;source-atop&quot;</span>,<span class="hljs-string">&quot;destination-over&quot;</span>,<span class="hljs-string">&quot;destination-in&quot;</span>,<span class="hljs-string">&quot;destination-out&quot;</span>,<span class="hljs-string">&quot;destination-atop&quot;</span>,<span class="hljs-string">&quot;lighter&quot;</span>,<span class="hljs-string">&quot;copy&quot;</span>,<span class="hljs-string">&quot;xor&quot;</span>]<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Flex</span>(&#123; <span class="hljs-attr">direction</span>: <span class="hljs-title class_">FlexDirection</span>.<span class="hljs-property">Row</span>, <span class="hljs-attr">wrap</span>: <span class="hljs-title class_">FlexWrap</span>.<span class="hljs-property">Wrap</span>, &#125;)&#123;<br>      <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">compositeOperation</span>,<span class="hljs-function">(<span class="hljs-params">item:<span class="hljs-built_in">string</span></span>)=&gt;</span>&#123;<br>        <span class="hljs-title class_">Column</span>()&#123;<br>          <span class="hljs-title class_">Text</span>(item)<br>          <span class="hljs-title class_">CompositeOperationView</span>(&#123;<span class="hljs-attr">compositeOperation</span>:item&#125;).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;80%&quot;</span>)<br>        &#125;.<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;30%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;20%&quot;</span>)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这里我们用<code>ForEach</code>循环来进行绘制，这里就不在过多介绍，不清楚的可以去看鸿蒙开发文档中的指南。<br>我们最终得到这样的一张图<br><img src="/image/HarmonyOS/compositeOperation.png"><br>这就一目了然了，我们可以选用<code>destination-out</code>来实现刮刮乐效果</p>
<h2 id="刮刮乐效果"><a href="#刮刮乐效果" class="headerlink" title="刮刮乐效果"></a>刮刮乐效果</h2><p>就和文章开始说的一样，先放一张图，然后canvas绘制蒙层，画布复合操作模式为<code>destination-out</code>，记录手指移动路径，绘制到canvas上，结束。<br>详细一点就是：</p>
<ol>
<li>外层Stack层叠布局，子控件先放一个Image然后再放一个Canvas</li>
<li>Canvas上我们可以绘制上纯颜色，也可以绘制另外一张图片</li>
<li>画布复合操作模式为<code>destination-out</code>，</li>
<li>在Canvas的<code>onTouch</code>事件中，当<code>TouchType.Move</code>时，在当前坐标画一个小圆。</li>
<li>结束</li>
</ol>
<p>按照这个思路，整体代码就是这样的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Preview</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">ScratchOffView</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">path</span>: <span class="hljs-title class_">Path2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Stack</span>() &#123;<br>      <span class="hljs-title class_">Image</span>($r(<span class="hljs-string">&quot;app.media.cat&quot;</span>))<br>      <span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> canvasWidth = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">width</span><br>        <span class="hljs-keyword">let</span> canvasHeight = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">height</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#aaf7f7f7&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvasWidth, canvasHeight)<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#00000000&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#000000&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">globalCompositeOperation</span> = <span class="hljs-string">&quot;destination-out&quot;</span><br><br><br>      &#125;).<span class="hljs-title function_">onTouch</span>(<span class="hljs-function">(<span class="hljs-params">event: TouchEvent</span>) =&gt;</span> &#123;<br><br>        <span class="hljs-keyword">let</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>        <span class="hljs-keyword">let</span> prex = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">let</span> prey = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">switch</span> (event.<span class="hljs-property">type</span>) &#123;<br>          <span class="hljs-keyword">case</span> <span class="hljs-title class_">TouchType</span>.<span class="hljs-property">Down</span>:<br>            prex = event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">x</span><br>            prey = event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">y</span><br>            path.<span class="hljs-title function_">moveTo</span>(prex, prey)<br>            <span class="hljs-keyword">break</span><br>          <span class="hljs-keyword">case</span> <span class="hljs-title class_">TouchType</span>.<span class="hljs-property">Move</span>:<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">path</span>.<span class="hljs-title function_">moveTo</span>(event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">x</span>, event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">y</span>)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">path</span>.<span class="hljs-title function_">arc</span>(event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">x</span>, event.<span class="hljs-property">touches</span>[<span class="hljs-number">0</span>].<span class="hljs-property">y</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>*<span class="hljs-number">2</span>, <span class="hljs-literal">false</span>)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">path</span>)<br>            <br>            <span class="hljs-keyword">break</span><br>          <span class="hljs-keyword">case</span> <span class="hljs-title class_">TouchType</span>.<span class="hljs-property">Up</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;)<br>    &#125;.<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>)<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后放张效果图吧</p>
<p><img src="/image/HarmonyOS/ScratchOffView.gif"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实canvas并没有那么麻烦那么困难，我们只要熟悉了鸿蒙canvas的api，在Android上能实现的功能，鸿蒙能基本都能实现。比如手写签名、贝塞尔曲线、图片翻转、九宫格图片等等。<br>并不像我们想象中的那么困难，总之，先动手rua代码试试呗</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙--Canvas 图片滑动验证</title>
    <url>/2024/11/28/%E9%B8%BF%E8%92%99-Canvas-%E5%9B%BE%E7%89%87%E6%BB%91%E5%8A%A8%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>群里有朋友问图片滑块验证码怎么做，就是一张图上扣出来一块，然后拖动这一小块完成拼图。<br>第一个想法就是偷懒一下：直接让设计在图片上抠出来一小块，把这两个图片和抠图的坐标一块下发，用Image或者canvas自己绘制一下，监听一下手指移动，当手指抬起的时候，如果移动的坐标和抠图的坐标误差在指定范围内，就算成功。<br>后来说Android那边是自己处理的，下发整张图片，然后客户端自己抠图，自己处理。<br>Android能做的，鸿蒙应该也能做，这时候就应该掏出来Canvas怼一波了</p>
<span id="more"></span>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>两个Canvas，一个使用<code>drawImage</code>画整张图片，画出来后，随机两个坐标值使用<code>getImageData</code>获取指定位置的图片内容。然后在这个区域绘制上边框或者填充颜色，告诉用户获取的是这个区域的内容。想上难度的话，不提示这个截取位置也行。<br>在另外一个Canvas上使用<code>putImageData</code>将图片绘制出来，绑定一下移动手势监听，然后不断更新绘制图片的坐标。当抬起手指的时候，对比一下移动的坐标和抠图的坐标，在允许的范围内，判定为成功。<br>结束。打完收工。完结撒花。</p>
<p><img src="/image/HarmonyOS/slide_code.gif" alt="image.png">  </p>
<h2 id="绘制形状方式详细解释"><a href="#绘制形状方式详细解释" class="headerlink" title="绘制形状方式详细解释"></a>绘制形状方式详细解释</h2><p>先看下面不需要处理抠图的，这个简单点，我们循序渐进。</p>
<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>两个Canvas，需要两个<code>CanvasRenderingContext2D</code>分别绘制两个Canvas上的内容。<br>一个能接受的误差值。<br>随机出来的抠图的横纵坐标。<br>抠图的大小。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering2</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><span class="hljs-comment">//允许的误差</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">diffInterval</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span> <br><span class="hljs-comment">//随机抠图的横坐标</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">clip_start_x</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span><br><span class="hljs-comment">//随机抠图的纵坐标</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">clip_start_y</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span><br><span class="hljs-comment">//抠图的宽度</span><br><span class="hljs-keyword">private</span> clip_image_width = <span class="hljs-number">120</span><br><span class="hljs-comment">//抠图的高度</span><br><span class="hljs-keyword">private</span> clip_image_height = <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure>

<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>这个没啥好说的，Stack里面摞两个Canvas，底部的Canvas画整个图，上面的Canvas画形状。</p>
<h3 id="整图Canvas"><a href="#整图Canvas" class="headerlink" title="整图Canvas"></a>整图Canvas</h3><p>这里使用的本地图片，理论上讲，使用网络图片应该也能处理。<br>随机坐标时，注意减去抠图的宽度，否则万一随机出来的坐标在绘制完形状之后超出的图片范围就好玩了。<br>这里随机之后绘制了一个三角形。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>   <span class="hljs-comment">//这里用的本地图片</span><br>   <span class="hljs-keyword">let</span> <span class="hljs-attr">imageBitMap</span>: <span class="hljs-title class_">ImageBitmap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageBitmap</span>(<span class="hljs-string">&quot;pages/playground/cat.webp&quot;</span>)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">drawImage</span>(imageBitMap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>   hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;imageBitMap width --&gt; &#x27;</span> + imageBitMap.<span class="hljs-property">width</span>)<br>   hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;imageBitMap height --&gt; &#x27;</span> + imageBitMap.<span class="hljs-property">height</span>)<br><br>   <span class="hljs-comment">//随机两个坐标，注意不要超出图片范围</span><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (imageBitMap.<span class="hljs-property">width</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>))<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (imageBitMap.<span class="hljs-property">height</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>))<br><br>   hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;clip_start_x --&gt; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>)<br>   hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;clip_start_y --&gt; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&#x27;#FFFFFF&#x27;</span><br>   <span class="hljs-comment">//在对应的区域绘制标识，这里画了个三角形，想画其他的自己调整就好</span><br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">moveTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span> / <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span> / <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br> &#125;)<br></code></pre></td></tr></table></figure>

<h3 id="需要滑动的形状"><a href="#需要滑动的形状" class="headerlink" title="需要滑动的形状"></a>需要滑动的形状</h3><p>我们拿到了随机的坐标后，在新的Canvas上绘制相同的形状。<br>这里需要监听手指的滑动，我们使用了<code>priorityGesture</code>来绑定<code>PanGesture</code>。注意这里<strong>滑动最小距离为5vp时识别成功</strong>。<br>这里我们限制了只能横向滑动。想加点难度的话，可以在横纵方向上都能滑动。<br>最后在<code>onActionEnd</code>的时候判断一下移动的坐标是否满足条件</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>&#125;)<br>  <span class="hljs-comment">//绑定优先识别手势</span><br>  .<span class="hljs-title function_">priorityGesture</span>(<br>    <span class="hljs-comment">//平移手势，滑动最小距离为5vp时识别成功。</span><br>    <span class="hljs-title class_">PanGesture</span>()<br>      .<span class="hljs-title function_">onActionStart</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>      &#125;)<br>      .<span class="hljs-title function_">onActionUpdate</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//重置一下画布</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">reset</span>()<br><br>        <span class="hljs-comment">//绘制形状，和整图canvas中的形状、大小一致</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">moveTo</span>(event.<span class="hljs-property">offsetX</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>/<span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">lineTo</span>(event.<span class="hljs-property">offsetX</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">lineTo</span>(event.<span class="hljs-property">offsetX</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">lineTo</span>(event.<span class="hljs-property">offsetX</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>/<span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Pink</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">stroke</span>()<br><br>      &#125;)<br>      .<span class="hljs-title function_">onActionEnd</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>        hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView&#x27;</span>, <span class="hljs-string">`onActionEnd <span class="hljs-subst">$&#123;event.offsetX.toString()&#125;</span>`</span>)<br>        <span class="hljs-comment">//判定是否成功</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(event.<span class="hljs-property">offsetX</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>) &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">diffInterval</span>) &#123;<br>          promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;验证成功&#x27;</span> &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;验证失败&#x27;</span> &#125;)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">reset</span>()<br>        &#125;<br>      &#125;)<br>  )<br></code></pre></td></tr></table></figure>

<p>这种是最简单的，不需要处理图片，只需要绘制形状就好了</p>
<h2 id="需要处理图片的方式"><a href="#需要处理图片的方式" class="headerlink" title="需要处理图片的方式"></a>需要处理图片的方式</h2><p>比起上面这种，我们只需要多定义一个ImageData就好了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering2</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">diffInterval</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">clip_start_x</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">clip_start_y</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span><br><span class="hljs-keyword">private</span> clip_image_width = <span class="hljs-number">120</span><br><span class="hljs-keyword">private</span> clip_image_height = <span class="hljs-number">120</span><br><span class="hljs-keyword">private</span> imageData?: <span class="hljs-title class_">ImageData</span><br></code></pre></td></tr></table></figure>

<h3 id="处理抠图"><a href="#处理抠图" class="headerlink" title="处理抠图"></a>处理抠图</h3><p>在绘制整图的Canvas上调用<code>getImageData</code>获取一下抠出来的图片内容就好了。<br>由于ImageData是个正方形，我们这里需要处理成三角形，我没有找到很好的方法，只能对ImageData.data属性进行处理，它是一维数组，保存了相应的颜色数据，数据值范围为0到255。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">imageBitMap</span>: <span class="hljs-title class_">ImageBitmap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageBitmap</span>(<span class="hljs-string">&quot;pages/playground/cat.webp&quot;</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">drawImage</span>(imageBitMap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;imageBitMap width --&gt; &#x27;</span> + imageBitMap.<span class="hljs-property">width</span>)<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;imageBitMap height --&gt; &#x27;</span> + imageBitMap.<span class="hljs-property">height</span>)<br><br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (imageBitMap.<span class="hljs-property">width</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>))<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (imageBitMap.<span class="hljs-property">height</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>))<br><br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;clip_start_x --&gt; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>)<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView2&#x27;</span>, <span class="hljs-string">&#x27;clip_start_y --&gt; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">getImageData</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br><br>  <span class="hljs-comment">//在对应的区域绘制标识</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&#x27;#66FFFFFF&#x27;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">moveTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span> / <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_height</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">lineTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_image_width</span> / <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>()<br><br>  <span class="hljs-comment">//将ImageData处理成三角形</span><br>  <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>)&#123;<br>    <span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>.<span class="hljs-property">width</span> * <span class="hljs-number">4</span><br>    <span class="hljs-keyword">let</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>.<span class="hljs-property">height</span><br>    <span class="hljs-keyword">let</span> rate = width / height<br>    <span class="hljs-keyword">let</span> widthCenter = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(width / <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) &#123;<br>      <span class="hljs-comment">//第几行</span><br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; width; j++) &#123;<br>        <span class="hljs-comment">//第几列</span><br>        <span class="hljs-keyword">if</span> (j &lt; widthCenter - rate * i / <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>.<span class="hljs-property">data</span>[i * width +j] = <span class="hljs-number">0</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; widthCenter + rate * i / <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>.<span class="hljs-property">data</span>[i * width +j] = <span class="hljs-number">0</span><br>        &#125;<br><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="绘制抠出来的图"><a href="#绘制抠出来的图" class="headerlink" title="绘制抠出来的图"></a>绘制抠出来的图</h3><p>这个就更简单了，相同的绑定手势方法，相同的判定方法。<br>唯一的变化就是在<code>onActionUpdate</code>回调中使用<code>putImageData</code>绘制图片</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  &#125;)<br>    .<span class="hljs-title function_">priorityGesture</span>(<br>      <span class="hljs-title class_">PanGesture</span>()<br>        .<span class="hljs-title function_">onActionStart</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>        &#125;)<br>        .<span class="hljs-title function_">onActionUpdate</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>          hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView&#x27;</span>, event.<span class="hljs-property">offsetX</span>.<span class="hljs-title function_">toString</span>())<br>          <br>          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">reset</span>()<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">putImageData</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">imageData</span>, event.<span class="hljs-property">offsetX</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_y</span>)<br>          &#125;<br>        &#125;)<br>        .<span class="hljs-title function_">onActionEnd</span>(<span class="hljs-function">(<span class="hljs-params">event: GestureEvent</span>) =&gt;</span> &#123;<br>          hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;SlideVerificationView&#x27;</span>, <span class="hljs-string">`onActionEnd <span class="hljs-subst">$&#123;event.offsetX.toString()&#125;</span>`</span>)<br><br>          <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(event.<span class="hljs-property">offsetX</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">clip_start_x</span>) &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">diffInterval</span>) &#123;<br>            promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;验证成功&#x27;</span> &#125;)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;验证失败&#x27;</span> &#125;)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering2</span>.<span class="hljs-title function_">reset</span>()<br>          &#125;<br>        &#125;)<br>    )<br></code></pre></td></tr></table></figure>

<p>到此，我们就完成了简单的滑动图片验证的功能</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体的流程上面也说过了，这里就不再赘述。<br>我们还可以加大点难度，比如在抠图后不在原图上提示范围，让使用者自己找。<br>比如我们还可以将抠出来的图镜像一下，让使用者自己找。<br>比如我们还可以将抠出来的图隔像素点抽样一下。<br>比如我们还可以将抠出来的图中的像素调整一下颜色。<br>。。。</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙--canvas 实现波浪效果</title>
    <url>/2024/03/27/%E9%B8%BF%E8%92%99-canvas-%E5%AE%9E%E7%8E%B0%E6%B3%A2%E6%B5%AA%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Android 中 canvas 能画出来的东西鸿蒙的 canvas 还画不了，不大可能吧？有个朋友问鸿蒙应用中想实现波浪效果，应该咋画？这个问题，你能在 Android 上用 canvas 画出来，在鸿蒙里面用 canvas 画不出来？还是 api 不熟悉吧？</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>波浪效果嘛，首先想到的是正弦、余弦函数、贝塞尔曲线，还有一个傅里叶变换，不过这个有点搞不定。这里选择使用贝塞尔曲线，因为之前在 Android 中画过，应该可以很丝滑的迁移过来<br>先复习一下在 Android 中怎么实现：<a href="https://blog.huangyuanlove.com/2019/01/20/%E8%87%AA%E5%AE%9A%E4%B9%89View-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E3%80%81Shader/">https://blog.huangyuanlove.com/2019/01/20/%E8%87%AA%E5%AE%9A%E4%B9%89View-%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E3%80%81Shader/</a></p>
<p>确认起始点，确认终点，计算控制点，然后调用 api 划线，最后填充一下就好了。<br>怎么动起来？Android 这边用的动画，其实用 handler 或者其他东西搞个定时更新也行。<br>先看效果图<br><img src="/image/HarmonyOS/wave.gif" alt="wave.gif">  </p>
<p>看下鸿蒙对应的 api，目前开放的最新的HarmonyOS文档是 3.1&#x2F;4.0的，对应地址是这个 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-canvasrenderingcontext2d-0000001478181441-V3#ZH-CN_TOPIC_0000001573928937__quadraticcurveto">https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-canvasrenderingcontext2d-0000001478181441-V3#ZH-CN_TOPIC_0000001573928937__quadraticcurveto</a><br>目前开放的最新的 OpenHarmony 文档是4.0 的，对应地址在这里 <a href="https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/ui/arkts-drawing-customization-on-canvas.md/#%E7%94%BB%E5%B8%83%E7%BB%84%E4%BB%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/ui/arkts-drawing-customization-on-canvas.md/#%E7%94%BB%E5%B8%83%E7%BB%84%E4%BB%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95</a><br>步骤都差不多，只不过鸿蒙中没有画笔的概念，需要对<code>CanvasRenderingContext2D</code>对象进行操作设置，包括设置线条颜色、线条宽度、图型填充颜色等。<br>想要画线、画出各种形状，可以直接操作<code>CanvasRenderingContext2D</code>对象，也可以创建<code>Path2D</code>对象进行操作。其余 api 可以查看对应的文档。  </p>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>这还有啥好设计的，直接<del>抄</del>移植 Android 上面的实现就好了<br>由于需要动起来，为了避免移动后左右有空白，这里需要<strong>多画一个波浪</strong></p>
<p><img src="/image/HarmonyOS/wave.png" alt="WX20240108-233545@2x.png">  </p>
<p>这里需要注意的是，我们需要上面这条蓝色的线，而不是下面这条绿色的。</p>
<p>在 Android 中画二阶贝塞尔曲线有两个 api,一个是<br><code>public void rQuadTo(float dx1, float dy1, float dx2, float dy2)</code><br>这个表示的是控制点和终点相对于上一个控制点和终点的偏移量<br>另外一个是<br><code>public void quadTo(float x1, float y1, float x2, float y2)</code><br>这个表示是控制点和终点的绝对坐标值<br>但在鸿蒙中没有找到对应的 api，我们可以自己计算一下：这里的控制点的横坐标是起点和终点的中间值，控制点的纵坐标取的是波浪高度<br>所以上面两条线的画法是这样的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;30%&quot;</span>)<br>        .<span class="hljs-title function_">onAreaChange</span>(<span class="hljs-function">(<span class="hljs-params">oldValue,newValue</span>)=&gt;</span>&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#39d167&quot;</span><br><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#39d167&quot;</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">10</span><br>          <span class="hljs-keyword">let</span> canvasWidth = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">width</span>.<span class="hljs-title function_">toString</span>())<br>          <span class="hljs-keyword">let</span> canvasHeight = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">height</span>.<span class="hljs-title function_">toString</span>())<br><br>          <span class="hljs-keyword">let</span> waveWidth = canvasWidth/<span class="hljs-number">2</span><br>          <span class="hljs-keyword">let</span> waveHeight = <span class="hljs-number">100</span><br>          <span class="hljs-keyword">let</span> baseHeight =canvasHeight<br><br>          <span class="hljs-keyword">let</span> <span class="hljs-attr">path</span>:<span class="hljs-title class_">Path2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>          <br>          path.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">0</span>,baseHeight)<br>          <span class="hljs-comment">//波浪宽度是画布的一半，这里偷懒直接写了</span><br>          path.<span class="hljs-title function_">quadraticCurveTo</span>( waveWidth/<span class="hljs-number">2</span>,baseHeight-waveHeight ,waveWidth,baseHeight)<br>          path.<span class="hljs-title function_">quadraticCurveTo</span>(waveWidth+waveWidth/<span class="hljs-number">2</span>,  baseHeight-waveHeight ,canvasWidth,baseHeight)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>(path)<br><br><br>          path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>          baseHeight /=<span class="hljs-number">3</span><br>          path.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">0</span>,baseHeight)<br>          <span class="hljs-comment">//波浪宽度是画布的一半，这里偷懒直接写了</span><br>          path.<span class="hljs-title function_">quadraticCurveTo</span>( waveWidth/<span class="hljs-number">2</span>,baseHeight-waveHeight ,waveWidth,baseHeight)<br>          path.<span class="hljs-title function_">quadraticCurveTo</span>(waveWidth+waveWidth/<span class="hljs-number">2</span>,  baseHeight+waveHeight ,canvasWidth,baseHeight)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#1b91e0&quot;</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>(path)<br>          <br>        &#125;)<br></code></pre></td></tr></table></figure>


<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现也一样，直接<del>抄</del> 移植过来就好了，对应的 api 怎么用也搞定了，代码如下</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">WaveView</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasHeight</span>: <span class="hljs-built_in">number</span> = -<span class="hljs-number">1</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasWidth</span>: <span class="hljs-built_in">number</span> = -<span class="hljs-number">1</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-attr">dx</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span> <span class="hljs-comment">//最大值等于 waveWidth，每次移动的距离</span><br>  <span class="hljs-keyword">private</span> waveHeight = <span class="hljs-number">50</span> <span class="hljs-comment">//拍脑袋订的数值</span><br>  <span class="hljs-keyword">private</span> baseHeight = <span class="hljs-number">300</span> <span class="hljs-comment">//拍脑袋订的数值</span><br>  <span class="hljs-keyword">private</span> waveWidth = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">intervalTimer</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-title function_">drawWave</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span> += <span class="hljs-number">4</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span> = <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>)<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> / <span class="hljs-number">2</span><br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">path</span>: <span class="hljs-title class_">Path2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>    <span class="hljs-comment">//需要在屏幕外多画一个波浪，这里先将画笔移动到画布|屏幕外，记得加上动画的偏移量 dx</span><br>    path.<span class="hljs-title function_">moveTo</span>(-<span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span>)<br>    <span class="hljs-keyword">let</span> startX = -<span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span><span class="hljs-comment">//记录开始点的横坐标</span><br>    <span class="hljs-comment">//需要多画一个波浪，直接循环开始画就好了</span><br>    <span class="hljs-keyword">while</span> (startX &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">dx</span>) &#123;<br><br>      <span class="hljs-keyword">let</span> endY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span><br>      <span class="hljs-comment">//画向下和向上的波浪，全靠控制点的纵坐标控制波浪的上线</span><br>      path.<span class="hljs-title function_">quadraticCurveTo</span>(startX + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> / <span class="hljs-number">4</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveHeight</span>, startX + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span>/<span class="hljs-number">2</span>, endY)<br>      path.<span class="hljs-title function_">quadraticCurveTo</span>(startX + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> / <span class="hljs-number">4</span>*<span class="hljs-number">3</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveHeight</span>, startX + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span>, endY)<br>      <span class="hljs-comment">//画完一上一下这一组波浪后更新起始点坐标</span><br>      startX += <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span><br>    &#125;<br>    <span class="hljs-comment">//需要将波浪线下方的区域填满颜色，这里取巧圈起来一个框，使用 fill 方法填充</span><br>    path.<span class="hljs-title function_">lineTo</span>(startX ,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>) <span class="hljs-comment">//波浪线最右侧画一条到画布底部的垂线</span><br>    path.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">0</span> ,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>)<span class="hljs-comment">//画布底部的横线</span><br>    path.<span class="hljs-title function_">lineTo</span>(<span class="hljs-number">0</span> ,<span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveHeight</span>) <span class="hljs-comment">//波浪线最左侧到画布底部的垂线</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#39d167&quot;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#39d167&quot;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">10</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>(path)<br><br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>)<br>        .<span class="hljs-title function_">onAreaChange</span>(<span class="hljs-function">(<span class="hljs-params">oldValue, newValue</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">width</span>.<span class="hljs-title function_">toString</span>())<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">height</span>.<span class="hljs-title function_">toString</span>())<br><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">baseHeight</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> - <span class="hljs-number">300</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">waveWidth</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> / <span class="hljs-number">2</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawWave</span>()<br><br>        &#125;)<br>      <span class="hljs-title class_">Row</span>() &#123;<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;开始&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">intervalTimer</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">intervalTimer</span>)<br>          &#125;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">intervalTimer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawWave</span>()<br>          &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">10</span>)<br>        &#125;)<br>        <span class="hljs-title class_">Blank</span>().<span class="hljs-title function_">width</span>(<span class="hljs-number">15</span>)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;停止&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">intervalTimer</span> != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">intervalTimer</span>)<br>          &#125;<br>        &#125;)<br>      &#125;.<span class="hljs-title function_">margin</span>(&#123; <span class="hljs-attr">bottom</span>: <span class="hljs-number">10</span> &#125;)<br><br>    &#125;<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>上面就是完整的代码了，github 仓库在这里：<a href="https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/WaveView.ets">https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/WaveView.ets</a><br><a href="https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/WaveLinePage.ets">https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/WaveLinePage.ets</a></p>
<h3 id="进化"><a href="#进化" class="headerlink" title="进化"></a>进化</h3><p>稍微修改一下就可以做成其他效果<br>比如将<code>baseHeight</code>也用<code>@State</code>修饰一下，同时在定时器中更新一下，就可以实现注水效果<br>再将画布裁成圆形，就是一个简单的充电、内存加速球效果。再做点随机的粒子效果或者多画几条浅色的波浪线，效果就更好了</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-flutter-使用FlutterEntry的路由管理和参数传递_下</title>
    <url>/2025/06/10/%E9%B8%BF%E8%92%99-flutter-%E4%BD%BF%E7%94%A8FlutterEntry%E7%9A%84%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面两篇介绍了如何打开指定页面，并且传递对应的参数。这一篇中我们来看下在页面返回时，如何将数据传递给上一个页面。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>按照之前的介绍，我们在<code>flutter</code>打开<code>native</code>时，也是通过<code>methodChannel</code>调用原生的方法打开的对应页面，那么当原生页面返回的时候，也是会将数据放在<code>HMRouterPathCallback</code>回调中返回。当我们获取到对应的数据之后，可以通过<code>MethodResult</code>将数据返回给<code>flutter</code>。<br>当<code>flutter</code>页面返回时，需要先判断能不能由<code>flutter</code>进行返回，不能返回的话再通过<code>methodChannel</code>调用 <code>native</code>返回。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="native页面返回"><a href="#native页面返回" class="headerlink" title="native页面返回"></a>native页面返回</h3><p>对于 native 页面返回，我们看一下上一篇中提到的 flutter 打开 native，在·EntryAbility·中调用的<code>setRouterPushHandler</code>，当页面返回的时候，会回调<code>HMRouterMgr.push</code>传入的<code>HMRouterPathCallback</code>对象中的方法。我们来改造一下<code>setRouterPushHandler</code>这个方法，将 MethodResult 对象也传过来，当页面返回的时候调用MethodResult.success将参数返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">FlutterRouterPlugin</span>.<span class="hljs-title function_">setRouterPushHandler</span>(<span class="hljs-function">(<span class="hljs-params">path:<span class="hljs-built_in">string</span>,args:Record&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">Object</span>&gt;|<span class="hljs-literal">undefined</span>,result: MethodResult</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`rouerHandler:path=&gt; <span class="hljs-subst">$&#123;path&#125;</span> ,args=&gt;<span class="hljs-subst">$&#123;args&#125;</span>`</span>)<br>  <span class="hljs-keyword">if</span>(path ==<span class="hljs-string">&#x27;pages/flutter/FromFlutterPage&#x27;</span>)&#123;<br>    <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">pageUrl</span>:<span class="hljs-string">&#x27;pages/flutter/FromFlutterPage&#x27;</span>,<span class="hljs-attr">param</span>:args&#125;,&#123;<br>      <span class="hljs-attr">onResult</span>:<span class="hljs-function">(<span class="hljs-params">popInfo:PopInfo</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(popInfo)&#123;<br>          result.<span class="hljs-title function_">success</span>(popInfo.<span class="hljs-property">result</span>)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          result.<span class="hljs-title function_">success</span>(<span class="hljs-string">&quot;&quot;</span>)<br>        &#125;<br>      &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="flutter页面返回"><a href="#flutter页面返回" class="headerlink" title="flutter页面返回"></a>flutter页面返回</h3><p>按照之前的介绍，flutter 返回也统一调用插件的返回方法。<br>在插件的<code>FlutterRouterPlatform</code>中添加<code>pop</code>方法:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> pop([args]) &#123;<br>  <span class="hljs-keyword">throw</span> UnimplementedError(<span class="hljs-string">&#x27;open() has not been implemented.&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在插件的<code>MethodChannelFlutterRouter</code>中添加实现：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br><span class="hljs-keyword">void</span> pop([args]) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">await</span> methodChannel.invokeMethod(<span class="hljs-string">&#x27;pop&#x27;</span>, args);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在插件的<code>FlutterRouterPlugin</code>中添加调用，这里我们还是将返回的处理交给宿主项目决定</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">static</span> <span class="hljs-attr">routerPopHandler</span>:<span class="hljs-function">(<span class="hljs-params">call:MethodCall,result: MethodResult</span>)=&gt;</span><span class="hljs-built_in">boolean</span> =<span class="hljs-function">(<span class="hljs-params">call,result</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-title function_">setRouterPopHandler</span>(<span class="hljs-params">handler:(call:MethodCall,result: MethodResult)=&gt;<span class="hljs-built_in">boolean</span></span>)&#123;<br>  <span class="hljs-title class_">FlutterRouterPlugin</span>.<span class="hljs-property">routerPopHandler</span> = handler<br>&#125;<br><span class="hljs-title function_">onMethodCall</span>(<span class="hljs-attr">call</span>: <span class="hljs-title class_">MethodCall</span>, <span class="hljs-attr">result</span>: <span class="hljs-title class_">MethodResult</span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">if</span>(call.<span class="hljs-property">method</span> ==<span class="hljs-string">&#x27;pop&#x27;</span>)&#123;<br>    <span class="hljs-title class_">FlutterRouterPlugin</span>.<span class="hljs-title function_">routerPopHandler</span>(call,result)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在插件的<code>FlutterRouter</code>中统一调用返回的方法：先判断 flutter 是否可以 pop</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> pop(context, [<span class="hljs-built_in">dynamic</span> args]) &#123;<br>  <span class="hljs-keyword">if</span> (Navigator.of(context).canPop()) &#123;<br>    Navigator.of(context).pop(args);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    FlutterRouterPlatform.instance.pop(args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了测试简单全面，我们在 flutter_module中添加一个 flutter 页面。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//from_flutter_page.dart</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_router/flutter_router.dart&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FromFlutterPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; args;<br>  <span class="hljs-keyword">const</span> FromFlutterPage(<span class="hljs-keyword">this</span>.args,&#123;  <span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;FromFlutterPage&gt; createState() =&gt; _FromFlutterPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_FromFlutterPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">FromFlutterPage</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(centerTitle: <span class="hljs-keyword">true</span>,title: Text(<span class="hljs-string">&#x27;from flutter&#x27;</span>,style: TextStyle(fontSize: <span class="hljs-number">16</span>,color: Color(<span class="hljs-number">0xff333333</span>)),),),<br>      body: Column(<br>        children: [<br>            Text(<span class="hljs-string">&quot;收到上个页面传过来的数据&quot;</span>),<br>          Text(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;widget.args&#125;</span>&quot;</span>),<br>          ElevatedButton(<br>            onPressed: () &#123;<br>              FlutterRouter().pop(context,&#123;<span class="hljs-string">&quot;user_id&quot;</span>:<span class="hljs-string">&quot;xuan&quot;</span>,<span class="hljs-string">&quot;page_name&quot;</span>:<span class="hljs-string">&quot;FromFlutterPage&quot;</span>&#125;);<br>            &#125;,<br>            child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;带数据返回上个页面&quot;</span>,<br>                style: TextStyle(fontSize: <span class="hljs-number">16</span>, color: Color(<span class="hljs-number">0xff333333</span>))),<br>          ),<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>注意，添加的页面需要在 flutter 侧注册一下</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//main.dart</span><br><span class="hljs-keyword">void</span> initRouter()&#123;<br>  RouterManager.instance.addRouter(<span class="hljs-string">&quot;login&quot;</span>,(args)&#123;<span class="hljs-keyword">return</span> LoginPage(args);&#125;);<br>  RouterManager.instance.addRouter(<span class="hljs-string">&quot;from_flutter&quot;</span>,(args)&#123;<span class="hljs-keyword">return</span> FromFlutterPage(args);&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>之后我们在LoginPage中添加一下相关跳转、返回、参数展示</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//login_page.dart</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_router/flutter_router.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; args;<br><br>  <span class="hljs-keyword">const</span> LoginPage(<span class="hljs-keyword">this</span>.args, &#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;LoginPage&gt; createState() =&gt; _LoginPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_LoginPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">LoginPage</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">String</span> nativeResult = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-built_in">String</span> flutterResult = <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(<br>        title: Text(<span class="hljs-string">&quot;登录页面&quot;</span>),<br>        centerTitle: <span class="hljs-keyword">true</span>,<br>      ),<br>      body: Column(<br>        children: [<br>          <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;登录页面获取到的参数&quot;</span>,<br>              style: TextStyle(fontSize: <span class="hljs-number">16</span>, color: Color(<span class="hljs-number">0xff333333</span>))),<br>          Text(jsonEncode(widget.args)),<br>          Text(<span class="hljs-string">&quot;name:<span class="hljs-subst">$&#123;widget.args[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>),<br>          Text(<span class="hljs-string">&quot;age:<span class="hljs-subst">$&#123;widget.args[<span class="hljs-string">&#x27;age&#x27;</span>]&#125;</span>&quot;</span>),<br>          ElevatedButton(<br>            onPressed: () &#123;<br>              <span class="hljs-comment">//HMRouterAPage</span><br>              FlutterRouter().open(context, <span class="hljs-string">&#x27;pages/flutter/FromFlutterPage&#x27;</span>,<br>                  arguments: &#123;<br>                    <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;flutter_harmony&#x27;</span>,<br>                    <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">3</span><br>                  &#125;).then((value) &#123;<br>                debugPrint(<span class="hljs-string">&quot;native页面返回 flutter 传递的参数 <span class="hljs-subst">$&#123;jsonEncode(value)&#125;</span>&quot;</span>);<br>                setState(() &#123;<br>                  nativeResult = jsonEncode(value);<br>                &#125;);<br>              &#125;);<br>            &#125;,<br>            child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;FromFlutterPage&quot;</span>,<br>                style: TextStyle(fontSize: <span class="hljs-number">16</span>, color: Color(<span class="hljs-number">0xff333333</span>))),<br>          ),<br>          ElevatedButton(<br>            onPressed: () &#123;<br>              FlutterRouter().open(context, <span class="hljs-string">&quot;from_flutter&quot;</span>, arguments: &#123;<br>                <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-string">&quot;LoginPage&quot;</span>,<br>                <span class="hljs-string">&quot;business_id&quot;</span>: <span class="hljs-string">&quot;123&quot;</span><br>              &#125;).then((value) &#123;<br>                debugPrint(<span class="hljs-string">&quot;flutter页面返回 flutter 传递的参数 <span class="hljs-subst">$&#123;jsonEncode(value)&#125;</span>&quot;</span>);<br>                setState(() &#123;<br>                  flutterResult = jsonEncode(value);<br>                &#125;);<br>              &#125;);<br>            &#125;,<br>            child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;跳转到 flutter&quot;</span>,<br>                style: TextStyle(fontSize: <span class="hljs-number">16</span>, color: Color(<span class="hljs-number">0xff333333</span>))),<br>          ),<br>          ElevatedButton(<br>            onPressed: () &#123;<br>              FlutterRouter().pop(context, &#123;<span class="hljs-string">&quot;user_id&quot;</span>: <span class="hljs-string">&quot;xuan&quot;</span>&#125;);<br>            &#125;,<br>            child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;返回上个页面携带参数&quot;</span>,<br>                style: TextStyle(fontSize: <span class="hljs-number">16</span>, color: Color(<span class="hljs-number">0xff333333</span>))),<br>          ),<br>          Container(<br>            margin: <span class="hljs-keyword">const</span> EdgeInsets.all(<span class="hljs-number">15</span>),<br>            color: <span class="hljs-keyword">const</span> Color(<span class="hljs-number">0xff9c649a</span>),<br>            child: Column(<br>              children: [<span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;flutter页面返回携带的参数：&#x27;</span>), Text(flutterResult)],<br>            ),<br>          ),<br>          Container(<br>            margin: <span class="hljs-keyword">const</span> EdgeInsets.all(<span class="hljs-number">15</span>),<br>            color: <span class="hljs-keyword">const</span> Color(<span class="hljs-number">0xff7b7a32</span>),<br>            child: Column(<br>              children: [<span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;native页面返回携带的参数：&#x27;</span>), Text(nativeResult)],<br>            ),<br>          ),<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这样我们在 flutter 中需要做的事情就已经做完了，执行<code>flutter build har --debug</code>会在<code>my_flutter_module/.ohos/har</code>文件夹下看到三个<strong>har</strong>文件，直接复制到鸿蒙工程中进行依赖就行了。记得把源码依赖删掉</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//oh-package.json5</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;modelVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;5.0.5&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Please describe the basic information.&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@hadss/hmrouter&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0-rc.10&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@ohos/flutter_ohos&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;file:./har/flutter.har&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;@ohos/flutter_module&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;.//har/flutter_module.har&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;flutter_router&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;file:./har/flutter_router.har&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-attr">&quot;overrides&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@ohos/flutter_ohos&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;file:./har/flutter.har&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;flutter_router&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;file:./har/flutter_router.har&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure>
<p>最后一步，在<code>EntryAbility</code>中设置一下处理返回的调用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">onCreate</span>(<span class="hljs-attr">want</span>: <span class="hljs-title class_">Want</span>, <span class="hljs-attr">launchParam</span>: <span class="hljs-title class_">AbilityConstant</span>.<span class="hljs-property">LaunchParam</span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-title class_">FlutterRouterPlugin</span>.<span class="hljs-title function_">setRouterPopHandler</span>(<span class="hljs-function">(<span class="hljs-params">call:MethodCall,result: MethodResult</span>)=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`flutter 调用 pop  setRouterPopHandler:  <span class="hljs-subst">$&#123;call.method&#125;</span>  <span class="hljs-subst">$&#123;call.args&#125;</span>`</span>)<br>    <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">pop</span>(&#123;<span class="hljs-attr">param</span>:call.<span class="hljs-property">args</span>&#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样我们就完成了页面返回时参数的传递。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>先看下效果<br><img src="/image/harmony_flutter/go_back_params.gif"></p>
<p>总结一下：</p>
<ol>
<li>native 打开 flutter 时，将参数拼接到初始化路径上。</li>
<li>flutter 侧需要将所有的页面注册到插件中</li>
<li>flutter 打开页面时，插件判断目标页面是 flutter 还是 native，选择对应的方法打开页面</li>
<li>页面返回时，通过 MethodResult 将数据返回</li>
</ol>
<hr>
<p>至此，鸿蒙和 flutter 混编的介绍就已经结束了。</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙--canvas 画时钟</title>
    <url>/2024/03/27/%E9%B8%BF%E8%92%99-canvas-%E7%94%BB%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>你在 Android 上能画出来的东西，在鸿蒙上画不出来？<br>画个时钟嘛，有啥难的？<br>你行你上！<br>给钱就上！<br>给钱？早说嘛，来来来，现在就画</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>画时钟需要画哪些元素？<br>圆圈、直线，没了，就这些，临时看一下canvas 相关的 api，这不都有么？直接画。<br>看看需要用的方法  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">arc</span>(<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">radius</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">startAngle</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">endAngle</span>: <span class="hljs-built_in">number</span>, counterclockwise?: <span class="hljs-built_in">boolean</span>): <span class="hljs-built_in">void</span><br></code></pre></td></tr></table></figure>
<p>看下参数含义</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">必填</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">x</td>
<td align="left">number</td>
<td align="left">是</td>
<td align="left">0</td>
<td align="left">弧线圆心的x坐标值。</td>
</tr>
<tr>
<td align="left">y</td>
<td align="left">number</td>
<td align="left">是</td>
<td align="left">0</td>
<td align="left">弧线圆心的y坐标值。</td>
</tr>
<tr>
<td align="left">radius</td>
<td align="left">number</td>
<td align="left">是</td>
<td align="left">0</td>
<td align="left">弧线的圆半径。</td>
</tr>
<tr>
<td align="left">startAngle</td>
<td align="left">number</td>
<td align="left">是</td>
<td align="left">0</td>
<td align="left">弧线的起始弧度。</td>
</tr>
<tr>
<td align="left">endAngle</td>
<td align="left">number</td>
<td align="left">是</td>
<td align="left">0</td>
<td align="left">弧线的终止弧度。</td>
</tr>
<tr>
<td align="left">counterclockwise</td>
<td align="left">boolean</td>
<td align="left">否</td>
<td align="left">false</td>
<td align="left">是否逆时针绘制圆弧。</td>
</tr>
</tbody></table>
<p>弧度制，一圈是 2π，这个需要注意一下，还有endAngle，是终止弧度，而不是需要画多少弧度，浅浅的尝试。  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br>struct <span class="hljs-title class_">ClockViewTest</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>)<br>      .<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>        <span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">width</span><br>        <span class="hljs-keyword">let</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">height</span><br><br>        <span class="hljs-keyword">let</span> centerX = width / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">let</span> centerY = height / <span class="hljs-number">2</span><br>        <span class="hljs-comment">//取长宽中小的一个做直径</span><br>        <span class="hljs-keyword">let</span> maxRadius = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(width, height) / <span class="hljs-number">2</span><br><br>        <span class="hljs-comment">//设置线的粗细</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">4</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(centerX, centerY, maxRadius-<span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)<br>        <span class="hljs-comment">//设置线的颜色</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#ff0000&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">beginPath</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(centerX, centerY, maxRadius - <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)<br>        <span class="hljs-comment">//设置线的颜色</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#00ff00&quot;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br><br>      &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>效果是这样的：  </p>
<p><img src="/image/HarmonyOS/canvas_circle.png" alt="image.png"><br>画直线就不用多说了，开干~~  </p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><p>指针是需要根据时间变化来转动的，表盘画好一次就不需要重绘了，偷个懒，搞两个 canvas 摞起来，底层画表盘，上层画指针，时间变了只重画上层指针就行了。  </p>
<h4 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h4><p>简单的三角函数，但要注意是弧度制，数值别搞错了。<br>另外需要注意的是画布左上角坐标是(0,0)，右下角坐标为(width,height)。  </p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>先画一大一小两个圆圈组成一个圆环。  </li>
<li>再划线把圆环均分 60 份，每 5 条线加粗一下。  </li>
<li>再把圆周分成 12 份，对应位置画上1~12 数字。  </li>
<li>获取当前时间，计算出指针位置，划线。  </li>
<li>定时更新指针位置。  </li>
<li>结束。</li>
</ol>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="第一步-画圆环"><a href="#第一步-画圆环" class="headerlink" title="第一步 画圆环"></a>第一步 画圆环</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>)<br>  .<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>    <span class="hljs-keyword">let</span> width = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">width</span><br>    <span class="hljs-keyword">let</span> height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">height</span><br><br>    <span class="hljs-keyword">let</span> centerX = width / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">let</span> centerY = height / <span class="hljs-number">2</span><br>    <span class="hljs-comment">//取长宽中小的一个做直径</span><br>    <span class="hljs-keyword">let</span> maxRadius = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(centerX, centerY)<br><br>    <span class="hljs-comment">//留一些外边距</span><br>    <span class="hljs-keyword">let</span> outerCircleRadius = maxRadius - <span class="hljs-number">20</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#1b91e0&quot;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>    <span class="hljs-comment">//最中间的小圈圈</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(centerX, centerY, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br><br>    <span class="hljs-comment">//画内圈</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">beginPath</span>()<br>    <span class="hljs-keyword">let</span> innerCircleRadius = outerCircleRadius -<span class="hljs-number">20</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(centerX, centerY, innerCircleRadius, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br><br>    <span class="hljs-comment">//画外圈</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">beginPath</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">arc</span>(centerX, centerY, outerCircleRadius, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>()<br>    <br>  &#125;)<br></code></pre></td></tr></table></figure>
<p>效果图  </p>
<p><img src="/image/HarmonyOS/canvas_ring.png" alt="image.png"></p>
<p>看着还行，颜色和粗细大家自己调。</p>
<h4 id="第二步-画格子"><a href="#第二步-画格子" class="headerlink" title="第二步 画格子"></a>第二步 画格子</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//画 60 个格子，5 的倍数则线条粗一些</span><br><span class="hljs-keyword">let</span> perMinuteDegree = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">60</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">60</span>; i++) &#123;<br>  <span class="hljs-comment">//结束坐标，也就是在外圆上的点</span><br>  <span class="hljs-keyword">let</span> endX = centerX + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(i * perMinuteDegree) * outerCircleRadius<br>  <span class="hljs-keyword">let</span> endY = centerY + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(i * perMinuteDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * outerCircleRadius<br>  <span class="hljs-comment">//起始坐标，也就是在内圆上的点</span><br>  <span class="hljs-keyword">let</span> startX = centerX + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(i * perMinuteDegree) * innerCircleRadius<br>  <span class="hljs-keyword">let</span> startY = centerY + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(i * perMinuteDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * innerCircleRadius<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#000000&quot;</span><br>  <span class="hljs-keyword">let</span> path2D = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>  path2D.<span class="hljs-title function_">moveTo</span>(startX, startY)<br>  path2D.<span class="hljs-title function_">lineTo</span>(endX, endY)<br>  <span class="hljs-keyword">if</span> (i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">6</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>(path2D)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>效果图  </p>
<p><img src="/image/HarmonyOS/canvas_ring_clock.png" alt="image.png"><br>马马虎虎，不太好看。<br>这里需要注意一下，画布是以垂直向下为 Y 轴的正方向，计算时加了 <code>Math.PI</code> 弧度纠正一下  </p>
<h4 id="第三步-画数字"><a href="#第三步-画数字" class="headerlink" title="第三步 画数字"></a>第三步 画数字</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//画 1~12 数字圆形分布</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">font</span> = <span class="hljs-string">&quot;40px&quot;</span><br><span class="hljs-keyword">let</span> perNumberDegree = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">12</span><br><span class="hljs-keyword">let</span> numberRadius = outerCircleRadius - <span class="hljs-number">40</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">12</span>; i++) &#123;<br>  <span class="hljs-keyword">let</span> x = centerX + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(i * perNumberDegree) * numberRadius<br>  <span class="hljs-keyword">let</span> y = centerY + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(i * perNumberDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * numberRadius<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span> = i + <span class="hljs-string">&quot;&quot;</span><br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#000000&quot;</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">textMetrics</span>: <span class="hljs-title class_">TextMetrics</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">measureText</span>(text)<br>  <span class="hljs-comment">//填充文字时，传入的坐标是文字的左下角坐标</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fillText</span>(text, x-textMetrics.<span class="hljs-property">width</span>/<span class="hljs-number">2</span> , y+textMetrics.<span class="hljs-property">height</span>/<span class="hljs-number">2</span>)<br>  <span class="hljs-comment">//把下面这两行注释掉就没有小方块了</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#aaff6134&quot;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fillRect</span>(x,y,textMetrics.<span class="hljs-property">width</span>,textMetrics.<span class="hljs-property">height</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>效果图</p>
<p><img src="/image/HarmonyOS/canvas_ring_clock_number.png" alt="image.png"><br>图上的方块是为了对比画文字和画方块的坐标区别展示出来的：填充文字时传入的坐标是<code>文字左下角的坐标</code>，而画方块时是传入的<code>方块左上角坐标</code>,这里注意一下就好了，代码中测量了一下文字宽高，粗暴的做了一下纠偏。  </p>
<h4 id="第四、五步-画指针-amp-定时更新"><a href="#第四、五步-画指针-amp-定时更新" class="headerlink" title="第四、五步 画指针&amp;定时更新"></a>第四、五步 画指针&amp;定时更新</h4><p>上面也说要把指针画在另外一个 <code>canvas</code> 上，减少一下绘制时的内容，没做对比，也不知道有没有作用。<br>准备另外个画布，把两个画布用 <code>Stack</code> 包一下。  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">onReady</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">date</span>: <span class="hljs-title class_">Date</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">minute</span> = date.<span class="hljs-title function_">getMinutes</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hour</span> = date.<span class="hljs-title function_">getHours</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span> = date.<span class="hljs-title function_">getSeconds</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">draw</span>()<br>  &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">500</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>这里需要把第一块代码中的 <code>innerCircleRadius</code> 变量提到外部，作为类成员两个画布共用一下，主要是计算指针终点坐标用的。<code>centerX</code> 和 <code>centerY</code> 无所谓，只要两个画布对齐了，用哪个都行，这里还是提到了外部，用的第一块画布的。  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">private</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) &#123;<br>  清空一下画布<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span> * <span class="hljs-number">2</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span> * <span class="hljs-number">2</span>)<br><br>  <span class="hljs-comment">//画秒针</span><br>  <span class="hljs-comment">//计算秒针的角度</span><br>  <span class="hljs-keyword">let</span> secondDegree = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">60</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">second</span><br>  <span class="hljs-keyword">let</span> secondStartX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span><br>  <span class="hljs-keyword">let</span> secondStartY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span><br>  <span class="hljs-keyword">let</span> secondEndX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(secondDegree) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span><br>  <span class="hljs-keyword">let</span> secondEndY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(secondDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span><br>  <span class="hljs-keyword">let</span> secondPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>  secondPath.<span class="hljs-title function_">moveTo</span>(secondStartX, secondStartY)<br>  secondPath.<span class="hljs-title function_">lineTo</span>(secondEndX, secondEndY)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-title function_">stroke</span>(secondPath)<br><br><br>  <span class="hljs-comment">//画分针 颜色弄点透明度，要不然重合的时候看不清楚</span><br>  <span class="hljs-comment">//秒针走一圈，分针走一格，其实可以忽略不计</span><br>  <span class="hljs-keyword">let</span> minuteDegree = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">60</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">minute</span><br>  <span class="hljs-keyword">let</span> minuteStartX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span><br>  <span class="hljs-keyword">let</span> minuteStartY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span><br>  <span class="hljs-keyword">let</span> minuteEndX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(minuteDegree) * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span> / <span class="hljs-number">5</span> * <span class="hljs-number">4</span>)<br>  <span class="hljs-keyword">let</span> minuteEndY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(minuteDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span> / <span class="hljs-number">5</span> * <span class="hljs-number">4</span>)<br>  <span class="hljs-keyword">let</span> minutePath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>  minutePath.<span class="hljs-title function_">moveTo</span>(minuteStartX, minuteStartY)<br>  minutePath.<span class="hljs-title function_">lineTo</span>(minuteEndX, minuteEndY)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#aa1b91e0&quot;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">4</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-title function_">stroke</span>(minutePath)<br><br>  <span class="hljs-comment">//画时针</span><br>  <span class="hljs-comment">//分针走一圈，时针走 5 小格</span><br>  <span class="hljs-keyword">let</span> hourDegree = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">12</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">hour</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">minute</span> / <span class="hljs-number">60</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> / <span class="hljs-number">12</span><br>  <span class="hljs-keyword">let</span> hourStartX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span><br>  <span class="hljs-keyword">let</span> hourStartY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span><br>  <span class="hljs-keyword">let</span> hourEndX = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerX</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(hourDegree) * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span> / <span class="hljs-number">4</span> * <span class="hljs-number">3</span>)<br>  <span class="hljs-keyword">let</span> hourEndY = <span class="hljs-variable language_">this</span>.<span class="hljs-property">centerY</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(hourDegree + <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * (<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerCircleRadius</span> / <span class="hljs-number">4</span> * <span class="hljs-number">3</span>)<br>  <span class="hljs-keyword">let</span> hourPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>  hourPath.<span class="hljs-title function_">moveTo</span>(hourStartX, hourStartY)<br>  hourPath.<span class="hljs-title function_">lineTo</span>(hourEndX, hourEndY)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">6</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#aa39d167&quot;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRenderingClock</span>.<span class="hljs-title function_">stroke</span>(hourPath)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>计算指针角度的时候也偷懒了，时针只考虑了当前分钟数，没有考虑秒数，实际差不多，先这样吧。  </p>
<h4 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h4><p>效果图</p>
<p><img src="/image/HarmonyOS/canvas_clock_finish.png" alt="image.png"><br>就先这样吧，勉勉强强，可以自己调调颜色，调调样式，或者搞一些图片来代替这些元素也行。  </p>
<p>源码在这里 <a href="https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/AlarmClockPage.ets">github</a> ,<br><a href="https://gitee.com/huangyuan/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/AlarmClockPage.ets">gitee</a></p>
<p>仓库地址：<a href="https://github.com/huangyuanlove/HelloArkUI">https://github.com/huangyuanlove/HelloArkUI</a>  </p>
<p><a href="https://gitee.com/huangyuan/HelloArkUI">https://gitee.com/huangyuan/HelloArkUI</a></p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-flutter-使用FlutterEntry的路由管理和参数传递_中</title>
    <url>/2025/06/08/%E9%B8%BF%E8%92%99-flutter-%E4%BD%BF%E7%94%A8FlutterEntry%E7%9A%84%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92-%E4%B8%AD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们完成了鸿蒙打开flutter指定页面，并且传递参数，接下来我们看一下在flutter侧打开鸿蒙原生页面，并且传递参数应该如何处理。<br>当然了，我们在前面也提到了，在flutter发起路由的时候，都交给插件来处理。并且我们在上一章中也创建好了flutter插件，并没有使用和原生交互，只是创建了一个flutter路由和页面映射的管理类。</p>
<h2 id="创建插件"><a href="#创建插件" class="headerlink" title="创建插件"></a>创建插件</h2><p>这里为了简单，我们在<code>my_flutter_module</code>下新建一个<code>plugins</code>文件，将插件工程放在这个文件夹下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd my_flutter_module/plugins/<br>flutter create --org com.huangyuanlove.flutter_router --template=plugin --platforms=ohos flutter_router<br></code></pre></td></tr></table></figure>
<p>这里我们演示鸿蒙项目下的插件，就没有支持 Android 和 iOS。<br>在 my_flutter_module中引用这个插件,在<code>pubspec.yaml</code>中添加引用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter_router:</span> <br>    <span class="hljs-attr">path:</span> <span class="hljs-string">plugins/flutter_router</span><br></code></pre></td></tr></table></figure>



<h2 id="flutter打开native"><a href="#flutter打开native" class="headerlink" title="flutter打开native"></a>flutter打开native</h2><p>这里需要用到和native通信了。前面也提到过，当flutter发起路由时，先判断目标页面是不是flutter页面，是的话用flutter中的Navigator打开，否则调用channel通知原生打开。</p>
<p>因为打开原生页面有时候也需要传递一些参数，我们在<code>FlutterRouterPlatform</code>中定义这么一个方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Future&lt;T&gt; open&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(url, &#123;<span class="hljs-built_in">dynamic</span> arguments&#125;) &#123;<br>  <span class="hljs-keyword">throw</span> UnimplementedError(<span class="hljs-string">&#x27;open() has not been implemented.&#x27;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>然后我们在<code>MethodChannelFlutterRouter</code>中实现这个方法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@override</span><br>Future&lt;T&gt; open&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(url,<br>    &#123;<span class="hljs-built_in">dynamic</span> arguments&#125;) <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-keyword">var</span> args = &#123;&#125;;<br>  args[<span class="hljs-string">&#x27;path&#x27;</span>] = url;<br><br>  <span class="hljs-keyword">if</span> (arguments != <span class="hljs-keyword">null</span>) &#123;<br>    args[<span class="hljs-string">&#x27;arguments&#x27;</span>] = arguments;<br>  &#125;<br>  debugPrint(<span class="hljs-string">&quot;-----------open---start--------&quot;</span>);<br>  debugPrint(<span class="hljs-string">&quot;path <span class="hljs-subst">$url</span>&quot;</span>);<br>  debugPrint(<span class="hljs-string">&quot;arguments <span class="hljs-subst">$arguments</span>&quot;</span>);<br>  debugPrint(<span class="hljs-string">&quot;-----------open----end-------&quot;</span>);<br><br>  <span class="hljs-keyword">final</span> result = <span class="hljs-keyword">await</span> methodChannel.invokeMethod(<span class="hljs-string">&#x27;open&#x27;</span>, args);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看着代码挺多，实际上只是把<code>url</code>和<code>arguments</code>这两个参数打包到了<code>args</code>里面，通过<code>methodChannel</code>传给原生。</p>
<h3 id="原生侧处理"><a href="#原生侧处理" class="headerlink" title="原生侧处理"></a>原生侧处理</h3><p>这里我们可以使用DevEco打开插件目录下的ohos文件夹，把它当作一个鸿蒙工程。或者简单点，直接在当前工程中编辑也行。只是方法提示不太友好，我们可以把ohos工程中的<code>FlutterRouterPlugin</code>文件直接复制到当前鸿蒙工程中，编辑完后再复制回去。<br>我们看下<code>FlutterRouterPlugin</code>应该如何处理。<br>考虑到我们是传入的路径，也是打算注册路径和关联页面，但考虑到我们的实际业务情况，就开放了一个处理接口，由native侧设置，当触发打开native页面时，由native来处理</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123;<br>  <span class="hljs-title class_">FlutterPlugin</span>,<br>  <span class="hljs-title class_">FlutterPluginBinding</span>,<br>  <span class="hljs-title class_">MethodCall</span>,<br>  <span class="hljs-title class_">MethodCallHandler</span>,<br>  <span class="hljs-title class_">MethodChannel</span>,<br>  <span class="hljs-title class_">MethodResult</span>,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos&#x27;</span>;<br><br><span class="hljs-comment">/** FlutterRouterPlugin **/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlutterRouterPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlutterPlugin</span>, <span class="hljs-title class_">MethodCallHandler</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">channel</span>: <span class="hljs-title class_">MethodChannel</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-attr">routerPushHandler</span>: <span class="hljs-function">(<span class="hljs-params">path: <span class="hljs-built_in">string</span>, args: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">Object</span>&gt; | <span class="hljs-literal">undefined</span>,result:MethodResult</span>) =&gt;</span> <span class="hljs-built_in">boolean</span> = <span class="hljs-function">(<span class="hljs-params">path, args,result</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">setRouterPushHandler</span>(<span class="hljs-params">handler: (path: <span class="hljs-built_in">string</span>, args: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">Object</span>&gt; | <span class="hljs-literal">undefined</span>,result:MethodResult) =&gt; <span class="hljs-built_in">boolean</span></span>) &#123;<br>    <span class="hljs-title class_">FlutterRouterPlugin</span>.<span class="hljs-property">routerPushHandler</span> = handler<br>  &#125;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>  &#125;<br><br>  <span class="hljs-title function_">getUniqueClassName</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FlutterRouterPlugin&quot;</span><br>  &#125;<br><br>  <span class="hljs-title function_">onAttachedToEngine</span>(<span class="hljs-attr">binding</span>: <span class="hljs-title class_">FlutterPluginBinding</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">channel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChannel</span>(binding.<span class="hljs-title function_">getBinaryMessenger</span>(), <span class="hljs-string">&quot;flutter_router&quot;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">channel</span>.<span class="hljs-title function_">setMethodCallHandler</span>(<span class="hljs-variable language_">this</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">onDetachedFromEngine</span>(<span class="hljs-attr">binding</span>: <span class="hljs-title class_">FlutterPluginBinding</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">channel</span> != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">channel</span>.<span class="hljs-title function_">setMethodCallHandler</span>(<span class="hljs-literal">null</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">onMethodCall</span>(<span class="hljs-attr">call</span>: <span class="hljs-title class_">MethodCall</span>, <span class="hljs-attr">result</span>: <span class="hljs-title class_">MethodResult</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">if</span> (call.<span class="hljs-property">method</span> == <span class="hljs-string">&quot;getPlatformVersion&quot;</span>) &#123;<br>      result.<span class="hljs-title function_">success</span>(<span class="hljs-string">&quot;OpenHarmony ^ ^ &quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (call.<span class="hljs-property">method</span> == <span class="hljs-string">&#x27;open&#x27;</span>) &#123;<br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span> = call.<span class="hljs-title function_">argument</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">args</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Object</span>&gt; | <span class="hljs-literal">undefined</span> = call.<span class="hljs-title function_">argument</span>(<span class="hljs-string">&#x27;arguments&#x27;</span>)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;-------onMethodCall----open---start--------&quot;</span>)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`path <span class="hljs-subst">$&#123;path&#125;</span>`</span>)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`arguments <span class="hljs-subst">$&#123;args&#125;</span>`</span>)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;------onMethodCall-----open----end-------&quot;</span>)<br>      <span class="hljs-title class_">FlutterRouterPlugin</span>.<span class="hljs-title function_">routerPushHandler</span>(path, args,result)<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-title function_">notImplemented</span>()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们再写一个鸿蒙页面，用来测试flutter打开native的情况</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HMRouter</span>, <span class="hljs-title class_">HMRouterMgr</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@hadss/hmrouter&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ActionBar</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../../comm/ActionBar&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UIUtils</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@kit.ArkUI&quot;</span>;<br><br><span class="hljs-meta">@HMRouter</span>(&#123; <span class="hljs-attr">pageUrl</span>: <span class="hljs-string">&#x27;pages/flutter/FromFlutterPage&#x27;</span> &#125;)<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">FromFlutterPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">routerParam</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Object</span>&gt; | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><br>  <span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routerParam</span> = <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">getCurrentParam</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Object</span>&gt;<br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">ActionBar</span>(&#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;从 flutter 打开的页面&quot;</span>,<span class="hljs-attr">onClickBack</span>:<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">pop</span>()&#125; &#125;)<br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;获取到的路由参数&#x27;</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">routerParamsToStr</span>())<br><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">routerParamsToStr</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">routerParam</span>) &#123;<br>      <span class="hljs-keyword">let</span> result = <span class="hljs-string">&#x27;&#x27;</span><br><br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">tmp</span>:<span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Object</span>&gt; = <span class="hljs-title class_">UIUtils</span>.<span class="hljs-property">getTarget</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Object</span>&gt;&gt;(<span class="hljs-variable language_">this</span>.<span class="hljs-property">routerParam</span>);<br>      tmp.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value,key</span>)=&gt;</span>&#123;<br>        result += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> : <span class="hljs-subst">$&#123;value&#125;</span> \n`</span><br>      &#125;)<br><br>      <span class="hljs-keyword">return</span> result<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;无参数&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们在<code>EntryAbility</code>的<code>onCreate</code>方法中设置一下<code>routerPushHandler</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">FlutterRouterPlugin</span>.<span class="hljs-title function_">setRouterPushHandler</span>(<span class="hljs-function">(<span class="hljs-params">path:<span class="hljs-built_in">string</span>,args:Record&lt;<span class="hljs-built_in">string</span>,<span class="hljs-built_in">Object</span>&gt;|<span class="hljs-literal">undefined</span>,result: MethodResult</span>)=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`rouerHandler:path=&gt; <span class="hljs-subst">$&#123;path&#125;</span> ,args=&gt;<span class="hljs-subst">$&#123;args&#125;</span>`</span>)<br>  <span class="hljs-keyword">if</span>(path ==<span class="hljs-string">&#x27;pages/flutter/FromFlutterPage&#x27;</span>)&#123;<br>    <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">push</span>(&#123;<span class="hljs-attr">pageUrl</span>:<span class="hljs-string">&#x27;pages/flutter/FromFlutterPage&#x27;</span>,<span class="hljs-attr">param</span>:args&#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>这里我们判断了path的值和跳转对应的页面。</p>
<h3 id="flutter侧调用"><a href="#flutter侧调用" class="headerlink" title="flutter侧调用"></a>flutter侧调用</h3><p>我们调用的方法都写在了<code>FlutterRouter</code>中,并且也是在这里判断是打开 flutter 页面还是打开native 页面<br>我们在<code>RouterManager</code>中添加一个判断是否为 flutter 页面的方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">bool</span> hasRouterWidget(<span class="hljs-built_in">String</span> path) &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> routerName = _getRouterName(path);<br>  <span class="hljs-keyword">return</span> _routerMap.containsKey(routerName);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们在<code>FlutterRouter</code>写一下对应的打开页面的方法:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_router/router_manager.dart&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;flutter_router_platform_interface.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlutterRouter</span> </span>&#123;<br>  Future&lt;<span class="hljs-built_in">String?</span>&gt; getPlatformVersion() &#123;<br>    <span class="hljs-keyword">return</span> FlutterRouterPlatform.instance.getPlatformVersion();<br>  &#125;<br>  Future&lt;T?&gt; open&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Object?</span>&gt;(context, path,<br>      &#123;<span class="hljs-built_in">Object?</span> arguments&#125;) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">bool</span> useFlutterPage = RouterManager.instance.hasRouterWidget(path);<br>    <span class="hljs-keyword">if</span>(useFlutterPage)&#123;<br>      debugPrint(<span class="hljs-string">&quot;FlutterRouter#open 打开 flutter&quot;</span>);<br>      Widget target =  RouterManager.instance.getRouterWidget(path,params: arguments);<br>      <span class="hljs-keyword">return</span> Navigator.of(context).push(MaterialPageRoute(<br>        builder: (context) =&gt; target,<br>      ),);<br>      <span class="hljs-comment">// return Navigator.of(context).pushNamed(path, arguments: arguments);</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 打开native页面: path已在native端注册</span><br>      debugPrint(<span class="hljs-string">&quot;FlutterRouter#open 打开 native&quot;</span>);<br>      <span class="hljs-keyword">return</span> FlutterRouterPlatform.instance<br>          .open&lt;T&gt;(path, arguments: arguments)<br>          .then((value) &#123;<br>        <span class="hljs-keyword">return</span> value;<br>      &#125;);<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>之后我们在之前使用的<code>LoginPage</code>页面中调用一下这个方法:</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">ElevatedButton(<br>  onPressed: () &#123;<br>    <span class="hljs-comment">//HMRouterAPage</span><br>    FlutterRouter().open(context, <span class="hljs-string">&#x27;pages/flutter/FromFlutterPage&#x27;</span>,<br>        arguments: &#123;<br>          <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;flutter_harmony&#x27;</span>,<br>          <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">3</span><br>        &#125;);<br>  &#125;,<br>  child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;FromFlutterPage&quot;</span>,<br>      style: TextStyle(fontSize: <span class="hljs-number">16</span>, color: Color(<span class="hljs-number">0xff333333</span>))),<br>),<br></code></pre></td></tr></table></figure>

<p>看一下效果<br><img src="/image/harmony_flutter/flutter_to_native.gif"></p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><ol>
<li>flutter打开页面时，调用<code>FlutterRouter#open</code>方法，</li>
<li>在该方法中判断目标页面是 flutter 页面还是 native 页面</li>
<li>如果是 native 页面，则通过 methodChannel 调用 native 方法</li>
<li>最终调用的 native 方法由宿主原生工程中设置，由宿主原生工程来打开对应页面</li>
</ol>
]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-flutter-使用FlutterEntry的路由管理和参数传递_上</title>
    <url>/2025/06/04/%E9%B8%BF%E8%92%99-flutter-%E4%BD%BF%E7%94%A8FlutterEntry%E7%9A%84%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92_%E4%B8%8A/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在前面介绍了如何搭建环境，如何向现有鸿蒙工程中添加 flutter 模块，这篇文章中我们来看一下参数传递问题。<br>我们先看一下有哪些场景</p>
<ol>
<li>native 打开 flutter 页面</li>
<li>flutter 打开 native 页面</li>
<li>flutter 打开 flutter 页面</li>
<li>native 返回 flutter 页面</li>
<li>flutter 返回 native 页面</li>
<li>flutter 返回 flutter 页面</li>
</ol>
<p>一开始考虑的是 flutter 打开 flutter 的时候用 flutter 的路由，不需要 native 参与，比如 FlutterA 跳转到 FlutterB，直接在 flutter 进行跳转。但是也有可能会出现由 nativeA 打开 FlutterB，这时候 FlutterB 返回时需要将数据传给上个页面，如果按照一开始的逻辑，FlutterB 页面就需要判断来源，增加了复杂性。<br>因此，我们决定 flutter 打开 flutter 页需要重新打开一个新的 native 页面，让这个 native 页面加载对应的 flutter 页面。<br>也就是说，一个 native 页面只承载一个FlutterView。<br>这种情况下就需要我们写插件了。</p>
<h2 id="创建插件"><a href="#创建插件" class="headerlink" title="创建插件"></a>创建插件</h2><p>这里为了简单，我们在<code>my_flutter_module</code>下新建一个<code>plugins</code>文件，将插件工程放在这个文件夹下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd my_flutter_module/plugins/<br>flutter create --org com.huangyuanlove.flutter_router --template=plugin --platforms=ohos flutter_router<br></code></pre></td></tr></table></figure>
<p>这里我们演示鸿蒙项目下的插件，就没有支持 Android 和 iOS。<br>在 my_flutter_module中引用这个插件,在<code>pubspec.yaml</code>中添加引用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-attr">flutter_router:</span> <br>    <span class="hljs-attr">path:</span> <span class="hljs-string">plugins/flutter_router</span><br></code></pre></td></tr></table></figure>


<h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><p>这里主要考虑flutter发起路由时的情况：</p>
<ol>
<li>flutter 页面路由统一调用插件中的方法进行跳转。</li>
<li>在 flutter 的 main 函数中注册页面路径相关参数</li>
<li>跳转时判断目标是 flutter 还是 native，如果是 flutter，则使用 Navigator；如果是 native ，则通过 methodChannel 调用原生打开</li>
<li>当页面返回时，先判断是否可以由flutter进行pop(flutter打开flutter页面的情况)，可以的话则由flutter进行pop，否则通过methodChannel调用原生进行返回</li>
</ol>
<h3 id="native打开flutter"><a href="#native打开flutter" class="headerlink" title="native打开flutter"></a>native打开flutter</h3><p>在前面的章节，我们了解了如何打开flutter页面，但仅仅是打开了默认的页面，并没有打开指定的页面和传入参数，在这一节中，我们来看下如何实现。</p>
<h3 id="flutter页面注册"><a href="#flutter页面注册" class="headerlink" title="flutter页面注册"></a>flutter页面注册</h3><p>由于我们确定是用路径+参数的形式来确定要打开的页面，因此需要我们先将路径和对应的flutter页面关联起来，并且能创建页面的时候把对应的参数传进去。<br>我们在flutter_router插件中创建一个用来记录路径和页面关系的类<code>router_manager.dart</code>,考虑到创建页面的时候需要传递参数，所以我们可以这么保存</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">typedef</span> RouteWidgetBuilder = Widget <span class="hljs-built_in">Function</span>(<span class="hljs-built_in">dynamic</span> args);<br><span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, RouteWidgetBuilder&gt; _routerMap = &#123;&#125;;<br><br><span class="hljs-built_in">bool</span> addRouter(<span class="hljs-built_in">String</span> path, RouteWidgetBuilder routerBuilder) &#123;<br>  _routerMap[path] = routerBuilder;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="路径和参数获取"><a href="#路径和参数获取" class="headerlink" title="路径和参数获取"></a>路径和参数获取</h3><p>由于没有找到太好的方法来传递参数，暂时先将参数拼接到路径上，因此，我们还需要定义两个方法：从带参数路径中获取路径，从带参数路径中获取参数。<br>比如要打开的全路径为：<code>login?&#123;&quot;name&quot;:&quot;harmonyos&quot;,&quot;age&quot;:3&#125;</code>,我们获取到的路径为<code>login</code>,获取到的参数为<code>&#123;&quot;name&quot;:&quot;harmonyos&quot;,&quot;age&quot;:3&#125;</code>,也就是说路径和参数是用<code>?</code>拼接，并且参数是json字符串，这样方便我们解析。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> _getRouterName(<span class="hljs-built_in">String?</span> path) &#123;<br>  <span class="hljs-keyword">if</span> (path == <span class="hljs-keyword">null</span>) &#123;<br>    debugPrint(<span class="hljs-string">&quot;获取路径出错，path 为空&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (path.contains(<span class="hljs-string">&#x27;?&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.parse(path);<br>    <span class="hljs-keyword">return</span> uri.path;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> path;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">Object?</span> _getRouteArgs(<span class="hljs-built_in">String?</span> route) &#123;<br>  <span class="hljs-keyword">if</span> (route == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (route.contains(<span class="hljs-string">&#x27;?&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">var</span> uri = <span class="hljs-built_in">Uri</span>.parse(route);<br><br>    <span class="hljs-built_in">String</span> query = uri.query;<br>    <span class="hljs-keyword">try</span> &#123;<br>      query = <span class="hljs-built_in">Uri</span>.decodeFull(query);<br>      <span class="hljs-keyword">return</span> json.decode(query);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      <span class="hljs-comment">// Map&lt;String, String&gt;</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Uri</span>.splitQueryString(query);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>我们还需要一个根据路径获取页面的方法</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">Widget getRouterWidget(<span class="hljs-built_in">String</span> path, &#123;<span class="hljs-built_in">Object?</span> params&#125;) &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> routerName = _getRouterName(path);<br>  <span class="hljs-built_in">Object?</span> pathParam = _getRouteArgs(path);<br>  debugPrint(<br>      <span class="hljs-string">&quot;getRouterWidget path:<span class="hljs-subst">$path</span>, routerName:<span class="hljs-subst">$routerName</span>,pathParam:<span class="hljs-subst">$pathParam</span> ,params:<span class="hljs-subst">$params</span>&quot;</span>);<br>  RouteWidgetBuilder? routerBuilder = _routerMap[routerName];<br>  <span class="hljs-keyword">if</span> (routerBuilder != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> routerBuilder(pathParam ?? params);<br>  &#125;<br>  <span class="hljs-keyword">return</span> Container();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里我们就已经做好了native打开flutter页面的准备。</p>
<h3 id="准备目标页面"><a href="#准备目标页面" class="headerlink" title="准备目标页面"></a>准备目标页面</h3><p>这假设我们有一个login页面，</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//login.dart</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:convert&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt; args;<br><br>  <span class="hljs-keyword">const</span> LoginPage(<span class="hljs-keyword">this</span>.args, &#123;<span class="hljs-keyword">super</span>.key&#125;);<br>  <span class="hljs-meta">@override</span><br>  State&lt;LoginPage&gt; createState() =&gt; _LoginPageState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_LoginPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">LoginPage</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Scaffold(<br>      appBar: AppBar(title: Text(<span class="hljs-string">&quot;登录页面&quot;</span>),centerTitle: <span class="hljs-keyword">true</span>,),<br>      body: Column(<br>        children: [<br>          <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&quot;登录页面获取到的参数&quot;</span>,<br>              style: TextStyle(fontSize: <span class="hljs-number">16</span>, color: Color(<span class="hljs-number">0xff333333</span>))),<br>          Text(jsonEncode(widget.args)),<br>          Text(<span class="hljs-string">&quot;name:<span class="hljs-subst">$&#123;widget.args[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>),<br>          Text(<span class="hljs-string">&quot;age:<span class="hljs-subst">$&#123;widget.args[<span class="hljs-string">&#x27;age&#x27;</span>]&#125;</span>&quot;</span>),<br>        ],<br>      ),<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="flutter中的处理"><a href="#flutter中的处理" class="headerlink" title="flutter中的处理"></a>flutter中的处理</h3><p>然后我们在flutter的main方法中注册，之后获取要打开的路径，获取对应页面和参数，最后展示出来.<br>我们在<code>main.dart</code>中做一下处理</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:ui&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter_router/router_manager.dart&#x27;</span>;<br><br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;login_page.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  initRouter(); <span class="hljs-comment">//注册flutter页面</span><br>  <span class="hljs-keyword">var</span> routerName = PlatformDispatcher.instance.defaultRouteName;<br>  debugPrint(<span class="hljs-string">&quot;获取到需要加载的路径：<span class="hljs-subst">$&#123;routerName&#125;</span>&quot;</span>);<br>  runApp(MyApp(path: routerName));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> path;<br>  <span class="hljs-keyword">const</span> MyApp(&#123;<span class="hljs-keyword">required</span> <span class="hljs-keyword">this</span>.path, <span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-comment">// This widget is the root of your application.</span><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> MaterialApp(<br>      home: RouterManager.instance.getRouterWidget(path),<br>    );<br><br>  &#125;<br>&#125;<br><span class="hljs-keyword">void</span> initRouter()&#123;<br>  RouterManager.instance.addRouter(<span class="hljs-string">&quot;login&quot;</span>,(args)&#123;<span class="hljs-keyword">return</span> LoginPage(args);&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="鸿蒙侧的处理"><a href="#鸿蒙侧的处理" class="headerlink" title="鸿蒙侧的处理"></a>鸿蒙侧的处理</h3><p>我们先从原生页面点击按钮之后跳转到flutter的登录页面，并且传递一些参数过去。<br>我这里使用HMRouter这个三方库来做的页面跳转。<br>添加flutter模块还是和前面的讲的一样，没啥太大的区别</p>
<h4 id="EntryAbility"><a href="#EntryAbility" class="headerlink" title="EntryAbility"></a>EntryAbility</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">UIAbility</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos.app.ability.UIAbility&#x27;</span>;<br><span class="hljs-keyword">import</span> hilog <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos.hilog&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AbilityConstant</span>, <span class="hljs-title class_">Want</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.AbilityKit&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">UIContext</span>, <span class="hljs-variable language_">window</span>, uiObserver <span class="hljs-keyword">as</span> observer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.ArkUI&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">JSON</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.ArkTS&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HMRouterMgr</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@hadss/hmrouter&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ExclusiveAppComponent</span>, <span class="hljs-title class_">FlutterManager</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryAbility</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">UIAbility</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExclusiveAppComponent</span>&lt;<span class="hljs-title class_">UIAbility</span>&gt;&#123;<br><br>  <span class="hljs-title function_">detachFromFlutterEngine</span>(): <span class="hljs-built_in">void</span> &#123;<br>  &#125;<br>  <span class="hljs-title function_">getAppComponent</span>(): <span class="hljs-title class_">UIAbility</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">uiContext</span>: <span class="hljs-title class_">UIContext</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-title function_">onCreate</span>(<span class="hljs-attr">want</span>: <span class="hljs-title class_">Want</span>, <span class="hljs-attr">launchParam</span>: <span class="hljs-title class_">AbilityConstant</span>.<span class="hljs-property">LaunchParam</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">init</span>(&#123;<br>      <span class="hljs-attr">context</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span><br>    &#125;)<br>    <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">pushUIAbility</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br><br>  <span class="hljs-title function_">onDestroy</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">popUIAbility</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">onWindowStageCreate</span>(<span class="hljs-attr">windowStage</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">WindowStage</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">pushWindowStage</span>(<span class="hljs-variable language_">this</span>, windowStage);<br><br>    windowStage.<span class="hljs-title function_">loadContent</span>(<span class="hljs-string">&#x27;pages/Index&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// windowStage.loadContent(&#x27;pages/tel_inquiry_waiting_page/index&#x27;, (err) =&gt; &#123;</span><br>      <span class="hljs-keyword">if</span> (err.<span class="hljs-property">code</span>) &#123;<br>        hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">&#x27;testTag&#x27;</span>, <span class="hljs-string">&#x27;Failed to load the content. Cause: %&#123;public&#125;s&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(err) ?? <span class="hljs-string">&#x27;&#x27;</span>);<br>      &#125;<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">onWindowStageDestroy</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">popWindowStage</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-comment">// Main window is destroyed, release UI related resources</span><br>    hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x0000</span>, <span class="hljs-string">&#x27;testTag&#x27;</span>, <span class="hljs-string">&#x27;%&#123;public&#125;s&#x27;</span>, <span class="hljs-string">&#x27;Ability onWindowStageDestroy&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">uiContext</span>) &#123;<br>      observer.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;routerPageUpdate&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiContext</span>);<br>    &#125;<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="index-ets"><a href="#index-ets" class="headerlink" title="index.ets"></a>index.ets</h4><p>主页</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HMDefaultGlobalAnimator</span>, <span class="hljs-title class_">HMNavigation</span>, <span class="hljs-title class_">HMRouterMgr</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@hadss/hmrouter&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">AttributeUpdater</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.ArkUI&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FlutterMainPage</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./flutter/FlutterMainPage&#x27;</span>;<br><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">Index</span> &#123;<br><br>  <span class="hljs-attr">modifier</span>: <span class="hljs-title class_">NavModifier</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NavModifier</span>();<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>()&#123;<br>      <span class="hljs-title class_">HMNavigation</span>(&#123;<br>        <span class="hljs-attr">navigationId</span>: <span class="hljs-string">&#x27;mainNavigation&#x27;</span>, <span class="hljs-attr">options</span>: &#123;<br>          <span class="hljs-attr">standardAnimator</span>: <span class="hljs-title class_">HMDefaultGlobalAnimator</span>.<span class="hljs-property">STANDARD_ANIMATOR</span>,<br>          <span class="hljs-attr">dialogAnimator</span>: <span class="hljs-title class_">HMDefaultGlobalAnimator</span>.<span class="hljs-property">DIALOG_ANIMATOR</span>,<br>          <span class="hljs-attr">modifier</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">modifier</span><br>        &#125;<br>      &#125;)&#123;<br>        <span class="hljs-title class_">Column</span>() &#123;<br><br>          <span class="hljs-title class_">FlutterMainPage</span>()<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NavModifier</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AttributeUpdater</span>&lt;<span class="hljs-title class_">NavigationAttribute</span>&gt; &#123;<br>  <span class="hljs-title function_">initializeModifier</span>(<span class="hljs-attr">instance</span>: <span class="hljs-title class_">NavigationAttribute</span>): <span class="hljs-built_in">void</span> &#123;<br>    instance.<span class="hljs-title function_">mode</span>(<span class="hljs-title class_">NavigationMode</span>.<span class="hljs-property">Stack</span>);<br>    instance.<span class="hljs-title function_">navBarWidth</span>(<span class="hljs-string">&#x27;100%&#x27;</span>);<br>    instance.<span class="hljs-title function_">hideTitleBar</span>(<span class="hljs-literal">true</span>);<br>    instance.<span class="hljs-title function_">hideToolBar</span>(<span class="hljs-literal">true</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="MyFlutterEntry"><a href="#MyFlutterEntry" class="headerlink" title="MyFlutterEntry"></a>MyFlutterEntry</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">GeneratedPluginRegistrant</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_module&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FlutterEngine</span>, <span class="hljs-title class_">FlutterEntry</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos&#x27;</span>;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFlutterEntry</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">FlutterEntry</span> &#123;<br>  <span class="hljs-title function_">configureFlutterEngine</span>(<span class="hljs-attr">flutterEngine</span>: <span class="hljs-title class_">FlutterEngine</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">configureFlutterEngine</span>(flutterEngine)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;MyFlutterEntry configureFlutterEngine&quot;</span>)<br>    <span class="hljs-title class_">GeneratedPluginRegistrant</span>.<span class="hljs-title function_">registerWith</span>(flutterEngine)<br>  &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="MyFlutterPage"><a href="#MyFlutterPage" class="headerlink" title="MyFlutterPage"></a>MyFlutterPage</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FlutterManager</span>, <span class="hljs-title class_">FlutterPage</span>, <span class="hljs-title class_">FlutterView</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HMLifecycleState</span>, <span class="hljs-title class_">HMRouter</span>, <span class="hljs-title class_">HMRouterMgr</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@hadss/hmrouter&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">MyFlutterEntry</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyFlutterEntry&#x27;</span><br><br><span class="hljs-meta">@HMRouter</span>(&#123; <span class="hljs-attr">pageUrl</span>: <span class="hljs-string">&#x27;pages/flutter/MyFlutterPage&#x27;</span> &#125;)<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">MyFlutterPage</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">flutterEntry</span>: <span class="hljs-title class_">MyFlutterEntry</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">private</span> flutterView?: <span class="hljs-title class_">FlutterView</span><br><br>  <span class="hljs-title function_">aboutToAppear</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">param</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; = <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">getCurrentParam</span>() <span class="hljs-keyword">as</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`MyFlutterPage params <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(param)&#125;</span>`</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFlutterEntry</span>(<span class="hljs-title function_">getContext</span>(<span class="hljs-variable language_">this</span>), param)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span>.<span class="hljs-title function_">aboutToAppear</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterView</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span>.<span class="hljs-title function_">getFlutterView</span>()<br>    <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">getCurrentLifecycleOwner</span>()?.<span class="hljs-title function_">addObserver</span>(<span class="hljs-title class_">HMLifecycleState</span>.<span class="hljs-property">onShown</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span>?.<span class="hljs-title function_">onPageShow</span>()<br>      <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">setUseFullScreen</span>(<span class="hljs-literal">true</span>)<br>    &#125;)<br>    <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">getCurrentLifecycleOwner</span>()?.<span class="hljs-title function_">addObserver</span>(<span class="hljs-title class_">HMLifecycleState</span>.<span class="hljs-property">onHidden</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span>?.<span class="hljs-title function_">onPageHide</span>()<br>      <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">setUseFullScreen</span>(<span class="hljs-literal">false</span>)<br>    &#125;)<br>    <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">getCurrentLifecycleOwner</span>()?.<span class="hljs-title function_">addObserver</span>(<span class="hljs-title class_">HMLifecycleState</span>.<span class="hljs-property">onBackPressed</span>, (): <span class="hljs-function"><span class="hljs-params">boolean</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// this.flutterEntry?.onBackPress()</span><br>      <span class="hljs-comment">// (getContext(this) as common.UIAbilityContext).eventHub.emit(&#x27;EVENT_BACK_PRESS&#x27;)</span><br>      <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">pop</span>()<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-title function_">aboutToDisappear</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span>?.<span class="hljs-title function_">aboutToDisappear</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br><br>      <span class="hljs-title class_">FlutterPage</span>(&#123; <span class="hljs-attr">viewId</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterView</span>?.<span class="hljs-title function_">getId</span>() &#125;).<span class="hljs-title function_">expandSafeArea</span>([<span class="hljs-title class_">SafeAreaType</span>.<span class="hljs-property">SYSTEM</span>], [<span class="hljs-title class_">SafeAreaEdge</span>.<span class="hljs-property">BOTTOM</span>])<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="FlutterMainPage"><a href="#FlutterMainPage" class="headerlink" title="FlutterMainPage"></a>FlutterMainPage</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HMPopInfo</span>, <span class="hljs-title class_">HMRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@hadss/hmrouter&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ActionBar</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../comm/ActionBar&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FlutterPath</span>, <span class="hljs-title class_">MyFlutterRouter</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyFlutterRouter&#x27;</span>;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">FlutterMainPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">popResult</span>:<span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Object</span>&gt; | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">ActionBar</span>(&#123;<span class="hljs-attr">title</span>:<span class="hljs-string">&quot;flutter测试页面&quot;</span>&#125;)<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;HMRouter flutter&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-title class_">MyFlutterRouter</span>.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">FlutterPath</span>.<span class="hljs-property">LOGIN</span>, &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;harmonyos&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">3</span> &#125;, &#123;<br>          <span class="hljs-attr">onResult</span>: <span class="hljs-function">(<span class="hljs-params">popInfo: HMPopInfo</span>) =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`FlutterMainPage.push result <span class="hljs-subst">$&#123;popInfo.result&#125;</span>`</span>)<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">popResult</span> = popInfo.<span class="hljs-property">result</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Object</span>&gt;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">popResult</span>)&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;&quot;</span><br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">popResult</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value,key</span>)=&gt;</span>&#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span> : <span class="hljs-subst">$&#123;value&#125;</span> \n`</span><br>              &#125;)<br>            &#125;<br>          &#125;,<br>          <span class="hljs-attr">onArrival</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`FlutterMainPage.push onArrival `</span>)<br>          &#125;,<br>          <span class="hljs-attr">onLost</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`FlutterMainPage.push onLost `</span>)<br>          &#125;<br>        &#125;)<br>      &#125;)<br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&quot;页面返回携带的参数&quot;</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>)<br><br>    &#125;<br>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="MyFlutterRouter"><a href="#MyFlutterRouter" class="headerlink" title="MyFlutterRouter"></a>MyFlutterRouter</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">HMPopInfo</span>, <span class="hljs-title class_">HMRouterMgr</span>, <span class="hljs-title class_">HMRouterPathCallback</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@hadss/hmrouter&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">JSON</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.ArkTS&#x27;</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FlutterAbilityLaunchConfigs</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">FlutterPath</span> &#123;<br>  <span class="hljs-variable constant_">MAIN</span> = <span class="hljs-string">&#x27;main&#x27;</span>,<br>  <span class="hljs-variable constant_">LOGIN</span> = <span class="hljs-string">&#x27;login&#x27;</span>,<br>  <span class="hljs-variable constant_">TEST</span> = <span class="hljs-string">&#x27;test&#x27;</span>,<br>  <span class="hljs-variable constant_">ROOT</span> = <span class="hljs-string">&#x27;/&#x27;</span><br>&#125;<br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFlutterRouter</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">path: FlutterPath, params: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">Object</span>&gt; | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>,</span><br><span class="hljs-params">    callback?: HMRouterPathCallback</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">target</span>: <span class="hljs-built_in">string</span> = path.<span class="hljs-title function_">toString</span>()<br>    <span class="hljs-keyword">if</span> (params) &#123;<br>      target = <span class="hljs-string">`<span class="hljs-subst">$&#123;target&#125;</span>?<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(params)&#125;</span>`</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">routerParams</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; = &#123;&#125;<br>    routerParams[<span class="hljs-title class_">FlutterAbilityLaunchConfigs</span>.<span class="hljs-property">EXTRA_INITIAL_ROUTE</span>] = target;<br><br>    <span class="hljs-title class_">HMRouterMgr</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">pageUrl</span>: <span class="hljs-string">&#x27;pages/flutter/MyFlutterPage&#x27;</span>, <span class="hljs-attr">param</span>: routerParams &#125;, &#123;<br>      <span class="hljs-attr">onResult</span>: <span class="hljs-function">(<span class="hljs-params">popInfo: HMPopInfo</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`获取到页面返回时携带的参数 <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(popInfo.result)&#125;</span>`</span>)<br>        <span class="hljs-keyword">if</span> (callback &amp;&amp; callback.<span class="hljs-property">onResult</span>) &#123;<br>          callback.<span class="hljs-title function_">onResult</span>(popInfo)<br>        &#125;<br>      &#125;,<br>      <span class="hljs-attr">onArrival</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (callback &amp;&amp; callback.<span class="hljs-property">onArrival</span>) &#123;<br>          callback.<span class="hljs-title function_">onArrival</span>()<br>        &#125;<br>      &#125;,<br>      <span class="hljs-attr">onLost</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (callback &amp;&amp; callback.<span class="hljs-property">onLost</span>) &#123;<br>          callback.<span class="hljs-title function_">onLost</span>()<br>        &#125;<br>      &#125;<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>这样我们就完成了从native侧跳转到指定页面，并且还可以将参数传递过去。<br>这里需要特别注意的是在<code>MyFlutterRouter</code>中，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">routerParams</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; = &#123;&#125;<br>routerParams[<span class="hljs-title class_">FlutterAbilityLaunchConfigs</span>.<span class="hljs-property">EXTRA_INITIAL_ROUTE</span>] = target;<br></code></pre></td></tr></table></figure>
<p>这里的参数key用的是<code>FlutterAbilityLaunchConfigs.EXTRA_INITIAL_ROUTE</code>,值为<code>route</code>。<br>这是因为在<code>FlutterEntry</code>中<code>getInitialRoute</code>方法中，获取初始路径使用的就是这个</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">getInitialRoute</span>(): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">parameters</span>![<span class="hljs-title class_">FlutterAbilityLaunchConfigs</span>.<span class="hljs-property">EXTRA_INITIAL_ROUTE</span>]) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">parameters</span>![<span class="hljs-title class_">FlutterAbilityLaunchConfigs</span>.<span class="hljs-property">EXTRA_INITIAL_ROUTE</span>] <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看下效果图：</p>
<p><img src="/image/harmony_flutter/harmony_flutter_initial_route.gif" alt="鸿蒙打开flutter指定页面并且传递参数"></p>
]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-flutter-使用PlatformView</title>
    <url>/2025/06/10/%E9%B8%BF%E8%92%99-flutter-%E4%BD%BF%E7%94%A8PlatformView/</url>
    <content><![CDATA[<p>我们自己的业务比较简单，基本上没有使用PlatformView，所有的页面要么是原生，要么是flutter，没有这种在flutter页面上展示原生控件的需求。<br>这里介绍一下如何在纯flutter项目中使用platformView展示鸿蒙组件。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>按照之前的环境搭建和第一个helloworld，搭建好环境，运行起来。</p>
<h2 id="原生侧"><a href="#原生侧" class="headerlink" title="原生侧"></a>原生侧</h2><p>使用DevEco打开项目工程下的ohos文件夹，DevEco会将该文件夹识别为一个鸿蒙项目，可以获得完整的代码提示和语法高亮。<br>我们先从底层向接口方向编写代码。</p>
<h3 id="需要展示的View"><a href="#需要展示的View" class="headerlink" title="需要展示的View"></a>需要展示的View</h3><p>定义一个用来在Flutter上展示的 Component。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CustomView</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./CustomView&quot;</span> <span class="hljs-comment">//这里的CustomView是我们后面需要继承PlatformView的类</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Params</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/platform/PlatformView&#x27;</span>;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">ButtonComponent</span> &#123;<br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">params</span>: <span class="hljs-title class_">Params</span><br>  <span class="hljs-attr">customView</span>: <span class="hljs-title class_">CustomView</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">params</span>.<span class="hljs-property">platformView</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">CustomView</span><br>  <span class="hljs-meta">@StorageLink</span>(<span class="hljs-string">&#x27;numValue&#x27;</span>) <span class="hljs-attr">storageLink</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;first&quot;</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">bkColor</span>: <span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span><br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;发送数据给Flutter&quot;</span>)<br>        .<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span>&#125;)<br>        .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">bkColor</span>)<br>        .<span class="hljs-title function_">onTouch</span>(<span class="hljs-function">(<span class="hljs-params">event: TouchEvent</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nodeController button on touched&quot;</span>)<br>        &#125;)<br>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">event: ClickEvent</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">customView</span>.<span class="hljs-title function_">sendMessage</span>();<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nodeController button on click&quot;</span>)<br>        &#125;)<br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`来自Flutter的数据 : <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.storageLink&#125;</span>`</span>)<br>        .<span class="hljs-title function_">onTouch</span>(<span class="hljs-function">(<span class="hljs-params">event: TouchEvent</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nodeController text on touched&quot;</span>)<br>        &#125;)<br><br>    &#125;.<span class="hljs-title function_">alignItems</span>(<span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">Center</span>)<br>    .<span class="hljs-title function_">justifyContent</span>(<span class="hljs-title class_">FlexAlign</span>.<span class="hljs-property">Center</span>)<br>    .<span class="hljs-title function_">direction</span>(<span class="hljs-title class_">Direction</span>.<span class="hljs-property">Ltr</span>)<br>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="PlatformView的编写"><a href="#PlatformView的编写" class="headerlink" title="PlatformView的编写"></a>PlatformView的编写</h3><p>我们需要继承<code>PlatformView</code>,并且实现其中的<code>getView</code>方法，返回一个<code>WrappedBuilder</code>, 在这个<code>WrappedBuilder</code>中，返回我们上面自定义的<code>ButtonComponent</code>。<br>当然免不了互相传输数据，因此我们这里还需要实现<code>MethodCallHandler</code>接口.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MethodChannel</span>, &#123;<br>  <span class="hljs-title class_">MethodCallHandler</span>,<br>  <span class="hljs-title class_">MethodResult</span><br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/common/MethodChannel&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">PlatformView</span>, &#123; <span class="hljs-title class_">Params</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/platform/PlatformView&#x27;</span>;<br><span class="hljs-keyword">import</span> common <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos.app.ability.common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BinaryMessenger</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/common/BinaryMessenger&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">StandardMethodCodec</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/common/StandardMethodCodec&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MethodCall</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/common/MethodCall&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">ButtonComponent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ButtonComponent&#x27;</span>;<br><br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PlatformView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodCallHandler</span> &#123;<br>  <span class="hljs-attr">numValue</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;test&quot;</span>;<br><br>  <span class="hljs-attr">methodChannel</span>: <span class="hljs-title class_">MethodChannel</span>;<br>  <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">context: common.Context, viewId: <span class="hljs-built_in">number</span>, args: ESObject, message: BinaryMessenger</span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nodeController viewId:&quot;</span> + viewId)<br>    <span class="hljs-comment">// 注册消息通道，消息通道根据具体需求添加，代码仅作为示例</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodChannel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodChannel</span>(message, <span class="hljs-string">`com.huangyuanlove/customView<span class="hljs-subst">$&#123;viewId&#125;</span>`</span>, <span class="hljs-title class_">StandardMethodCodec</span>.<span class="hljs-property">INSTANCE</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodChannel</span>.<span class="hljs-title function_">setMethodCallHandler</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">onMethodCall</span>(<span class="hljs-attr">call</span>: <span class="hljs-title class_">MethodCall</span>, <span class="hljs-attr">result</span>: <span class="hljs-title class_">MethodResult</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-comment">// 接受Dart侧发来的消息</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span> = call.<span class="hljs-property">method</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">link1</span>: <span class="hljs-title class_">SubscribedAbstractProperty</span>&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-title class_">AppStorage</span>.<span class="hljs-title function_">link</span>(<span class="hljs-string">&#x27;numValue&#x27;</span>);<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;getMessageFromFlutterView&#x27;</span>:<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-title class_">ESObject</span> = call.<span class="hljs-property">args</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">numValue</span> = value;<br>        link1.<span class="hljs-title function_">set</span>(value)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nodeController receive message from dart: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">numValue</span>);<br>        result.<span class="hljs-title function_">success</span>(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> sendMessage = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;nodeController sendMessage&quot;</span>)<br>    <span class="hljs-comment">//向Dart侧发送消息</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodChannel</span>.<span class="hljs-title function_">invokeMethod</span>(<span class="hljs-string">&#x27;getMessageFromOhosView&#x27;</span>, <span class="hljs-string">&#x27;natvie - &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span>++);<br>  &#125;<br><br>  <span class="hljs-title function_">getView</span>(): <span class="hljs-title class_">WrappedBuilder</span>&lt;[<span class="hljs-title class_">Params</span>]&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WrappedBuilder</span>(<span class="hljs-title class_">ButtonBuilder</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">dispose</span>(): <span class="hljs-built_in">void</span> &#123;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Builder</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">ButtonBuilder</span>(<span class="hljs-params">params: Params</span>) &#123;<br>  <span class="hljs-title class_">ButtonComponent</span>(&#123; <span class="hljs-attr">params</span>: params &#125;)<br>    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Yellow</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="自定义PlatformViewFactory"><a href="#自定义PlatformViewFactory" class="headerlink" title="自定义PlatformViewFactory"></a>自定义PlatformViewFactory</h3><p>在这里需要在其create方法中创建自定义的PlatformView的实例。这个<code>PlatformViewFactory</code>主要就干这件事情。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> common <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos.app.ability.common&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MessageCodec</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/common/MessageCodec&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">PlatformViewFactory</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/platform/PlatformViewFactory&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">BinaryMessenger</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/common/BinaryMessenger&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">PlatformView</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/platform/PlatformView&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CustomView</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./CustomView&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PlatformViewFactory</span> &#123;<br>  <span class="hljs-attr">message</span>: <span class="hljs-title class_">BinaryMessenger</span>;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message: BinaryMessenger, createArgsCodes: MessageCodec&lt;<span class="hljs-built_in">Object</span>&gt;</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(createArgsCodes);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = message;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">create</span>(<span class="hljs-attr">context</span>: common.<span class="hljs-property">Context</span>, <span class="hljs-attr">viewId</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">args</span>: <span class="hljs-title class_">Object</span>): <span class="hljs-title class_">PlatformView</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomView</span>(context, viewId, args, <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="自定义FlutterPlugin"><a href="#自定义FlutterPlugin" class="headerlink" title="自定义FlutterPlugin"></a>自定义FlutterPlugin</h3><p>这里我们需要自定义一个继承于FlutterPlugin的CustomPlugin插件，在onAttachedToEngine中，注册自定义的PlatformViewFactory。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span>  &#123; <span class="hljs-title class_">FlutterPlugin</span>,<br>  <span class="hljs-title class_">FlutterPluginBinding</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/embedding/engine/plugins/FlutterPlugin&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">StandardMessageCodec</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos/src/main/ets/plugin/common/StandardMessageCodec&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CustomFactory</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./CustomFactory&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomPlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FlutterPlugin</span> &#123;<br>  <span class="hljs-title function_">getUniqueClassName</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;CustomPlugin&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">onAttachedToEngine</span>(<span class="hljs-attr">binding</span>: <span class="hljs-title class_">FlutterPluginBinding</span>): <span class="hljs-built_in">void</span> &#123;<br>    binding.<span class="hljs-title function_">getPlatformViewRegistry</span>()?.<br>    <span class="hljs-title function_">registerViewFactory</span>(<span class="hljs-string">&#x27;com.huangyuanlove/customView&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomFactory</span>(binding.<span class="hljs-title function_">getBinaryMessenger</span>(), <span class="hljs-title class_">StandardMessageCodec</span>.<span class="hljs-property">INSTANCE</span>));<br>  &#125;<br><br>  <span class="hljs-title function_">onDetachedFromEngine</span>(<span class="hljs-attr">binding</span>: <span class="hljs-title class_">FlutterPluginBinding</span>): <span class="hljs-built_in">void</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="添加Plugin"><a href="#添加Plugin" class="headerlink" title="添加Plugin"></a>添加Plugin</h3><p>现在我们需要将上面自定义的plugin在<code>EntryAbility</code>中注册一下.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">FlutterAbility</span>, <span class="hljs-title class_">FlutterEngine</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/flutter_ohos&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">GeneratedPluginRegistrant</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../plugins/GeneratedPluginRegistrant&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CustomPlugin</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../widget/CustomPlugin&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryAbility</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">FlutterAbility</span> &#123;<br>  <span class="hljs-title function_">configureFlutterEngine</span>(<span class="hljs-params">flutterEngine: FlutterEngine</span>) &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">configureFlutterEngine</span>(flutterEngine)<br>    <span class="hljs-title class_">GeneratedPluginRegistrant</span>.<span class="hljs-title function_">registerWith</span>(flutterEngine)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addPlugin</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomPlugin</span>());<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>  至此，我们完成了原生侧的开发，下面看一下flutter侧怎么搞</p>
<h2 id="Flutter侧"><a href="#Flutter侧" class="headerlink" title="Flutter侧"></a>Flutter侧</h2><h3 id="用于发送和接收数据的Controller"><a href="#用于发送和接收数据的Controller" class="headerlink" title="用于发送和接收数据的Controller"></a>用于发送和接收数据的Controller</h3><p>这里我们先封装一个用于和原生侧进行数据交互的类，就叫<code>CustomViewController</code>了。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomViewController</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> MethodChannel _channel;<br>  <span class="hljs-keyword">final</span> StreamController&lt;<span class="hljs-built_in">String</span>&gt; _controller = StreamController&lt;<span class="hljs-built_in">String</span>&gt;();<br><br>  CustomViewController._(<br>    <span class="hljs-keyword">this</span>._channel,<br>  ) &#123;<br>    _channel.setMethodCallHandler(<br>      (call) <span class="hljs-keyword">async</span> &#123;<br>        <span class="hljs-keyword">switch</span> (call.method) &#123;<br>          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;getMessageFromOhosView&#x27;</span>:<br>            <span class="hljs-comment">// 从native端获取数据</span><br>            <span class="hljs-keyword">final</span> result = call.arguments <span class="hljs-keyword">as</span> <span class="hljs-built_in">String</span>;<br>            _controller.sink.add(result);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;,<br>    );<br>  &#125;<br><br>  Stream&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">get</span> customDataStream =&gt; _controller.stream;<br><br>  <span class="hljs-comment">// 发送数据给native</span><br>  Future&lt;<span class="hljs-keyword">void</span>&gt; sendMessageToOhosView(<span class="hljs-built_in">String</span> message) <span class="hljs-keyword">async</span> &#123;<br>    <span class="hljs-keyword">await</span> _channel.invokeMethod(<br>      <span class="hljs-string">&#x27;getMessageFromFlutterView&#x27;</span>,<br>      message,<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这个类不封装也行，看自己的喜好。</p>
<h3 id="用于展示原生控件的Widget"><a href="#用于展示原生控件的Widget" class="headerlink" title="用于展示原生控件的Widget"></a>用于展示原生控件的Widget</h3><p>flutter侧比较简单，只需要搞一个用来展示原生控件的Widget就可以了，交互的话还是走channel，就是用上面封装的<code>CustomViewController</code>.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:async&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/services.dart&#x27;</span>;<br><br><span class="hljs-keyword">typedef</span> OnViewCreated = <span class="hljs-built_in">Function</span>(CustomViewController);<br><br><span class="hljs-comment">///<span class="language-markdown">自定义OhosView</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomOhosView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">final</span> OnViewCreated onViewCreated;<br><br>  <span class="hljs-keyword">const</span> CustomOhosView(<span class="hljs-keyword">this</span>.onViewCreated, &#123;Key? key&#125;) : <span class="hljs-keyword">super</span>(key: key);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;CustomOhosView&gt; createState() =&gt; _CustomOhosViewState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_CustomOhosViewState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CustomOhosView</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">late</span> MethodChannel _channel;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> _getPlatformFaceView();<br>  &#125;<br><br>  Widget _getPlatformFaceView() &#123;<br>    <span class="hljs-keyword">return</span> OhosView(<br>      viewType: <span class="hljs-string">&#x27;com.huangyuanlove/customView&#x27;</span>,<br>      onPlatformViewCreated: _onPlatformViewCreated,<br>      creationParams: <span class="hljs-keyword">const</span> &lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">dynamic</span>&gt;&#123;<span class="hljs-string">&#x27;initParams&#x27;</span>: <span class="hljs-string">&#x27;hello world&#x27;</span>&#125;,<br>      creationParamsCodec: <span class="hljs-keyword">const</span> StandardMessageCodec(),<br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> _onPlatformViewCreated(<span class="hljs-built_in">int</span> id) &#123;<br>    _channel = MethodChannel(<span class="hljs-string">&#x27;com.huangyuanlove/customView<span class="hljs-subst">$id</span>&#x27;</span>);<br>    <span class="hljs-keyword">final</span> controller = CustomViewController._(<br>      _channel,<br>    );<br>    widget.onViewCreated(controller);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这里的<code>OhosView</code>组件就是用来桥接PlatformView组件的。<br>其中：</p>
<blockquote>
<p>viewType：传递给Native侧，告知插件需要创建那个PlatformView，这个PlatformView需要在插件初始化时注册。<br>onPlatformViewCreated：PlatformView创建成功时的回调。<br>creationParams：传递给PlatformView的初始化参数。</p>
</blockquote>
<p>这里需要注意，参数<code>viewType</code>必须和原生侧的<code>CustomPlugin</code>类中的<code>onAttachedToEngine</code>方法中，调用<code>registerViewFactory</code>方法第一个参数一致。<br>在<code>_onPlatformViewCreated</code>方法中注册的<code>Channel</code>就更不需要多说了.</p>
<h3 id="展示并运行"><a href="#展示并运行" class="headerlink" title="展示并运行"></a>展示并运行</h3><p>我们找个页面来同时展示一下flutter组件和原生组件，这里为了简单，直接修改了<code>main.dart</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dart:math&#x27;</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:flutter/material.dart&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;package:ohflutter_3221/widget/CustomOhosView.dart&#x27;</span>;<br><br><span class="hljs-keyword">void</span> main() &#123;<br>  runApp(<span class="hljs-keyword">const</span> MaterialApp(home: Main()));<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> Main(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">const</span> Scaffold(<br>      body: CustomViewExample(),<br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomViewExample</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatefulWidget</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> CustomViewExample(&#123;<span class="hljs-keyword">super</span>.key&#125;);<br><br>  <span class="hljs-meta">@override</span><br>  State&lt;CustomViewExample&gt; createState() =&gt; _CustomViewExampleState();<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_CustomViewExampleState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">CustomViewExample</span>&gt; </span>&#123;<br>  <span class="hljs-built_in">String</span> receivedData = <span class="hljs-string">&#x27;&#x27;</span>;<br>  CustomViewController? _controller;<br><br>  <span class="hljs-keyword">void</span> _onCustomOhosViewCreated(CustomViewController controller) &#123;<br>    _controller = controller;<br>    _controller?.customDataStream.listen((data) &#123;<br>      <span class="hljs-comment">//接收到来自OHOS端的数据</span><br>      setState(() &#123;<br>        receivedData = <span class="hljs-string">&#x27;来自ohos的数据：<span class="hljs-subst">$data</span>&#x27;</span>;<br>      &#125;);<br>    &#125;);<br>  &#125;<br><br>  Widget _buildOhosView() &#123;<br>    <span class="hljs-keyword">return</span> Expanded(<br>      flex: <span class="hljs-number">1</span>,<br>      child: Container(<br>        color: Colors.blueAccent.withAlpha(<span class="hljs-number">60</span>),<br>        child: CustomOhosView(_onCustomOhosViewCreated),<br>      ),<br>    );<br>  &#125;<br><br>  Widget _buildFlutterView() &#123;<br>    <span class="hljs-keyword">return</span> Expanded(<br>      flex: <span class="hljs-number">1</span>,<br>      child: Column(<br>        mainAxisAlignment: MainAxisAlignment.center,<br>        mainAxisSize: MainAxisSize.max,<br>        children: [<br>          TextButton(<br>            onPressed: () &#123;<br>              <span class="hljs-keyword">final</span> randomNum = Random().nextInt(<span class="hljs-number">10</span>);<br>              _controller?.sendMessageToOhosView(<span class="hljs-string">&#x27;flutter - <span class="hljs-subst">$randomNum</span> &#x27;</span>);<br>            &#125;,<br>            child: <span class="hljs-keyword">const</span> Text(<span class="hljs-string">&#x27;发送数据给ohos&#x27;</span>),<br>          ),<br>          <span class="hljs-keyword">const</span> SizedBox(height: <span class="hljs-number">10</span>),<br>          Text(receivedData),<br>        ],<br>      ),<br>    );<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Column(<br>      children: [<br>        _buildOhosView(),<br>        _buildFlutterView(),<br>      ],<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这样我们就完成了原生组件的展示，和flutter组件的通信。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>放个效果图<br><img src="/image/harmony_flutter/platform_view.gif" alt="platform_view"></p>
]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-flutter-如何向现有鸿蒙项目中添加flutter模块</title>
    <url>/2025/04/29/%E9%B8%BF%E8%92%99-flutter-%E5%A6%82%E4%BD%95%E5%90%91%E7%8E%B0%E6%9C%89%E9%B8%BF%E8%92%99%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%B7%BB%E5%8A%A0flutter%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在版本迭代时，有部分新增的功能，需要开发新的业务模块，这里希望使用跨平台框架，实现代码Android、iOS、HarmonyOS 复用。之前的部分业务使用flutter 开发，HarmonyOS 也支持 flutter 的接入，因此，这次依然使用选择使用 flutter。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>在上一篇中详细介绍了如何安装和配置环境，flutter使用的是<code>3.22.0-ohos</code>的版本，如果需要使用多个flutter版本的话，可以使用fvm来管理和切换多个版本</p>
<h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><h3 id="创建-flutter-模块"><a href="#创建-flutter-模块" class="headerlink" title="创建 flutter 模块"></a>创建 flutter 模块</h3><p>在鸿蒙项目文件夹中创建flutter module</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">为方便代码管理，将flutter代码放到工程目录内统一管理</span><br>cd HarmonyProject<br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.以module形式集成到项目，创建flutter_module</span><br>flutter create -t module my_flutter_module<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.构建har文件,注意，这里需要限制性一下flutter的构建，否则是没有har文件的</span><br>cd flutter_module<br>flutter build har --release<br></code></pre></td></tr></table></figure>
<h3 id="引用-flutter"><a href="#引用-flutter" class="headerlink" title="引用 flutter"></a>引用 flutter</h3><p>这里有两种方案，直接应用源码和引用har文件。<br>我们可以在开发阶段引用源码，在测试发版时引用 har 文件。</p>
<h4 id="引用源码"><a href="#引用源码" class="headerlink" title="引用源码"></a>引用源码</h4><p>修改鸿蒙工程根目录下的<code>oh-package.json5</code>文件并添加对应的依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs json5">&quot;dependencies&quot;:&#123;<br>    &quot;@ohos/flutter_ohos&quot;: &quot;file:./my_flutter_module/.ohos/har/flutter.har&quot;,<br>    &quot;@ohos/flutter_module&quot;: &quot;./my_flutter_module/.ohos/flutter_module&quot;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>修改项目工程下的<code>build-profile.json5</code>文件，添加一个新的module</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 以下为新增内容</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;flutter_module&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;srcPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./my_flutter_module/.ohos/flutter_module&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;targets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;applyToProducts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;default&quot;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>

<h4 id="引用har文件"><a href="#引用har文件" class="headerlink" title="引用har文件"></a>引用har文件</h4><p>在测试发版的时候先将 flutter 模块打成 har 包，复制到鸿蒙项目中，直接引用 har 文件就好。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">2.构建har文件</span><br>cd my_flutter_module<br>flutter build har --release<br></code></pre></td></tr></table></figure>
<p>我们可以在<code>my_flutter_module/.ohos/har</code>文件夹下看到两个har文件： <code>flutter.har</code>和<code>flutter_module.har</code>。<br>我们可以将这两个文件复制到harmony项目中直接应用。</p>
<p>这里有个小问题，flutter 项目引入了三方库时，会生成多个 har 文件，在鸿蒙工程内运行时会报错，<br>我们可以添加<code>overrides</code>声明</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;overrides&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;@ohos/flutter_ohos&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;file:./har/flutter.har&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;fluttertoast&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;file:har/fluttertoast.har&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;path_provider_ohos&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;file:har/path_provider_ohos.har&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;permission_handler_ohos&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;file:har/permission_handler_ohos.har&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>需要注意的是，在切换引用方式的时候，记得修改工程下的<code>build-profile.json5</code>文件。</p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>我们这里使用FlutterEntry来展示flutter相关页面。</p>
<h3 id="EntryAbility-可以继承-UIAbility"><a href="#EntryAbility-可以继承-UIAbility" class="headerlink" title="EntryAbility 可以继承 UIAbility"></a>EntryAbility 可以继承 UIAbility</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryAbility</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">UIAbility</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ExclusiveAppComponent</span>&lt;<span class="hljs-title class_">UIAbility</span>&gt; &#123;<br><br>  <span class="hljs-title function_">detachFromFlutterEngine</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-comment">// throw new Error(&#x27;Method not implemented.&#x27;);</span><br>  &#125;<br><br>  <span class="hljs-title function_">getAppComponent</span>(): <span class="hljs-title class_">UIAbility</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">onCreate</span>(<span class="hljs-attr">want</span>: <span class="hljs-title class_">Want</span>, <span class="hljs-attr">launchParam</span>: <span class="hljs-title class_">AbilityConstant</span>.<span class="hljs-property">LaunchParam</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">pushUIAbility</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">onDestroy</span>(): <span class="hljs-built_in">void</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; &#123;<br>    <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">popUIAbility</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">onWindowStageCreate</span>(<span class="hljs-attr">windowStage</span>: <span class="hljs-variable language_">window</span>.<span class="hljs-property">WindowStage</span>): <span class="hljs-built_in">void</span> &#123;<br>    windowStage.<span class="hljs-title function_">getMainWindowSync</span>().<span class="hljs-title function_">setWindowLayoutFullScreen</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">pushWindowStage</span>(<span class="hljs-variable language_">this</span>, windowStage);<br>    windowStage.<span class="hljs-title function_">loadContent</span>(<span class="hljs-string">&#x27;pages/Index&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">onWindowStageDestroy</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">popWindowStage</span>(<span class="hljs-variable language_">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="继承-FlutterEntry-并注册插件"><a href="#继承-FlutterEntry-并注册插件" class="headerlink" title="继承 FlutterEntry 并注册插件"></a>继承 FlutterEntry 并注册插件</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFlutterEntry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">FlutterEntry</span> &#123;<br>  <span class="hljs-title function_">configureFlutterEngine</span>(<span class="hljs-attr">flutterEngine</span>: <span class="hljs-title class_">FlutterEngine</span>): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">configureFlutterEngine</span>(flutterEngine);<br>    <span class="hljs-title class_">GeneratedPluginRegistrant</span>.<span class="hljs-title function_">registerWith</span>(flutterEngine);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">delegate</span>?.<span class="hljs-title function_">addPlugin</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BatteryPlugin</span>());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="FlutterEntry-需要和-FlutterView-一起使用"><a href="#FlutterEntry-需要和-FlutterView-一起使用" class="headerlink" title="FlutterEntry 需要和 FlutterView 一起使用"></a>FlutterEntry 需要和 FlutterView 一起使用</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">Index</span> &#123;<br>  <span class="hljs-keyword">private</span> context = <span class="hljs-title function_">getContext</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-keyword">as</span> common.<span class="hljs-property">UIAbilityContext</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">flutterEntry</span>: <span class="hljs-title class_">FlutterEntry</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">private</span> flutterView?: <span class="hljs-title class_">FlutterView</span><br><br>  <span class="hljs-title function_">aboutToAppear</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-string">&quot;Flutter&quot;</span>, <span class="hljs-string">&quot;Index aboutToAppear===&quot;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFlutterEntry</span>(<span class="hljs-title function_">getContext</span>(<span class="hljs-variable language_">this</span>))<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span>.<span class="hljs-title function_">aboutToAppear</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterView</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span>.<span class="hljs-title function_">getFlutterView</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">aboutToDisappear</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-string">&quot;Flutter&quot;</span>, <span class="hljs-string">&quot;Index aboutToDisappear===&quot;</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span>?.<span class="hljs-title function_">aboutToDisappear</span>()<br>  &#125;<br><br>  <span class="hljs-comment">// Navigation的生命周期是onShown</span><br>  <span class="hljs-title function_">onPageShow</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-string">&quot;Flutter&quot;</span>, <span class="hljs-string">&quot;Index onPageShow===&quot;</span>);<br>     <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">setUseFullScreen</span>(<span class="hljs-literal">true</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span>?.<span class="hljs-title function_">onPageShow</span>()<br>  &#125;<br><br>  <span class="hljs-comment">// Navigation的生命周期是onHidden</span><br>  <span class="hljs-title function_">onPageHide</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Log</span>.<span class="hljs-title function_">d</span>(<span class="hljs-string">&quot;Flutter&quot;</span>, <span class="hljs-string">&quot;Index onPageHide===&quot;</span>);<br>     <span class="hljs-title class_">FlutterManager</span>.<span class="hljs-title function_">getInstance</span>().<span class="hljs-title function_">setUseFullScreen</span>(<span class="hljs-literal">false</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterEntry</span>?.<span class="hljs-title function_">onPageHide</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Stack</span>() &#123;<br>      <span class="hljs-title class_">FlutterPage</span>(&#123; <span class="hljs-attr">viewId</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">flutterView</span>?.<span class="hljs-title function_">getId</span>() &#125;)<br>  &#125;<br><br>  <span class="hljs-title function_">onBackPress</span>(): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span>.<span class="hljs-property">eventHub</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;EVENT_BACK_PRESS&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>运行后我们使用router跳转到这个页面，发现是可以加载出来的，点击页面按钮行为也是正常的。</p>
<p><img src="/image/harmony_flutter/flutter_entry_demo.gif" alt="flutter entry示例"></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>接下来我们继续看下路由管理以及参数传递问题</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-flutter-环境搭建和第一个HelloWorld</title>
    <url>/2025/05/27/%E9%B8%BF%E8%92%99-flutter-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AAHelloWorld/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正在慢慢的补齐鸿蒙版本应用的功能，之前 Android 和 iOS 上有一部分功能是 flutter 实现的，现在需要把相关代码移植到鸿蒙应用中。慢慢来，不着急。<br>由于目前只有64位引擎，暂不支持模拟器，需要使用真机调试。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>现存的flutter 相关代码使用的是 flutter3.0.2 版本，正好趁这个机会升级一下版本。<br>由于鸿蒙版的flutter 3.22.0 已经 release，直接升级到这个版本。<br>这里插播一条消息</p>
<blockquote>
<p>所有鸿蒙相关开源仓后续均迁移至GitCode平台，SIG、TPC组织已完成迁移，OpenHarmony主组织仓也即将完成迁移<br>SDK:<br>gitcode分支（官方分支，持续更新）：<br><a href="https://gitcode.com/openharmony-sig/flutter_flutter/tree/3.22.0-ohos">https://gitcode.com/openharmony-sig/flutter_flutter/tree/3.22.0-ohos</a><br>原始仓库<br><a href="https://gitee.com/harmonycommando_flutter/flutter">https://gitee.com/harmonycommando_flutter/flutter</a><br>Engine:<br>gitcode分支（官方分支，持续更新）：<br><a href="https://gitcode.com/openharmony-sig/flutter_engine/tree/oh-3.22.0">https://gitcode.com/openharmony-sig/flutter_engine/tree/oh-3.22.0</a><br>原始仓库<br><a href="https://gitee.com/harmonycommando_flutter/flutter_engine">https://gitee.com/harmonycommando_flutter/flutter_engine</a></p>
</blockquote>
<h3 id="鸿蒙环境"><a href="#鸿蒙环境" class="headerlink" title="鸿蒙环境"></a>鸿蒙环境</h3><p>鸿蒙的环境很简单，下载最新的 DevEco 安装好就行了。这样就包含了开发鸿蒙所需要的所有工具。<br>但使用 flutter 混编时还需要将几个工具路径添加的环境变量里面。<br>当然了，不下载 DevEco，下载对应的<code>Command Line Tools for HarmonyOS </code>也可以。但是免不了会编写一些 ArkTS 相关的鸿蒙代码，比如录音、相机的调用等，目前来看还没有其他的IDE 支持 ArkTS 的语法，所以，还是建议安装 DevEco。<br>需要添加到环境变量的工具。<br>mac上需要配置这些</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">export TOOL_HOME=/Applications/DevEco-Studio.app/Contents # mac环境<br>export DEVECO_SDK_HOME=$TOOL_HOME/sdk # command-line-tools/sdk<br>export PATH=$TOOL_HOME/tools/ohpm/bin:$PATH # command-line-tools/ohpm/bin<br>export PATH=$TOOL_HOME/tools/hvigor/bin:$PATH # command-line-tools/hvigor/bin<br>export PATH=$TOOL_HOME/tools/node/bin:$PATH # command-line-tools/tool/node/bin<br></code></pre></td></tr></table></figure>
<p>在 windows 上有些修改，<br>需要配置一个变量名为<code>HOS_SDK_HOME</code>,值为sdk路径的变量，比如我是安装的DevEco，sdk路径就是<code>D:\DevEco\DevEco Studio\sdk</code><br><img src="/image/harmony_flutter/HOS_SDK_HOME.png">。<br>然后我们再将<code>D:\DevEco\DevEco Studio\tools\hvigor\bin</code>、<code>D:\DevEco\DevEco Studio\tools\node</code>、<code>D:\DevEco\DevEco Studio\tools\ohpm\bin</code>添加到环境变量。</p>
<p><strong>注意注意注意</strong><br>如用下载的是flutter分支是<code>3.22.0-ohos</code>,则环境变量名字为<code>DEVECO_SDK_HOME</code></p>
<h3 id="flutter-环境"><a href="#flutter-环境" class="headerlink" title="flutter 环境"></a>flutter 环境</h3><p>克隆(flutter_flutter)[<a href="https://gitcode.com/openharmony-tpc/flutter_flutter/tree/3.22.0-ohos]%E4%BB%93%E5%BA%93%E7%9A%84%603.22.0-ohos%60%E5%88%86%E6%94%AF%E5%B0%B1%E5%8F%AF%E4%BB%A5%E3%80%82">https://gitcode.com/openharmony-tpc/flutter_flutter/tree/3.22.0-ohos]仓库的`3.22.0-ohos`分支就可以。</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">git clone -b 3.22.1-ohos-1.0.1 https://gitcode.com/openharmony-sig/flutter_flutter.git<br></code></pre></td></tr></table></figure>
<p>下载完成后，将<code>flutter</code>添加到环境变量<br>mac环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">export PATH=&lt;flutter_flutter path&gt;/bin:$PATH<br>export PUB_HOSTED_URL=https://pub.flutter-io.cn  #国内的镜像，也可以使用其他镜像，比如清华镜像源<br>export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn #国内的镜像，也可以使用其他镜像，比如清华镜像源<br></code></pre></td></tr></table></figure>

<p>windows环境变量，也是将<code>&lt;flutter_flutter path&gt;\bin</code>添加到环境变量。然后再分别新建<code>PUB_HOSTED_URL</code>、<code>FLUTTER_STORAGE_BASE_URL</code>添加到环境变量。</p>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>命令行执行一下<code>flutter doctor -v</code>,如果能找到能执行成功，并且Futter与OpenHarmony应都为ok标识，若两处提示缺少环境，按提示补上相应环境即可。</p>
<p><img src="/image/harmony_flutter/harmony_flutter_doctor_mac.png" alt="harmony_flutter_doctor_mac"></p>
<h2 id="第一个-HelloWorld"><a href="#第一个-HelloWorld" class="headerlink" title="第一个 HelloWorld"></a>第一个 HelloWorld</h2><p>创建项目的命令和官方的 flutter 是一样的，只不过是多了一个鸿蒙平台的支持。<br>我们创建一个支持 Android、iOS 和鸿蒙的 flutter 项目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">flutter create  --platforms android,ios,ohos  -i objc -a java ohflutter_3221<br></code></pre></td></tr></table></figure>
<p>可以指定 iOS 平台使用 oc,Android平台使用 Java 语言，鸿蒙平台不需要指定，只有一个 ArkTS 可用<br>执行的结果也没什么两样,只不过在对应的项目文件夹下多了一个<code>ohos</code>文件夹，和 <code>android</code>、<code>ios</code>文件夹一样，用来存放原生相关的代码<br>然后我们连接好设备，在工程文件夹下执行<code>flutter run</code>，会提示我们需要配置调试签名。<br><img src="/image/harmony_flutter/oh_flutter_config_sign.png" alt="oh_flutter_config_sign">。<br>这里我们需要注册一个华为开发者账号，然后按照提示进行签名。<br>配置完签名之后，我们再次执行<code>flutter run</code></p>
<p>看下效果<br><img src="/image/harmony_flutter/oh_flutter_hello_world.gif" alt="运行结果"></p>
<h2 id="FlutterPage"><a href="#FlutterPage" class="headerlink" title="FlutterPage"></a>FlutterPage</h2><p>我们可以使用DevEcoStudio打开项目下的ohos文件夹中的项目看一下，其中的<code>EntryAbility</code>继承了<code>FlutterAbility</code>,在FlutterAbility中，我们可以看到<code>FlutterManager</code>，<code>FlutterView</code>,以及在<code>onWindowStageCreate</code>方法中默认加载的<code>pages/Index</code>。<br>因此我们如果想要向现有鸿蒙工程中添加flutter模块时，借鉴一下这里面的写法。</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-hvigor定制构建</title>
    <url>/2025/01/17/%E9%B8%BF%E8%92%99-hvigor%E5%AE%9A%E5%88%B6%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前需要发版时都是在开发机上修改一下相关配置，比如签名文件、三方SDK参数等，然后打包上传到应用商店。略显繁琐，也担心某次打包会有漏改错改的配置。现在使用jenkins搭建了构建流水线，希望可以根据传入的参数不同，替换配置文件中的字段。翻看文档后发现可以在<code>hvigorfile.ts</code>中接收部分编译配置。</p>
<h2 id="BuildProfile"><a href="#BuildProfile" class="headerlink" title="BuildProfile"></a>BuildProfile</h2><p>该类和 Android 项目中的 BuildConfig类很像，也是在编译构建时生成的。我们可以通过该类在运行时获取编译构建参数，也可以在<code>build-profile.json5</code>中通过buildProfileFields增加自定义字段，从而在运行时获取自定义的参数。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>项目代码已经迭代了将近10年，有些功能的添加没有办法做到完美向下兼容，只能在请求参数中添加当前应用版本号，服务端根据版本号来判断需要下发哪些数据。但鸿蒙版本是刚开发开发，在一个版本内无法完成全部功能，需要分版本按紧急程度开发，因此版本号也不能直接和 Android、iOS 对齐，也是从 1.0.0 版本开始发版。所以无法在请求参数中直接传递应用版本号。因此我们将当前适配的版本号写入到<code>BuildProfile.ets</code>文件中，方便各个业务调用。</p>
<p>我们在项目根目录下的<code>build-profile.json5</code>文件中添加如下内容就可以将自定义的字段写入到该文件中.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript">&#123;<br>	<span class="hljs-attr">app</span>: &#123;<br>		<span class="hljs-attr">products</span>: [&#123;<br>			<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;default&quot;</span>,<br>			<span class="hljs-attr">signingConfig</span>: <span class="hljs-string">&quot;default&quot;</span>,<br>			<span class="hljs-attr">compatibleSdkVersion</span>: <span class="hljs-string">&quot;5.0.0(12)&quot;</span>,<br>			<span class="hljs-attr">runtimeOS</span>: <span class="hljs-string">&quot;HarmonyOS&quot;</span>,<br>			<span class="hljs-attr">buildOption</span>: &#123;<br>				<span class="hljs-attr">arkOptions</span>: &#123;<br>					<span class="hljs-attr">buildProfileFields</span>: &#123;<br>						<span class="hljs-attr">online</span>: <span class="hljs-literal">false</span>,<br>						<span class="hljs-attr">version_to_servier</span>: <span class="hljs-string">&quot;5.11.10&quot;</span>,<br>					&#125;,<br>				&#125;<br>			&#125;,<br>		&#125;,<br>		]<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>自定义参数可以在<code>buildOption</code>、<code>buildOptionSet</code>、<code>targets</code>节点下的<code>arkOptions</code>子节点中通过增加<code>buildProfileFields</code>字段实现，自定义参数通过<code>key-value</code>键值对的方式配置，其中<code>value</code>取值仅支持<code>number</code>、<code>string</code>、<code>boolean</code>类型。<br>当然，该配置也可以在模块下的<code>build-profile.json5</code>中配置。优先级如下：</p>
<blockquote>
<p>模块级target &gt; 模块级buildOptionSet &gt; 模块级buildOption &gt; 工程级product &gt; 工程级buildModeSet</p>
</blockquote>
<p>这里我们添加了<code>version_to_servier</code>字段来表示当前应用适配到了哪个版本。<br>正常情况下，我们运行代码就可以在<code>$&#123;moduleName&#125; / build / $&#123;productName&#125; / generated / profile / $&#123;targetName&#125; </code>目录下生成<code>BuildProfile.ets</code>文件。<br>也可以在命令行执行<code>hvigorw GenerateBuildProfile</code>。<br>也可以选中需要编译的模块，在菜单栏选择<code>Build &gt; Generate Build Profile $&#123;moduleName&#125;</code>。<br>也可以在菜单栏选择<code>Build &gt; Build Hap(s)/APP(s) &gt; Build Hap(s)”或“Build &gt; Build Hap(s)/APP(s) &gt; Build APP(s)</code>。</p>
<p>使用时可以这么用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">BuildProfile</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./BuildProfile&#x27;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">VERSION_TO_SERVER</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">BuildProfile</span>.<span class="hljs-property">version_to_servier</span>;<br></code></pre></td></tr></table></figure>

<h2 id="替换模块module-json5字段的值"><a href="#替换模块module-json5字段的值" class="headerlink" title="替换模块module.json5字段的值"></a>替换模块module.json5字段的值</h2><p>我们使用了某三方SDK，需要在<strong>模块</strong>下<code>module.json5</code>文件中添加对应的id </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript">&#123;<br>  <span class="hljs-string">&quot;module&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;metadata&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;xxx_APPID&quot;</span>,<br>        <span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;1234567&quot;</span><br>      &#125;<br>    ],<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了区分测试环境和生产环境，<code>xxx_APPID</code>配置了不一样的值，我们期望是打包时通过命令行参数来修改这个值，避免认为配置出现错误。</p>
<h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p>使用命令行<code>hvigorw</code>打包时除了<code>buildMode</code>、<code>debuggable</code>等参数外，还支持<code>--config properties.key=value</code>进行自定义参数。并且在模块下、工程下的<code>hvigorfile.ts</code>中都可以接收到该参数。</p>
<p>这里我们定义了布尔类型的<code>online</code>参数来表示是否为发版包，当模块下的<code>hvigorfile.ts</code>文件中根据该字段的值来区分配置的参数。<br>具体代码如下，在模块下的<code>hvigorfile.ts</code>文件中：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; hapTasks, <span class="hljs-title class_">OhosHapContext</span>, <span class="hljs-title class_">OhosPluginId</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/hvigor-ohos-plugin&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; getNode &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/hvigor&#x27;</span><br><br><span class="hljs-keyword">const</span> entryNode = <span class="hljs-title function_">getNode</span>(__filename);<br><span class="hljs-comment">// 为此节点添加一个afterNodeEvaluate hook 在hook中修改module.json5的内容并使能</span><br>entryNode.<span class="hljs-title function_">afterNodeEvaluate</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">//获取命令行参数</span><br>  <span class="hljs-keyword">let</span> online = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">let</span> propertyOnline = hvigor.<span class="hljs-title function_">getParameter</span>().<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&#x27;online&#x27;</span>);<br>  <span class="hljs-keyword">if</span> (propertyOnline != <span class="hljs-literal">undefined</span>) &#123;<br>    online = propertyOnline<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;entry online-&gt; &quot;</span> + propertyOnline);<br><br>  <span class="hljs-comment">// 获取此节点使用插件的上下文对象 此时为hap插件 获取hap插件上下文对象</span><br>  <span class="hljs-keyword">const</span> hapContext = node.<span class="hljs-title function_">getContext</span>(<span class="hljs-title class_">OhosPluginId</span>.<span class="hljs-property">OHOS_HAP_PLUGIN</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">OhosHapContext</span>;<br>  <span class="hljs-comment">// 通过上下文对象获取从module.json5文件中读出来的obj对象</span><br>  <span class="hljs-keyword">const</span> moduleJsonOpt = hapContext.<span class="hljs-title function_">getModuleJsonOpt</span>();<br>  <span class="hljs-comment">// 修改obj对象为想要的，此处举例修改module中的deviceTypes</span><br>  <span class="hljs-keyword">let</span> metaDateList = moduleJsonOpt[<span class="hljs-string">&#x27;module&#x27;</span>][<span class="hljs-string">&#x27;metadata&#x27;</span>]<br>  metaDateList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (element[<span class="hljs-string">&#x27;name&#x27;</span>] === <span class="hljs-string">&#x27;xxx_APPID&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (online) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;线上环境，修改xxx_APPID配置为   abcdefg&#x27;</span>)<br>        element[<span class="hljs-string">&#x27;value&#x27;</span>] = <span class="hljs-string">&#x27;abcdefg&#x27;</span><br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;测试环境，修改xxx_APPID配置为   1234567&#x27;</span>)<br>        element[<span class="hljs-string">&#x27;value&#x27;</span>] = <span class="hljs-string">&#x27;1234567&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;);<br><br>    <span class="hljs-comment">// 将obj对象设置回上下文对象以使能到构建的过程与结果中</span><br>    hapContext.<span class="hljs-title function_">setModuleJsonOpt</span>(moduleJsonOpt);<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">system</span>: hapTasks,  <span class="hljs-comment">/* Built-in plugin of Hvigor. It cannot be modified. */</span><br>    <span class="hljs-attr">plugins</span>:[]         <span class="hljs-comment">/* Custom plugin to extend the functionality of Hvigor. */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在打包构建时只需要执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">hvigorw clean  assembleApp -p buildMode=release --config properties.online=true<br></code></pre></td></tr></table></figure>
<p>就可以直接替换为生产环境的配置了。因为平时开发都是直接点 IDE 中的 run 进行调试，不会传入该参数，也就不会影响文件中原本配置的值。</p>
<h2 id="打包签名"><a href="#打包签名" class="headerlink" title="打包签名"></a>打包签名</h2><p>上面也提到自定义的参数也可以在工程下的<code>hvigorfile.ts</code>接收到该参数，上面<code>BuildProfile</code>中也提到在工程下的<code>build-profile.json5</code>添加了自定义字段<code>online</code>。我们同样可以根据命令行参数替换掉。同时也将配置的测试签名文件删除，只构建产物，随后再使用命令行进行签名。</p>
<p>代码如下，在工程根目录下的<code>hvigorfile.ts</code>文件中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; appTasks, <span class="hljs-title class_">OhosAppContext</span>, <span class="hljs-title class_">OhosPluginId</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/hvigor-ohos-plugin&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; hvigor,getNode &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos/hvigor&#x27;</span><br><span class="hljs-comment">// 获取根节点</span><br><span class="hljs-keyword">const</span> rootNode = <span class="hljs-title function_">getNode</span>(__filename);<br><span class="hljs-comment">// 为根节点添加一个afterNodeEvaluate hook 在hook中修改根目录下的build-profile.json5的内容并使能</span><br>rootNode.<span class="hljs-title function_">afterNodeEvaluate</span>(<span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;<br><br>    <span class="hljs-comment">//获取命令行参数</span><br>    <span class="hljs-keyword">let</span> online = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">let</span> propertyOnline = hvigor.<span class="hljs-title function_">getParameter</span>().<span class="hljs-title function_">getProperty</span>(<span class="hljs-string">&#x27;online&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (propertyOnline != <span class="hljs-literal">undefined</span>) &#123;<br>        online = propertyOnline<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;online-&gt; &quot;</span> + propertyOnline);<br><br>    <span class="hljs-comment">// 获取app插件的上下文对象</span><br>    <span class="hljs-keyword">const</span> appContext = node.<span class="hljs-title function_">getContext</span>(<span class="hljs-title class_">OhosPluginId</span>.<span class="hljs-property">OHOS_APP_PLUGIN</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">OhosAppContext</span>;<br>    <span class="hljs-comment">// 通过上下文对象获取从根目录build-profile.json5文件中读出来的obj对象</span><br>    <span class="hljs-keyword">const</span> buildProfileOpt = appContext.<span class="hljs-title function_">getBuildProfileOpt</span>();<br>    <span class="hljs-comment">//将 BuildProfile 文件中的online值改为传入的值</span><br>    buildProfileOpt[<span class="hljs-string">&#x27;app&#x27;</span>][<span class="hljs-string">&#x27;products&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;buildOption&#x27;</span>][<span class="hljs-string">&#x27;arkOptions&#x27;</span>][<span class="hljs-string">&#x27;buildProfileFields&#x27;</span>][<span class="hljs-string">&#x27;online&#x27;</span>] = online<br>    <span class="hljs-keyword">if</span> (online) &#123;<br>      <span class="hljs-comment">//清除签名文件信息</span><br>        buildProfileOpt[<span class="hljs-string">&#x27;app&#x27;</span>][<span class="hljs-string">&#x27;signingConfigs&#x27;</span>] = []<br>    &#125;<br>    <br>    <span class="hljs-comment">// 将obj对象设置回上下文对象以使能到构建的过程与结果中</span><br>    appContext.<span class="hljs-title function_">setBuildProfileOpt</span>(buildProfileOpt);<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">system</span>: appTasks,  <span class="hljs-comment">/* Built-in plugin of Hvigor. It cannot be modified. */</span><br>    <span class="hljs-attr">plugins</span>:[]         <span class="hljs-comment">/* Custom plugin to extend the functionality of Hvigor. */</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>打包的时候，由于上架需要 app 文件，所以我们需要打 release 模式的 app 文件。测试时需要打release 模式的hap 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">//先安装一下依赖<br>ohpm install --all<br>//发版包<br>hvigorw clean  assembleApp -p buildMode=release --config properties.online=true <br>//测试包<br>hvigorw clean  assembleHap -p buildMode=release --config properties.online=false<br></code></pre></td></tr></table></figure>
<p>这样我们就将<code>BuildProfile</code>文件中的<code>online</code>值改为传入的值，同时也清除了签名文件配置。</p>
<p>这里需要注意的是，如果执行的是<code>assembleApp</code>,则产物是在项目根目录<code>build/outputs/$&#123;productName&#125;/xxx-default-unsigned.app</code>。如果执行的是<code>assembleHap</code>，则会在<code>$&#123;moduleName&#125;/build/$&#123;productName&#125;/outputs/$&#123;productName&#125;/entry-default-unsigned.hap</code>.</p>
<p>下面我们对产物进行签名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">/Applications/DevEco-Studio.app/Contents/jbr/Contents/Home/bin/java -jar /Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains/lib/hap-sign-tool.jar sign-app -keyAlias &quot;keyAlias&quot; -signAlg &quot;SHA256withECDSA&quot; -mode &quot;localSign&quot; -appCertFile &quot;release.cer&quot; -profileFile &quot;release.p7b&quot; -inFile &quot;build/outputs/default/xxx-default-unsigned.app&quot; -keystoreFile &quot;default.p12&quot; -outFile &quot;xxx-default-signed.app&quot; -keyPwd &quot;keyPwd&quot; -keystorePwd &quot;keystorePwd&quot; -signCode &quot;1&quot;<br><br>/Applications/DevEco-Studio.app/Contents/jbr/Contents/Home/bin/java -jar /Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains/lib/hap-sign-tool.jar sign-app -keyAlias &quot;keyAlias&quot; -signAlg &quot;SHA256withECDSA&quot; -mode &quot;localSign&quot; -appCertFile &quot;debug.cer&quot; -profileFile &quot;debug.p7b&quot; -inFile &quot;entry/build/default/outputs/default/entry-default-unsigned.hap&quot; -keystoreFile &quot;default.p12&quot; -outFile &quot;entry-default-signed.hap&quot; -keyPwd &quot;keyPwd&quot; -keystorePwd &quot;keystorePwd&quot; -signCode &quot;1&quot;<br><br></code></pre></td></tr></table></figure>

<p>我们可以把打包签名的流程写在文件(build.sh)中，每次去执行这个文件就好了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化build_type为release</span><br>online=true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解析命令行参数</span><br>while [[ $# -gt 0 ]]; do<br>    case $1 in<br>        --debug)<br>            online=false<br>            echo &quot;需要构建测试包&quot;<br>            shift<br>            ;;<br>        --release)<br>            # 实际上这个选项是多余的，因为默认就是release<br>            # 但如果你希望明确指定release以覆盖其他可能设置默认值的逻辑，可以保留<br>            online=true<br>            echo &quot;需要构建线上包&quot;<br>            shift<br>            ;;<br>        *)<br>            # 未知选项，打印帮助信息或错误消息<br>            echo &quot;Usage: $0 [--debug|--release]&quot;<br>            exit 1<br>            ;;<br>    esac<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装依赖</span><br>ohpm install --all<br><br><br>if [ &quot;$online&quot; == true ]; then<br>    # 打线上 app 包<br>    echo &quot;Executing online release build commands...&quot;<br>    hvigorw clean  assembleApp -p buildMode=release --config properties.online=true <br>elif [ &quot;$online&quot; == false ]; then<br>    # 打测试 hap 包<br>    echo &quot;Executing not online release build commands...&quot;<br>    hvigorw clean  assembleHap -p buildMode=release --config properties.online=false<br>else<br>    # 理论上不应该走到这里，除非build_type被设置为非预期的值<br>    echo &quot;Unknown build type: $build_type&quot;<br>    exit 1<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">签名</span><br><br>if [ &quot;$online&quot; == true ]; then<br>    # 打线上 app 包<br>    echo &quot;签名 app 文件&quot;<br>    /Applications/DevEco-Studio.app/Contents/jbr/Contents/Home/bin/java -jar /Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains/lib/hap-sign-tool.jar sign-app -keyAlias &quot;keyAlias&quot; -signAlg &quot;SHA256withECDSA&quot; -mode &quot;localSign&quot; -appCertFile &quot;release.cer&quot; -profileFile &quot;release.p7b&quot; -inFile &quot;build/outputs/default/xxx-default-unsigned.app&quot; -keystoreFile &quot;default.p12&quot; -outFile &quot;xxx-default-signed.app&quot; -keyPwd &quot;keyPwd&quot; -keystorePwd &quot;keystorePwd&quot; -signCode &quot;1&quot;<br><br>elif [ &quot;$online&quot; == false ]; then<br>    # 打测试 hap 包<br>    echo &quot;签名 hap 文件&quot;<br>    /Applications/DevEco-Studio.app/Contents/jbr/Contents/Home/bin/java -jar /Applications/DevEco-Studio.app/Contents/sdk/default/openharmony/toolchains/lib/hap-sign-tool.jar sign-app -keyAlias &quot;keyAlias&quot; -signAlg &quot;SHA256withECDSA&quot; -mode &quot;localSign&quot; -appCertFile &quot;debug.cer&quot; -profileFile &quot;debug.p7b&quot; -inFile &quot;entry/build/default/outputs/default/entry-default-unsigned.hap&quot; -keystoreFile &quot;default.p12&quot; -outFile &quot;entry-default-signed.hap&quot; -keyPwd &quot;keyPwd&quot; -keystorePwd &quot;keystorePwd&quot; -signCode &quot;1&quot;<br><br>else<br>    # 理论上不应该走到这里，除非build_type被设置为非预期的值<br>    echo &quot;Unknown build type: $build_type&quot;<br>    exit 1<br>fi<br></code></pre></td></tr></table></figure>
<p>打包时，如果需要打测试包，则执行 <code>build.sh --debug</code>，如果要打发版包，则执行<code>build.sh --release</code></p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-仓颉环境搭建和 HelloWorld</title>
    <url>/2025/06/13/%E9%B8%BF%E8%92%99-%E4%BB%93%E9%A2%89%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C-HelloWorld/</url>
    <content><![CDATA[<p>虽然HarmonyOS NEXT Cangjie正式版本测试活动开始小范围招募了，报名链接还不太想让大范围转发，这里就不放了。<br><img src="/image/cangjie/%E4%BB%93%E9%A2%89-%E9%B8%BF%E8%92%99%E6%AD%A3%E5%BC%8F%E7%89%88%E6%8B%9B%E5%8B%9F.png" alt="仓颉-鸿蒙正式版招募"><br><img src="/image/cangjie/HarmonyOS_NEXT_Cangjie%E6%AD%A3%E5%BC%8F%E7%89%88%E6%9C%AC%E6%B5%8B%E8%AF%95%E6%B4%BB%E5%8A%A8.png" alt="HarmonyOS_NEXT_Cangjie正式版本测试活动.png"><br>但公测版还是申请审核制度。我们可以在仓颉官网上找到<a href="https://developer.huawei.com/consumer/cn/activityDetail/cangjie-beta/">公测版报名链接</a>,审核挺快的，一两天就通过了。<br>但最近他们可能在忙 hdc 活动，审核可能会慢些。</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官方下载页面：<a href="https://developer.huawei.com/consumer/cn/download/">https://developer.huawei.com/consumer/cn/download/</a><br>注意：公测版申请不通过的话，是看到不插件的。<br><img src="/image/cangjie/Harmony_next_cangjie_beta.png" alt="Harmony_next_cangjie_beta">  </p>
<p>建议使用最新稳定版本的DevEco，目前是 <code>DevEco Studio 5.1.0 Release</code>,版本号是<code>Build Version 5.1.0.828</code>。<br>最新的插件版本为：<code>DevEco Studio-Cangjie Plugin 5.0.13.200 Canary</code></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>先安装 DevEco，安装完成后我们打开软件，点击左侧的<code>Customize</code>,右侧最下方点击<code>All settings</code><br><img src="/image/cangjie/%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E8%AE%BE%E7%BD%AE.png" alt="找到所有设置"><br>在新的窗口左侧找到<code>Plugins</code>,右侧点击齿轮，在弹出的菜单中选择<code>Install from Disk</code><br><img src="/image/cangjie/%E5%AE%89%E8%A3%85%E4%BB%93%E9%A2%89%E6%8F%92%E4%BB%B6.png" alt="安装仓颉插件"><br>选择我们刚才下载的插件压缩包，安装完成后需要重启一下DevEco</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>安装仓颉插件后，需要重新启动 DevEco Studio。初始化工程时，会自动配置仓颉 SDK，仓颉 SDK 存放的路径在 macOS 系统下默认为 $HOME&#x2F;.cangjie-sdk，Windows 下默认为 %USERPROFILE%&#x2F;.cangjie-sdk。如需指定 .cangjie-sdk 的存放路径，请在安装插件前配置系统环境变量，变量名为 DEVECO_CANGJIE_PATH，变量值为要存放的路径。<br>配置系统环境变量后，请重启 DevEco Studio，使环境变量生效。</p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>现在我们打开 DevEco，创建一个新的工程，选择[Cangjie]Empty Ability。输入项目名称、应用包名等信息后点击 finish 就可以了。有一点不同的是，目前 cangjie 只支持 phone 这个选项。<br><img src="/image/cangjie/create_cangjie_harmony_project.png" alt="create_cangjie_harmony_project">。<br>等待项目同步完成后，我们就可以进行开发了。</p>
<h2 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h2><p><img src="/image/cangjie/%E9%B8%BF%E8%92%99%E4%BB%93%E9%A2%89%E7%9B%AE%E5%BD%95.png" alt="鸿蒙仓颉目录"><br>我们可以看到鸿蒙仓颉目录和 ArkTS 工程的目录几乎是相同的，降低了我们上手开发的难度。</p>
<h2 id="编译构建"><a href="#编译构建" class="headerlink" title="编译构建"></a>编译构建</h2><p>和使用<code>ArkTS</code>一样，我们同样需要对应用进行签名，之后才可以编译运行。<br>这里需要注意的是仓颉工程默认编译架构为arm64-v8a，因此在使用x86模拟器时,需要编译出x86_64版本的so。<br>我们需要在仓颉模块的<code>build-profile.json5</code>配置文件中，为<code>cangjieOptions.abiFilters</code>的值增加<strong>x86_64</strong>，具体编译配置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;buildOption&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>      <span class="hljs-comment">// 配置项目在构建过程中使用的相关配置</span><br>  <span class="hljs-attr">&quot;cangjieOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">// 仓颉相关配置</span><br>    <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;./src/main/cangjie/cjpm.toml&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// cjpm配置文件路径，提供仓颉构建配置</span><br>    <span class="hljs-attr">&quot;abiFilters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;arm64-v8a&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;x86_64&quot;</span><span class="hljs-punctuation">]</span>   <span class="hljs-comment">// 自定义仓颉编译架构，默认编译架构为arm64-v8a</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>之后我们就可以编译运行了。<br><img src="/image/cangjie/harmony_cangjie_demo.png" alt="仓颉鸿蒙应用"></p>
<h2 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a>功能开发</h2><p>我们做个最简单的页面跳转看看<br>先创建一个新的文件:<code>second_page.cj</code>,然后简单写一下页面布局</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript">package ohos_app_cangjie_entry<br><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">base</span>.<span class="hljs-property">LengthProp</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">Column</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">Row</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">Button</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">Text</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">CustomView</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">CJEntry</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">loadNativeView</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_manage</span>.<span class="hljs-property">SubscriberManager</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_manage</span>.<span class="hljs-property">ObservedProperty</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_manage</span>.<span class="hljs-property">LocalStorage</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_macro_manage</span>.<span class="hljs-property">Entry</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_macro_manage</span>.<span class="hljs-property">Component</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_macro_manage</span>.<span class="hljs-property">State</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_macro_manage</span>.<span class="hljs-property">r</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">hiappevent</span>.<span class="hljs-property">Event</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">router</span>.<span class="hljs-property">Router</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">Alignment</span><br><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondPage</span> &#123;<br>    <span class="hljs-meta">@State</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span> = <span class="hljs-string">&quot;Second Page&quot;</span><br>    func <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Column</span> &#123;<br>            <span class="hljs-title class_">Button</span>(message).<span class="hljs-property">onClick</span> &#123;<br>                <span class="hljs-function"><span class="hljs-params">evt</span> =&gt;</span> <span class="hljs-title class_">AppLog</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;Second Page&quot;</span>)<br>            &#125;.<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">40</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">80</span>)<br><br>            <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;返回上个页面&quot;</span>).<span class="hljs-title function_">onClick</span>(&#123;<br>                <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> <span class="hljs-title class_">Router</span>.<span class="hljs-title function_">back</span>()<br>            &#125;)<br>        &#125;.<span class="hljs-title function_">width</span>(<span class="hljs-number">100.</span>percent).<span class="hljs-title function_">align</span>(<span class="hljs-title class_">Alignment</span>.<span class="hljs-property">Start</span>)<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>然后我们在第一个页面<code>index.cj</code>中添加一下跳转</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript">package ohos_app_cangjie_entry<br><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">base</span>.<span class="hljs-property">LengthProp</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">Column</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">Row</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">Button</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">Text</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">CustomView</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">CJEntry</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">loadNativeView</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_manage</span>.<span class="hljs-property">SubscriberManager</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_manage</span>.<span class="hljs-property">ObservedProperty</span><br>internal <span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_manage</span>.<span class="hljs-property">LocalStorage</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_macro_manage</span>.<span class="hljs-property">Entry</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_macro_manage</span>.<span class="hljs-property">Component</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_macro_manage</span>.<span class="hljs-property">State</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">state_macro_manage</span>.<span class="hljs-property">r</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">hiappevent</span>.<span class="hljs-property">Event</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">router</span>.<span class="hljs-property">Router</span><br><span class="hljs-keyword">import</span> ohos.<span class="hljs-property">component</span>.<span class="hljs-property">Alignment</span><br><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryView</span> &#123;<br>    <span class="hljs-meta">@State</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span> = <span class="hljs-string">&quot;Hello Cangjie&quot;</span><br>    func <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Column</span> &#123;<br>            <span class="hljs-title class_">Button</span>(message).<span class="hljs-property">onClick</span> &#123;<br>                <span class="hljs-function"><span class="hljs-params">evt</span> =&gt;</span> <span class="hljs-title class_">AppLog</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;Hello Cangjie&quot;</span>)<br>            &#125;.<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">40</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">80</span>)<br><br>            <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;跳转到下个页面&quot;</span>).<span class="hljs-title function_">onClick</span>(<br>                &#123;<br>                    <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span><br>                    <span class="hljs-title class_">AppLog</span>.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;点击了跳转到下个页面&quot;</span>)<br>                    <span class="hljs-title class_">Router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-attr">url</span>: <span class="hljs-string">&quot;SecondPage&quot;</span>, <span class="hljs-attr">params</span>: <span class="hljs-string">&quot;123456789&quot;</span>)<br>                &#125;<br>            )<br>        &#125;.<span class="hljs-title function_">width</span>(<span class="hljs-number">100.</span>percent).<span class="hljs-title function_">align</span>(<span class="hljs-title class_">Alignment</span>.<span class="hljs-property">Start</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>我们看下效果：<br><img src="/image/cangjie/cangjie_harmony_demo_router.gif" alt="页面跳转"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>说点题外话：<br>一开始我还很纳闷，应用启动的时候是如何识别第一个需要加载的页面的。 直到我看完教程，发现使用 Router 跳转时是直接写死的目标页面的<code>class name</code>，回去看了一下<code>MainAbility</code>代码，发现是在<code>onWindowStageCreate</code>这个方法中调用了<code>windowStage.loadContent(&quot;EntryView&quot;)</code>，直接加载了<code>index.cj</code>中的<code>class name</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>官网上貌似没有直达的链接：</p>
<p><a href="https://developer.huawei.com/consumer/cn/doc/cangjie-guides-V5/cj-first-cangjie-app-V5">快速入门</a><br><a href="https://developer.huawei.com/consumer/cn/doc/cangjie-references-V5/_u4ed3_u9889api-V5">仓颉 API</a><br><a href="https://developer.huawei.com/consumer/cn/doc/cangjie-references-V5/_u4ed3_u9889_u7ec4_u4ef6-V5">仓颉组件</a>  </p>
<p>仓颉语言更新或者鸿蒙版本更新时，上面的链接可能会失效，我们可以在<a href="https://gitcode.com/Cangjie">gitcode Cangjie</a>项目中的鸿蒙版本介绍中获取最新的链接。</p>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>大部分调用的 api 看不到源码，写起来就很难受，有的是因为 api 不熟悉，不知道该传什么类型的参数。<br>有的是报错找不到对应的解决方案<br>有时候报错、页面不是预期效果、运行起来和官网示例效果不一样等等，有可能不是我们的问题，<br>现在有好多 issue 没有关闭，还在优化中，<br><a href="https://gitcode.com/Cangjie/CangjieMoBileUsersForm/issues">https://gitcode.com/Cangjie/CangjieMoBileUsersForm</a>，同样的，访问这个页面也需要权限。。。</p>
]]></content>
      <tags>
        <tag>仓颉</tag>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-使用Charles抓包</title>
    <url>/2025/04/20/%E9%B8%BF%E8%92%99-%E4%BD%BF%E7%94%A8Charles%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>抓包，对于各位开发者应该不陌生，各种抓包工具应该的都听说过，像 charles、fiddler、Wireshark‌等。在 Android 和 iOS 上抓包都挺简单的，把证书存放到手机上，然后安装一下，网络设置里面配置一下代理，代码里面忽略一下证书校验或者信任一下用户证书就好了。<br>但在鸿蒙手机上，似乎第一步把证书存放到手机上就卡住了一部分人。</p>
<h2 id="鸿蒙应用中的网络请求"><a href="#鸿蒙应用中的网络请求" class="headerlink" title="鸿蒙应用中的网络请求"></a>鸿蒙应用中的网络请求</h2><p>在开发文档中有提到两种网络请求的方法，一开始是用 http，再后来推荐使用 rcp。现在上架的应用估计大部分是用的 http 或者axios 这个封装好的框架进行的网络请求。  </p>
<h3 id="rcp-抓包"><a href="#rcp-抓包" class="headerlink" title="rcp 抓包"></a>rcp 抓包</h3><p>在官方文档中，并没有找到http 如何忽略证书校验或者信任用户证书，只翻到了如何使用自定义证书。<br>嘿嘿，问题不大，因为我们用的是 rcp 做的网络请求，自己封装了一下。并且在官方文档中找到了跳过证书校验的配置：</p>
<blockquote>
<p>SecurityConfiguration接口允许开发人员在会话中配置与安全相关的设置，包括证书和服务器身份验证。</p>
</blockquote>
<p>其中有个属性：remoteValidation，解释说明是证书颁发机构（CA），用于验证远程服务器的身份。默认值为’system’。<br>我们可以配置的类型有：<code>&quot;system&quot;</code>、<code>&quot;skip&quot;</code>、<code>CertificateAuthority</code>、<code>ValidationCallback</code>，其中默认值为’system’。<br>如果未设置此字段，系统CA将被用于验证远程服务器的标识。<br>‘system’：表示使用系统CA配置。<br>‘skip’：跳过验证。<br>CertificateAuthority：证书颁发机构（CA）验证。<br>ValidationCallback：自定义证书校验。  </p>
<p>这不就简单了么，整个 demo 试一下</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;charles抓包 rcp&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">const</span> session = rcp.<span class="hljs-title function_">createSession</span>();<br>  <span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> rcp.<span class="hljs-title class_">Request</span>(<span class="hljs-string">&#x27;https:/xxxxxx&#x27;</span>,<span class="hljs-string">&#x27;GET&#x27;</span>);<br>  request.<span class="hljs-property">configuration</span> = &#123;<br>    <span class="hljs-attr">security</span>: &#123;<br>      <span class="hljs-attr">remoteValidation</span>: <span class="hljs-string">&#x27;skip&#x27;</span>,<br>    &#125;,<br>  &#125;;<br>  session.<span class="hljs-title function_">fetch</span>(request).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">rep: rcp.Response</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`Response succeeded: <span class="hljs-subst">$&#123;rep&#125;</span>`</span>);<br>  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Response err: Code is <span class="hljs-subst">$&#123;err.code&#125;</span>, message is <span class="hljs-subst">$&#123;err.message&#125;</span>`</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>打开抓包软件，手机 wifi 设置里面配置一下代理，就可以看到能抓包了，甚至不需要安装证书。</p>
<h3 id="http-抓包"><a href="#http-抓包" class="headerlink" title="http 抓包"></a>http 抓包</h3><p>由于没有找到如何忽略证书，就和 Android 抓包一样，先把证书安装到手机上。<br>在抓包软件中导出证书，注意查看一下<strong>证书的有效期</strong>，当然安装抓包软件的电脑上也需要安装一下证书，并且需要信任才行。<br>然后使用<code>hdc file send</code>将证书发送到手机上，问题就在这里，不知道手机的文件夹目录是啥。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">hdc file send charles-ssl-proxying-certificate.pem /storage/media/100/local/files/Docs/Download/charles.pem<br></code></pre></td></tr></table></figure>
<p>这里的目标路径为<code>/storage/media/100/local/files/Docs/Download/</code>,也就是我们在手机文件管理里面看到的<code>Download</code>文件夹。这里需要注意的是，需要在后面加目标文件的名字,这也是和Android的<code>adb psuh</code>最大的区别，adb 只需要指定到文件夹就好，相当于把文件复制到这个文件夹中，复制之后的名字可以不指定。<br>我们可以在 DevEco 的右下角<code>Device File Browser</code>把文件夹展开看一下：<br><img src="/image/HarmonyOS/harmony_os_next_file_system.png"></p>
<p>然后我们打开证书安装页面：<code>hdc shell aa start -a MainAbility -b com.ohos.certmanager </code>,或者在手机设置–&gt;隐私和安全–&gt;高级–&gt;证书与凭据–&gt;从存储设备安装,点击 CA 证书，会弹出警告弹窗，我们点击继续，找到我们刚才发送到设备的证书，完成安装  </p>
<p><img src="/image/HarmonyOS/install_pem_tip.png"></p>
<p>随后撸一坨代码测试一下  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;charles抓包 http&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">let</span> httpRequest = http.<span class="hljs-title function_">createHttp</span>();<br>  httpRequest.<span class="hljs-title function_">request</span>(<br>    <span class="hljs-comment">// 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定</span><br>    <span class="hljs-string">&quot;https://biztest.chunyutianxia.com/user_operation/app_interface/home_page/?app=0&amp;platform=android&amp;systemVer=10&amp;version=10.6.12&amp;app_ver=Build+10.6.12.250402&amp;cyudId=53f38352-da64-4dac-b4e0-1b0cc681f6a0&amp;secureId=e9ddd1fd-fffe-8a9f-57f7-defffdca8058&amp;installId=1742785027244&amp;phoneType=COL-AL10_by_HUAWEI&amp;vendor=chunyu&amp;screen_height=2060&amp;screen_width=1080&quot;</span>,<br>    &#123;<br>      <span class="hljs-attr">method</span>: http.<span class="hljs-property">RequestMethod</span>.<span class="hljs-property">GET</span>, <span class="hljs-comment">// 可选，默认为http.RequestMethod.GET</span><br>      <span class="hljs-comment">// 开发者根据自身业务需要添加header字段</span><br>      <span class="hljs-attr">header</span>: &#123;<br>        <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span><br>      &#125;,<br><br>      <span class="hljs-attr">expectDataType</span>: http.<span class="hljs-property">HttpDataType</span>.<span class="hljs-property">STRING</span>, <span class="hljs-comment">// 可选，指定返回数据的类型</span><br>      <span class="hljs-attr">priority</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 可选，默认为1</span><br>      <span class="hljs-attr">connectTimeout</span>: <span class="hljs-number">60000</span>, <span class="hljs-comment">// 可选，默认为60000ms</span><br>      <span class="hljs-attr">readTimeout</span>: <span class="hljs-number">60000</span>, <span class="hljs-comment">// 可选，默认为60000ms</span><br>      <span class="hljs-attr">usingProxy</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 可选，默认不使用网络代理，自API 10开始支持该属性</span><br>      <span class="hljs-comment">// caPath:filePath</span><br><br>    &#125;, <span class="hljs-function">(<span class="hljs-params">err: BusinessError, data: http.HttpResponse</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!err) &#123;<br>      <span class="hljs-comment">// data.result为HTTP响应内容，可根据业务需要进行解析</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;Result:&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data.<span class="hljs-property">result</span>));<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;code:&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data.<span class="hljs-property">responseCode</span>));<br>      <span class="hljs-comment">// data.header为HTTP响应头，可根据业务需要进行解析</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;header:&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data.<span class="hljs-property">header</span>));<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;cookies:&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data.<span class="hljs-property">cookies</span>)); <span class="hljs-comment">// 8+</span><br>      <span class="hljs-comment">// 当该请求使用完毕时，调用destroy方法主动销毁</span><br>      httpRequest.<span class="hljs-title function_">destroy</span>();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;error:&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(err));<br><br>      <span class="hljs-comment">// 当该请求使用完毕时，调用destroy方法主动销毁</span><br>      httpRequest.<span class="hljs-title function_">destroy</span>();<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;flutter 鸿蒙打点：&quot;</span>)<br>    &#125;<br>  &#125;<br>  );<br><br>&#125;)<br></code></pre></td></tr></table></figure>
<p>同样的操作，熟悉的配方就可以看到抓包结果了。</p>
<h2 id="以下是排查过程，没啥参考价值"><a href="#以下是排查过程，没啥参考价值" class="headerlink" title="以下是排查过程，没啥参考价值"></a>以下是排查过程，没啥参考价值</h2><h3 id="发送文件"><a href="#发送文件" class="headerlink" title="发送文件"></a>发送文件</h3><p>一开始使用 hdc 发送文件一直失败，一个原因是找不到正确的文件夹，另外一个原因就是没有加指定目标文件的文件名，路径只写到了某个文件夹。<br>还想尝试使用手机上登录微信，通过微信发送。<br>蓝牙配对一下，使用蓝牙发送。<br>电脑上搞个 ftp，手机上访问下载一下。<br>这些方案应该都能解决文件传输问题，但我就想用 hdc 搞定一下，折腾了好半天，搜了一摞一摞的教程。。。</p>
<h3 id="http-抓包报错"><a href="#http-抓包报错" class="headerlink" title="http 抓包报错"></a>http 抓包报错</h3><p>安装完证书，配置好代理之后抓包时发现 http 请求失败，报错<code>2300060 远程服务器SSL证书或SSH秘钥不正确</code>.<br>刚开始以为是在 http 请求中需求配置点什么属性，比如<code>usingProxy</code>这个属性：可以配置属性值类型<code>boolean</code>或者<code>HttpProxy</code>。<br>首先设置为 true，抓包还是不行。<br>设置为<code>HttpProxy</code>对象，地址就写电脑的 ip 和抓包软件中设置的对应的端口号，结果还是报错。  </p>
<p>然后就以为需要把证书拷贝到沙箱目录，然后走自定义证书那一套流程，结果还是不行，照样是<code>2300060</code>这个错误码。  </p>
<p>之后就去翻官方文档，看到有个提示<br><img src="/image/HarmonyOS/http_2300060_error_code.png"></p>
<p>然后看了下证书有效期，果然是证书过期了，但奇怪的是在 Android 上可以抓包。解决方案就是在抓包软件里面重置一下证书，再重新导出一下，安装到手机上就可以了。</p>
<hr>
<p>为啥会关心这两个网络请求抓包：因为有个立项比较早的项目，是由前端主导的，当时还没有 rcp，于是选择了axios。后面又立项了另外一个项目，是客户端主导的，并且这时候官方文档也开始推荐使用 rcp 了。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-做一个简版的富文本解析控件</title>
    <url>/2024/10/17/%E9%B8%BF%E8%92%99-%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E7%89%88%E7%9A%84%E5%AF%8C%E6%96%87%E6%9C%AC%E8%A7%A3%E6%9E%90%E6%8E%A7%E4%BB%B6/</url>
    <content><![CDATA[<p>本来只是需要展示一下简单的富文本，支持简单的背景色，字体大小，字体颜色就够了。调研了一圈都没有完全符合需求的。那就自己撸一个呗。<br>支持 span、font、br、a标签就好，属性的话就支持color、font-color、size、font-size、background、href这些属性就好了。</p>
<span id="more"></span>
<p>老规矩，先上效果图</p>
<p><img src="/image/HarmonyOS/html_parse_render.png" alt="富文本解析.png">  </p>
<p>最上方是在浏览器中的表现，手机截图分割线中间是自己撸的控件，最下方是鸿蒙自带的<code>RichText</code></p>
<p>看起来还行，主要是自己写的，调整起来也方便</p>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ol>
<li>目前只支持了上面说的那些标签级属性：span、font、br、a标签 和 color、font-color、size、font-size、background、href这些属性</li>
<li>富文本的解析使用的是<code>xml.XmlPullParser</code>,因此对富文本内容中的标签要求比较严格，一定要严格闭合才行，否则解析会失败。</li>
<li>也要求所有元素都必须包含在标签内容，否则也会失败，应对这个问题，可以通过在富文本最外层添加没有属性的span标签解决</li>
<li>对于颜色值，只支持了有限了英文名字，建议使用十六进制表示</li>
</ol>
<h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>解析结果的展示是<code>Text</code>中嵌套<code>Span</code>和<code>ContainerSpan</code>实现的：</p>
<ol>
<li><code>Span</code>不支持背景色，要么只能依赖父级控件<code>Text</code>或者父级控件<code>ContainerSpan</code>来设置背景色</li>
<li><code>ContainerSpan</code>只能包含<code>Span</code>、<code>ImageSpan</code>子组件。</li>
<li><code>Span</code>、<code>ImageSpan</code> 没有子控件</li>
</ol>
<p>也就是说解析结果只有一个<code>Text</code>控件，内容样式都由<code>Span</code>和<code>ContainerSpan</code>完成</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>展示结果使用<code>Text</code>嵌套<code>Span</code>和<code>ContainerSpan</code>实现,将样式抽成一个类，要展示的文字作为属性就好了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VNode</span>&#123;<br>  <span class="hljs-attr">text</span>:<span class="hljs-built_in">string</span>=<span class="hljs-string">&#x27;&#x27;</span><br>  child?:<span class="hljs-title class_">VNode</span>[]=[]<br>  <span class="hljs-attr">style</span>:<span class="hljs-title class_">Style</span>= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 属性默认值都可以做成配置，由调用者传入</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Style</span>&#123;<br>  <span class="hljs-comment">//如果有backGround属性需要使用 ContainerSpan</span><br>  <span class="hljs-attr">backgroundColor</span>:<span class="hljs-built_in">string</span>|<span class="hljs-title class_">Resource</span>|<span class="hljs-title class_">Color</span>=<span class="hljs-title class_">Color</span>.<span class="hljs-property">Transparent</span><br>  <span class="hljs-attr">fontSize</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">16</span><br>  <span class="hljs-attr">fontColor</span>:<span class="hljs-built_in">string</span>|<span class="hljs-title class_">Resource</span>|<span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Black</span><br>  <span class="hljs-attr">hrefFontColor</span>:<span class="hljs-built_in">string</span>|<span class="hljs-title class_">Resource</span>|<span class="hljs-title class_">Color</span> = <span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span><br>  <span class="hljs-attr">href</span>:<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了方便的话，这里的<code>Style</code>属性默认值可以做成配置的，由调用者传入，方便定制。<br>如果父级标签设置了背景颜色、文字颜色等属性，子控件没有设置的话，需要继承父标签的属性。如果子标签也设置了属性，则需要覆盖父控件对应的属性。简单来讲就是需要合并子标签和父标签的属性来作为子标签的属性，当然，子标签属性值优先级高于父标签，也就是子标签属性值覆盖父标签的属性值。</p>
<p>就拿截图中的例子来讲：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue;background:yellow&quot;</span>&gt;</span><br>  这位姑娘有一双 <br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:blue;background:red&quot;</span>&gt;</span>蓝<br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red;background:blue&quot;</span>&gt;</span>色<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  的眼睛<br><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>代码按照<code>xml</code>样式格式化了一下，看着方便<br><code>蓝</code>这个字的父级标签设置了背景色为<code>yellow</code>,字体颜色为<code>blue</code>,所以<code>这位姑娘有一双</code>这几个字的背景色就是<code>yellow</code>，字体颜色为<code>blue</code>。但<code>蓝</code>这个字的标签同样设置了背景色为<code>red</code>,优先级要高于父标签，所以<code>蓝</code>这个字的背景色为<code>red</code>。<br><code>的眼睛</code>是和<code>这位姑娘有一双</code>同级的文字，因此背景色和字体颜色也是一致的。</p>
<p>基于上面的规则，很自然的想到使用<code>Stack</code>来保存每一层级的属性，遇到开始标签则复制一份父控件的样式属性(栈顶元素)然后入栈。遇到结束标签则出栈。注意下<code>br</code>标签，只是换行，不会有样式，直接添加一个<code>Span(&#39;\n&#39;)</code>就行。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基于我们的需求，需要展示的富文本不会很复杂，最多也就是上面说的这些属性，鸿蒙正好也由自带的<code>xml</code>解析，用来解析富文本也行。<br>具体文档可以看这里 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/xml-parsing-V5">XML解析</a>  </p>
<h3 id="xml-XmlPullParser"><a href="#xml-XmlPullParser" class="headerlink" title="xml.XmlPullParser"></a>xml.XmlPullParser</h3><p>这里简单介绍一下流程，<br>需要导入 <code>import &#123; util, xml &#125; from &quot;@kit.ArkTS&quot;;</code> 这两个包，其中需要用<code>util</code>对富文本进行编码，防止中文和特殊符号乱码。</p>
<p>首先准备好富文本，并且编码一下,创建<code>xml.XmlPullParser</code>对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// 对数据编码，防止包含中文字符乱码</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">textEncoder</span>: util.<span class="hljs-property">TextEncoder</span> = <span class="hljs-keyword">new</span> util.<span class="hljs-title class_">TextEncoder</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-attr">arrBuffer</span>: <span class="hljs-title class_">Uint8Array</span> = textEncoder.<span class="hljs-title function_">encodeInto</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">htmlContent</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">xmlPullParser</span>: xml.<span class="hljs-property">XmlPullParser</span> = <span class="hljs-keyword">new</span> xml.<span class="hljs-title class_">XmlPullParser</span>(arrBuffer.<span class="hljs-property">buffer</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">ArrayBuffer</span>, <span class="hljs-string">&#x27;UTF-8&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>调用开始解析的方法需要传入一个<code>xml.ParseOptions</code>对象，这个是重点。<br>这个对象由三个回调方法：<code>tagValueCallbackFunction</code>、<code>attributeValueCallbackFunction</code>和<code>tokenValueCallbackFunction</code>。我们在解析的过程中需要知道标签名(根据标签名解析属性值)，标签的开始和结束以及标签包裹的文本。因此我们这里只需要<code>attributeValueCallbackFunction</code> 和 <code>tokenValueCallbackFunction</code>这两个回调就好了。<br>先来打印一下解析出来的数据，再决定后面怎么获取属性值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">attributeValueCallback</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">let</span> str = name + <span class="hljs-string">&#x27; &#x27;</span> + value + <span class="hljs-string">&#x27; &#x27;</span>;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;HtmlParsePage&#x27;</span>, <span class="hljs-string">`attribute  <span class="hljs-subst">$&#123;str&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// true:继续解析 false:停止解析</span><br>&#125;<br><span class="hljs-title function_">tokenValueCallback</span>(<span class="hljs-attr">name</span>: xml.<span class="hljs-property">EventType</span>, <span class="hljs-attr">value</span>: xml.<span class="hljs-property">ParseInfo</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-comment">//只需要关心 START_TAG  END_TAG TEXT 这三个类型就好</span><br>  <span class="hljs-keyword">let</span> nameStr = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">if</span>(name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">START_TAG</span> || name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">END_TAG</span> || name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">TEXT</span>)&#123;<br>    nameStr = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getTagEventName</span>(name)<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br><br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;HtmlParsePage&#x27;</span>, <span class="hljs-string">`token    <span class="hljs-subst">$&#123;nameStr&#125;</span>  getName:<span class="hljs-subst">$&#123;value.getName()&#125;</span>    getText:<span class="hljs-subst">$&#123;value.getText()&#125;</span> `</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-title function_">getTagEventName</span>(<span class="hljs-attr">name</span>: xml.<span class="hljs-property">EventType</span>):<span class="hljs-built_in">string</span>&#123;<br>  <span class="hljs-keyword">let</span> nameStr = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> (name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">START_TAG</span>) &#123;<br>    nameStr = <span class="hljs-string">&#x27;START_TAG&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">END_TAG</span>) &#123;<br>    nameStr = <span class="hljs-string">&#x27;END_TAG&#x27;</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">TEXT</span>) &#123;<br>    nameStr = <span class="hljs-string">&#x27;TEXT&#x27;</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> nameStr<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们开始解析，看看打印出来的数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-keyword">let</span> <span class="hljs-attr">options</span>: xml.<span class="hljs-property">ParseOptions</span> = &#123;<br>  <span class="hljs-attr">supportDoctype</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">ignoreNameSpace</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">attributeValueCallbackFunction</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">attributeValueCallback</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>),<br>  <span class="hljs-attr">tokenValueCallbackFunction</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">tokenValueCallback</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>)<br>&#125;;<br>xmlPullParser.<span class="hljs-title function_">parse</span>(options);<br></code></pre></td></tr></table></figure>


<h3 id="得到属性值"><a href="#得到属性值" class="headerlink" title="得到属性值"></a>得到属性值</h3><p>然后我们就可以看到结果</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">token    START_TAG  getName:span    getText: <br>attribute  style color:blue;background:yellow <br>token    TEXT  getName:    getText:这位姑娘有一双  <br>token    START_TAG  getName:span    getText: <br>attribute  style color:blue;background:red <br>token    TEXT  getName:    getText:蓝 <br>token    START_TAG  getName:span    getText: <br>attribute  style color:red;background:blue <br>token    TEXT  getName:    getText:色 <br>token    END_TAG  getName:span    getText: <br>token    END_TAG  getName:span    getText: <br>token    TEXT  getName:    getText:的眼睛 <br>token    END_TAG  getName:span    getText: <br></code></pre></td></tr></table></figure>
<p>这就好办多了，就像上面思路中说的一样：遇到<code>START_TAG</code>复制一个父标签属性对象，在属性回调中解析属性并设置属性，然后入栈。遇到<code>TEXT</code>则根据有无背景色属性添加一个<code>ContainerSpan</code>或者<code>Span</code>,遇到<code>END_TAG</code>则属性出栈。<br>对于属性解析，<code>style</code>属性根据<code>;</code>分割一下，将结果再按<code>:</code>分割，就得到了我们想要的属性名字(color、backgroud等)和属性值。然后我们就可以映射成抽象出来的<code>Style</code>类。<br>哦，对了，还有一点，如果颜色的属性值是<code>red</code>、<code>green</code>这种英文名字，需要解析成对应的十六进制或者在鸿蒙中对应的Color对象。</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>按照上面的介绍，我们在<code>tokenValueCallback</code>创建样式或者<code>Span</code>、<code>ContainerSpan</code>。在<code>attributeValueCallback</code>中解析具体属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">attributeValueCallback</span>(<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-keyword">let</span> str = name + <span class="hljs-string">&#x27; &#x27;</span> + value + <span class="hljs-string">&#x27; &#x27;</span>;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;HtmlParsePage&#x27;</span>, <span class="hljs-string">`attribute  <span class="hljs-subst">$&#123;str&#125;</span>`</span>)<br>  <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;href&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">href</span> = value<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;size&#x27;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;px&#x27;</span>)) &#123;<br>      <span class="hljs-keyword">let</span> tmp = value.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;px&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">fontSize</span> = <span class="hljs-title function_">px2fp</span>(<span class="hljs-built_in">parseInt</span>(tmp))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">fontSize</span> = <span class="hljs-title function_">px2fp</span>(<span class="hljs-built_in">parseInt</span>(value))<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;style&#x27;</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">attributes</span>: <span class="hljs-built_in">string</span>[] = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;;&#x27;</span>)<br>    attributes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">attribute: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">tmp</span>: <span class="hljs-built_in">string</span> [] = attribute.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;:&#x27;</span>)<br>      <span class="hljs-keyword">if</span> (tmp[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;color&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">fontColor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getColorWithStr</span>(tmp[<span class="hljs-number">1</span>])<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;background&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">backgroundColor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getColorWithStr</span>(tmp[<span class="hljs-number">1</span>])<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;font-size&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">fontSize</span> = <span class="hljs-title function_">px2fp</span>(<span class="hljs-built_in">parseInt</span>(tmp[<span class="hljs-number">1</span>].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;px&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)))<br>      &#125;<br>    &#125;)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&#x27;color&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>().<span class="hljs-property">fontColor</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getColorWithStr</span>(value)<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// true:继续解析 false:停止解析</span><br>&#125;<br><br><span class="hljs-title function_">tokenValueCallback</span>(<span class="hljs-attr">name</span>: xml.<span class="hljs-property">EventType</span>, <span class="hljs-attr">value</span>: xml.<span class="hljs-property">ParseInfo</span>): <span class="hljs-built_in">boolean</span> &#123;<br>  <span class="hljs-comment">//只需要关心 START_TAG  END_TAG TEXT 这三个类型就好</span><br>  <span class="hljs-keyword">let</span> nameStr = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">if</span>(name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">START_TAG</span> || name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">END_TAG</span> || name == xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">TEXT</span>)&#123;<br>    nameStr = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getTagEventName</span>(name)<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br><br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;HtmlParsePage&#x27;</span>, <span class="hljs-string">`token    <span class="hljs-subst">$&#123;nameStr&#125;</span>  getName:<span class="hljs-subst">$&#123;value.getName()&#125;</span>    getText:<span class="hljs-subst">$&#123;value.getText()&#125;</span> `</span>)<br>  <span class="hljs-keyword">if</span> (name === xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">TEXT</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">vNode</span>: <span class="hljs-title class_">VNode</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>()<br>    vNode.<span class="hljs-property">text</span> = value.<span class="hljs-title function_">getText</span>()<br>    vNode.<span class="hljs-property">style</span> = <span class="hljs-title function_">copyStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>())<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rootNode</span>.<span class="hljs-property">child</span>?.<span class="hljs-title function_">push</span>(vNode)<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (name === xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">START_TAG</span>) &#123;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;br&#x27;</span>) &#123;<br>      <span class="hljs-keyword">let</span> lineBreakSpan = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VNode</span>()<br>      lineBreakSpan.<span class="hljs-property">text</span> = <span class="hljs-string">&#x27;\n&#x27;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">rootNode</span>.<span class="hljs-property">child</span>?.<span class="hljs-title function_">push</span>(lineBreakSpan)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;font&#x27;</span> || value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;span&#x27;</span> || value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">isEmpty</span>()) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Style</span>())<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">let</span> style = <span class="hljs-title function_">copyStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">peek</span>())<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">push</span>(style)<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (name === xml.<span class="hljs-property">EventType</span>.<span class="hljs-property">END_TAG</span> &amp;&amp; (value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;font&#x27;</span> || value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;span&#x27;</span>|| value.<span class="hljs-title function_">getName</span>() === <span class="hljs-string">&#x27;a&#x27;</span>)) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">styleStack</span>.<span class="hljs-title function_">pop</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//true:继续解析 false:停止解析</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>所有的准备工作都做完了，渲染就成了最简单的一步。<br>根节点使用Text控件，判断子节点Sytle背景色属性，如果设置了其他值，就使用<code>ContainerSpan()&#123;Span()&#125;</code>,如果没有，直接使用<code>Span()</code>.<br>这里将属性写成了<code>Extend(Span)</code>形式  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Extend</span>(<span class="hljs-title class_">Span</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">configSpanStyle</span>(<span class="hljs-params">vNode: VNode</span>) &#123;<br>  .<span class="hljs-title function_">backgroundColor</span>(vNode.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span>)<br>  .<span class="hljs-title function_">fontColor</span>(vNode.<span class="hljs-property">style</span>.<span class="hljs-property">href</span> ? vNode.<span class="hljs-property">style</span>.<span class="hljs-property">hrefFontColor</span> : vNode.<span class="hljs-property">style</span>.<span class="hljs-property">fontColor</span>)<br>  .<span class="hljs-title function_">fontSize</span>(vNode.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span>)<br>  .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">event: ClickEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (vNode.<span class="hljs-property">style</span>.<span class="hljs-property">href</span>) &#123;<br>      promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: vNode.<span class="hljs-property">style</span>.<span class="hljs-property">href</span> &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">hasParse</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">buildWithVNode</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">rootNode</span>)<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title class_">LoadingProgress</span>()<br>        .<span class="hljs-title function_">color</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span>).<span class="hljs-title function_">width</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">10</span>)<br><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Builder</span><br>  <span class="hljs-title function_">buildWithVNode</span>(<span class="hljs-params">vNode: VNode</span>) &#123;<br>    <span class="hljs-title class_">Text</span>() &#123;<br>      <span class="hljs-title class_">ForEach</span>(vNode.<span class="hljs-property">child</span>, <span class="hljs-function">(<span class="hljs-params">child: VNode</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (child.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> != <span class="hljs-title class_">Color</span>.<span class="hljs-property">Transparent</span>) &#123;<br>          <span class="hljs-title class_">ContainerSpan</span>() &#123;<br>            <span class="hljs-title class_">Span</span>(child.<span class="hljs-property">text</span>).<span class="hljs-title function_">configSpanStyle</span>(child)<br>          &#125;.<span class="hljs-title function_">textBackgroundStyle</span>(&#123; <span class="hljs-attr">color</span>: child.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title class_">Span</span>(child.<span class="hljs-property">text</span>).<span class="hljs-title function_">configSpanStyle</span>(child)<br>        &#125;<br>      &#125;)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>到这里就结束了，源码在github<a href="https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/html_parse/HtmlParsePage.ets">github</a>、<a href="https://gitee.com/huangyuan/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/html_parse/HtmlParsePage.ets">gitee</a></p>
<p>当然代码都是硬怼上去的，有很多可以改进的地方：</p>
<ol>
<li>上面提到的默认属性，可以由调用者传入</li>
<li>结果标签和属性目前也是直接写死的支持哪些，其实可以做成责任链，解析可以让使用者自定义，更加方便扩展</li>
<li>因为是使用xml的解析器，遇到不复合标准的富文本会崩溃，要么在解析上加个try catch。或者在使用无属性的<code>span</code>标签再包裹一下。建议可以两个都用上，毕竟墨菲定律</li>
</ol>
<hr>
<p>下个版本再说吧</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-卡证识别</title>
    <url>/2025/05/06/%E9%B8%BF%E8%92%99-%E5%8D%A1%E8%AF%81%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在移动端实名认证的过程中，需要移动端识别图片是不是身份证，并且识别出身份证上的相关信息，上报到服务端，减少后台人工比对的工作量。<br>我们之前是使用的服务端api，将拍好的照片先上传至服务端识别，然后由服务端告诉移动端相关信息。在鸿蒙上看到了Vision Kit(场景视觉化服务)中有卡证识别，提供身份证（目前仅支持中国大陆二代身份证，且不包含民汉双文身份证）、行驶证、驾驶证、护照、银行卡等证件的结构化识别服务，满足卡证的自动分类功能，系统可自动判断所属卡证类型并返回结构化信息和卡证图片信息。</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>对于需要填充卡证信息的场景，如身份证、银行卡信息等，可使用卡证识别控件读取OCR（Optical Character Recognition）信息，将结果信息返回后进行填充。支持单独识别正面、反面，或同时进行双面识别。<br>我们先来看一下身份证识别相关配置。<br>使用的控件是<code>CardRecognition</code>，直接嵌入到页面上就可以该控件会直接调用相机进行识别，这里不需要我们申请权限，类似与 SaveButton 这种安全控件。<br>使用之后会被应用隐私数据访问记录中记录下来。<br>使用该控件之前需要先判断下设备是否支持.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">if</span>(<span class="hljs-title function_">canIUse</span>(<span class="hljs-string">&quot;SystemCapability.AI.Component.CardRecognition&quot;</span>))&#123;<br>     <span class="hljs-title class_">CardRecognition</span>(&#123;<br>       .....<br>     &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>据其他开发者反馈，某些设备上这个canIUse方法会失效，不过我还没遇到过。<br>接下来配置一下需要用到的属性</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">CardRecognition</span>(&#123;<br>    <span class="hljs-attr">supportType</span>:<span class="hljs-title class_">CardType</span>.<span class="hljs-property">CARD_ID</span>,<br>    <span class="hljs-attr">cardSide</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">cardSide</span>,<br>    <span class="hljs-attr">cardRecognitionConfig</span>:&#123;<br>    <span class="hljs-attr">isPhotoSelectionSupported</span>:<span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">defaultShootingMode</span>:<span class="hljs-title class_">ShootingMode</span>.<span class="hljs-property">AUTO</span><br>    &#125;,<br>    <span class="hljs-attr">callback</span>:<span class="hljs-title function_">async</span>(<span class="hljs-attr">params</span>:<span class="hljs-title class_">CallbackParam</span>)=&gt;&#123;<br>    <span class="hljs-keyword">if</span>(params.<span class="hljs-property">code</span> == <span class="hljs-number">200</span> &amp;&amp; params.<span class="hljs-property">cardInfo</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;识别成功&quot;</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123; <span class="hljs-built_in">JSON</span>.stringify(params.cardInfo)&#125;</span>`</span>)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cardSide</span> == <span class="hljs-title class_">CardSide</span>.<span class="hljs-property">FRONT</span>)&#123;<br>        emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;id_card_recognition&quot;</span>,&#123;<span class="hljs-attr">data</span>:params.<span class="hljs-property">cardInfo</span>.<span class="hljs-property">front</span>&#125;)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>        emitter.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;id_card_recognition&quot;</span>,&#123;<span class="hljs-attr">data</span>:params.<span class="hljs-property">cardInfo</span>.<span class="hljs-property">back</span>&#125;)<br>        &#125;<br>        router.<span class="hljs-title function_">back</span>()<br><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;识别失败&quot;</span>)<br>        promptAction.<span class="hljs-title function_">showToast</span>(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&quot;识别失败&quot;</span>&#125;)<br>        router.<span class="hljs-title function_">back</span>()<br>    &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这里的<code>supportType</code>和<code>callback</code>属性是必填项。其中<code>supportType</code>属性我们这里设置的是<code>CardType.CARD_ID</code>,表示要识别身份证信息，注意导入包时 <code>import &#123; CardType &#125; from &#39;@hms.ai.CardRecognition&#39;;</code>，不要搞混了。<br>这里还支持其他属性，可以在官网查询<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-card-recognition#section156871424104118">CardType</a><br>然后是cardSide属性，这个是选填的，虽然文档上说默认值为<code>CardSide.DEFAULT</code>,解释也是说<code>卡证默认面。如身份证为人像面，其他卡证为正面。</code>,但在实际操作中会发现，使用默认值做身份证识别的时候，是需要识别完正面再识别反面。<br>但我们这里希望每次只识别一面就行。因此我们从上个页面传入参数，来表示我们需要识别哪个。</p>
<p>在<code>cardRecognitionConfig</code>属性中，<code>defaultShootingMode</code>设置为自动拍照，也就是当识别到是身份证时就直接拍照了，不需要手动点拍照之后再进行识别。<br><code>isPhotoSelectionSupported</code>这个属性就很好理解了，为true会在页面左下角显示图库按钮，支持从图库选择图片进行识别。</p>
<p>最后就是<code>callback</code>了，有一个类型为<code>CallbackParam</code>的参数，这个参数对象只有三个属性：<code>code:number</code>、<code>cardType:CardType</code>、<code>cardInfo:Record&lt;string, Record&lt;string, string&gt;&gt;</code>。当code值为200时表示识别成功，我们可以在cardInfo中获取识别到的信息。</p>
<div>
<img src='/image/HarmonyOS/身份证识别过程.png' width='30%' heigh='30%'/>
<img src='/image/HarmonyOS/识别成功.png' width='30%' heigh='30%'/>
<img src='/image/HarmonyOS/识别结果.png' width='30%' heigh='30%'/>
</div>

<p>第一张图就是识别过程中截取的一张图，会提示<code>请对准身份证人面像</code>，下面会有一个<strong>安全访问</strong>标识，该标识会自动消失。当检测到画面中有身份证时，会有边框提示。识别成功后会捕捉一张身份证的图片，该图片对应的字段是<code>cardImageUri</code>,也就是最右边图片中的中间那张图，在最右边这张图上我们也可以看到常用的能识别到的字段。<br>当然对于银行卡识别也是一样的，具体的取值可以看官网介绍<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references/vision-card-recognition#section911365315328">cardInfo</a></p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-多包开发:HAP、HAR和HSP</title>
    <url>/2025/02/27/%E9%B8%BF%E8%92%99-%E5%A4%9A%E5%8C%85%E5%BC%80%E5%8F%91-HAP%E3%80%81HAR%E5%92%8CHSP/</url>
    <content><![CDATA[<p>支持模块化开发：将每个功能模块作为一个独立的 Module进行开发，Module 中可以包含源码、资源文件、第三方库、配置文件等，每一个 Module可以独立编译，实现特定的功能<br>支持多设备适配：每个 Module可以单独配置所支持的设备类型，那么在应用市场分发应用包时，也能够根据设备类型做精准的筛选和匹配，从而将不同的包合理的组合和部署到对应的设备上。</p>
<h2 id="Module-类型"><a href="#Module-类型" class="headerlink" title="Module 类型"></a>Module 类型</h2><h3 id="Ability类型的-Module"><a href="#Ability类型的-Module" class="headerlink" title="Ability类型的 Module"></a>Ability类型的 Module</h3><p>用于实现应用的功能和特性，每一个 Ability 类型的 Module编译后，会生成一个以<code>.hap</code>为后缀的文件，被称为HAP(Harmony Abilit Package)。可以被独立安装和运行，是应用安装的基本单位，一个应用中可以包含一个或多个HAP 包。其中又可以分为两种类型：<br>entry 类型的Module：应用主模块，包含应用的入口界面、入口图标和主功能特性，编译后生成entry 类型的 HAP。每一个应用分发到同一类型的设备上的应用程序包，只能包含唯一一个entry 类型的HAP，也可以不包含。<br>feature类型的 Module：应用的动态特性模块，编译后生成feature 类型的 HAP，一个应用可以包含一个或多个feature 类型的HAP，也可以不包含。</p>
<h3 id="Library类型的-Module"><a href="#Library类型的-Module" class="headerlink" title="Library类型的 Module"></a>Library类型的 Module</h3><p>用于实现代码和资源的共享，同一个Library 类型的 Module可以被其他的 Module多次引用。Library 类型的 Module分为 Static和 Shared 两种类型，编译后会生成共享包。<br>Static Library：静态共享库。编译后会生成一个以<code>.har</code>为后缀的文件，也就是静态共享包HAR(Harmony Archive)。<br>Shared Library：动态共享库，编译后会生成一个已<code>.hsp</code>为后缀的文件，也就是动态共享包HSR(Harmony Shared Package)</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>实际上，Shared Library编译后除了会生成一个 hsp 文件外，还会生成一个 har文件，这个 har 文件中包含了 hsp对外导出的接口，应用中其他模块需要通过har 文件来引用 hsp功能，为了表述方便，通常认为Shared Library编译后生成 HSP。来看一下二者的区别。</p>
<p>对于 HAR 文件来讲，其中的代码和资源跟随使用方编译，如果有多个使用方，他们的编译产物中会存在多份拷贝。建议开启混淆能力，保护代码资产。除了支持应用内引用，还可以独立打包发布，供其他应用引用。<br>对于 HSP 文件来讲，其中的代码和资源可以独立编译，运行时在一个进程中代码也只会存在一份。该文件一般随应用进行打包，当前支持应用内和集成态HSP。应用内HSP只支持应用内引用，集成态HSP支持发布到ohpm私仓和跨应用引用。</p>
<h3 id="HAP包限制"><a href="#HAP包限制" class="headerlink" title="HAP包限制"></a>HAP包限制</h3><ul>
<li><p>不支持导出接口和ArkUI组件，给其他模块使用。</p>
</li>
<li><p>多HAP场景下，App Pack包中同一设备类型的所有HAP中必须有且只有一个Entry类型的HAP，Feature类型的HAP可以有一个或者多个，也可以没有。</p>
</li>
<li><p>多HAP场景下，同一应用中的所有HAP的配置文件中的bundleName、versionCode、versionName、minCompatibleVersionCode、debug、minAPIVersion、targetAPIVersion、apiReleaseType相同，同一设备类型的所有HAP对应的moduleName标签必须唯一。HAP打包生成App Pack包时，会对上述参数配置进行校验。</p>
</li>
<li><p>多HAP场景下，同一应用的所有HAP、HSP的签名证书要保持一致。上架应用市场是以App Pack形式上架，应用市场分发时会将所有HAP从App Pack中拆分出来，同时对其中的所有HAP进行重签名，这样保证了所有HAP签名证书的一致性。在调试阶段，开发者通过命令行或DevEco Studio将HAP安装到设备上时，要保证所有HAP签名证书一致，否则会出现安装失败的问题。</p>
</li>
</ul>
<h3 id="HAR包限制"><a href="#HAR包限制" class="headerlink" title="HAR包限制"></a>HAR包限制</h3><ul>
<li><p>HAR不支持在设备上单独安装&#x2F;运行，只能作为应用模块的依赖项被引用。</p>
</li>
<li><p>HAR不支持在配置文件中声明ExtensionAbility组件，但支持UIAbility组件。</p>
<blockquote>
<p>说明<br>如果使用startAbility接口拉起HAR中的UIAbility，接口参数中的moduleName取值需要为依赖该HAR的HAP&#x2F;HSP的moduleName。</p>
</blockquote>
</li>
<li><p>HAR不支持在配置文件中声明pages页面，但是可以包含pages页面，并通过Navigation跳转的方式进行跳转。</p>
</li>
<li><p>HAR不支持引用AppScope目录中的资源。在编译构建时，AppScope中的内容不会打包到HAR中，因此会导致HAR资源引用失败。</p>
</li>
<li><p>HAR可以依赖其他HAR，但不支持循环依赖，也不支持依赖传递。</p>
</li>
</ul>
<h3 id="HSP包限制"><a href="#HSP包限制" class="headerlink" title="HSP包限制"></a>HSP包限制</h3><ul>
<li>HSP不支持在设备上单独安装&#x2F;运行，需要与依赖该HSP的HAP一起安装&#x2F;运行。HSP的版本号必须与HAP版本号一致。</li>
<li>HSP不支持在配置文件中声明ExtensionAbility组件，但支持在配置文件中声明UIAbility（除入口ability外）组件。</li>
<li>HSP可以依赖其他HAR或HSP，但不支持循环依赖，也不支持依赖传递。</li>
</ul>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙--如何发布一个三方库</title>
    <url>/2024/11/06/%E9%B8%BF%E8%92%99-%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AA%E4%B8%89%E6%96%B9%E5%BA%93/</url>
    <content><![CDATA[<p>最近不是觉得官方的展示富文本的控件<code>RichText</code>和<code>RichEditor</code>不好用嘛,然后自己撸了一个能展示简单富文本的组件,具体文章内容看<a href="https://juejin.cn/post/7427455855941156876">鸿蒙-做一个简单的、大家都能学会的富文本解析渲染控件</a>。然后把这个控件发布到了<code>OpenHarmony三方库中心仓</code>,地址<a href="https://ohpm.openharmony.cn/#/cn/detail/simplehtmlrender">simplehtmlrender</a>,没有依赖任何三方控件,使用官方的xml解析器进行解析,使用<code>Text</code>、<code>ContainerSpan</code>、<code>Span</code>和<code>ImageSpan</code>进行展示。<br>这里记录一下发布过程以及需要注意的点</p>
<span id="more"></span>

<h2 id="需要的工具"><a href="#需要的工具" class="headerlink" title="需要的工具"></a>需要的工具</h2><p>DevEcoStudio和ohpm命令行工具。<br>安装完DevEcoStudio后,windows上ohpm在安装目录的<code>DevEco Studio\tools\ohpm\bin</code>文件夹下,mac上是在<code>/Applications/DevEco-Studio.app/Contents/tools/ohpm/bin</code>文件夹下。</p>
<h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>这没啥好说的,按提示注册就好了</p>
<h2 id="认证管理"><a href="#认证管理" class="headerlink" title="认证管理"></a>认证管理</h2><h3 id="生成公私密钥文件"><a href="#生成公私密钥文件" class="headerlink" title="生成公私密钥文件"></a>生成公私密钥文件</h3><p>利用工具 ssh-keygen 生成公、私钥文件,这个和github的流程差不多</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ssh-keygen -m PEM -t RSA -b 4096 -f ~/.ssh_ohpm/mykey <br></code></pre></td></tr></table></figure>
<p>windows下可以把路径换成<code>C:\Users\username\.ssh_ohpm</code>。<br>需要注意几点：</p>
<ul>
<li>先创建对应的文件夹,否则会报错。</li>
<li>生成公私密钥文件时一定要输入密码,不要直接回车跳过,要不然在发布流程会有对应提示,还得再重新生成</li>
</ul>
<h3 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h3><p>在【个人中心】-【认证管理】下：点击页面左上角的“新增”按钮,并将公钥文件（mykey.pub）的内容粘贴到公钥输入框中。<br>在<code>.ohpmrc</code>文件的<code>key_path</code>字段上。该文件一般在<code>C:\Users\username\.ohpm</code> 或者mac的<code>~/.ohpm</code>文件夹下。<br>找不到这个文件也可以执行下面的命令进行配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ohpm config set key_path ~/.ssh_ohpm/mykey <br></code></pre></td></tr></table></figure>
<p>同样的,windows下把路径换成<code>C:\Users\username\.ssh_ohpm</code>。</p>
<h3 id="发布之前的配置"><a href="#发布之前的配置" class="headerlink" title="发布之前的配置"></a>发布之前的配置</h3><p>登录OpenHarmony三方库中心仓,从 【个人中心】页面中【复制发布码】,并配置到<code>.ohpmrc</code>文件中<code>publish_id</code>字段上,可执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ohpm config set publish_id your_publish_id<br></code></pre></td></tr></table></figure>

<p>配置发布地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ohpm config set publish_registry https://ohpm.openharmony.cn/ohpm<br></code></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>可以创建自己的组织,这个不是必须的。<br>注意一下三方库的名称,<a href="https://ohpm.openharmony.cn/#/cn/help/guidename">三方库名称指南</a></p>
<h2 id="编写及发布"><a href="#编写及发布" class="headerlink" title="编写及发布"></a>编写及发布</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>创建一个新的项目,然后在项目中创建一个Module,这里需要选择<code>static library</code>。然后在这个Module中编写相关代码。</p>
<h3 id="必须的文件"><a href="#必须的文件" class="headerlink" title="必须的文件"></a>必须的文件</h3><h4 id="README-md"><a href="#README-md" class="headerlink" title="README.md"></a>README.md</h4><p>在Module的根目录创建一个 README.md 文件,描述您三方库的代码以及如何使用它,文件不能为空。<br>并且该文件中<strong>必须</strong>包含如何安装,也就是<code> ohpm install 库名字</code>,否则审核不通过。<br>可以看下其他仓库怎么写的。基本上包含如何安装、如何使用以及一些示例。<br>该文件的内容会展示在仓库的描述标签下。</p>
<h4 id="CHANGELOG-md"><a href="#CHANGELOG-md" class="headerlink" title="CHANGELOG.md"></a>CHANGELOG.md</h4><p>在Module的根目录中,创建一个 CHANGELOG.md 文件,描述您三方库的代码不同版本的变更内容,文件不能为空。<br>该文件的内容会展示在仓库的更新日志标签下</p>
<h4 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h4><p>在Module的根目录中,创建一个 LICENSE 文件,指定该软件包可以在什么样的许可下被使用、修改和共享,文件不能为空。</p>
<h4 id="oh-package-json5"><a href="#oh-package-json5" class="headerlink" title="oh-package.json5"></a>oh-package.json5</h4><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;simplehtmlrender&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.2&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;简易的富文本渲染控件，支持span、font、br、a标签，支持color、font-color、size、font-size、background、href属性&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Index.ets&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;富文本&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;html展示&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;富文本展示&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> &#x27;huangyuan&#x27;<span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;huangyuan@huangyuanlove.com&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Apache-2.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;homepage&quot;</span><span class="hljs-punctuation">:</span> &#x27;https<span class="hljs-punctuation">:</span><span class="hljs-comment">//juejin.cn/post/7427455855941156876&#x27;,</span><br>  <span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span>&#x27;https<span class="hljs-punctuation">:</span><span class="hljs-comment">//gitee.com/huangyuan/SimpleHtmlRender&#x27;,</span><br>  <span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure>
<p>其中,<code>name</code>、<code>version</code>、<code>description</code>、<code>keywords</code>、<code>author</code>、<code>license</code>字段是必须的</p>
<h4 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h4><p>三方库中央仓里面还有个points评分，最高是50分，这个是根据文件、文档的健全程度来打分的，不包含任何个人主观看法。</p>
<p><img src="/image/HarmonyOS/third_part_points.png" alt="三方库评分"><br>这个评分很好弄，按照标准来就行</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><strong>发布之前删除敏感信息</strong><br><strong>发布之前删除敏感信息</strong><br><strong>发布之前删除敏感信息</strong><br>发布的时候需要上传har文件，这就需要使用DevEcoStudio来构建，如何构建看(这里)[<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-hvigor-build-har-V5]%E3%80%82">https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ide-hvigor-build-har-V5]。</a><br>我们在前面已经配置好了<code>publish_id</code>和<code>publish_registry</code>信息，接着执行<code>ohpm publish &lt;HAR路径&gt;</code>就可以了。过程中会让你输入生成公钥时使用的密码，上传成功后可以在<code>个人中心--&gt;消息</code>中查看审核是否通过的消息。<br>如果上传失败，会提示对应的错误信息，根据提示修改就好了</p>
<p>这样就完成了发布。</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-状态管理V1</title>
    <url>/2025/01/26/%E9%B8%BF%E8%92%99-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86V1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着鸿蒙Next的推广，做鸿蒙开发的人是越来越多，提问和寻求帮助的人也是越来越多，就我自己回答的问题而言，大部分和状态管理相关，比如List刷新问题，，还有一些录音录像拍照问题。也不是太难的问题，需要特别仔细的阅读官方文档，有些问题的解决方法还分散在好几个文档里面，文档上也没有对一些关键点做特别讲解。这里就最常见的问题总结一下，希望后来的朋友少走一些弯路。</p>
<h2 id="状态管理V1"><a href="#状态管理V1" class="headerlink" title="状态管理V1"></a>状态管理V1</h2><p>组件的状态管理一共就这几个：<br>@State装饰器：组件内状态<br>@Prop装饰器：父子单向同步<br>@Link装饰器：父子双向同步<br>@Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化<br>@Provide装饰器和@Consume装饰器：与后代组件双向同步<br>其中<br>@Provide和@Consume群里也几乎没有人问过，姑且认为是大家都比较清楚应该怎么使用或者用的较少</p>
<h3 id="State装饰器"><a href="#State装饰器" class="headerlink" title="@State装饰器"></a>@State装饰器</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><strong>必须</strong>本地初始化。如果从父组件初始化，并且从父组件传入的值非<code>undefined</code>，将会覆盖本地初始化；如果从父组件传入的值为<code>undefined</code>，则初值为<code>@State</code>装饰变量自身的初值。<br>也就是说无论父组件是否传值，被<code>@State</code>修饰的变量都必须要指定初始值，即使被<code>@Require</code>修饰也必须指定初始值。</p>
<h4 id="观察能力"><a href="#观察能力" class="headerlink" title="观察能力"></a>观察能力</h4><p>能观察到简单对象的变化；能观察到class 或者 Object 的赋值变化；能观察到其属性赋值的变化，但无法观察嵌套类属性赋值的变化;<br>看个例子，假设我们的数据类是这样的:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OutClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">outClassName: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">outClassName</span> = outClassName<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerClass</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;outClassName&#125;</span>_innerClass`</span>)<br>  &#125;<br>  <span class="hljs-attr">outClassName</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">innerClass</span>: <span class="hljs-title class_">InnerClass</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">innerClassName: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerClassName</span> = innerClassName<br>  &#125;<br>  <span class="hljs-attr">innerClassName</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们的业务逻辑姑且简化为这样</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">AboutStateAnno</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">grade</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;a&#x27;</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">success</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">outClass</span>: <span class="hljs-title class_">OutClass</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutClass</span>(<span class="hljs-string">&quot;out_class&quot;</span>)<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`count: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.count&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`grade: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.grade&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`success: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.success&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`out_class_name: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.outClass.outClassName&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`inner_class_name: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.outClass.innerClass.innerClassName&#125;</span>`</span>)<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;改变简单数据,UI刷新&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> ++<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span> += <span class="hljs-variable language_">this</span>.<span class="hljs-property">grade</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">success</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">success</span><br>      &#125;)<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;改变outClassName,UI刷新&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">outClass</span>.<span class="hljs-property">outClassName</span> = <span class="hljs-string">&#x27;out_afterChange&#x27;</span><br>      &#125;)<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;改变innerClassName,UI不刷新&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">outClass</span>.<span class="hljs-property">innerClass</span>.<span class="hljs-property">innerClassName</span> = <span class="hljs-string">&#x27;inner_afterChange&#x27;</span><br>      &#125;)<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;改变innerClass,UI刷新&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">outClass</span>.<span class="hljs-property">innerClass</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InnerClass</span>(<span class="hljs-string">&#x27;new inner_class&#x27;</span>)<br>      &#125;)<br><br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">borderRadius</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Gray</span>).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>可以看到，改变简单数据后，UI 直接刷新了。修改对象中的属性，UI 也刷新了，但是在改变嵌套类属性时(改变innerClassName,UI不刷新)，UI 没有刷新，也就是说改变<code>Object.keys(observedObject)</code>返回的所有属性时，UI都可以刷新。<br>同样的，对于数组类型来讲：数组的整体赋值，数组项的赋值，调用 pop 和 push 也能观察到。<br>对于<code>Map</code>来讲：可以观察到<code>Map</code>整体的赋值，同时可通过调用<code>Map</code>的接口<code>set</code>, <code>clear</code>, <code>delete</code> 更新Map的值。<br>对于<code>Set</code>来讲：可以观察到<code>Set</code>整体的赋值，同时可通过调用<code>Set</code>的接口<code>add</code>, <code>clear</code>, <code>delete</code> 更新Set的值。<br>这里就不再过多赘述。</p>
<h4 id="小坑"><a href="#小坑" class="headerlink" title="小坑"></a>小坑</h4><p>但这里有个比较麻烦的地方：当在build方法内，当@State装饰的变量是Object类型、且通过a.b(this.object)形式调用时，<strong>修改对象中的属性后，UI 无法刷新</strong><br>比如有一个 Person 类，有个 age 属性，我们定义一个方法用来修改 age 属性。我能想到的大概有这么 5 种方式</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">//方法 1：定义一个工具类，写个静态方法，传入 person 对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddAge</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">addAge</span>(<span class="hljs-params">person: Person</span>) &#123;<br>    person.<span class="hljs-property">age</span> += <span class="hljs-number">2</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">//方法 2：定义一个工具类，写个普通方法，传入 person 对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddAge1</span> &#123;<br>  <span class="hljs-title function_">addAge</span>(<span class="hljs-params">person: Person</span>) &#123;<br>    person.<span class="hljs-property">age</span> += <span class="hljs-number">2</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">//方法 3：在组件中定义一个方法，传入 person 对象</span><br><span class="hljs-title function_">addAge1</span>(<span class="hljs-params">person: Person</span>) &#123;<br>  person.<span class="hljs-property">age</span> += <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-comment">//方法 4：在组件中定义一个方法，直接修改 person 对象</span><br><span class="hljs-title function_">addAge</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">age</span> += <span class="hljs-number">2</span><br>&#125;<br><span class="hljs-comment">//方法 5：在需要的地方直接修改 person 对象的 age 属性，比如在onClick事件中</span><br><span class="hljs-title class_">Text</span>(<span class="hljs-string">`person.add:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.age&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">age</span> += <span class="hljs-number">2</span>;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>我们来试一下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@State</span> <span class="hljs-attr">person1</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-meta">@State</span> <span class="hljs-attr">person2</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-meta">@State</span> <span class="hljs-attr">person3</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-meta">@State</span> <span class="hljs-attr">person4</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-meta">@State</span> <span class="hljs-attr">person5</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Column</span>() &#123;<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">`person1.add: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person1.age&#125;</span>`</span>)<br>    .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>      <span class="hljs-title class_">AddAge</span>.<span class="hljs-title function_">addAge</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">person1</span>)<br>    &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">`person2.add:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person2.age&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddAge1</span>().<span class="hljs-title function_">addAge</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">person2</span>)<br>  &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">`person3.add:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person3.age&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addAge1</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">person3</span>)<br>  &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">`person4.add:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person4.age&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addAge</span>()<br>  &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>  <span class="hljs-title class_">Text</span>(<span class="hljs-string">`person5.add:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person5.age&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">person5</span>.<span class="hljs-property">age</span> += <span class="hljs-number">2</span>;<br>  &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>&#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>会发现只有方法 4 和方法 5 才能使得UI 刷新，这是因为方法内传过去的是原生对象，修改其属性后不能触发刷新。如果我们有一些理由非得这么做，可以先赋值给一个临时变量，再将这个临时变量传入方法中，就可以刷新 UI 了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Column</span>() &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`person1.add: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person1.age&#125;</span>`</span>)<br>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> tmp = <span class="hljs-variable language_">this</span>.<span class="hljs-property">person1</span><br>          <span class="hljs-title class_">AddAge</span>.<span class="hljs-title function_">addAge</span>(tmp)<br>        &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`person2.add:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person2.age&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> tmp = <span class="hljs-variable language_">this</span>.<span class="hljs-property">person2</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddAge1</span>().<span class="hljs-title function_">addAge</span>(tmp)<br>      &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`person3.add:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person3.age&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> tmp = <span class="hljs-variable language_">this</span>.<span class="hljs-property">person3</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addAge1</span>(tmp)<br>      &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`person4.add:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person4.age&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addAge</span>()<br>      &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`person5.add:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person5.age&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">person5</span>.<span class="hljs-property">age</span> += <span class="hljs-number">2</span>;<br>      &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>  &#125;.<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>  .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>没想到吧，哈哈哈哈哈</p>
<h3 id="Prop装饰器-和-Link装饰器"><a href="#Prop装饰器-和-Link装饰器" class="headerlink" title="@Prop装饰器 和 @Link装饰器"></a>@Prop装饰器 和 @Link装饰器</h3><p>这两个装饰器的观察能力和坑点和@State 相同，只不过是用来自定义的子组件中。<br>其中@Prop装饰器是父组件向子组件同步数据：子组件改变数据不会同步到父组件，但父组件修改数据会同步到子组件。也就是说父组件的修改会覆盖掉子组件对变量的修改，并且被它装饰的变量会进行深拷贝，在拷贝的过程中除了基本类型、Map、Set、Date、Array外，都会丢失类型。因此建议深度嵌套的数据不要太多，文档上建议不要超过 5 层。<br>@Link装饰器是父子组件双向同步的，但禁止本地进行初始化。</p>
<h3 id="Observed装饰器和-ObjectLink装饰器"><a href="#Observed装饰器和-ObjectLink装饰器" class="headerlink" title="@Observed装饰器和@ObjectLink装饰器"></a>@Observed装饰器和@ObjectLink装饰器</h3><p>在实际开发中，我们使用的数据模型一般都会有多层嵌套的情况，但之前介绍过的装饰器只能观察到第一层变化，无法观察到第二层变化，这种情况我们就需要使用<code>@Observed</code>和<code>@ObjectLink</code>装饰器.</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p><code>@Observed</code>装饰class。需要放在class的定义前，使用<code>new</code>创建类对象。<br><code>@ObjectLink</code>变量装饰器只能装饰被<code>@Observed</code>装饰的class实例，<strong>必须</strong>指定类型，并且不支持简单类型。</p>
<p>另外这两个装饰器是配套使用的，单一的使用某个装饰器无法实现观察，并且<code>@ObjectLink</code>只能装饰被<code>@Observed</code>装饰的类对象变量，否则会报错</p>
<blockquote>
<p>The ‘@ObjectLink’ decorated attribute ‘education’ must be an ‘@Observed’ decorated class or a union of ‘@Observed’ decorated class and undefined or null, or both. <ArkTSCheck></p>
</blockquote>
<p><img src="/image/HarmonyOS/ObjectLink%E4%BF%AE%E9%A5%B0%E6%B2%A1%E6%9C%89%E8%A2%ABObserved%E8%A3%85%E9%A5%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1.png" alt="ObjectLink修饰没有被Observed装饰的类对象">  </p>
<p>我们先定义一个数据类，来模拟一下业务逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">address</span>: <span class="hljs-title class_">Address</span><br>  <span class="hljs-attr">education</span>: <span class="hljs-title class_">Education</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id: <span class="hljs-built_in">number</span>, name: <span class="hljs-built_in">string</span>, address: Address, education: Education</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = id;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span> = address;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">education</span> = education;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>  <span class="hljs-attr">zipCode</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">location</span>: <span class="hljs-built_in">string</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">zipCode: <span class="hljs-built_in">number</span>, location: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">zipCode</span> = zipCode;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">location</span> = location;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Education</span> &#123;<br>  <span class="hljs-attr">school</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">degree</span>: <span class="hljs-built_in">string</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">school: <span class="hljs-built_in">string</span>, degree: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">school</span> = school;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">degree</span> = degree;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里还有一点需要注意的，到目前为止<code>@ObjectLink</code>必须在自定义组件中使用。我们这里定义两个组件，用来展示<code>Address</code>和<code>Education</code>.  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">UserAddress</span> &#123;<br>  <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">address</span>: <span class="hljs-title class_">Address</span><br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`location:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.address.location&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`zipCode:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.address.zipCode&#125;</span>`</span>)<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">padding</span>(<span class="hljs-number">5</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">UserEducation</span> &#123;<br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">education</span>: <span class="hljs-title class_">Education</span><br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`school:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.education.school&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`degree:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.education.degree&#125;</span>`</span>)<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">padding</span>(<span class="hljs-number">5</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>简单的写个页面，看下效果。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@State</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-comment">//这里必须使用 new 关键字创建对象，使用字面量创建出来的对象无法被观察</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">address</span>: <span class="hljs-title class_">Address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-number">10000</span>, <span class="hljs-string">&quot;北京&quot;</span>)<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">education</span>: <span class="hljs-title class_">Education</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Education</span>(<span class="hljs-string">&#x27;university&#x27;</span>, <span class="hljs-string">&#x27;Master&#x27;</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;new User&#x27;</span>, address, education) <br>&#125;<br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>        <span class="hljs-title class_">Text</span>(<span class="hljs-string">`id:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.user.id&#125;</span> , name:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.user.name&#125;</span>`</span>)<br>        <span class="hljs-title class_">UserAddress</span>(&#123; <span class="hljs-attr">address</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">address</span> &#125;)<br>        <span class="hljs-title class_">UserEducation</span>(&#123; <span class="hljs-attr">education</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">education</span> &#125;)<br>        <span class="hljs-title class_">Flex</span>(&#123; <span class="hljs-attr">wrap</span>: <span class="hljs-title class_">FlexWrap</span>.<span class="hljs-property">Wrap</span>, <span class="hljs-attr">space</span>: &#123; <span class="hljs-attr">cross</span>: <span class="hljs-title class_">LengthMetrics</span>.<span class="hljs-title function_">vp</span>(<span class="hljs-number">5</span>), <span class="hljs-attr">main</span>: <span class="hljs-title class_">LengthMetrics</span>.<span class="hljs-title function_">vp</span>(<span class="hljs-number">5</span>) &#125; &#125;) &#123;<br>          <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改 name&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">name</span> += <span class="hljs-string">&#x27;a&#x27;</span><br>            &#125;<br>          &#125;)<br>          <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改address.location&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">address</span>.<span class="hljs-property">location</span> += <span class="hljs-string">&#x27;b&#x27;</span><br>            &#125;<br>          &#125;)<br>          <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改education.degree&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>) &#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>.<span class="hljs-property">education</span>.<span class="hljs-property">degree</span> += <span class="hljs-string">&#x27;c&#x27;</span><br>            &#125;<br>          &#125;)<br>        &#125;<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，点击<code>修改 name</code>和<code>修改address.location</code>都可以引起 UI 刷新，但点击<code>修改education.degree</code>UI不会刷新。</p>
<p>另外还有一点需要注意的：被@Observed 修饰的嵌套类，不能跨嵌套层观察。举个例子：我们有一个嵌套的三层的数据类，我们是无法在第二层的自定义控件中观察到第三层数据的变化。示例如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//嵌套了三层的数据类：也就是A类中有类型为B的属性，B类中又有类型为C的属性 </span><br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstLevel</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">secondLevel</span>: <span class="hljs-title class_">SecondLevel</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, secondLevel: SecondLevel</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">secondLevel</span> = secondLevel;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondLevel</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">thirdLevel</span>: <span class="hljs-title class_">ThirdLevel</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, thirdLevel: ThirdLevel</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">thirdLevel</span> = thirdLevel;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThirdLevel</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们定义两个用来展示<code>SecondLevel</code>和<code>ThirdLevel</code>的控件</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">SecondLevelView</span>&#123;<br>  <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">secondLevel</span>:<span class="hljs-title class_">SecondLevel</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>()&#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`second level:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.secondLevel.name&#125;</span>`</span>)<br>      <span class="hljs-comment">//这里直接跨层级观察是无效的，修改thirdLevel.name时 UI 不会刷新</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`third level name:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.secondLevel.thirdLevel.name&#125;</span>`</span>)<br>      <span class="hljs-title class_">ThirdLevelView</span>(&#123;<span class="hljs-attr">thirdLevel</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">thirdLevel</span>&#125;).<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&#x27;#846f9b&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">ThirdLevelView</span>&#123;<br>  <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">thirdLevel</span>:<span class="hljs-title class_">ThirdLevel</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Text</span>(<span class="hljs-string">`third level: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.thirdLevel.name&#125;</span>`</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接着写个页面试一下</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@State</span> <span class="hljs-attr">firstLevel</span>:<span class="hljs-title class_">FirstLevel</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">thirdLevel</span>:<span class="hljs-title class_">ThirdLevel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdLevel</span>(<span class="hljs-string">&#x27;third level&#x27;</span>)<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">secondLevel</span>:<span class="hljs-title class_">SecondLevel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondLevel</span>(<span class="hljs-string">&#x27;second level&#x27;</span>,thirdLevel)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstLevel</span>(<span class="hljs-string">&#x27;first level&#x27;</span>,secondLevel)<br>&#125;<br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Column</span>() &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>)&#123;<br>      <span class="hljs-title class_">Column</span>()&#123;<br>        <span class="hljs-title class_">Text</span>(<span class="hljs-string">`first level:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.firstLevel.name&#125;</span>`</span>)<br>        <span class="hljs-title class_">SecondLevelView</span>(&#123;<span class="hljs-attr">secondLevel</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>&#125;).<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&#x27;#aa42f5&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br><br>        <span class="hljs-title class_">Flex</span>(&#123; <span class="hljs-attr">wrap</span>: <span class="hljs-title class_">FlexWrap</span>.<span class="hljs-property">Wrap</span>, <span class="hljs-attr">space</span>: &#123; <span class="hljs-attr">cross</span>: <span class="hljs-title class_">LengthMetrics</span>.<span class="hljs-title function_">vp</span>(<span class="hljs-number">5</span>), <span class="hljs-attr">main</span>: <span class="hljs-title class_">LengthMetrics</span>.<span class="hljs-title function_">vp</span>(<span class="hljs-number">5</span>) &#125; &#125;) &#123;<br>          <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改 firstLevel.name&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>)&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">name</span>  += <span class="hljs-string">&#x27;a&#x27;</span><br>            &#125;<br>          &#125;)<br>          <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改 secondLevel.name&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>)&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">name</span>  += <span class="hljs-string">&#x27;a&#x27;</span><br>            &#125;<br>          &#125;)<br>          <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改 thirdLevel.name&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>)&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">thirdLevel</span>.<span class="hljs-property">name</span>  += <span class="hljs-string">&#x27;a&#x27;</span><br>            &#125;<br>          &#125;)<br>        &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>      &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">padding</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&quot;#657e57&quot;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image/HarmonyOS/%E8%B7%A8%E5%B5%8C%E5%A5%97%E5%B1%82%E7%BA%A7%E8%A7%82%E5%AF%9F%E5%A4%B1%E8%B4%A5.gif" alt="跨嵌套层级观察失效"><br>可以看到，在对应的层级观察对应的嵌套类是生效的，但当我们点击<code>修改 thirdLevel.name</code>时，只有在<code>ThirdLevelView</code>中的控件刷新了，在<code>SecondLevelView</code>中观察<code>thirdLevel.name</code>的 Text内容并没有刷新。这是因为在<code>SecondLevelView</code>中，<code>@ObjectLink</code>仅能观察到其代理的<code>secondLevel:SecondLevel</code>对象的属性变化，而<code>secondLevel.thirdLevel.name</code>是<code>ThirdLevel</code>的属性，无法观察到嵌套类的变化。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>不建议在被@Observed 修饰的类的构造函数中修改值，不会引起UI刷新，因为修改的是原始对象的值，并非是代理对象。</li>
<li>被<code>@Observed</code>修饰的嵌套类，不要跨嵌套层观察，建议一个数据类对应一个自定义控件。</li>
<li>必须使用new 创建的类对象，使用字面量对象无法被观察。比如网络请求返回的数据转成 JSON 后使用 as 强转为对应类型</li>
<li>通过a.b(this.object)形式调用时，修改对象中的属性后，UI 无法刷新，原因同@State</li>
<li>@ObjectLink的数据源更新依赖其父组件，当父组件中数据源改变引起父组件刷新时，会重新设置子组件@ObjectLink的数据源。这个过程不是在父组件数据源变化后立刻发生的，而是在父组件实际刷新时才会进行。</li>
</ul>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-状态管理V1和V2在ForEach循环渲染的表现</title>
    <url>/2025/03/24/%E9%B8%BF%E8%92%99-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86V1%E5%92%8CV2%E5%9C%A8ForEach%E5%BE%AA%E7%8E%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E8%A1%A8%E7%8E%B0/</url>
    <content><![CDATA[<p>状态管理V2已经出来好长时间了，移除GAP说明也有一段时间了，相信有一部分朋友已经开始着手从V1迁移到V2了，应该也踩了不少坑。<br>下面向大家分享一下我使用状态管理V1和Foreach时遇到的坑，以及状态管理V2在Foreach循环渲染中的表现。</p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>这里就先默认大家都已经熟悉状态管理V1中的@Observed装饰器和@ObjectLink装饰器，以及ForEach循环渲染相关的知识，并且仔细阅读过<code>ForEach：循环渲染</code>章节中的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach#%E6%B8%B2%E6%9F%93%E7%BB%93%E6%9E%9C%E9%9D%9E%E9%A2%84%E6%9C%9F">渲染结果非预期</a>了。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>先说场景需求：<br>典型的支付结算页面选择优惠券的场景。当用户在结算页面点击优惠券时，跳转到优惠券列表页面，并在该页面向服务器请求优惠券列表数据。<br>这是服务器会根据传入的订单信息按照需求计算出默认选中哪个优惠券，该页面支持下拉刷新。<br>我们来简化一下优惠券数据，关键数据优惠券id，抵扣信息和描述。于是我们很容易写出如下代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//数据类</span><br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CouponData</span> &#123;<br>  <span class="hljs-attr">id</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">defaultSelect</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">//用于展示数据的控件</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CouponView</span> &#123;<br>  <span class="hljs-meta">@Watch</span>(<span class="hljs-string">&#x27;onCouponDataChange&#x27;</span>) <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">CouponData</span><br>  <span class="hljs-comment">//优惠券是单选，因此选中|取消选中优惠券时通知父组件更新数据</span><br>  <span class="hljs-attr">onChangeSelect</span>:<span class="hljs-function">(<span class="hljs-params">id:<span class="hljs-built_in">string</span>,select:<span class="hljs-built_in">boolean</span></span>)=&gt;</span><span class="hljs-built_in">void</span> = <span class="hljs-function">(<span class="hljs-params">id:<span class="hljs-built_in">string</span>,select:<span class="hljs-built_in">boolean</span></span>)=&gt;</span>&#123;&#125;<br><br>  <span class="hljs-title function_">onCouponDataChange</span>(<span class="hljs-params"></span>) &#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, <span class="hljs-string">`onCouponDataChange <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model.id&#125;</span>  <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model.defaultSelect&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model.name&#125;</span> , select :<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model.defaultSelect&#125;</span>`</span>)<br>      <span class="hljs-title class_">Circle</span>()<br>        .<span class="hljs-title function_">width</span>(<span class="hljs-number">20</span>)<br>        .<span class="hljs-title function_">height</span>(<span class="hljs-number">20</span>)<br>        .<span class="hljs-title function_">fill</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">defaultSelect</span> ? <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span> : <span class="hljs-title class_">Color</span>.<span class="hljs-property">Gray</span>)<br>        .<span class="hljs-title function_">stroke</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">defaultSelect</span> ? <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span> : <span class="hljs-title class_">Color</span>.<span class="hljs-property">Grey</span>)<br><br>    &#125;.<span class="hljs-title function_">padding</span>(&#123; <span class="hljs-attr">top</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">bottom</span>: <span class="hljs-number">10</span> &#125;).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onChangeSelect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">id</span>,!<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">defaultSelect</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//为了简单展示，这里没有从服务器获取数据；下拉刷新也用按钮代替；点击确认时弹个toast提示一下选中的优惠券id</span><br><br><br><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">ForeachPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">couponDataList</span>: <span class="hljs-title class_">CouponData</span>[] = []<br>  <span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initData</span>()<br>  &#125;<br>  <span class="hljs-comment">//模拟一下数据</span><br>  <span class="hljs-title function_">initData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span> = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">CouponData</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CouponData</span>()<br>      model.<span class="hljs-property">id</span>= i.<span class="hljs-title function_">toString</span>()<br>      model.<span class="hljs-property">name</span> = <span class="hljs-string">`优惠券 <span class="hljs-subst">$&#123;i&#125;</span> 项`</span><br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">false</span><br>      &#125;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span>.<span class="hljs-title function_">push</span>(model)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br><br>    <span class="hljs-comment">//就当这里是下拉刷新了，问题不大</span><br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;刷新&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initData</span>()<br>      &#125;)<br>      <span class="hljs-title class_">List</span>() &#123;<br>        <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span>, <span class="hljs-function">(<span class="hljs-params">model: CouponData</span>) =&gt;</span> &#123;<br>          <span class="hljs-title class_">ListItem</span>() &#123;<br>            <span class="hljs-title class_">CouponView</span>(&#123; <span class="hljs-attr">model</span>: model ,<span class="hljs-attr">onChangeSelect</span>:<span class="hljs-function">(<span class="hljs-params">id:<span class="hljs-built_in">string</span>,select:<span class="hljs-built_in">boolean</span></span>)=&gt;</span>&#123;<br>              hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, <span class="hljs-string">`onChangeSelect <span class="hljs-subst">$&#123;id&#125;</span> <span class="hljs-subst">$&#123;select&#125;</span>`</span>)<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">data:CouponData</span>)=&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span>(data.<span class="hljs-property">id</span> == id)&#123;<br>                  data.<span class="hljs-property">defaultSelect</span> = select<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                  <span class="hljs-keyword">if</span>(select)&#123;<br>                    data.<span class="hljs-property">defaultSelect</span> =<span class="hljs-literal">false</span>;<br>                  &#125;<br>                &#125;<br>              &#125;)<br>            &#125;&#125;)<br>          &#125;<br><br>        &#125;, <span class="hljs-function">(<span class="hljs-params">item: CouponData,index:<span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> key = item.<span class="hljs-property">id</span> +<span class="hljs-string">&quot;__&quot;</span> +item.<span class="hljs-property">defaultSelect</span><br>          hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, key)<br>          <span class="hljs-keyword">return</span> key<br>        &#125;)<br>      &#125;.<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)<br><br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;确定&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">selectCouponID</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;未选中&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">couponData:CouponData</span>)=&gt;</span>&#123;<br>          <span class="hljs-keyword">if</span>(couponData.<span class="hljs-property">defaultSelect</span>)&#123;<br>            selectCouponID = couponData.<span class="hljs-property">id</span><br>          &#125;<br>        &#125;)<br>        promptAction.<span class="hljs-title function_">showToast</span>(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">`选中的优惠券是 <span class="hljs-subst">$&#123;selectCouponID&#125;</span>`</span>&#125;)<br>      &#125;)<br><br>    &#125;<br>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>使用了ForEach循环渲染来生成List的子组件，并且根据开发文档的<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-rendering-control-foreach#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE">使用建议</a>，我们没有让index参与key的生成，而是使用优惠券的唯一id作为key。<br>运行后切换选中状态，完美。<br>但是遇到了两个问题：</p>
<ol>
<li>点击刷新后，并没有将第二项设置未选中、其他项设置为未选中。  </li>
<li>没有办法切换选中状态。<br>—–emmmmmm——<br>不急，肯定有它的原因。</li>
</ol>
<p>看日志：发现在切换选中状态的时候列表项的key没有打印，说明选中状态的切换也就是UI的刷新不是因为key发生了变化，而是因为ObjectLink和Observed观测能力驱动的UI发生的变化。</p>
<p>接着就能确认问题1：因为切换选中状态时key没有变化，导致点击刷新之后，第二次列表的key和刚进入时列表key一致，因此UI没有刷新。<br>但这里有个问题：为什么参与计算key的属性发生了变化，但key却不会变化？这可能和ObjectLink和Observed观测能力的实现有关，这里没有确认。</p>
<p>但为什么没有办法切换选中状态？看文档中@State是可以观测到数组项赋值的。<br>根据问题1的结论接着推论：因为key相同，不会重新绘制列表项，这就引起了另外一个问题：列表项没有被重新绘制，因此列表项还是绑定着点击刷新之前数组中的对象，但我们点击列表项时，修改的是数组中的新对象，因此更不会刷新UI。</p>
<p>为了验证这个推论，我们第一次对数组赋值时将第二项默认选中设置为true； 点击刷新的时候，将第四项默认选中设置为true。<br>修改一下initData方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript">  <span class="hljs-attr">firstInit</span>:<span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-title function_">initData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span>=[]<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">CouponData</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CouponData</span>()<br>    model.<span class="hljs-property">id</span>= i.<span class="hljs-title function_">toString</span>()<br>    model.<span class="hljs-property">name</span> = <span class="hljs-string">`优惠券 <span class="hljs-subst">$&#123;i+<span class="hljs-number">1</span>&#125;</span> 项`</span><br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstInit</span>)&#123;<br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> ) &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span> ) &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span>.<span class="hljs-title function_">push</span>(model)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstInit</span> = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这时候，我们进入页面，默认选中了第二项。然后点击第一项，将第一项切换为选中状态。之后点击刷新。发现第一项和第四项都变成了选中状态。</p>
<p>这时候我们点击第二项，可以将第二项切换为选中状态，并且第四项切换为未选中状态。这是是因key发生了变化，列表项重绘，绑定了数组中新的对象。</p>
<p>然后点击第三项或者第五项，都可以将第二项切换为未选中状态，但第三项和第五项本身不会被选中。因为第三项和第五项没有重绘，还是绑定的数组中之前的对象。</p>
<p>这时候选中第二项或者第四项之后，再点击第一项，发现并没有将第二项或者第四项切换为未选中状态，这是因为第一项没有被重绘，绑定的还是数组中之前的对象，并且是选中状态，这时候我们点击第一项是取消第一项的选中，并不会修改其他数据。</p>
<p>这里也验证了我们上面的推论。</p>
<p>这里就有人问了：</p>
<blockquote>
<p>emmm，那怎么办？<br>凉拌呗，换V2。<br>不行哇，这个数据类在其他地方也在用，还都是用的V1。<br>你看，着kpi不就有着落了嘛</p>
</blockquote>
<p>好吧，也有个比较恶心的办法，不追求极致性能、数据量较小的时候可以拿来应急：<br>定义一个变量，让这个变量参与key的生成，并且在每次刷新的时候都修改这个变量，进而达到强制让key发生变化，重绘所有列表项。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-attr">refreshTime</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br><span class="hljs-title function_">initData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">refreshTime</span> = systemDateTime.<span class="hljs-title function_">getTime</span>()<br>    ...<br>&#125;<br><span class="hljs-comment">//ForEach额key生成方法</span><br>(<span class="hljs-attr">item</span>: <span class="hljs-title class_">CouponData</span>,<span class="hljs-attr">index</span>:<span class="hljs-built_in">number</span>) =&gt; &#123;<br>          <span class="hljs-keyword">let</span> key = item.<span class="hljs-property">id</span> +<span class="hljs-string">&quot;__&quot;</span> +item.<span class="hljs-property">defaultSelect</span> +<span class="hljs-string">&quot;__&quot;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">refreshTime</span><br>          hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, key)<br>          <span class="hljs-keyword">return</span> key<br>        &#125;<br></code></pre></td></tr></table></figure>
<p>emmm，这样可以正常刷新。</p>
<h2 id="换V2呗"><a href="#换V2呗" class="headerlink" title="换V2呗"></a>换V2呗</h2><p>改动也没多少，不过有一点比较恶心，就是被@ObservedV2修饰的类，参与UI展示的属性必须被@Trace修饰，属性少了还好说，属性多了纯纯体力活。<br>写了个插件，可以从json字符串转为ArkTS对象，并且自动加上@Trace修饰<br><a href="https://github.com/huangyuanlove/JsonToArkTS">github</a><br><a href="https://gitee.com/huangyuan/JsonToArkTS">gitee</a><br><a href="https://gitcode.com/huangyuan_xuan/JsonToArkTS">gitcode</a>   </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@ComponentV2</span> <span class="hljs-comment">//修改为V2</span><br>struct <span class="hljs-title class_">ForeachPage</span> &#123;<br>  <span class="hljs-meta">@Local</span> <span class="hljs-attr">couponDataList</span>: <span class="hljs-title class_">CouponData</span>[] = [] <span class="hljs-comment">//修改为V2</span><br><br>  <span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initData</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">initData</span>(<span class="hljs-params"></span>) &#123;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span> = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">CouponData</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CouponData</span>()<br>      model.<span class="hljs-property">id</span> = i.<span class="hljs-title function_">toString</span>()<br>      model.<span class="hljs-property">name</span> = <span class="hljs-string">`优惠券 <span class="hljs-subst">$&#123;i + <span class="hljs-number">1</span>&#125;</span> 项`</span><br><br><br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">false</span><br>      &#125;<br><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span>.<span class="hljs-title function_">push</span>(model)<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;刷新&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initData</span>()<br>      &#125;)<br>      <span class="hljs-title class_">List</span>() &#123;<br>        <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span>, <span class="hljs-function">(<span class="hljs-params">model: CouponData</span>) =&gt;</span> &#123;<br>          <span class="hljs-title class_">ListItem</span>() &#123;<br>            <span class="hljs-title class_">CouponView</span>(&#123;<br>              <span class="hljs-attr">model</span>: model, <span class="hljs-attr">onChangeSelect</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, select: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> &#123;<br>                hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, <span class="hljs-string">`onChangeSelect <span class="hljs-subst">$&#123;id&#125;</span> <span class="hljs-subst">$&#123;select&#125;</span>`</span>)<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">data: CouponData</span>) =&gt;</span> &#123;<br>                  <span class="hljs-keyword">if</span> (data.<span class="hljs-property">id</span> == id) &#123;<br>                    data.<span class="hljs-property">defaultSelect</span> = select<br>                  &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (select) &#123;<br>                      data.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                  &#125;<br>                &#125;)<br>              &#125;<br>            &#125;)<br>          &#125;<br><br>        &#125;, <span class="hljs-function">(<span class="hljs-params">item: CouponData, index: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> key = item.<span class="hljs-property">id</span> + <span class="hljs-string">&quot;__&quot;</span> + item.<span class="hljs-property">defaultSelect</span><br>          hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, key)<br>          <span class="hljs-keyword">return</span> key<br>        &#125;)<br>      &#125;.<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)<br><br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;确定&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">selectCouponID</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;未选中&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">couponDataList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">couponData: CouponData</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (couponData.<span class="hljs-property">defaultSelect</span>) &#123;<br>            selectCouponID = couponData.<span class="hljs-property">id</span><br>          &#125;<br>        &#125;)<br>        promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">`选中的优惠券是 <span class="hljs-subst">$&#123;selectCouponID&#125;</span>`</span> &#125;)<br>      &#125;)<br><br>    &#125;<br>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>  &#125;<br>&#125;<br><br><br><span class="hljs-meta">@ComponentV2</span>   <span class="hljs-comment">//修改为V2</span><br>struct <span class="hljs-title class_">CouponView</span> &#123;<br>  <span class="hljs-meta">@Require</span> <span class="hljs-meta">@Param</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">CouponData</span>   <span class="hljs-comment">//修改为V2</span><br>  <span class="hljs-meta">@Event</span> <span class="hljs-comment">//修改为V2</span><br>  <span class="hljs-attr">onChangeSelect</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, select: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> <span class="hljs-built_in">void</span> = <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, select: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> &#123;<br>  &#125;<br>  <span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-built_in">void</span> &#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, <span class="hljs-string">`aboutToAppear <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model.id&#125;</span>`</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model.name&#125;</span> , select :<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.model.defaultSelect&#125;</span>`</span>)<br>      <span class="hljs-title class_">Circle</span>()<br>        .<span class="hljs-title function_">width</span>(<span class="hljs-number">20</span>)<br>        .<span class="hljs-title function_">height</span>(<span class="hljs-number">20</span>)<br>        .<span class="hljs-title function_">fill</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">defaultSelect</span> ? <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span> : <span class="hljs-title class_">Color</span>.<span class="hljs-property">Gray</span>)<br>        .<span class="hljs-title function_">stroke</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">defaultSelect</span> ? <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span> : <span class="hljs-title class_">Color</span>.<span class="hljs-property">Grey</span>)<br><br>    &#125;.<span class="hljs-title function_">padding</span>(&#123; <span class="hljs-attr">top</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">bottom</span>: <span class="hljs-number">10</span> &#125;).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onChangeSelect</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">id</span>, !<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">defaultSelect</span>)<br><br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@ObservedV2</span> <span class="hljs-comment">//修改为V2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CouponData</span> &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">//修改为V2</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">defaultSelect</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//修改为V2</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>当我们切换选中状态，然后点击刷新后，再次切换选中状态也是正常的。通过<code>CouponView</code>中<code>aboutToAppear</code>方法的日志，也可以看到只重绘了key发生改变的列表项。</p>
<p>所以，那么，因此，迁移到V2不？</p>
<p>你问我迁移了吗？正在迁移，或许等到V3出来，我就迁移完了。</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-状态管理V2</title>
    <url>/2025/02/08/%E9%B8%BF%E8%92%99-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86V2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们讲了状态管理V1相关装饰器和注意事项，一般来讲是足够在开发中使用了，但还是有一些不方便的地方，因此又有了状态管理 V2。<br>截止到现在，V2的指南中已经移除了 gap提示，说明已经稳定可用。官方也希望我们尽快做迁移，当然，将来会不会出 V3 那就不得而知了。</p>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>V2 版本的状态管理装饰器有以下几种，都是从api12开始支持。不过问题不大，目前应用市场上架鸿蒙应用最低版本要求就是api12</p>
<ul>
<li>@ComponentV2装饰器：自定义组件</li>
<li>@ObservedV2装饰器和@Trace装饰器</li>
<li>@Local装饰器：组件内部状态</li>
<li>@Param：组件外部输入</li>
<li>@Once：初始化同步一次</li>
<li>@Event装饰器：规范组件输出</li>
<li>@Provider装饰器和@Consumer装饰器：跨组件层级双向同步</li>
<li>@Monitor装饰器：状态变量修改监听</li>
<li>@Computed装饰器：计算属性</li>
</ul>
<h3 id="ComponentV2"><a href="#ComponentV2" class="headerlink" title="@ComponentV2"></a>@ComponentV2</h3><p>和V1中的@Component装饰器一样，@ComponentV2装饰器用于装饰自定义组件：只有在该装饰器修饰的类中才能使用，也仅能使用其他V2版本的状态管理装饰器，无法在同一个自定义组件中混用V1、V2装饰器</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@ComponentV2</span> <span class="hljs-comment">// 装饰器</span><br>struct <span class="hljs-title class_">Index</span> &#123; <span class="hljs-comment">// struct声明的数据结构</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">// build定义的UI</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ObservedV2和-Trace"><a href="#ObservedV2和-Trace" class="headerlink" title="@ObservedV2和@Trace"></a>@ObservedV2和@Trace</h3><p>先来看下这两个，后续介绍其他装饰器时有用到。<br>这两个装饰器被用来做深度观测，也就是嵌套类的变化。在 V1 版本中，我们使用<code>@Observed</code>和<code>@ObjectLink</code>来实现，但有一个问题就是无法进行嵌套观测，只能观测当前层级的属性变化。V2 版本的这两个装饰器配合使用，可以实现跨嵌套层级观测。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@ObservedV2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">address</span>:<span class="hljs-title class_">Address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>()<br>&#125;<br><br><span class="hljs-meta">@ObservedV2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>&#123;<br>  <span class="hljs-meta">@Trace</span> zipCode : <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;000000&#x27;</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">city</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;北京&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>定义一个嵌套类，使用<code>@ObservedV2</code>装饰需要观测的类，并且在类中使用<code>@Trace</code>修饰每一个需要参与UI绘制的属性。当需要观测的类和属性较多时，写起来就比较恶心了。<br>还有一个非常恶心也非常麻烦的点：@ObservedV2的类实例目前不支持使用JSON.stringify进行序列化。</p>
<h3 id="Local"><a href="#Local" class="headerlink" title="@Local"></a>@Local</h3><p>该装饰器修饰的变量<strong>只能</strong>在本地初始化，不能由外部传入，目的是能更好的表示组件内部的状态，不会被外部传入参数影响。<br>和<code>@State</code>相比，它无法观察到class对象属性的赋值，仅能观察到对象的整体赋值，也就是说它的观测能力仅限于被装饰变量的本身。<br>当需要观察class对象属性的变化时，需要使用<code>@ObservedV2</code>和<code>@Trace</code>装饰器。<br>有一点需要注意的地方：在状态管理V2中，会给使用状态变量装饰器如@Trace、@Local装饰的Date、Map、Set、Array添加一层代理用于观测API调用产生的变化，因此我们在取其中的值进行比较时，需要使用<code>UIUtils.getTarget()</code>获取原始对象进行比较。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-attr">list</span>: <span class="hljs-built_in">string</span>[][] = [[<span class="hljs-string">&#x27;a&#x27;</span>], [<span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-string">&#x27;c&#x27;</span>]];<br><span class="hljs-meta">@Local</span> <span class="hljs-attr">strList</span>: <span class="hljs-built_in">string</span>[] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>];<br><span class="hljs-meta">@Monitor</span>(<span class="hljs-string">&quot;strList&quot;</span>)<br><span class="hljs-title function_">onStrChange</span>(<span class="hljs-params">monitor: IMonitor</span>) &#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;@Local&#x27;</span>, <span class="hljs-string">&#x27;strList has changed&#x27;</span>)<br>&#125;<br><br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>          <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改为同一个对象&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">strList</span> !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]) &#123;<br>          hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;@Local&#x27;</span>, <span class="hljs-string">&#x27;重新赋值&#x27;</span>)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">strList</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>      &#125;)<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改为同一个对象&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">UIUtils</span>.<span class="hljs-title function_">getTarget</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">strList</span>) !== <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>]) &#123;<br>          hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;@Local&#x27;</span>, <span class="hljs-string">&#x27;重新赋值&#x27;</span>)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">strList</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>      &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里我们定义了一个二维数组，同时将数组第一项赋值给被<code>@Local</code>修饰的变量，同时使用<code>@Monitor</code>观察该变量的变化。<br>当我们点击第一个按钮时，发现控制台会打印<code>重新赋值</code>和<code>strList has changed</code>。当我们点击第二个按钮时，控制台没有打印。</p>
<h3 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h3><p>可以从父组件传入，也可以在本地初始化，如果配合<code>@Require</code>使用，则父组件必须传入该参数，此时本地初始化的值将被覆盖。<br>有一点需要注意：不能在组件内部直接修改变量本身，但可以修改类对象的属性;如何类对象属性<strong>没有</strong>被<code>@Trace</code>修饰，修改类对象属性也不会引起 UI 刷新<br>当我们在组件内部直接修改变量本身时，则会提示<code>Cannot assign to &#39;count&#39; because it is a read-only property.</code></p>
<p><img src="/image/HarmonyOS/%E4%BF%AE%E6%94%B9@Param%E5%8F%98%E9%87%8F%E6%8A%A5%E9%94%99%E6%8F%90%E7%A4%BA.png" alt="修改@Param变量报错提示"></p>
<h3 id="Once"><a href="#Once" class="headerlink" title="@Once"></a>@Once</h3><p>如果想要直接在组件内修改被<code>@Param</code>修饰的变量本身，可以配合<code>@Once</code>，但是，但是，但是，被<code>@Once</code>装饰的变量仅能在外部初始化一次，当在外部修改该变量本身时，不会同步到子组件。看下示例:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@ObservedV2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">address</span>:<span class="hljs-title class_">Address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>()<br>&#125;<br><br><span class="hljs-meta">@ObservedV2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>&#123;<br>  <span class="hljs-meta">@Trace</span> zipCode : <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;000000&#x27;</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">city</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;北京&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>两个数据类都被<code>@ObservedV2</code>修饰，属性都被<code>@Trace</code>修饰，方便我们观察数据变化。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-meta">@ComponentV2</span><br>struct <span class="hljs-title class_">PersonView</span> &#123;<br>  <span class="hljs-meta">@Require</span> <span class="hljs-meta">@Param</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br>  <span class="hljs-meta">@Param</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;子组件内容，未被@Once 修饰&#x27;</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.name&#125;</span>  <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.age&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.count&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">name</span> += <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">age</span>++<br>      &#125;)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.address.zipCode&#125;</span>  <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.address.city&#125;</span>`</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@ComponentV2</span><br>struct <span class="hljs-title class_">PersonView2</span> &#123;<br>  <span class="hljs-meta">@Require</span> <span class="hljs-meta">@Param</span> <span class="hljs-meta">@Once</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br>  <span class="hljs-meta">@Once</span> <span class="hljs-meta">@Param</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;子组件内容，被@Once 修饰&#x27;</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.name&#125;</span>  <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.age&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.count&#125;</span>`</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">name</span> += <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">age</span>++<br>      &#125;)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.address.zipCode&#125;</span>  <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.address.city&#125;</span>`</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>两个自定义组件，其中 <code>PersonView2</code>内部的变量都是用<code>@Once</code>修饰。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Local</span> <span class="hljs-attr">person</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;父组件内容&#x27;</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.name&#125;</span>  <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.age&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.count&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.address.zipCode&#125;</span>  <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.address.city&#125;</span>`</span>)<br><br>      <span class="hljs-title class_">PersonView</span>(&#123; <span class="hljs-attr">person</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>, <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &#125;).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&quot;#66ace4&quot;</span>)<br>      <span class="hljs-title class_">PersonView2</span>(&#123; <span class="hljs-attr">person</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>, <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> &#125;).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&quot;#66ace4&quot;</span>)<br>      <span class="hljs-title class_">Flex</span>(&#123; <span class="hljs-attr">wrap</span>: <span class="hljs-title class_">FlexWrap</span>.<span class="hljs-property">Wrap</span>, <span class="hljs-attr">space</span>: &#123; <span class="hljs-attr">main</span>: <span class="hljs-title class_">LengthMetrics</span>.<span class="hljs-title function_">vp</span>(<span class="hljs-number">5</span>), <span class="hljs-attr">cross</span>: <span class="hljs-title class_">LengthMetrics</span>.<span class="hljs-title function_">vp</span>(<span class="hljs-number">5</span>) &#125; &#125;) &#123;<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改Person属性&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">age</span> += <span class="hljs-number">3</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">name</span> += <span class="hljs-string">&#x27;c&#x27;</span><br>        &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改Count&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> += <span class="hljs-number">7</span><br>        &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改 address属性&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">address</span>.<span class="hljs-property">zipCode</span> += <span class="hljs-string">&#x27;9&#x27;</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">address</span>.<span class="hljs-property">city</span> += <span class="hljs-string">&#x27;w&#x27;</span><br>        &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;对Person重新赋值&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;new person&#x27;</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">age</span> = <span class="hljs-number">22</span><br>        &#125;)<br>      &#125;<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&quot;#55ff6134&quot;</span>)<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>我们在父组件和两个子组件中传入了同一个<code>person</code>对象和<code>count</code>，然后用四个按钮来修改<code>person</code>对象的属性、修改<code>person</code>本身来做一个直观的展示</p>
<p><img src="/image/HarmonyOS/@Once%E6%95%88%E6%9E%9C.gif" alt="@Once装饰器作用"><br>可以从图中看到，当我们点击<code>修改Person属性</code>按钮时，父组件、两个子组件都可以刷新 UI，而点击<code>修改Count</code>和<code>对Person重新赋值</code>时，只有父组件和<code>PersonView</code>刷新了UI,可以看到<code>@Once</code>是拦截了数据源的变化，不影响<code>@Param</code>的观察能力。并且拦截的是数据源的赋值操作，修改其属性并不会被拦截。</p>
<p>还有一点就是，当我们点击<code>对Person重新赋值</code>后，再点击<code>修改Person属性</code>，发现只有父组件和<code>PersonView</code>刷新了UI，因为这时在父组件和<code>PersonView</code>中已经是新的对象了，而<code>PersonView2</code>中还是之前的对象，同步被打断，无法进行更新。</p>
<h3 id="Event"><a href="#Event" class="headerlink" title="@Event"></a>@Event</h3><p>上面说了这么多，但就是想做到像 V1中的数据双向同步怎么办？毕竟这是一个挺常见的需求。<br>假如不提供对应装饰器的话，我们可以很容易想到让父组件传入一个回调方法，当需要改变数据时，调用传入的回调方法，让父组件来更新数据。<br>在 V2 中也是这么做的：使用<code>@Event</code>装饰器装饰回调方法并调用，可以实现更改数据源的变量，再通过<code>@Local</code>的同步机制，将修改同步回<code>@Param</code>，以此达到主动更新<code>@Param</code>装饰变量的效果。<br>文档上解释说是为了<code>规范组件输出</code>:</p>
<blockquote>
<p>@Param标志着组件的输入，表明该变量受父组件影响，而@Event标志着组件的输出，可以通过该方法影响父组件。使用@Event装饰回调方法是一种规范，表明该回调作为自定义组件的输出。父组件需要判断是否提供对应方法用于子组件更改@Param变量的数据源。</p>
</blockquote>
<p>直接看示例</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@ComponentV2</span><br>struct <span class="hljs-title class_">ShowEventAnno</span> &#123;<br>  <span class="hljs-meta">@Event</span> <span class="hljs-attr">changeFontColor</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br>  <span class="hljs-meta">@Event</span> <span class="hljs-attr">changeFontSize</span>: <span class="hljs-function">(<span class="hljs-params">size: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>  <span class="hljs-meta">@Require</span> <span class="hljs-meta">@Param</span> <span class="hljs-attr">fontColor</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-meta">@Require</span> <span class="hljs-meta">@Param</span> <span class="hljs-attr">fontSize</span>: <span class="hljs-built_in">number</span><br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>()&#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;ShowEventAnno View&#x27;</span>).<span class="hljs-title function_">fontColor</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fontColor</span>).<span class="hljs-title function_">fontSize</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fontSize</span>)<br>      <span class="hljs-title class_">Row</span>()&#123;<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改文字大小&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>          <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">changeFontSize</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">changeFontSize</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fontSize</span> +<span class="hljs-number">2</span>)<br>          &#125;<br>        &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改文字颜色&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>          <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">changeFontColor</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">changeFontColor</span>()<br>          &#125;<br>        &#125;)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用@Event装饰箭头函数，这个函数的参数、返回值类型没有要求。当我们需要修改<code>@Param</code>修饰的变量时，比如在点击事件中，可以调用传入的@Event 修饰的函数，通知父控件对数据进行修改。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Local</span> <span class="hljs-attr">fontColor</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;#ff6134&#x27;</span><br><span class="hljs-meta">@Local</span> <span class="hljs-attr">fontSize</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">14</span><br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">ShowEventAnno</span>(&#123;<br>      <span class="hljs-attr">fontColor</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">fontColor</span>,<br>      <span class="hljs-attr">fontSize</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">fontSize</span>,<br>      <span class="hljs-attr">changeFontColor</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">fontColor</span> == <span class="hljs-string">&#x27;#ff6134&#x27;</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">fontColor</span> = <span class="hljs-string">&#x27;#39d167&#x27;</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">fontColor</span> = <span class="hljs-string">&#x27;#ff6134&#x27;</span><br>        &#125;<br>      &#125;,<br>      <span class="hljs-attr">changeFontSize</span>: <span class="hljs-function">(<span class="hljs-params">size: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fontSize</span> = size<br>      &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>值得注意的是，使用@Event修改父组件的值是立刻生效的，但从父组件将变化同步回子组件的过程是异步的，即在调用完@Event的方法后，子组件内的值不会立刻变化。这是因为@Event将子组件值实际的变化能力交由父组件处理，在父组件实际决定如何处理后，将最终值在渲染之前同步回子组件。</p>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="@Monitor"></a>@Monitor</h3><p>可以用来监听状态变量的改变，在V1版本的<code>@Watch</code>中，无法实现对对象、数组中某一单个属性或数组项变化的监听，且无法获取变化之前的值。并且<code>@Monitor</code>既可以用在自定义组件中，也可以用在数据类中，可以同时监听多个对象属性，也可以精确的监听对象的某个属性。<br>需要注意的是：</p>
<ul>
<li>监听的变量需要被@Local、@Param、@Provider、@Consumer、@Computed装饰，未被状态变量装饰器装饰的变量在变化时无法被监听。@Monitor可以同时监听多个状态变量，这些变量名之间用”,”隔开。</li>
<li>监听的状态变量为类对象时，仅能监听对象整体的变化。监听类属性的变化需要类属性被@Trace装饰，未被@Trace装饰的属性的变化无法被监听。</li>
<li>支持对数组中的项进行监听，包括多维数组，对象数组。@Monitor无法监听内置类型（Array、Map、Date、Set）的API调用引起的变化。当@Monitor监听数组整体时，只能观测到数组整体的赋值。可以通过监听数组的长度变化来判断数组是否有插入、删除等变化。当前仅支持使用”.”的方式表达深层属性、数组项的监听。</li>
</ul>
<p>一个简单的例子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Local</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;xuan&quot;</span>;<br><span class="hljs-meta">@Local</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">12</span>;<br><span class="hljs-meta">@Monitor</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>)<br><span class="hljs-title function_">onStrChange</span>(<span class="hljs-params">monitor: IMonitor</span>) &#123;<br>  monitor.<span class="hljs-property">dirty</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">paramsName: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;MonitorPage&#x27;</span>,<br>      <span class="hljs-string">`属性名：<span class="hljs-subst">$&#123;paramsName&#125;</span>  由 <span class="hljs-subst">$&#123;monitor.value(paramsName)?.before&#125;</span> 修改为 <span class="hljs-subst">$&#123;monitor.value(paramsName)?.now&#125;</span>`</span>)<br>  &#125;)<br>&#125;<br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Column</span>() &#123;<br>    <span class="hljs-title class_">Text</span>(<span class="hljs-string">`name:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>  message:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span>)<br>    <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;修改简单类型变量&quot;</span>)<br>      .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> += <span class="hljs-string">&quot;a&quot;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> += <span class="hljs-number">3</span><br>      &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当我们点击<code>修改简单类型变量</code>按钮时，会触发<code>@Monitor</code>装饰的方法，但需要注意的是，该方法的参数是<code>IMonitor</code>类型，它有两个属性： <code>dirty: Array&lt;string&gt;</code>和<code>value&lt;T&gt;(path?: string): IMonitorValue&lt;T&gt; | undefined</code>，其中<code>dirty</code>保存发生变化的属性名。而<code>value</code>是一个方法，用于获取指定属性的变化信息，当该方法有返回值时，返回值是<code>IMonitorValue</code>类型，包含<code>before</code>、<code>now</code>和<code>path</code>属性。</p>
<p>我们还可以精确的监听类对象的某个属性，这个监听可以写在类中，也可以写在控件中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-meta">@ObservedV2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Tom&quot;</span>;<br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">region</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;North&quot;</span>;<br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">job</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Teacher&quot;</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">25</span>;<br><br>  <span class="hljs-comment">// name被@Trace装饰，能够监听变化</span><br>  <span class="hljs-meta">@Monitor</span>(<span class="hljs-string">&quot;name&quot;</span>)<br>  <span class="hljs-title function_">onNameChange</span>(<span class="hljs-params">monitor: IMonitor</span>) &#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;MonitorTest&#x27;</span>, <span class="hljs-string">`name change from <span class="hljs-subst">$&#123;monitor.value()?.before&#125;</span> to <span class="hljs-subst">$&#123;monitor.value()?.now&#125;</span>`</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// age未被@Trace装饰，不能监听变化</span><br>  <span class="hljs-meta">@Monitor</span>(<span class="hljs-string">&quot;age&quot;</span>)<br>  <span class="hljs-title function_">onAgeChange</span>(<span class="hljs-params">monitor: IMonitor</span>) &#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;MonitorTest&#x27;</span>, <span class="hljs-string">`age change from <span class="hljs-subst">$&#123;monitor.value()?.before&#125;</span> to <span class="hljs-subst">$&#123;monitor.value()?.now&#125;</span>`</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// region与job均被@Trace装饰，能够监听变化</span><br>  <span class="hljs-meta">@Monitor</span>(<span class="hljs-string">&quot;region&quot;</span>, <span class="hljs-string">&quot;job&quot;</span>)<br>  <span class="hljs-title function_">onChange</span>(<span class="hljs-params">monitor: IMonitor</span>) &#123;<br>    monitor.<span class="hljs-property">dirty</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">path: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>      hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;MonitorTest&#x27;</span>,<br>        <span class="hljs-string">`<span class="hljs-subst">$&#123;path&#125;</span> change from <span class="hljs-subst">$&#123;monitor.value(path)?.before&#125;</span> to <span class="hljs-subst">$&#123;monitor.value(path)?.now&#125;</span>`</span>);<br>    &#125;)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>在控件中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript">  <span class="hljs-meta">@Local</span> <span class="hljs-attr">monitorTest</span>: <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br>  <span class="hljs-meta">@Monitor</span>(<span class="hljs-string">&quot;monitorTest.name&quot;</span>)<br>  <span class="hljs-title function_">onChangeName</span>(<span class="hljs-params">monitor: IMonitor</span>) &#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;MonitorPage&#x27;</span>, <span class="hljs-string">&#x27;在自定义控件中监听对象属性变化：&#x27;</span> +<br>      <span class="hljs-string">`<span class="hljs-subst">$&#123;monitor.value()?.path&#125;</span> 由 <span class="hljs-subst">$&#123;monitor.value()?.before&#125;</span> 修改为 <span class="hljs-subst">$&#123;monitor.value()?.now&#125;</span>`</span>)<br>  &#125;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Column</span>() &#123;<br>        <span class="hljs-title class_">Text</span>(<span class="hljs-string">`name: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.monitorTest.name&#125;</span> ,age:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.monitorTest.age&#125;</span> ,region: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.monitorTest.region&#125;</span>, job:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.monitorTest.job&#125;</span>`</span>)<br>          .<span class="hljs-title function_">padding</span>(<span class="hljs-number">4</span>)<br>          .<span class="hljs-title function_">borderWidth</span>(<span class="hljs-number">1</span>)<br>          .<span class="hljs-title function_">borderColor</span>(<span class="hljs-string">&quot;#887612&quot;</span>)<br><br><br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;change name&quot;</span>)<br>          .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">monitorTest</span>.<span class="hljs-property">name</span> += <span class="hljs-string">&#x27;b&#x27;</span>; <span class="hljs-comment">// 能够触发onNameChange方法</span><br>          &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;change age&quot;</span>)<br>          .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">monitorTest</span>.<span class="hljs-property">age</span> += <span class="hljs-number">1</span>; <span class="hljs-comment">// 不能够触发onAgeChange方法</span><br>          &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;change region&quot;</span>)<br>          .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">monitorTest</span>.<span class="hljs-property">region</span> +=<span class="hljs-string">&#x27;region &#x27;</span>; <span class="hljs-comment">// 能够触发onChange方法</span><br>          &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;change job&quot;</span>)<br>          .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">monitorTest</span>.<span class="hljs-property">job</span> +=<span class="hljs-string">&#x27;job &#x27;</span>; <span class="hljs-comment">// 能够触发onChange方法</span><br>          &#125;)<br>      &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure>
<p>这个也有一点需要注意，当我们对类对象重新赋值，但是赋值前后类对象的属性值不变，也不会触发<code>@Monitor</code>回调。<br>还有一点需要注意的是监听的生效和失效时间：<br>当在组件中使用时，<code>@Monitor</code>会在状态变量初始化完成之后生效，并在组件销毁时失效。<br>当在类中使用时，<code>@Monitor</code>会在类创建完成后生效，在类销毁时失效。这个时机晚于类的constructor，早于自定义组件的aboutToAppear。然而由于类的实际销毁释放依赖于垃圾回收机制，因此会出现即使所在自定义组件已经销毁，类却还未及时销毁，导致类中定义的@Monitor仍在监听变化的情况。</p>
<h3 id="Computed"><a href="#Computed" class="headerlink" title="@Computed"></a>@Computed</h3><p>千呼万唤始出来的装饰器，谁家的状态管理还没有计算属性哇<br>该装饰器为方法装饰器，装饰getter方法。<code>@Computed</code>会检测被计算的属性变化，当被计算的属性变化时，<code>@Computed</code>只会被求解一次。<br>该装饰器既可以在组件中使用，也可以在数据类中使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@ObservedV2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span> =<span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br><br>  <span class="hljs-meta">@Computed</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">info</span>()&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&#x27;ComputedPge&#x27;</span>,<span class="hljs-string">&quot;在数据类中获取所有信息&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`name:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> , age:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span>`</span><br>  &#125;<br>&#125;<br>  <span class="hljs-meta">@Local</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;xuan&#x27;</span>;<br>  <span class="hljs-meta">@Local</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">18</span>;<br>  <span class="hljs-meta">@Local</span> <span class="hljs-attr">address</span>:<span class="hljs-built_in">string</span>=<span class="hljs-string">&#x27;北京&#x27;</span><br><br>  <span class="hljs-meta">@Local</span> <span class="hljs-attr">person</span>:<span class="hljs-title class_">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br>  <span class="hljs-meta">@Computed</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">info</span>() &#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&#x27;ComputedPge&#x27;</span>,<span class="hljs-string">&quot;获取所有信息&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`name:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> ,age:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> , address:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.address&#125;</span>`</span><br>  &#125;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.info&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.info&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.info&#125;</span>`</span>)<br><br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改简单属性&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>++;<br>      &#125;)<br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.info&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.info&#125;</span>`</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.person.info&#125;</span>`</span>)<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改对象属性&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">person</span>.<span class="hljs-property">name</span> +=<span class="hljs-string">&#x27;p&#x27;</span><br>      &#125;)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>可以在控制台看到，虽然我们展示多次，但控制台只打印了一次信息；当我们分别点击<code>修改简单属性</code>和<code>修改对象属性</code>时，控制台也是打印一次信息。<br>这里还有个注意点：@Computed装饰的属性可以初始化@Param</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-状态管理V2其他方法</title>
    <url>/2025/02/17/%E9%B8%BF%E8%92%99-%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86V2%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>除了之前介绍的状态管理装饰器，在 V2 中还有其他新增的方法。</p>
<h2 id="makeObserved"><a href="#makeObserved" class="headerlink" title="makeObserved"></a>makeObserved</h2><p>开发过程中我们经常会用到从服务器获取到数据(一般是 json 字符串)，转化为对象，然后设置到 UI 中做展示。但有一点比较麻烦：比如我们使用 rcp做网络请求，对返回对象调用<code>toJson() as xxx</code>转为对象，但这样获取到的对象是没办法被观察的，因为这样创建出来的对象不会被添加代理，这时候我们就可以使用<code>UIUtils.makeObserved(xxx)</code>来让改对象变为可观测的。  </p>
<p>比如：<br>定义两个数据类</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@ObservedV2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">staticProp</span>:<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">address</span>: <span class="hljs-title class_">Address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>()<br>&#125;<br><br><span class="hljs-meta">@ObservedV2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">zipCode</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;000000&#x27;</span><br>  <span class="hljs-meta">@Trace</span> <span class="hljs-attr">city</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;北京&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后我们从 json 字符串中反序列化出来对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-meta">@Local</span> <span class="hljs-attr">jsonPerson</span>: <span class="hljs-title class_">Person</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">personJSON</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`</span><br><span class="hljs-string">  &#123;</span><br><span class="hljs-string">  &quot;name&quot;: &quot;huangyuan&quot;,</span><br><span class="hljs-string">  &quot;age&quot;: 19,</span><br><span class="hljs-string">  &quot;address&quot;: &#123;</span><br><span class="hljs-string">      &quot;zipCode&quot;: &quot;111111&quot;,</span><br><span class="hljs-string">      &quot;city&quot;: &quot;shangdong&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  `</span><br>  <span class="hljs-keyword">let</span> tmp = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(personJSON) <span class="hljs-keyword">as</span> <span class="hljs-title class_">Person</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">jsonPerson</span> = <span class="hljs-title class_">UIUtils</span>.<span class="hljs-title function_">makeObserved</span>(tmp)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样<code>this.jsonPerson</code>就是可以被观测到的对象了。当我们修改该对象的属性，对应的 UI 也可以刷新了</p>
<h2 id="getTarget"><a href="#getTarget" class="headerlink" title="getTarget"></a>getTarget</h2><ul>
<li>在状态管理中V1中，会给@Observed装饰的类对象以及使用状态变量装饰器如@State装饰的Class、Date、Map、Set、Array添加一层代理用于观测一层属性或API调用产生的变化。</li>
<li>在状态管理V2中，会给使用状态变量装饰器如@Trace、@Local装饰的Date、Map、Set、Array添加一层代理用于观测API调用产生的变化。</li>
</ul>
<p>我们可以使用<code>UIUtils.getTarget(xxx)</code>来获取到代理对象的原始对象。 但是当我们更改getTarget获取的原始对象中的内容不会被观察到变化，也<strong>不会</strong>触发UI刷新</p>
<h2 id="ObservedV2的类实例不支持JSON-stringify序列化"><a href="#ObservedV2的类实例不支持JSON-stringify序列化" class="headerlink" title="@ObservedV2的类实例不支持JSON.stringify序列化"></a>@ObservedV2的类实例不支持JSON.stringify序列化</h2><p>这个主要是针对使用new操作符创建且被<code>@ObservedV2</code>装饰的对象。即便是使用<code>UIUtils.getTarget</code>方法来获取原始对象，也不会对V2装饰器生成的前缀进行处理:<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-new-makeobserved-V5"></a></p>
<blockquote>
<p>状态管理V2装饰器会为装饰的变量生成getter和setter方法，同时为原有变量名添加”_<em>ob</em>“的前缀。出于性能考虑，getTarget接口不会对V2装饰器生成的前缀进行处理，因此向getTarget接口传入@ObservedV2装饰的类对象实例时，返回的对象依旧为对象本身，且被@Trace装饰的属性名仍有”_<em>ob</em>“前缀。</p>
</blockquote>
<p>来看个例子：</p>
<p>还是上面定义的两个数据类，被<code>@ObservedV2</code>修饰。<br>再来创建两个实例对象，一个还是和上面一样从json字符串中反序列化，另外一个使用<code>new</code>操作符创建。</p>
<p>然后我们输出一下使用<code>JSON.stringify</code>序列化之后的字符串</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;makeObserved 转为json&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&#x27;StateManagerV2Page&#x27;</span>,<span class="hljs-string">`toJSON: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-variable language_">this</span>.jsonPerson)&#125;</span>`</span>)<br>&#125;)<br><span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;new对象 转为json&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&#x27;StateManagerV2Page&#x27;</span>,<span class="hljs-string">`toJSON: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-variable language_">this</span>.person)&#125;</span>`</span>)<br>&#125;)<br><span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;new对象 getTarget 转为json&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&#x27;StateManagerV2Page&#x27;</span>,<span class="hljs-string">`toJSON: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(UIUtils.getTarget(<span class="hljs-variable language_">this</span>.person))&#125;</span>`</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>当我们一次点击这三个按钮后，控制台输出</p>
<blockquote>
<p>toJSON: {“name”:”huangyuan”,”age”:19,”address”:{“zipCode”:”111111”,”city”:”shangdong”}}<br>toJSON: {“__ob_name”:”xuan”,”__ob_age”:18,”__ob_address”:{“__ob_zipCode”:”000000”,”__ob_city”:”北京”}}<br>toJSON: {“__ob_name”:”xuan”,”__ob_age”:18,”__ob_address”:{“__ob_zipCode”:”000000”,”__ob_city”:”北京”}}</p>
</blockquote>
<p>可以看到，使用<code>new</code>操作符创建的ObservedV2对象属性都添加了<code>__ob_</code>前缀,而通过json 字符串反序列化之后再使用<code>UIUtils.makeObserved</code>方法添加代理之后的对象并没有添加<code>__ob_</code>前缀。</p>
<h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>在状态管理 V2 中，更倾向于单向数据流，所有可同步数据的修改都有父控件来处理，然后同步到子组件。 子组件想要修改数据时，需要调用用<code>@Event</code>修饰的回调方法。写起来略显繁琐，这里因此提供了<code>!!</code>双向绑定语法糖。<br>在使用时，子组件中<code>@Event</code>方法名需要声明为<code>“$”+ @Param</code>属性名，这里还有一些需要注意的地方</p>
<blockquote>
<p>如果父组件使用了!!双向绑定语法，则表明父组件的变化会同步给子组件，子组件的变化也会同步给父组件。<br>如果父组件没有使用!!，则父组件发生的变化是单向的。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Local</span> <span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">4</span><br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Star</span>(&#123;<span class="hljs-attr">count</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>!!&#125;) <span class="hljs-comment">//注意这里，在参数的末尾加了双叹号</span><br>&#125;<br><br><span class="hljs-meta">@ComponentV2</span><br>struct <span class="hljs-title class_">Star</span>&#123;<br><br>  <span class="hljs-meta">@Param</span> <span class="hljs-meta">@Require</span> <span class="hljs-attr">count</span>:<span class="hljs-built_in">number</span><br>  <span class="hljs-meta">@Event</span> <span class="hljs-attr">$count</span>:<span class="hljs-function">(<span class="hljs-params">val:<span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>()&#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">`value <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.count&#125;</span>`</span>)<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;改变value&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.$count(<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> +<span class="hljs-number">1</span>)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当我们点击<code>Star</code>中的<code>改变value</code>按钮时，组件中<code>count</code>值也会跟着改变。这个双向绑定的语法糖可以粗暴的理解为</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Star</span>(&#123; <span class="hljs-attr">value</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, <span class="hljs-attr">$value</span>: <span class="hljs-function">(<span class="hljs-params">val: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = val &#125;&#125;)<br></code></pre></td></tr></table></figure>
<p>如果是较为复杂的属性变化，还是使用原始的方案，不要使用语法糖了。  </p>
<hr>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-自定义布局-实现一个可限制行数的 Flex</title>
    <url>/2024/09/18/%E9%B8%BF%E8%92%99-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%99%90%E5%88%B6%E8%A1%8C%E6%95%B0%E7%9A%84-Flex/</url>
    <content><![CDATA[<p>千呼万唤始出来的自定义布局功能终于可以用了，这就给了我们更多自由发挥创造的空间，不再局限于使用已有组件做组合。当然，用 NAPI 和 C|C++页可以实现自己绘制所有内容，更别提还有类似<code>XComponent</code>这种东西了。但假如我们只是需要简单的自己控制子组件所在的位置，不需要接管绘制等逻辑，比如实现一个扇形菜单、实现一个可以控制行数的标签列表等，怎么搞嘞？现在鸿蒙提供了<code>onPlaceChildren</code>和<code>onMeasureSize</code>这两个回调方法，使得我们可以按照自己的意愿来摆放组件。</p>
<span id="more"></span>


<p>老样子，先放效果图</p>
<img src='/image/HarmonyOS/line_limit_flex.gif' width='30%' heigh='30%'/>



<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>我们先来了解一下这两个回调方法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">onMeasureSize</span>(<span class="hljs-params">selfLayoutInfo: GeometryInfo, children: <span class="hljs-built_in">Array</span>&lt;Measurable&gt;, constraint: ConstraintSizeOptions</span>) &#123;&#125;<br><span class="hljs-title function_">onPlaceChildren</span>(<span class="hljs-params">selfLayoutInfo: GeometryInfo, children: <span class="hljs-built_in">Array</span>&lt;Layoutable&gt;, constraint: ConstraintSizeOptions</span>) &#123;&#125;<br></code></pre></td></tr></table></figure>


<h3 id="onMeasureSize"><a href="#onMeasureSize" class="headerlink" title="onMeasureSize"></a>onMeasureSize</h3><blockquote>
<p>ArkUI框架会在自定义组件确定尺寸时，将该自定义组件的节点信息和尺寸范围通过onMeasureSize传递给该开发者。不允许在onMeasureSize函数中改变状态变量。</p>
</blockquote>
<p>在<code>build</code>方法调用之后，就会调用<code>onMeasureSize</code>方法。在该方法中，我们可以获取到组件本身和子组件的大小，通过计算确认组件本身大小后返回一个<code>SizeResult</code>对象，告知系统该组件最终大小。</p>
<h4 id="selfLayoutInfo"><a href="#selfLayoutInfo" class="headerlink" title="selfLayoutInfo"></a>selfLayoutInfo</h4><p>在该方法的的参数中，有一个<code>GeometryInfo</code>对象实例<code>selfLayoutInfo</code>.通过这个对象，我们可以拿到父组件的宽高、padding、margin、borderWidth等信息。<br>文档中对<code>selfLayoutInfo</code>的解释为<strong>父组件布局信息</strong>，这里的<code>父组件</code>是指的自定义组件本身，而不是包含该自定义组件的组件。举个简单的例子：<br>自定义组件名字为<code>CustomLayout</code>,有如下布局</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">LineLimitFlexPage</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">CustomLayout</span>().<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>).<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>.<span class="hljs-property">Yellow</span>, <span class="hljs-attr">radius</span>: <span class="hljs-number">2</span> &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">2</span>)<br>    &#125;.<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;90%&#x27;</span>).<span class="hljs-title function_">border</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-number">6</span>, <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>, <span class="hljs-attr">radius</span>: <span class="hljs-number">6</span> &#125;).<span class="hljs-title function_">padding</span>(<span class="hljs-number">6</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">6</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们在<code>CustomLayout</code>组建内重写<code>onMeasureSize</code>方法，将相关信息打印出来</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">onMeasureSize</span>(<span class="hljs-attr">selfLayoutInfo</span>: <span class="hljs-title class_">GeometryInfo</span>, <span class="hljs-attr">children</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Measurable</span>&gt;, <span class="hljs-attr">constraint</span>: <span class="hljs-title class_">ConstraintSizeOptions</span>):<span class="hljs-title class_">SizeResult</span> &#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&quot;LineLimitFlexPage&quot;</span>, <span class="hljs-string">`onMeasureSize selfLayoutInfo: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(selfLayoutInfo)&#125;</span>`</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>日志信息是这样的</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">onMeasureSize selfLayoutInfo: &#123;&quot;borderWidth&quot;:&#123;&quot;top&quot;:2,&quot;right&quot;:2,&quot;bottom&quot;:2,&quot;left&quot;:2&#125;,&quot;margin&quot;:&#123;&quot;top&quot;:2,&quot;right&quot;:2,&quot;bottom&quot;:2,&quot;left&quot;:2&#125;,&quot;padding&quot;:&#123;&quot;top&quot;:2,&quot;right&quot;:2,&quot;bottom&quot;:2,&quot;left&quot;:2&#125;,&quot;width&quot;:292.9846003605769,&quot;height&quot;:731.3846153846154&#125;<br><br></code></pre></td></tr></table></figure>
<p>可以看到，打印出来的信息是自定义组件本身的属性。</p>
<h4 id="constraint"><a href="#constraint" class="headerlink" title="constraint"></a>constraint</h4><p>另外，还有一个<code>constraint</code>的<code>ConstraintSizeOptions</code>对象，文档中对其解释是<strong>设置约束尺寸，组件布局时，进行尺寸范围限制。</strong>,同样也打印一下，</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">onMeasureSize constraint: &#123;&quot;minWidth&quot;:0,&quot;minHeight&quot;:0,&quot;maxWidth&quot;:285.59998497596155,&quot;maxHeight&quot;:724&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到有四个属性：最小宽度，最小高度，最大宽度，最大高度。这也是我们组件大小的下限和上限。</p>
<h4 id="children"><a href="#children" class="headerlink" title="children"></a>children</h4><p>一个关键的参数：<code>children: Array&lt;Measurable&gt;</code>,子组件的布局信息。这里并没有直接把子组件传递下来，而是抽象成了<code>Measurable</code>对象。该对象有四个方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">measure</span>(<span class="hljs-attr">constraint</span>: <span class="hljs-title class_">ConstraintSizeOptions</span>): <span class="hljs-title class_">MeasureResult</span>;<br><span class="hljs-title function_">getMargin</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br><span class="hljs-title function_">getPadding</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br><span class="hljs-title function_">getBorderWidth</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br></code></pre></td></tr></table></figure>
<p>见名知义，没有什么好说的，我们通过<code>measure</code>方法可以获取到子组件的大小，之后通过计算，综合子组件大小、selfLayoutInfo、constraint三者的信息来计算该组件需要的大小。并且返回<code>SizeResult</code>对象，来告知系统该组件的最终大小。</p>
<h3 id="onPlaceChildren"><a href="#onPlaceChildren" class="headerlink" title="onPlaceChildren"></a>onPlaceChildren</h3><p>在来看<code>onPlaceChildren</code>方法，在该方法中的<code>selfLayoutInfo</code>和<code>constraint</code>这两个参数，和<code>onMeasureSize</code>方法中的参数含义是相同的，这里不再赘述。<br>来看一下<code>children: Array&lt;Layoutable&gt;</code>参数。这里也是把子组件抽象成了<code>Layoutable</code>对象，它有一个<code>measureResult: MeasureResult;</code>属性和四个方法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">layout</span>(<span class="hljs-attr">position</span>: <span class="hljs-title class_">Position</span>): <span class="hljs-built_in">void</span>;<br><span class="hljs-title function_">getMargin</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br><span class="hljs-title function_">getPadding</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br><span class="hljs-title function_">getBorderWidth</span>(): <span class="hljs-title class_">DirectionalEdgesT</span>&lt;<span class="hljs-built_in">number</span>&gt;;<br></code></pre></td></tr></table></figure>
<p>同样的见名知义，没有什么好说的。我们不需要了解子组件的具体信息，只需要关心子组件大小和摆放的位置就好。这里我们通过<code>layout</code>方法来确认子组件摆放位置。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>前置的条件我们都已经了解了，那么如何实现一个简易版可指定展示行数的 Flex 也就有思路了。这里为了简单，我们只考虑横向从左向右排列的情况，没有考虑 <code>padding</code> 和 <code>margin</code>属性。其他的属性大家有兴趣可以自己实现</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在<code>onMeasureSize</code>方法中测量并获取每个子组件的大小，长度累加大于等于约束的最大宽度则换行，高度累加。直到超过指定行数或者遍历完子组件结束。返回组件大小。<br>在<code>onPlaceChildren</code>方法中遍历子组件，通过子组件的宽高确认摆放位置，长度累加大于等于约束的最大宽度则换行，高度累加，直到超过指定行数或者遍历完子组件结束。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>这里我们只考虑水平间隔和垂直间隔以及指定行数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CustomLayout</span> &#123;<br>  <span class="hljs-attr">hSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">vSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里还有一些需要特别注意的细节点：</p>
<ul>
<li>自定义布局暂不支持LazyForEach写法。</li>
<li>使用builder形式的自定义布局创建，自定义组件的build()方法内只允许存在this.builder()，即示例的推荐用法。</li>
<li>父容器（自定义组件）上设置的尺寸信息，除aspectRatio之外，优先级小于onMeasureSize设置的尺寸信息。</li>
<li>子组件设置的位置信息，offset、position、markAnchor优先级大于onPlaceChildren设置的位置信息，其他位置设置属性不生效。</li>
<li>使用自定义布局方法时，需要同时调用onMeasureSize和onPlaceChildren方法，否则可能出现布局异常。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>既然这样，我们先准备好大致框架</p>
<p>我们的自定义布局</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CustomLayout</span> &#123;<br>  <span class="hljs-attr">hSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">vSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">showAll</span>: <span class="hljs-built_in">boolean</span><br><br>  <span class="hljs-meta">@Builder</span><br>  <span class="hljs-title function_">doNothingBuilder</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br>  <span class="hljs-meta">@BuilderParam</span> <span class="hljs-attr">builder</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">doNothingBuilder</span>;<br><br>  <span class="hljs-title function_">onMeasureSize</span>(<span class="hljs-attr">selfLayoutInfo</span>: <span class="hljs-title class_">GeometryInfo</span>, <span class="hljs-attr">children</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Measurable</span>&gt;, <span class="hljs-attr">constraint</span>: <span class="hljs-title class_">ConstraintSizeOptions</span>): <span class="hljs-title class_">SizeResult</span>&#123;&#125;<br>  <span class="hljs-title function_">onPlaceChildren</span>(<span class="hljs-params">selfLayoutInfo: GeometryInfo, children: <span class="hljs-built_in">Array</span>&lt;Layoutable&gt;, constraint: ConstraintSizeOptions</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个全局的<code>@Builder</code>修饰的布局,也就是我们的子控件</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> <span class="hljs-attr">colors</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;#ff6134&quot;</span>, <span class="hljs-string">&quot;#1b91e0&quot;</span>, <span class="hljs-string">&quot;#39d167&quot;</span>]<br><br><span class="hljs-meta">@Builder</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ColumnChildren</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">ForEach</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>], <span class="hljs-function">(<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123; <span class="hljs-comment">//暂不支持lazyForEach的写法</span><br>    <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;标签&#x27;</span> + index)<br>      .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)<br>      .<span class="hljs-title function_">borderWidth</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">backgroundColor</span>(colors[index%<span class="hljs-number">3</span>])<br><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个页面</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">LineLimitFlexPage</span> &#123;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">CustomLayout</span>(&#123;<br>        <span class="hljs-attr">builder</span>: <span class="hljs-title class_">ColumnChildren</span>,<br>        <span class="hljs-attr">hSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">10</span>),<br>        <span class="hljs-attr">vSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">6</span>),<br>        <span class="hljs-attr">maxLine</span>: <span class="hljs-number">3</span><br>      &#125;)<br>    &#125;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样我们就准备好了框架内容，接下来就是处理测量组件大小及布局了</p>
<h3 id="测量组件"><a href="#测量组件" class="headerlink" title="测量组件"></a>测量组件</h3><p>我们按照上面的思路在<code>onMeasureSize</code>方法中对子组件进行测量，并确认组件大小。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-title function_">onMeasureSize</span>(<span class="hljs-attr">selfLayoutInfo</span>: <span class="hljs-title class_">GeometryInfo</span>, <span class="hljs-attr">children</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Measurable</span>&gt;, <span class="hljs-attr">constraint</span>: <span class="hljs-title class_">ConstraintSizeOptions</span>): <span class="hljs-title class_">SizeResult</span> &#123;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&quot;LineLimitFlexPage&quot;</span>, <span class="hljs-string">`onMeasureSize selfLayoutInfo: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(selfLayoutInfo)&#125;</span>`</span>)<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&quot;LineLimitFlexPage&quot;</span>, <span class="hljs-string">`onMeasureSize constraint: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(constraint)&#125;</span>`</span>)<br><br>  <span class="hljs-keyword">let</span> totalWidth = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> totalHeight = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> lineHeight = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> firstLineHeight = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> lineCount = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; i++) &#123;<br><br>    <span class="hljs-keyword">let</span> child = children[i]<br>    <span class="hljs-comment">//测量当前控件的宽高</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-title class_">MeasureResult</span> = child.<span class="hljs-title function_">measure</span>(&#123;<br>      <span class="hljs-attr">minHeight</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">minWidth</span>: <span class="hljs-number">0</span>,<br>      <span class="hljs-attr">maxWidth</span>: selfLayoutInfo.<span class="hljs-property">width</span>,<br>      <span class="hljs-attr">maxHeight</span>: selfLayoutInfo.<span class="hljs-property">height</span><br>    &#125;)<br>    <span class="hljs-comment">//累计当前行宽度</span><br>    totalWidth += result.<span class="hljs-property">width</span><br>    <span class="hljs-comment">//记录当前行的最大高度</span><br>    lineHeight = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(lineHeight, result.<span class="hljs-property">height</span>)<br><br><br>    <span class="hljs-keyword">if</span> (totalWidth &gt; selfLayoutInfo.<span class="hljs-property">width</span>) &#123;<br>      <span class="hljs-comment">//记录一下第一行高度</span><br>      <span class="hljs-keyword">if</span> (firstLineHeight == <span class="hljs-number">0</span>) &#123;<br>        firstLineHeight = lineHeight;<br>      &#125;<br>      <span class="hljs-comment">//如果加上当前控件超过了父控件宽度，则换行</span><br>      lineCount++<br>      <span class="hljs-keyword">if</span> (lineCount &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      totalHeight += lineHeight + <span class="hljs-variable language_">this</span>.<span class="hljs-property">vSpace</span><br>      totalWidth = result.<span class="hljs-property">width</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">vSpace</span><br>      lineHeight = <span class="hljs-number">0</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//如果加上当前控件没有超过父控件宽度，加上水平间距</span><br>      totalWidth += <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span><br>    &#125;<br><br><br>  &#125;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-title class_">SizeResult</span> = &#123;<br>    <span class="hljs-attr">width</span>: lineCount &gt; <span class="hljs-number">1</span> ? selfLayoutInfo.<span class="hljs-property">width</span> : totalWidth,<br>    <span class="hljs-attr">height</span>: totalHeight + firstLineHeight<br>  &#125;;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>在<code>onPlaceChildren</code>方法中确认每个组件的位置</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-title function_">onPlaceChildren</span>(<span class="hljs-params">selfLayoutInfo: GeometryInfo, children: <span class="hljs-built_in">Array</span>&lt;Layoutable&gt;, constraint: ConstraintSizeOptions</span>) &#123;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&quot;LineLimitFlexPage&quot;</span>, <span class="hljs-string">`onPlaceChildren: selfLayoutInfo: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(selfLayoutInfo)&#125;</span>`</span>)<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&quot;LineLimitFlexPage&quot;</span>, <span class="hljs-string">`onPlaceChildren: constraint: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(constraint)&#125;</span>`</span>)<br>  <span class="hljs-keyword">let</span> startX = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> startY = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> lineCount = <span class="hljs-number">1</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> child = children[i]<br>    <span class="hljs-keyword">let</span> childWidth = child.<span class="hljs-property">measureResult</span>.<span class="hljs-property">width</span>;<br>    <span class="hljs-keyword">let</span> childHeight = child.<span class="hljs-property">measureResult</span>.<span class="hljs-property">height</span><br><br><br>    <span class="hljs-keyword">if</span> (startX + childWidth &gt; selfLayoutInfo.<span class="hljs-property">width</span>) &#123;<br>      startX = <span class="hljs-number">0</span><br>      startY += childHeight + <span class="hljs-variable language_">this</span>.<span class="hljs-property">vSpace</span><br>      lineCount++<br>      <span class="hljs-keyword">if</span> (lineCount &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span>) &#123;<br>        <span class="hljs-keyword">break</span><br>      &#125;<br>    &#125;<br>    child.<span class="hljs-title function_">layout</span>(&#123; <span class="hljs-attr">x</span>: startX, <span class="hljs-attr">y</span>: startY &#125;)<br>    startX += childWidth + <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span><br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这样我们就完成了一个简易版的可以指定行数的类 Flex 组件。和 Android 中的自定义布局对比一下，流程几乎是一致的，只不过方法签名不一样而已。对于初学者来讲还是挺友好的。</p>
<h2 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h2><p>这里扩展一下，我们如何刷新自定义组件？<br>很自然的想到了父子组件传递参数并进行同步的修饰符：在父组件中使用<code>@State</code>修饰变量，在子组件中使用<code>@Prop</code>修饰变量，这样就能实现父子组件单向数据同步，父组件改变变量值时子组件同步刷新。那我们也这么写一下：<br>在父组件中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">LineLimitFlexPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">CustomLayout</span>(&#123;<br>        <span class="hljs-attr">builder</span>: <span class="hljs-title class_">ColumnChildren</span>,<br>        <span class="hljs-attr">hSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">10</span>),<br>        <span class="hljs-attr">vSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">6</span>),<br>        <span class="hljs-attr">maxLine</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span><br>      &#125;).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span> == <span class="hljs-number">2</span>)&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span> =<span class="hljs-number">2</span><br>        &#125;<br>        &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CustomLayout</span> &#123;<br>  <span class="hljs-attr">hSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">vSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样写完了，但是点击之后发现控件并没有刷新，这是啥原因？ 咨询之后了解到因为子控件中的<code>maxLine</code>变量没有直接在子控件的<code>build</code>方法中使用，因此改变它的值不会触发<code>build</code>函数,更不会触发<code>onMeasureSize</code>和<code>onPlaceChildren</code>方法。<br>ArkUI 也没有提供类似<code>invalidate()</code>方法也刷新页面。咨询之后给了个比较魔幻的操作：额外定义一个变量，让这个变量参与<code>build</code>就好了，因此有了下面的代码:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">LineLimitFlexPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">2</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">showAll</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span><br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">CustomLayout</span>(&#123;<br>        <span class="hljs-attr">builder</span>: <span class="hljs-title class_">ColumnChildren</span>,<br>        <span class="hljs-attr">hSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">10</span>),<br>        <span class="hljs-attr">vSpace</span>: <span class="hljs-title function_">vp2px</span>(<span class="hljs-number">6</span>),<br>        <span class="hljs-attr">maxLine</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span>,<br>        <span class="hljs-attr">showAll</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span><br>      &#125;).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span> = <span class="hljs-number">2</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">maxLine</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">MAX_VALUE</span><br>        &#125;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span><br>      &#125;<br>      )&#125;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CustomLayout</span> &#123;<br>  <span class="hljs-attr">hSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">vSpace</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">maxLine</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-meta">@Prop</span> <span class="hljs-attr">showAll</span>: <span class="hljs-built_in">boolean</span><br>    <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span> ) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">builder</span>()<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">builder</span>()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>嗯，这样点击控件的时候就能刷新了。。。。。<br>哈哈哈哈，我先笑一会。</p>
<p>嗯，或者把这个<code>if</code>判断放在父组件中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Column</span>() &#123;<br>    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">showAll</span>)&#123;<br>    <span class="hljs-title class_">CustomLayout</span>(&#123;&#125;)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title class_">CustomLayout</span>(&#123;&#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>哈哈哈哈哈哈哈， 就先这样吧。</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-自定义相机拍照</title>
    <url>/2024/12/19/%E9%B8%BF%E8%92%99-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个就没啥好说的，有需求就要搞定需求，搞不定需求就搞定提出需求的人嘛</p>
<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>相机开发需要使用真机，模拟器目前还是不支持的。这就劝退了一部分开发者。<br>所需要的调用的接口大部分集中在<code>@kit.CameraKit</code>、<code>@kit.AbilityKit</code>中。保存图片时需要用到<code>@kit.ImageKit</code>、<code>@kit.CoreFileKit</code>、<code>@kit.MediaLibraryKit</code>等<br>接下来看下需要做哪些工作：</p>
<ol>
<li>获取相机权限</li>
<li>获取可用相机列表<ol>
<li>可以在这里监听相机状态(USB相机连接、断开连接、关闭、被占用等)</li>
<li>选择当前使用的相机</li>
</ol>
</li>
<li>创建相机输入流并打开相机<ol>
<li>可以创建相机输入流</li>
<li>可以监听预览输出流状态，包括预览流启动、预览流结束、预览流输出错误</li>
<li>可以获取相机支持的模式列表(NORMAL_PHOTO,NORMAL_VIDEO,SECURE_PHOTO)</li>
<li>可以获取当前相机设备支持的所有输出流，如预览流、拍照流、录像流等</li>
</ol>
</li>
<li>会话(Session)管理<ol>
<li>配置相机的输入流和输出流(分辨路等配置)</li>
<li>添加闪光灯、调整焦距等配置</li>
<li>会话切换控制:切换拍照或者录像</li>
<li>交和开启会话，可以开始调用相机相关功能</li>
</ol>
</li>
<li>预览<ol>
<li>创建Surface用于预览</li>
<li>将预览输出流通过SurfaceID与Surface关联</li>
<li>调用Session.start方法开始预览</li>
</ol>
</li>
<li>拍照<ol>
<li>创建拍照输出流</li>
<li>设置拍照photoAvailable的回调，并将拍照的buffer保存为图片。</li>
<li>参数配置(闪光灯、变焦、焦距等)</li>
<li>触发拍照</li>
</ol>
</li>
</ol>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="权限处理"><a href="#权限处理" class="headerlink" title="权限处理"></a>权限处理</h3><p>在进入拍照页面之前先申请权限，具体的流程看这里<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/request-app-permissions-V5">申请应用权限</a>，本文不再赘述。</p>
<h3 id="获取可用相机列表"><a href="#获取可用相机列表" class="headerlink" title="获取可用相机列表"></a>获取可用相机列表</h3><p>首先要获取相机管理实例，这里为了代码看起来清晰，将各个步骤写到了单独的方法中。<br>另外多出使用<code>camera.CameraManager</code>实例，因此定义为了全局变量</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">TakePhotoPage</span> &#123;<br><br><br>  <span class="hljs-comment">//相机管理</span><br>  <span class="hljs-title function_">getCameraManager</span>(<span class="hljs-attr">context</span>: common.<span class="hljs-property">BaseContext</span>): camera.<span class="hljs-property">CameraManager</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">cameraManager</span>: camera.<span class="hljs-property">CameraManager</span> = camera.<span class="hljs-title function_">getCameraManager</span>(context);<br>    <span class="hljs-keyword">return</span> cameraManager;<br>  &#125;<br><br>  <span class="hljs-comment">//获取可用相机列表</span><br>  <span class="hljs-title function_">getCameraDevices</span>(<span class="hljs-attr">cameraManager</span>: camera.<span class="hljs-property">CameraManager</span>): <span class="hljs-title class_">Array</span>&lt;camera.<span class="hljs-property">CameraDevice</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">cameraArray</span>: <span class="hljs-title class_">Array</span>&lt;camera.<span class="hljs-property">CameraDevice</span>&gt; = cameraManager.<span class="hljs-title function_">getSupportedCameras</span>();<br>    <br>    <span class="hljs-keyword">if</span> (cameraArray != <span class="hljs-literal">undefined</span> &amp;&amp; cameraArray.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">//在这里可以输出一些相机参数，比如相机位置(前置、后置)、相机类型(广角相机、长焦相机)等信息</span><br>      <span class="hljs-keyword">return</span> cameraArray;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">&quot;cameraManager.getSupportedCameras error&quot;</span>);<br>      <span class="hljs-keyword">return</span> [];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 监听相机状态</span><br>  <span class="hljs-title function_">onCameraStatusChange</span>(<span class="hljs-attr">cameraManager</span>: camera.<span class="hljs-property">CameraManager</span>): <span class="hljs-built_in">void</span> &#123;<br>    cameraManager.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;cameraStatus&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err: BusinessError, cameraStatusInfo: camera.CameraStatusInfo</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (err !== <span class="hljs-literal">undefined</span> &amp;&amp; err.<span class="hljs-property">code</span> !== <span class="hljs-number">0</span>) &#123;<br>        hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`Callback Error, errorCode: <span class="hljs-subst">$&#123;err.code&#125;</span>`</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-comment">// 如果当通过USB连接相机设备时，回调函数会返回新的相机出现状态</span><br>      <span class="hljs-keyword">if</span> (cameraStatusInfo.<span class="hljs-property">status</span> == camera.<span class="hljs-property">CameraStatus</span>.<span class="hljs-property">CAMERA_STATUS_APPEAR</span>) &#123;<br>        hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`New Camera device appear.`</span>);<br>      &#125;<br>      <span class="hljs-comment">// 如果当断开相机设备USB连接时，回调函数会返回相机被移除状态</span><br>      <span class="hljs-keyword">if</span> (cameraStatusInfo.<span class="hljs-property">status</span> == camera.<span class="hljs-property">CameraStatus</span>.<span class="hljs-property">CAMERA_STATUS_DISAPPEAR</span>) &#123;<br>        hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`Camera device has been removed.`</span>);<br>      &#125;<br>      <span class="hljs-comment">// 相机被关闭时，回调函数会返回相机可用状态</span><br>      <span class="hljs-keyword">if</span> (cameraStatusInfo.<span class="hljs-property">status</span> == camera.<span class="hljs-property">CameraStatus</span>.<span class="hljs-property">CAMERA_STATUS_AVAILABLE</span>) &#123;<br>        hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`Current Camera is available.`</span>);<br>      &#125;<br>      <span class="hljs-comment">// 相机被打开/占用时，回调函数会返回相机不可用状态</span><br>      <span class="hljs-keyword">if</span> (cameraStatusInfo.<span class="hljs-property">status</span> == camera.<span class="hljs-property">CameraStatus</span>.<span class="hljs-property">CAMERA_STATUS_UNAVAILABLE</span>) &#123;<br>        hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`Current Camera has been occupied.`</span>);<br>      &#125;<br>      hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`camera: <span class="hljs-subst">$&#123;cameraStatusInfo.camera.cameraId&#125;</span>`</span>);<br>      hilog.<span class="hljs-title function_">info</span>(<span class="hljs-number">0x01</span>,<span class="hljs-variable constant_">TAG</span>,<span class="hljs-string">`status: <span class="hljs-subst">$&#123;cameraStatusInfo.status&#125;</span>`</span>);<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样我们可以获取到所有可用的相机列表，并且可以根据相机类型、连接类型等过滤掉不适用的相机。<br>在获取到相机列表后，我们默认使用返回列表的第一个相机。  </p>
<h3 id="创建相机输入流并打开相机"><a href="#创建相机输入流并打开相机" class="headerlink" title="创建相机输入流并打开相机"></a>创建相机输入流并打开相机</h3><p>在这一步我们主要是创建相机的输入流，为后面在<code>XComponent</code>中预览做准备。  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">createInput</span>(): camera.<span class="hljs-property">CameraInput</span> | <span class="hljs-literal">undefined</span> &#123;<br><span class="hljs-comment">// 创建相机输入流</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">cameraInput</span>: camera.<span class="hljs-property">CameraInput</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    cameraInput = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameraManager</span>.<span class="hljs-title function_">createCameraInput</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentCamera</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to createCameraInput errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (cameraInput === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>&#125;<br><span class="hljs-comment">// 监听cameraInput错误信息</span><br>cameraInput.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentCamera</span>, <span class="hljs-function">(<span class="hljs-params">error: BusinessError</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Camera input error code: <span class="hljs-subst">$&#123;error.code&#125;</span>`</span>);<br>&#125;);<br><br><span class="hljs-keyword">return</span> cameraInput;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最重要的就一行代码：调用<code>cameraManager.createCameraInput(camera: CameraDevice)</code>创建一个输入流并返回，之后调用返回的输入流的<code>open()</code>方法打开相机，注意该方法是异步的。<br>同样的，我们可以调用<code>cameraManager.getSupportedSceneModes(camera: CameraDevice)</code>来获取相机支持的模式，一般情况下都会支持拍照和录像。<br>之后我们获取设备支持的输出流能力</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">getSupportedOutputCapability</span>(): camera.<span class="hljs-property">CameraOutputCapability</span> | <span class="hljs-literal">undefined</span> &#123;<br><span class="hljs-comment">// 获取相机设备支持的输出流能力</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">cameraOutputCapability</span>: camera.<span class="hljs-property">CameraOutputCapability</span> =<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameraManager</span>.<span class="hljs-title function_">getSupportedOutputCapability</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentCamera</span>, camera.<span class="hljs-property">SceneMode</span>.<span class="hljs-property">NORMAL_PHOTO</span>)<br><br><span class="hljs-keyword">if</span> (!cameraOutputCapability) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;cameraManager.getSupportedOutputCapability error&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>&#125;<br><span class="hljs-keyword">return</span> cameraOutputCapability;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们拿到<code>cameraOutputCapability</code>之后，可以从该对象的<code>previewProfiles</code>、<code>photoProfiles</code>属性中获取到设备支持的分辨率大小。这里我们直接使用<code>1920*1080</code>的分辨率。<br>需要注意的是 <code>previewProfiles</code>和<code>photoProfiles</code>所支持的分辨率不一定是一致的。预览的话只要宽高比一致，分辨率别差的太离谱就可以。  </p>
<p>之后我们使用选择好的<code>Profile</code>对象来创建拍照输出流和预览输出流</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameraManager</span>.<span class="hljs-title function_">createPhotoOutput</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">currentPhotoProfile</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">previewOutput</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameraManager</span>.<span class="hljs-title function_">createPreviewOutput</span>(previewProfile, <span class="hljs-variable language_">this</span>.<span class="hljs-property">surfaceId</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>  <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to createPhotoOutput errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span> === <span class="hljs-literal">undefined</span>) &#123;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里需要注意的是，创建预览输出流的时候需要传入 surfaceID，该值来源于组件<code>XComponent</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">private</span> <span class="hljs-attr">mXComponentController</span>: <span class="hljs-title class_">XComponentController</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XComponentController</span>;<br><span class="hljs-title class_">XComponent</span>(&#123;<br><span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;componentId&#x27;</span>,<br><span class="hljs-attr">type</span>: <span class="hljs-title class_">XComponentType</span>.<span class="hljs-property">SURFACE</span>,<br><span class="hljs-attr">controller</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">mXComponentController</span>,<br>&#125;)<br>.<span class="hljs-title function_">onLoad</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">surfaceId</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">mXComponentController</span>.<span class="hljs-title function_">getXComponentSurfaceId</span>();<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>所以这里我们需要注意一下创建预览输出流的时机</p>
<h3 id="创建并配置会话"><a href="#创建并配置会话" class="headerlink" title="创建并配置会话"></a>创建并配置会话</h3><p>创建会话也只是一行的就可以搞定，但可能会有异常出现</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">createSession</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//创建会话</span><br><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cameraManager</span>.<span class="hljs-title function_">createSession</span>(camera.<span class="hljs-property">SceneMode</span>.<span class="hljs-property">NORMAL_PHOTO</span>) <span class="hljs-keyword">as</span> camera.<span class="hljs-property">PhotoSession</span>;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to create the session instance. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span> === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 监听session错误信息</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error: BusinessError</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Capture session error code: <span class="hljs-subst">$&#123;error.code&#125;</span>`</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置会话主要是添加相机输入流、预览输出流和拍照输出流，最后提交配置</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-keyword">async</span> <span class="hljs-title function_">configSession</span>(<span class="hljs-params">cameraInput: camera.CameraInput, previewOutput: camera.PreviewOutput</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// 开始配置会话</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">beginConfig</span>();<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to beginConfig. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 向会话中添加相机输入流</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">addInput</span>(cameraInput);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to addInput. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 向会话中添加预览输出流</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">addOutput</span>(previewOutput);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to addOutput(previewOutput). errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 向会话中添加拍照输出流</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">addOutput</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span>);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to addOutput(photoOutput). errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 提交会话配置</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">commitConfig</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="拍照回调和启动会话"><a href="#拍照回调和启动会话" class="headerlink" title="拍照回调和启动会话"></a>拍照回调和启动会话</h3><p>我们先启动会话</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">start</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;Promise returned to indicate the session start success.&#x27;</span>);<br>      &#125;);<br></code></pre></td></tr></table></figure>
<p>会话启动之后我们就可以进行拍照了。拍照的话需要调用拍照输出流的<code>capture</code>方法  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">takePhoto</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">photoCaptureSetting</span>: camera.<span class="hljs-property">PhotoCaptureSetting</span> = &#123;<br>    <span class="hljs-attr">quality</span>: camera.<span class="hljs-property">QualityLevel</span>.<span class="hljs-property">QUALITY_LEVEL_HIGH</span>, <span class="hljs-comment">// 设置图片质量高</span><br>    <span class="hljs-attr">rotation</span>: camera.<span class="hljs-property">ImageRotation</span>.<span class="hljs-property">ROTATION_0</span> <span class="hljs-comment">// 设置图片旋转角度0</span><br>&#125;<br><span class="hljs-comment">// 使用当前拍照设置进行拍照</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span>.<span class="hljs-title function_">capture</span>(photoCaptureSetting, <span class="hljs-function">(<span class="hljs-params">err: BusinessError</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`Failed to capture the photo <span class="hljs-subst">$&#123;err.message&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;Callback invoked to indicate the photo capture request success.&#x27;</span>);<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但照片内容确不是在该方法中返回，而是需要我们在拍照输出流中添加<code>photoAvailable</code>事件监听，该监听可以在创建拍照输出流之后就添加</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">setPhotoOutputCb</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">//设置回调之后，调用photoOutput的capture方法，就会将拍照的buffer回传到回调中</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoOutput</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;photoAvailable&#x27;</span>, (<span class="hljs-attr">errCode</span>: <span class="hljs-title class_">BusinessError</span>, <span class="hljs-attr">photo</span>: camera.<span class="hljs-property">Photo</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;getPhoto start&#x27;</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">`err: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(errCode)&#125;</span>`</span>);<br>      <span class="hljs-keyword">if</span> (errCode || photo === <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;getPhoto failed&#x27;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      <span class="hljs-keyword">let</span> imageObj = photo.<span class="hljs-property">main</span>;<br>      imageObj.<span class="hljs-title function_">getComponent</span>(image.<span class="hljs-property">ComponentType</span>.<span class="hljs-property">JPEG</span>, (<span class="hljs-attr">errCode</span>: <span class="hljs-title class_">BusinessError</span>, <span class="hljs-attr">component</span>: image.<span class="hljs-property">Component</span>): <span class="hljs-function"><span class="hljs-params">void</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;getComponent start&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (errCode || component === <span class="hljs-literal">undefined</span>) &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;getComponent failed&#x27;</span>);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">buffer</span>: <span class="hljs-title class_">ArrayBuffer</span>;<br>        <span class="hljs-keyword">if</span> (component.<span class="hljs-property">byteBuffer</span>) &#123;<br>          buffer = component.<span class="hljs-property">byteBuffer</span>;<br>          <span class="hljs-keyword">let</span> filePath = <span class="hljs-title function_">getContext</span>().<span class="hljs-property">cacheDir</span> + <span class="hljs-string">&#x27;/&#x27;</span> + systemDateTime.<span class="hljs-title function_">getTime</span>() + <span class="hljs-string">&#x27;.jpg&#x27;</span><br>          <span class="hljs-keyword">let</span> file = fileIo.<span class="hljs-title function_">openSync</span>(filePath, fileIo.<span class="hljs-property">OpenMode</span>.<span class="hljs-property">READ_WRITE</span> | fileIo.<span class="hljs-property">OpenMode</span>.<span class="hljs-property">CREATE</span>)<br>          fileIo.<span class="hljs-title function_">writeSync</span>(file.<span class="hljs-property">fd</span>, buffer)<br>          fileIo.<span class="hljs-title function_">closeSync</span>(file)<br><br>          <span class="hljs-keyword">let</span> fileUrl = fileUri.<span class="hljs-title function_">getUriFromPath</span>(filePath)<br>          promptAction.<span class="hljs-title function_">showToast</span>(&#123;<span class="hljs-attr">message</span>:fileUrl&#125;)<br><br><br>          <span class="hljs-keyword">let</span> <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>          promptAction.<span class="hljs-title function_">openCustomDialog</span>(&#123;<br>            <span class="hljs-attr">builder</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">saveImageToAlbumDialog</span>(fileUrl, <span class="hljs-function">() =&gt;</span> &#123;<br>                promptAction.<span class="hljs-title function_">closeCustomDialog</span>(id)<br>              &#125;)<br>            &#125;<br>          &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">dialogID</span>) =&gt;</span> &#123;<br>            id = dialogID<br>          &#125;)<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;byteBuffer is null&#x27;</span>);<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        imageObj.<span class="hljs-title function_">release</span>();<br>      &#125;);<br>    &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>这里就简单写了一下处理：拿到 ArrayBuffer 之后写入沙箱文件，然后在弹窗中展示</p>
<h3 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h3><p>我们创建会话(camera.PhotoSession)之后，可以通过该对象配置闪光灯模式、对焦模式、缩放等</p>
<h4 id="闪光灯"><a href="#闪光灯" class="headerlink" title="闪光灯"></a>闪光灯</h4><p>首先判断设备是否支持闪光灯，然后再判断支持的闪光灯模式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">getSupportFlashMode</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-variable language_">this</span>.<span class="hljs-property">supportFlashMode</span> = []<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>) &#123;<br>     <span class="hljs-keyword">return</span><br>   &#125;<br>   <span class="hljs-comment">// 判断设备是否支持闪光灯</span><br>   <span class="hljs-keyword">let</span> <span class="hljs-attr">flashStatus</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>   <span class="hljs-keyword">try</span> &#123;<br>     flashStatus = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">hasFlash</span>();<br>   &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>     <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to hasFlash. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>   &#125;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;Returned with the flash light support status:&#x27;</span> + flashStatus);<br><br>   <span class="hljs-keyword">if</span> (flashStatus) &#123;<br>     <span class="hljs-comment">// 判断支持的闪光灯模式</span><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">isFlashModeSupported</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_CLOSE</span>);<br>       <span class="hljs-keyword">if</span> (status) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">supportFlashMode</span>.<span class="hljs-title function_">push</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_CLOSE</span>)<br>       &#125;<br>     &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>       <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to check whether the flash mode is supported. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">isFlashModeSupported</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_OPEN</span>);<br>       <span class="hljs-keyword">if</span> (status) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">supportFlashMode</span>.<span class="hljs-title function_">push</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_OPEN</span>)<br>       &#125;<br>     &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>       <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to check whether the flash mode is supported. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">isFlashModeSupported</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_AUTO</span>);<br>       <span class="hljs-keyword">if</span> (status) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">supportFlashMode</span>.<span class="hljs-title function_">push</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_AUTO</span>)<br>       &#125;<br>     &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>       <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to check whether the flash mode is supported. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>     &#125;<br><br>     <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">isFlashModeSupported</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_ALWAYS_OPEN</span>);<br>       <span class="hljs-keyword">if</span> (status) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">supportFlashMode</span>.<span class="hljs-title function_">push</span>(camera.<span class="hljs-property">FlashMode</span>.<span class="hljs-property">FLASH_MODE_ALWAYS_OPEN</span>)<br>       &#125;<br>     &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>       <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to check whether the flash mode is supported. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>     &#125;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="连续自动对焦"><a href="#连续自动对焦" class="headerlink" title="连续自动对焦"></a>连续自动对焦</h4><p>也是需要先判断是否支持自动连续对焦，不支持的话只能手动对焦</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">setAutoContinuousFocus</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 判断是否支持连续自动变焦模式</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">focusModeStatus</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">status</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">isFocusModeSupported</span>(camera.<span class="hljs-property">FocusMode</span>.<span class="hljs-property">FOCUS_MODE_CONTINUOUS_AUTO</span>);<br>    focusModeStatus = status;<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to check whether the focus mode is supported. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (focusModeStatus) &#123;<br>    <span class="hljs-comment">// 设置连续自动变焦模式</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">setFocusMode</span>(camera.<span class="hljs-property">FocusMode</span>.<span class="hljs-property">FOCUS_MODE_CONTINUOUS_AUTO</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>      <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to set the focus mode. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>手动对焦则是获取到用户点击的位置，然后调用<code>this.photoSession.setFocusPoint(point: camera.Point)</code>方法进行对焦</p>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>同样的，需要先获取到支持的缩放范围</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">getZoomRatioRange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 获取相机支持的可变焦距比范围</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">zoomRatioRange</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [];<br>  <span class="hljs-keyword">try</span> &#123;<br>    zoomRatioRange = <span class="hljs-variable language_">this</span>.<span class="hljs-property">photoSession</span>.<span class="hljs-title function_">getZoomRatioRange</span>();<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> err = error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to get the zoom ratio range. errorCode = &#x27;</span> + err.<span class="hljs-property">code</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (zoomRatioRange.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">zoomRatioRangeStart</span> = zoomRatioRange[<span class="hljs-number">0</span>]<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">zoomRatioRangeEnd</span> = zoomRatioRange[<span class="hljs-number">1</span>]<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后调用<code>this.photoSession.setZoomRatio(zoom);</code>设置缩放比</p>
<h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><p>在拍照结束后需要释放相应的资源</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">await</span> photoSession.<span class="hljs-title function_">stop</span>();<br><br><span class="hljs-comment">// 释放相机输入流</span><br><span class="hljs-keyword">await</span> cameraInput.<span class="hljs-title function_">close</span>();<br><br><span class="hljs-comment">// 释放预览输出流</span><br><span class="hljs-keyword">await</span> previewOutput.<span class="hljs-title function_">release</span>();<br><br><span class="hljs-comment">// 释放拍照输出流</span><br><span class="hljs-keyword">await</span> photoOutput.<span class="hljs-title function_">release</span>();<br><br><span class="hljs-comment">// 释放会话</span><br><span class="hljs-keyword">await</span> photoSession.<span class="hljs-title function_">release</span>();<br><br><span class="hljs-comment">// 会话置空</span><br>photoSession = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="设备旋转"><a href="#设备旋转" class="headerlink" title="设备旋转"></a>设备旋转</h4><p>上面的代码中我们并没有考虑设备旋转问题</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; display &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.ArkUI&#x27;</span>;   <br><br><span class="hljs-keyword">let</span> initDisplayRotation = display.<span class="hljs-title function_">getDefaultDisplaySync</span>().<span class="hljs-property">rotation</span>;<br><span class="hljs-keyword">let</span> initPreviewRotation = previewOutput.<span class="hljs-title function_">getPreviewRotation</span>(initDisplayRotation * camera.<span class="hljs-property">ImageRotation</span>.<span class="hljs-property">ROTATION_90</span>);<br>previewOutput.<span class="hljs-title function_">setPreviewRotation</span>(initPreviewRotation, <span class="hljs-literal">false</span>);<br>display.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;change&#x27;</span>);<br>display.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  initDisplayRotation = display.<span class="hljs-title function_">getDefaultDisplaySync</span>().<span class="hljs-property">rotation</span>;<br>  <span class="hljs-keyword">let</span> imageRotation = initDisplayRotation * camera.<span class="hljs-property">ImageRotation</span>.<span class="hljs-property">ROTATION_90</span>;<br>  <span class="hljs-keyword">let</span> previewRotation = previewOutput.<span class="hljs-title function_">getPreviewRotation</span>(imageRotation);<br>  previewOutput.<span class="hljs-title function_">setPreviewRotation</span>(previewRotation, <span class="hljs-literal">false</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h4 id="在-Worker-线程中使用相机"><a href="#在-Worker-线程中使用相机" class="headerlink" title="在 Worker 线程中使用相机"></a>在 Worker 线程中使用相机</h4><p>一般情况下，设备的性能足以支持我们直接使用相机，但如果要追求极致性能，可以将拍照的一系列流程都放在 Worker 线程中完成，通过宿主线程的即时消息通信完成线程间交互</p>
<hr>
<p>具体的代码在<a href="https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/take_photo/TakePhotoPage.ets">https://github.com/huangyuanlove/HelloArkUI/blob/main/entry/src/main/ets/pages/playground/take_photo&#x2F;TakePhotoPage.ets</a><br>就不再贴一遍了。<br>上面代码中并没有实现切换摄像头、切换闪光灯、切换分辨率功能，只是做了展示。</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-试一下属性字符串</title>
    <url>/2025/04/09/%E9%B8%BF%E8%92%99-%E8%AF%95%E4%B8%80%E4%B8%8B%E5%B1%9E%E6%80%A7%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发中，经常会遇到一段文字中需要设置不同的字体样式和点击事件，最常见的就是在”我已仔细阅读并同意《隐私政策》和《用户协议》”这种情况，需要将书名号中的文字高亮，并且在点击的时候需要跳转到不同页面。一般我们可以使用Text+Span来实现，但我们还有另外一种方法：属性字符串</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>方便灵活应用文本样式的对象，可通过<code>TextController</code>中的<code>setStyledString</code>方法与<code>Text</code>组件绑定，可通过<code>RichEditorStyledStringController</code>中的<code>setStyledString</code>方法与<code>RichEditor</code>组件绑定。<br>但需要注意以下几点：</p>
<ul>
<li>当组件样式和属性字符串中的样式冲突时，冲突部分以属性字符串设置的样式为准，未冲突部分则生效组件的样式。</li>
<li>当属性字符串和Text子组件冲突时，属性字符串优先级高，即当Text组件中绑定了属性字符串，忽略Text组件下包含Span等子组件的情况。</li>
<li>不支持@State修饰。</li>
<li>建议将StyledString定义为成员变量，从而避免应用退后台后被销毁。</li>
<li>目前不支持在worker线程中使用。</li>
</ul>
<p>最重要的一点，文档上没提到的:在<code>aboutToAppear</code>生命周期中调用<code>textController.setStyledString()</code>是没有效果的的。<br>着也是为什么文档中的示例将该方法的调用放在<code>onPageShow</code>方法的原因。<br>当然也可以在组件的<code>onAppear</code>方法中调用</p>
<h2 id="有哪些类型"><a href="#有哪些类型" class="headerlink" title="有哪些类型"></a>有哪些类型</h2><p>一般情况下，<code>MutableStyledString</code>使用的多一些。该类继承自<code>StyledString</code>,其构造方法如下</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span> | ImageAttachment | CustomSpan , styles?: <span class="hljs-built_in">Array</span>&lt;StyleOptions&gt;</span>)<br></code></pre></td></tr></table></figure>
<p>一般情况下我们是这么使用的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//创建无样式属性的字符串，然后调用该对象的 appendStyledString insertStyledString 等方法设置各种属性</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">mutableStyledString</span>:<span class="hljs-title class_">MutableStyledString</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutableStyledString</span>(<span class="hljs-string">&quot;字符串&quot;</span>)<br><br><span class="hljs-comment">//直接添加各种样式属性</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">mutableStyledString</span>:<span class="hljs-title class_">MutableStyledString</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutableStyledString</span>(<span class="hljs-string">&quot;字符串&quot;</span>,[&#123;<br>      <span class="hljs-attr">start</span>:<span class="hljs-number">2</span>,<br>      <span class="hljs-attr">length</span>:<span class="hljs-number">2</span>,<br>      <span class="hljs-attr">styledKey</span>:<span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">DECORATION</span>,<br>      <span class="hljs-attr">styledValue</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecorationStyle</span>(&#123;<span class="hljs-attr">color</span>:<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>,<span class="hljs-attr">type</span>:<span class="hljs-title class_">TextDecorationType</span>.<span class="hljs-property">LineThrough</span>,<span class="hljs-attr">style</span>:<span class="hljs-title class_">TextDecorationStyle</span>.<span class="hljs-property">WAVY</span>&#125;)<br>    &#125;])<br></code></pre></td></tr></table></figure>
<p>这里的styledKey和styledValue是需要一一对应的，当这两个值不匹配时不生效。<br>比如： </p>
<blockquote>
<p>StyledStringKey.FONT &lt;-&gt; TextStyle<br>StyledStringKey.DECORATION &lt;-&gt; DecorationStyle<br>StyledStringKey.BASELINE_OFFSET &lt;-&gt; BaselineOffsetStyle<br>StyledStringKey.LETTER_SPACING &lt;-&gt; LetterSpacingStyle<br>StyledStringKey.TEXT_SHADOW &lt;-&gt; TextShadowStyle<br>StyledStringKey.LINE_HEIGHT &lt;-&gt; LineHeightStyle<br>StyledStringKey.BACKGROUND_COLOR &lt;-&gt; BackgroundColorStyle<br>StyledStringKey.URL &lt;-&gt; UrlStyle<br>StyledStringKey.GESTURE &lt;-&gt; GestureStyle<br>StyledStringKey.PARAGRAPH_STYLE &lt;-&gt; ParagraphStyle<br>StyledStringKey.USER_DATA &lt;-&gt;  extends UserDataSpan  </p>
</blockquote>
<p>还有两个比较特殊的：<code>StyledStringKey.CUSTOM_SPAN</code> 和 <code>StyledStringKey.IMAGE</code>，这两个用的比较少。</p>
<h2 id="拉出来溜溜"><a href="#拉出来溜溜" class="headerlink" title="拉出来溜溜"></a>拉出来溜溜</h2><p>来看下如何实现一开始说的那个例子</p>
<h3 id="Text-Span"><a href="#Text-Span" class="headerlink" title="Text + Span"></a>Text + Span</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Text</span>()&#123;<br>  <span class="hljs-title class_">Span</span>(<span class="hljs-string">&quot;我已仔细阅读并同意&quot;</span>).<span class="hljs-title function_">fontColor</span>(<span class="hljs-string">&quot;#333333&quot;</span>).<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">16</span>)<br>  <span class="hljs-title class_">Span</span>(<span class="hljs-string">&quot;《用户协议》&quot;</span>).<span class="hljs-title function_">fontColor</span>(<span class="hljs-string">&quot;#39d175&quot;</span>).<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>    promptAction.<span class="hljs-title function_">showToast</span>(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&quot;打开用户协议页面&quot;</span>&#125;)<br>  &#125;)<br>  <span class="hljs-title class_">Span</span>(<span class="hljs-string">&quot;和&quot;</span>).<span class="hljs-title function_">fontColor</span>(<span class="hljs-string">&quot;#333333&quot;</span>).<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">16</span>)<br>  <span class="hljs-title class_">Span</span>(<span class="hljs-string">&quot;《隐私协议》&quot;</span>).<span class="hljs-title function_">fontColor</span>(<span class="hljs-string">&quot;#39d175&quot;</span>).<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">16</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>    promptAction.<span class="hljs-title function_">showToast</span>(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&quot;打开隐私协议页面&quot;</span>&#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="StyledString"><a href="#StyledString" class="headerlink" title="StyledString"></a>StyledString</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Text</span>(<span class="hljs-literal">undefined</span>,&#123;<span class="hljs-attr">controller</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">protocolTextController</span>&#125;).<span class="hljs-title function_">onAppear</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-keyword">let</span> protocolStyledString : <span class="hljs-title class_">MutableStyledString</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutableStyledString</span>(<span class="hljs-string">&quot;我已仔细阅读并同意《用户协议》和《隐私协议》&quot;</span>,[<br>    &#123;<br>      <span class="hljs-attr">start</span>: <span class="hljs-number">9</span>,<br>      <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>      <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">FONT</span>,<br>      <span class="hljs-attr">styledValue</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextStyle</span>(&#123;<br>        <span class="hljs-attr">fontColor</span>:<span class="hljs-string">&quot;#39d175&quot;</span>,<br>        <span class="hljs-attr">fontSize</span>:<span class="hljs-title class_">LengthMetrics</span>.<span class="hljs-title function_">fp</span>(<span class="hljs-number">16</span>),<br>      &#125;)<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">start</span>: <span class="hljs-number">9</span>,<br>      <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>      <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">GESTURE</span>,<br>      <span class="hljs-attr">styledValue</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">GestureStyle</span>(&#123;<span class="hljs-attr">onClick</span>:<span class="hljs-function">(<span class="hljs-params">event:ClickEvent</span>)=&gt;</span>&#123;<br>        promptAction.<span class="hljs-title function_">showToast</span>(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&quot;打开用户协议页面&quot;</span>&#125;)<br>      &#125;,<span class="hljs-attr">onLongPress</span>:<span class="hljs-function">(<span class="hljs-params">event:GestureEvent</span>)=&gt;</span>&#123;&#125;&#125;)<br>    &#125;,<br><br>    &#123;<br>      <span class="hljs-attr">start</span>: <span class="hljs-number">16</span>,<br>      <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>      <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">FONT</span>,<br>      <span class="hljs-attr">styledValue</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextStyle</span>(&#123;<br>        <span class="hljs-attr">fontColor</span>:<span class="hljs-string">&quot;#39d175&quot;</span>,<br>        <span class="hljs-attr">fontSize</span>:<span class="hljs-title class_">LengthMetrics</span>.<span class="hljs-title function_">fp</span>(<span class="hljs-number">16</span>),<br>      &#125;)<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">start</span>: <span class="hljs-number">16</span>,<br>      <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>      <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">GESTURE</span>,<br>      <span class="hljs-attr">styledValue</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">GestureStyle</span>(&#123;<span class="hljs-attr">onClick</span>:<span class="hljs-function">(<span class="hljs-params">event:ClickEvent</span>)=&gt;</span>&#123;<br>        promptAction.<span class="hljs-title function_">showToast</span>(&#123;<span class="hljs-attr">message</span>:<span class="hljs-string">&quot;打开隐私协议页面&quot;</span>&#125;)<br>      &#125;,<span class="hljs-attr">onLongPress</span>:<span class="hljs-function">(<span class="hljs-params">event:GestureEvent</span>)=&gt;</span>&#123;&#125;&#125;)<br>    &#125;<br>  ])<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">protocolTextController</span>.<span class="hljs-title function_">setStyledString</span>(protocolStyledString)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>当然这么比较起来还是<code>Text+Span</code>比较简洁。但当遇到Span不支持的属性的时候，还是得用<code>StyledString</code>,比如设置背景色、下划线、删除线、偏移、字间距等等</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>整个全乎的看下效果</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">mutableStyledString</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutableStyledString</span>(<span class="hljs-string">&quot;豫章故郡，洪都新府。星分翼轸，地接衡庐。襟三江而带五湖，控蛮荆而引瓯越。物华天宝，龙光射牛斗之墟；人杰地灵，徐孺下陈蕃之榻。&quot;</span>, [&#123;<br>  <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>  <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">FONT</span>,<br>  <span class="hljs-attr">styledValue</span>:  <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextStyle</span>(&#123; <span class="hljs-attr">fontColor</span>: <span class="hljs-title class_">Color</span>.<span class="hljs-property">Blue</span> &#125;)<br>&#125;, &#123;<br>  <span class="hljs-attr">start</span>: <span class="hljs-number">7</span>,<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>  <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">DECORATION</span>,<br>  <span class="hljs-attr">styledValue</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecorationStyle</span>(&#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">TextDecorationType</span>.<span class="hljs-property">LineThrough</span>,<br>    <span class="hljs-attr">style</span>: <span class="hljs-title class_">TextDecorationStyle</span>.<span class="hljs-property">WAVY</span><br>  &#125;)<br>&#125;, &#123;<br>  <span class="hljs-attr">start</span>: <span class="hljs-number">14</span>,<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>  <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">BASELINE_OFFSET</span>,<br>  <span class="hljs-attr">styledValue</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaselineOffsetStyle</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LengthMetrics</span>(<span class="hljs-number">6</span>, <span class="hljs-title class_">LengthUnit</span>.<span class="hljs-property">VP</span>))<br>&#125;<br>  , &#123;<br>    <span class="hljs-attr">start</span>: <span class="hljs-number">21</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">LETTER_SPACING</span>,<br>    <span class="hljs-attr">styledValue</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">LetterSpacingStyle</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LengthMetrics</span>(<span class="hljs-number">6</span>, <span class="hljs-title class_">LengthUnit</span>.<span class="hljs-property">VP</span>))<br>  &#125;<br>  , &#123;<br>    <span class="hljs-attr">start</span>: <span class="hljs-number">28</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">TEXT_SHADOW</span>,<br>    <span class="hljs-attr">styledValue</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextShadowStyle</span>(&#123;<br>      <span class="hljs-attr">radius</span>: <span class="hljs-number">5</span>,<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">ShadowType</span>.<span class="hljs-property">COLOR</span>,<br>      <span class="hljs-attr">color</span>: <span class="hljs-title class_">Color</span>.<span class="hljs-property">Yellow</span>,<br>      <span class="hljs-attr">offsetX</span>: <span class="hljs-number">10</span>,<br>      <span class="hljs-attr">offsetY</span>: -<span class="hljs-number">10</span><br>    &#125;)<br>  &#125;<br>  , &#123;<br>    <span class="hljs-attr">start</span>: <span class="hljs-number">35</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">LINE_HEIGHT</span>,<br>    <span class="hljs-attr">styledValue</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">LineHeightStyle</span>(<span class="hljs-title class_">LengthMetrics</span>.<span class="hljs-title function_">fp</span>(<span class="hljs-number">20</span>))<br>  &#125;<br>  <span class="hljs-comment">// , &#123;</span><br>  <span class="hljs-comment">//   start: 42,</span><br>  <span class="hljs-comment">//   length: 6,</span><br>  <span class="hljs-comment">//   styledKey: StyledStringKey.BACKGROUND_COLOR,</span><br>  <span class="hljs-comment">//   styledValue: new BackgroundColorStyle(&#123;</span><br>  <span class="hljs-comment">//     color: Color.Pink,</span><br>  <span class="hljs-comment">//     radius: 6</span><br>  <span class="hljs-comment">//   &#125;)</span><br>  <span class="hljs-comment">// &#125;</span><br>  <span class="hljs-comment">// , &#123;</span><br>  <span class="hljs-comment">//   start: 49,</span><br>  <span class="hljs-comment">//   length: 6,</span><br>  <span class="hljs-comment">//   styledKey: StyledStringKey.URL,</span><br>  <span class="hljs-comment">//   styledValue: new UrlStyle(&quot;https://www.example.com&quot;)</span><br>  <span class="hljs-comment">// &#125;</span><br>  , &#123;<br>    <span class="hljs-attr">start</span>: <span class="hljs-number">56</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-attr">styledKey</span>: <span class="hljs-title class_">StyledStringKey</span>.<span class="hljs-property">PARAGRAPH_STYLE</span>,<br>    <span class="hljs-attr">styledValue</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">ParagraphStyle</span>(&#123; <span class="hljs-attr">textAlign</span>: <span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">End</span>, <span class="hljs-attr">maxLines</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">wordBreak</span>: <span class="hljs-title class_">WordBreak</span>.<span class="hljs-property">BREAK_ALL</span>, <span class="hljs-attr">overflow</span>: <span class="hljs-title class_">TextOverflow</span>.<span class="hljs-property">Ellipsis</span>&#125;)<br>  &#125;<br>]);<br></code></pre></td></tr></table></figure>
<p>注意：<code>BackgroundColorStyle</code>和<code>UrlStyle</code>是api14开始支持的<br><img src="/image/HarmonyOS/styled_string.png" alt="属性字符串"></p>
<h3 id="CustomSpan"><a href="#CustomSpan" class="headerlink" title="CustomSpan"></a>CustomSpan</h3><p>我们需要继承<code>CustomSpan</code>并重写<code>onMeasure(measureInfo: CustomSpanMeasureInfo): CustomSpanMetrics</code>来完成测量，重写<code>onDraw(context: DrawContext, options: CustomSpanDrawInfo)</code>来完成绘制，这和<code>自定义组件的自定义布局</code>中重写<code>onMeasureSize</code>和<code>onPlaceChildren</code>差不多。</p>
<h4 id="先看一下构造函数"><a href="#先看一下构造函数" class="headerlink" title="先看一下构造函数"></a>先看一下构造函数</h4><p>CustomSpan对象只有一个无参构造函数，但一般情况下我们需要在构造函数中传入我们需要的参数，大多数情况我们需要传入要绘制的内容，这里简单的以绘制字符串为例。还需要一个UIContext的上下文对象，用于获取各种工具。<br>另外我们还需要根据需求，定义一些变量，来保存我们需要使用的参数。这里我们需要保存<code>字体大小</code>。  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomSpan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">CustomSpan</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">text: <span class="hljs-built_in">string</span>, uiContext: UIContext</span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = text;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiContext</span> = uiContext<br>  &#125;<br><br>  <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">uiContext</span>: <span class="hljs-title class_">UIContext</span><br><br>  <span class="hljs-attr">fontSizeFp</span>:<span class="hljs-built_in">number</span> =<span class="hljs-number">0</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="onMeasure-measureInfo-CustomSpanMeasureInfo-CustomSpanMetrics"><a href="#onMeasure-measureInfo-CustomSpanMeasureInfo-CustomSpanMetrics" class="headerlink" title="onMeasure(measureInfo: CustomSpanMeasureInfo): CustomSpanMetrics"></a>onMeasure(measureInfo: CustomSpanMeasureInfo): CustomSpanMetrics</h4><p>这个方法中，我们可以获取到文字大小，需要返回一个<code>CustomSpanMetrics</code>对象，表示自定义绘制Span的尺寸。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">onMeasure</span>(<span class="hljs-attr">measureInfo</span>: <span class="hljs-title class_">CustomSpanMeasureInfo</span>): <span class="hljs-title class_">CustomSpanMetrics</span> &#123;<br>  <span class="hljs-comment">// measureInfo.fontSize单位为fp</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">fontSizeFp</span> = measureInfo.<span class="hljs-property">fontSize</span><br><br>  <span class="hljs-comment">// 传入的fontSize单位为fp，返回文本所占布局宽度和高度单位均为px。</span><br>  <span class="hljs-keyword">let</span> size =<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">uiContext</span>.<span class="hljs-title function_">getMeasureUtils</span>().<span class="hljs-title function_">measureTextSize</span>(&#123; <span class="hljs-attr">textContent</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span>, <span class="hljs-attr">fontSize</span>: measureInfo.<span class="hljs-property">fontSize</span> &#125;)<br><br>  <span class="hljs-comment">//customSpanMetrics的width和height 单位为vp</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">customSpanMetrics</span> = &#123; <span class="hljs-attr">width</span>: <span class="hljs-title function_">px2vp</span>(size.<span class="hljs-property">width</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>), <span class="hljs-attr">height</span>: <span class="hljs-title function_">px2vp</span>(size.<span class="hljs-property">height</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>) &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">customSpanMetrics</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这样我们就获取到了Span的尺寸信息  </p>
<h4 id="onDraw-context-DrawContext-drawInfo-CustomSpanDrawInfo"><a href="#onDraw-context-DrawContext-drawInfo-CustomSpanDrawInfo" class="headerlink" title="onDraw(context: DrawContext, drawInfo: CustomSpanDrawInfo)"></a>onDraw(context: DrawContext, drawInfo: CustomSpanDrawInfo)</h4><p><code>DrawContext</code>的实例对象<code>context</code>中的size属性保存的画布的宽高，canvas属性保存了画布对象；这里需要注意的是：获取的画布是Text组件的画布，绘制时不会超出Text组件的范围。这里就先认为是属性的，戳进去看源码就是定义的get方法：<code>get canvas(): drawing.Canvas;</code><br>而<code>CustomSpanDrawInfo</code>的实例对象<code>drawInfo</code>则保存了自定义绘制Span的绘制信息。比如属性<code>x</code>是<strong>自定义绘制Span相对于挂载组件的偏移</strong>、<br><code>lineTop</code>是<strong>自定义绘制Span相对于Text组件的上边距</strong>、 <code>lineBottom</code>是<strong>自定义绘制Span相对于Text组件的下边距</strong>。<code>baseline</code>是<strong>自定义绘制Span的所在行的基线偏移量</strong>，它们的单位是都<code>px</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">onDraw</span>(<span class="hljs-attr">context</span>: <span class="hljs-title class_">DrawContext</span>, <span class="hljs-attr">drawInfo</span>: <span class="hljs-title class_">CustomSpanDrawInfo</span>): <span class="hljs-built_in">void</span> &#123;<br><br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`onDraw drawInfo x:<span class="hljs-subst">$&#123;drawInfo.x&#125;</span>  lineTop:<span class="hljs-subst">$&#123;drawInfo.lineTop&#125;</span>  lineBottom:<span class="hljs-subst">$&#123;drawInfo.lineBottom&#125;</span>  baseline:<span class="hljs-subst">$&#123;drawInfo.baseline&#125;</span>`</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`onDraw context <span class="hljs-subst">$&#123;vp2px(context.size.width)&#125;</span>   <span class="hljs-subst">$&#123;vp2px(context.size.height)&#125;</span>`</span>)<br>  <br>  <span class="hljs-keyword">let</span> canvas = context.<span class="hljs-property">canvas</span>;<br>  <span class="hljs-keyword">const</span> font = <span class="hljs-keyword">new</span> drawing.<span class="hljs-title class_">Font</span>();<br>  font.<span class="hljs-title function_">setSize</span>(<span class="hljs-title function_">vp2px</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">fontSizeFp</span>));<br>  <span class="hljs-keyword">const</span> brush = <span class="hljs-keyword">new</span> drawing.<span class="hljs-title class_">Brush</span>();<br>  brush.<span class="hljs-title function_">setColor</span>(&#123;<br>    <span class="hljs-attr">alpha</span>: <span class="hljs-number">255</span>,<br>    <span class="hljs-attr">red</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">green</span>: <span class="hljs-number">74</span>,<br>    <span class="hljs-attr">blue</span>: <span class="hljs-number">175</span><br>  &#125;);<br><br>  canvas.<span class="hljs-title function_">attachBrush</span>(brush)<br>  <span class="hljs-keyword">const</span> textBlob = drawing.<span class="hljs-property">TextBlob</span>.<span class="hljs-title function_">makeFromString</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span>, font, drawing.<span class="hljs-property">TextEncoding</span>.<span class="hljs-property">TEXT_ENCODING_UTF8</span>);<br><br>  canvas.<span class="hljs-title function_">drawTextBlob</span>(textBlob, drawInfo.<span class="hljs-property">x</span>, drawInfo.<span class="hljs-property">baseline</span>);<br>  <br>  canvas.<span class="hljs-title function_">detachBrush</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们就完成了一个简单的自绘制的Span。  </p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>但是这里有个很大的问题：当绘制的文字多的时候，文字并不会换行。因为我们测量出来文字是按一行计算的，高度也是一行文字的高度。</p>
<p>想要计算需要几行，就需要知道Text组件的宽度。这里可以从构造函数中传进来。  </p>
<p>那么问题就变成了如何获取Text组件的宽度？可以从onAreaChange回调中获取，但这个函数并不可靠，有时候一步小心使用属性字符串时返回的宽度就是0。  </p>
<p>另外一个问题就是，我们如何知道组件的宽度可以放下几个字？假如一行可以放下5.4个字，那实际结果肯定是一行只绘制5个字。</p>
<p>我们可以根据这个方法来计算需要多大的高度。</p>
<p>还有一个问题就是在onDraw方法中drawInfo.baseLine属性，目前来看就是最后一行文字的baseLine，如果有多行文字，还需要我们自己计算每一行的baseLine</p>
<hr>
<p>哈哈，遗留的问题有时间再说吧，这个自定义绘制Span用的机会应该不大。</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙--那些年我们踩过的坑(上)</title>
    <url>/2024/11/09/%E9%B8%BF%E8%92%99-%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E4%B8%8A/</url>
    <content><![CDATA[<p>写了这么长时间的ArkTs,一个应用上架了,另外一个应用也快要提交审核了。记录一下自己踩过的坑以及对应的解决方案,大家可以借鉴一下,少走一些弯路。但也不一定,万一我的方法是另外一条弯路嘞~<br>不过话又说回来,再过几个版本说不定官方就把这些坑填上了。。  </p>
<span id="more"></span>

<h2 id="自绘制编辑框"><a href="#自绘制编辑框" class="headerlink" title="自绘制编辑框"></a>自绘制编辑框</h2><p>输入验证码的输入框,由于有些样式需要定制,使用<code>TextInput</code>满足不了需求(有没有一种可能是因为我菜？),于是就按照<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/use-inputmethod-in-custom-edit-box-V5">在自绘编辑框中使用输入法</a>中的介绍,通过<code>InputMethodController.on(&#39;insertText&#39;)</code>监听键盘输入, 使用多个<code>Text</code>来展示输入的验证码,具体文章可以看<a href="https://juejin.cn/post/7414024083443236927">这里</a>。<br>写起来也挺简单,带着业务跑了一下也挺好,直到后来这个组件被用到了验证码登录的情景:用户输入手机号,点击获取验证码按钮,请求服务器发送验证码,服务器返回成功,跳转到输入验证码页面,弹起键盘,用户输入验证码。  </p>
<p>中规中矩的流程,四四方方的需求。但是,键盘弹起来之后输入的内容不会展示。呵呵哒,在其他业务上表现正常,为啥在这里就不正常？<del>首先排除控件有bug</del> 首先怀疑控件问题,整个playground工程,精简业务流程后就留下一个输入框,一个按钮,点击按钮后跳转输入验证码页面,这个页面也只留下封装的控件。<br>简单走一下流程,果然键盘弹出来了,但输入内容后没有展示出来。</p>
<p>一开始以为是监听失败了,debug,加日志后发现是<code>InputMethodController.attach</code>失败了,报了<code>&#123;&quot;code&quot;:12800009&#125;</code>错误码,查问但发现该错误码是<code>input method client is detached.</code>当时就麻了:我要进行<strong>attach</strong>操作,你告诉我已经<strong>detached</strong>。 emmm  </p>
<p>后来发现是其他业务上是点击按钮或者其他操作之后直接发送验证码,然后跳转到输入验证码页面。而登录需要先输入手机号码,再跳转到输入验证码页面。当网络不好的时候,上个页面跳转之前键盘完全收起来,在输入验证码页面再调起键盘就正常。 </p>
<p>这里有两个解决方案:<br>方案一:在控件中延迟一定时间后再进行<strong>attach</strong>操作<br>方案二:展示的时候使用TextInput,可以看<a href="https://juejin.cn/post/7413607758577106978">这里</a></p>
<h2 id="Foreach循环渲染刷新"><a href="#Foreach循环渲染刷新" class="headerlink" title="Foreach循环渲染刷新"></a>Foreach循环渲染刷新</h2><p>列表渲染大部分甚至绝大部分都是使用的ForEach循环渲染,本着磨刀不误砍柴工的原则,先看文档,了解注意事项 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-rendering-control-foreach-V5#%E6%B8%B2%E6%9F%93%E7%BB%93%E6%9E%9C%E9%9D%9E%E9%A2%84%E6%9C%9F">ForEach:循环渲染</a>。<br>文档中提到:<strong>在ForEach组件进行非首次渲染时,它会检查新生成的键值是否在上次渲染中已经存在。如果键值不存在,则会创建一个新的组件；如果键值存在,则不会创建新的组件,而是直接渲染该键值所对应的组件</strong>。也就是说,我们如果想要刷新某一项,需要改变对应的生成的key,当然也提供了默认的生成规则:</p>
<blockquote>
<p>默认的键值生成函数,即(item: Object, index: number) &#x3D;&gt; { return index + ‘__’ + JSON.stringify(item); }。</p>
</blockquote>
<p>一般情况下, 默认的生成函数就够用了。</p>
<p>但我还是遇到了坑,这里先放结论:<strong>key一旦生成了,再去修改item的属性(假如item是个字面量对象),这个key也不会更新</strong>。</p>
<p>这就会遇到一些比较恶心的问题:当我们想要单独刷新某一项时,需要自已定义键值函数,单独改变这一项参与生成键值函数变量的值,比如自定义的键值生成函数<code>(item: Object, index: number) =&gt; &#123; return index + &#39;__&#39; + item.id +&#39;__&#39; +item.updateTime  ; &#125;</code>,并且这里的item必须是被<code>@Observed</code>修饰的class,并且每一个子组件都必须是自定义组件,并且组件内部的数据(也就是这个 item 类型的变量)需要使用<code>@ObjectLink</code>修饰。<br>这是因为@State只能观察到简单的数据类型数组数据源变化,对于自定义类,嵌套类,是观察不到的,需要使用<code>@Observed</code>和<code>@ObjectLink</code>来实现这种深度观察。</p>
<p>关于这两个装饰器可以看这里 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-observed-and-objectlink-V5">@Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化</a></p>
<p>举个例子<br>先定义一个普通的数据类</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ForeachModel</span>&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span>=<span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">defaultSelect</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>页面也很简单,顶部三个按钮操作数据,下面就是一个ForEach循环渲染的列表;自定义的键值生成函数就是index和属性name、属性defaultSelect字符串连接。<br>列表内容也很简单,一个展示<code>name</code>属性的<code>Text</code>组件,一个展示<code>defaultSelect</code>属性的<code>Checkbox</code>组件</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">ForeachPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">foreachModelList</span>: <span class="hljs-title class_">ForeachModel</span>[] = []<br><br>  <span class="hljs-title function_">aboutToAppear</span>(): <span class="hljs-built_in">void</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initData</span>()<br>  &#125;<br><br>  <span class="hljs-title function_">initData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span> = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">ForeachModel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForeachModel</span>()<br>      model.<span class="hljs-property">name</span> = <span class="hljs-string">`第 <span class="hljs-subst">$&#123;i&#125;</span> 项`</span><br>      <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        model.<span class="hljs-property">defaultSelect</span> = <span class="hljs-literal">false</span><br>      &#125;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>.<span class="hljs-title function_">push</span>(model)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>     <span class="hljs-comment">//顶部的三个操作函数</span><br>      <span class="hljs-title class_">Row</span>() &#123;<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;重新赋值&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initData</span>()<br>        &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;改变最后一项的值&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>].<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;改变后的值&#x27;</span><br>        &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;添加一项&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">ForeachModel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForeachModel</span>()<br>          model.<span class="hljs-property">name</span> = <span class="hljs-string">`第 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.foreachModelList.length&#125;</span> 项`</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>.<span class="hljs-title function_">push</span>(model)<br>        &#125;)<br><br>      &#125;<br><br>      <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>, <span class="hljs-function">(<span class="hljs-params">model: ForeachModel</span>) =&gt;</span> &#123;<br>        <br>        <span class="hljs-title class_">Row</span>() &#123;<br>          <span class="hljs-title class_">Text</span>(model.<span class="hljs-property">name</span>)<br>          <span class="hljs-title class_">Checkbox</span>().<span class="hljs-title function_">select</span>(model.<span class="hljs-property">defaultSelect</span>).<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">checked: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> &#123;<br>            model.<span class="hljs-property">defaultSelect</span> = checked<br>            hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, <span class="hljs-string">`checked <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(model.name)&#125;</span>`</span>)<br><br>          &#125;)<br>        &#125;<br>      &#125;, <span class="hljs-function">(<span class="hljs-params">item: ForeachModel, index: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> key = index + <span class="hljs-string">&#x27;__&#x27;</span> + item.<span class="hljs-property">name</span> +<span class="hljs-string">&#x27;__&#x27;</span>+item.<span class="hljs-property">defaultSelect</span>;<br>        <span class="hljs-keyword">return</span> key<br>      &#125;)<br><br>    &#125;<br>    .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>    .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/image/HarmonyOS/foreach_render_a.gif" alt="ForEach循环渲染_a"><br>gif图中有几个现象:</p>
<ol>
<li>当点击<code>添加一项</code>的时候,页面可以刷新,因为<code>@State</code>能观察到数组长度的变化从而刷新页面。</li>
<li>当<code>添加一项</code>后,点击<code>重新赋值</code>,页面可以刷新,因为数组长度发生了变化,而<code>@State</code>能观察到数组长度的变化从而刷新页面。</li>
<li>当点击<code>改变最后一项的值</code>时,页面并没有刷新,因为<code>@State</code>观察不到对象内部属性变化</li>
<li>先点击<code>改变最后一项的值</code>,再点击<code>添加一项</code>时,会发现最后一项内容发生了变化,并且新增了一项。因为数组长度发生变化,页面刷新。刷新时发现ForEach子组件的key发生了变化,重新渲染。</li>
<li>当点击某项的选择框,改变选中状态后,不管是点击修<code>改变最后一项的值</code>,还是<code>添加一项</code>、<code>重新赋值</code>都不会刷新其选中状态。</li>
</ol>
<p>对于第三项,我们只需要使用<code>@Observed</code>和<code>@ObjectLink</code>就可以解决:<br>修改后:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">SimpleView</span>&#123;<br>  <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">model</span>:<span class="hljs-title class_">ForeachModel</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">name</span>)<br>      <span class="hljs-title class_">Checkbox</span>().<span class="hljs-title function_">select</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">defaultSelect</span>).<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">checked: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">defaultSelect</span> = checked<br>        hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, <span class="hljs-string">`checked <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-variable language_">this</span>.model.name)&#125;</span>`</span>)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ForeachModel</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">defaultSelect</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">//循环渲染</span><br><span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">foreachModelList</span>, <span class="hljs-function">(<span class="hljs-params">model: ForeachModel</span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">SimpleView</span>(&#123;<span class="hljs-attr">model</span>:model&#125;)<br>&#125;, <span class="hljs-function">(<span class="hljs-params">item: ForeachModel, index: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> key = index + <span class="hljs-string">&#x27;__&#x27;</span> + item.<span class="hljs-property">name</span> +<span class="hljs-string">&#x27;__&#x27;</span>+item.<span class="hljs-property">defaultSelect</span>;<br>    <span class="hljs-keyword">return</span> key<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>修改成这种形式之后,点击<code>改变最后一项的值</code>后,发现内容页面刷新了,但需要注意的是,这是因为<code>@ObjectLink</code>观察到了类属性的变化,从而刷新了页面,但ForEach子组件的key并没有发生变化,我们可以通过在键值对生成函数中添加日志来验证。<br>在上面修改后的代码中,点击<code>改变最后一项的值</code>后,再次点击<code>重新赋值</code>,页面并没有刷新为初始状态。原因上面也解释了,因为点击<code>改变最后一项的值</code>后,key并没有发生变化,再次点击<code>重新赋值</code>后,通过函数生成的key和之前一致,所以页面也不会刷新。</p>
<p>在上面修改后的代码中,上述第五条依然成立：因为点击选择框之后,虽然UI发生了变化,但这种变化是因为点击行为导致的,并不是因为key的改变,也不是因为属性的改变。因此,不管是点击修<code>改变最后一项的值</code>,还是<code>添加一项</code>、<code>重新赋值</code>都不会刷新其选中状态。</p>
<h3 id="奇怪现象"><a href="#奇怪现象" class="headerlink" title="奇怪现象"></a>奇怪现象</h3><p>这里还有一个奇怪的现象，也可能是 SDK 的 bug 也不一定：<br>我们在页面<code>aboutToAppear</code>这个生命周期函数中调用了一次<code>this.initData()</code>,页面展示出来之后，点击<code>改变最后一项的值</code>表现是正常的。<br>但是如果页面在页面展示出来之后，再点击一次<code>重新赋值</code>，这时候 子组件是重新渲染了一遍，因为看到键值生成函数中有日志打印。但这时候点击<code>改变最后一项的值</code>，页面是没有刷新的。怀疑是因为key 没有改变(重新赋值是加载了同样的数据)，但实际的对象地址是变化了的，但不知道为啥<code>@ObjectLink</code>没有观察到。<br>当我们点击其他按钮，比如增加一项其他操作之后，再点击<code>改变最后一项的值</code>是有刷新的，这时候再点击<code>重新赋值</code>，再点击<code>改变最后一项的值</code>页面是有刷新的。 </p>
<p>也就是说，当我们两次或者多次对数组赋值，并且多次赋值使得键值对生成函数生成的 key 是一致的话，<code>@ObjectLink</code>和<code>@Observed</code>这两个装饰器会失效。<br>真让人摸不着头脑</p>
<hr>
<p>PS：如何知道<code>@ObjectLink</code>有没有生效。可以加个<code>@Watch</code>哇，比如这样：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Watch</span>(<span class="hljs-string">&#x27;onForeachModelChange&#x27;</span>)  <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">model</span>: <span class="hljs-title class_">ForeachModel</span><br><span class="hljs-title function_">onForeachModelChange</span>(<span class="hljs-params"></span>)&#123;<br>  hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;ForeachPage&#x27;</span>, <span class="hljs-string">`onForeachModelChange`</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>有了解这个奇怪现象细节的朋友可以在评论区留言，或者私信我，感谢您指点迷津</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-那些年我们踩过的坑-下</title>
    <url>/2024/11/11/%E9%B8%BF%E8%92%99-%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E4%B8%8B/</url>
    <content><![CDATA[<p>书接上回，在上一篇文章中介绍了 ForEach循环渲染和自绘制输入框遇到的坑，这里聊一下 字面量对象和类对象 以及 自定义 Dialog 的坑。</p>
<span id="more"></span>


<p>先从简单的Dialog 开始，这里没有很深入的讲解，只是一些注意点以及官方推荐用法</p>
<h2 id="CustomDialogController"><a href="#CustomDialogController" class="headerlink" title="CustomDialogController"></a>CustomDialogController</h2><p>先说结论：在使用<code>CustomDialog</code>和<code>CustomDialogController</code>做自定义弹窗时，只能作为被<code>@Component</code>修饰的自定义组件的成员变量，甚至可以写在组件的点击事件中，但不能写到单纯的方法中。因为它需要 UIContext 上下文</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>正常情况：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">DialogControllerPage</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br>  <span class="hljs-attr">dialogID</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">dialogController</span>: <span class="hljs-title class_">CustomDialogController</span> | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDialogController</span>(&#123;<br>    <span class="hljs-attr">builder</span>: <span class="hljs-title class_">CustomDialogExample</span>(&#123;<br>      <span class="hljs-attr">cancel</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>      <span class="hljs-attr">confirm</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>    &#125;),<br>  &#125;)<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;在 Click 事件中定义&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)<br>        .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)<br>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">let</span> <span class="hljs-attr">dialogController</span>: <span class="hljs-title class_">CustomDialogController</span> | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDialogController</span>(&#123;<br>            <span class="hljs-attr">builder</span>: <span class="hljs-title class_">CustomDialogExample</span>(&#123;<br>              <span class="hljs-attr">cancel</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>              &#125;,<br>              <span class="hljs-attr">confirm</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>              &#125;,<br>            &#125;),<br>          &#125;)<br>          dialogController.<span class="hljs-title function_">open</span>()<br>        &#125;)<br>      <br>      <span class="hljs-comment">//在自定义组件中定义</span><br>      <span class="hljs-title class_">CustomDialogView</span>()<br><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;在页面中定义&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)<br>        .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)<br>        .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogController</span>?.<span class="hljs-title function_">open</span>()<br>        &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">CustomDialogView</span>&#123;<br>  <span class="hljs-attr">dialogController</span>: <span class="hljs-title class_">CustomDialogController</span> | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDialogController</span>(&#123;<br>    <span class="hljs-attr">builder</span>: <span class="hljs-title class_">CustomDialogExample</span>(&#123;<br>      <span class="hljs-attr">cancel</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>      <span class="hljs-attr">confirm</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>    &#125;),<br>  &#125;)<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;在自定义组件中定义&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>)<br>      .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)<br>      .<span class="hljs-title function_">fontWeight</span>(<span class="hljs-title class_">FontWeight</span>.<span class="hljs-property">Bold</span>)<br>      .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogController</span>?.<span class="hljs-title function_">open</span>()<br>      &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的这三种情况都是可以正常弹出弹窗的，但当我们把<code>CustomDialogController</code>写在普通方法中时</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">showDialog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">dialogController</span>: <span class="hljs-title class_">CustomDialogController</span> | <span class="hljs-literal">null</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDialogController</span>(&#123;<br>    <span class="hljs-attr">builder</span>: <span class="hljs-title class_">CustomDialogExample</span>(&#123;<br>      <span class="hljs-attr">cancel</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>      <span class="hljs-attr">confirm</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      &#125;,<br>    &#125;),<br>  &#125;)<br>  dialogController.<span class="hljs-title function_">open</span>()<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这里会报一个错误，应用会崩溃，报错信息挺长的，这里截取了一部分</p>
<blockquote>
<p>Pid:25224<br>Uid:20020185<br>Process name:com.huangyuanlove.arkui_demo<br>Process life time:47s<br>Reason:Signal:SIGSEGV(SEGV_MAPERR)@0x00000000000008b0  probably caused by NULL pointer dereference<br>Fault thread info:<br>Tid:25224, Name:love.arkui_demo<br>#00 pc 00000000029cfd70 &#x2F;system&#x2F;lib64&#x2F;platformsdk&#x2F;libace_compatible.z.so(OHOS::Ace::Framework::JSCustomDialogController::JsOpenDialog(OHOS::Ace::Framework::JsiCallbackInfo const&amp;)+8)(1a64ce74d582cc151101042697df670d)<br>#01 pc 00000000009a8cb0 &#x2F;system&#x2F;lib64&#x2F;platformsdk&#x2F;libace_compatible.z.so(panda::Local<a href="panda::JSValueRef">panda::JSValueRef</a> OHOS::Ace::Framework::JsiClass<a href="OHOS::Ace::Framework::JSCustomDialogController">OHOS::Ace::Framework::JSCustomDialogController</a>::InternalJSMemberFunctionCallback<a href="OHOS::Ace::Framework::JSCustomDialogController">OHOS::Ace::Framework::JSCustomDialogController</a>(panda::JsiRuntimeCallInfo*)+2148)(1a64ce74d582cc151101042697df670d)<br>#02 pc 00000000004dc50c &#x2F;system&#x2F;lib64&#x2F;platformsdk&#x2F;libark_jsruntime.so(panda::Callback::RegisterCallback(panda::ecmascript::EcmaRuntimeCallInfo*)+456)(3499a0e0c3b8b8dc50b1a4589295965e)</p>
</blockquote>
<p>我想这可能就是为啥需要在<code>@CustomDialog</code>修饰的 struct 中声明一个<code>CustomDialogController</code>变量的原因。</p>
<h3 id="官方推荐方案"><a href="#官方推荐方案" class="headerlink" title="官方推荐方案"></a>官方推荐方案</h3><p>在官方文档中有一个 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-uicontext-custom-dialog-V5">不依赖UI组件的全局自定义弹窗 (推荐)</a>。虽然说是<strong>不依赖UI组件</strong>，但实际上还是使用的<code>UIContext</code>这个上下文获取到<code>promptAction</code>，调用<code>promptAction.openCustomDialog</code>方法来实现的弹窗。<br>吐槽归吐槽，先看下用法，看完了再评价也不迟。<br>这里有两种方案，一种是传入<code>ComponentContent</code>对象，这个方案在 <a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-uicontext-custom-dialog-V5">不依赖UI组件的全局自定义弹窗 (推荐)</a>这里有详细介绍<br>另外一种方案是传入<code> promptAction.CustomDialogOptions</code>,这种方案是在<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-promptaction-V5">@ohos.promptAction (弹窗)</a> API 参考中介绍的。</p>
<h4 id="传入ComponentContent对象"><a href="#传入ComponentContent对象" class="headerlink" title="传入ComponentContent对象"></a>传入<code>ComponentContent</code>对象</h4><p>创建<code>ComponentContent</code>对象需要一个<code>UIContext</code>对象，一个<code>wrapBuilder</code>以及<code>wrapBuilder</code>中需要的参数对象。</p>
<ul>
<li>UIContext对象可以在页面中通过<code>this.getUIContext()</code>获取。  </li>
<li><code>wrapBuilder</code>需要一个全局被@Build修饰的方法。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">glaobleConfirmOrCancelDialogBuilder1</span>(<span class="hljs-params">dialogData: DialogData</span>) &#123;<br>  <span class="hljs-title class_">Column</span>() &#123;<br>    <span class="hljs-comment">//这里写弹窗中的布局</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们可以在某个组件的点击事件中展示弹窗</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript">.<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">dialogData</span>: <span class="hljs-title class_">DialogData</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogData</span>()<br>  dialogData.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;推荐方案 一&#x27;</span><br>  dialogData.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;使用  promptAction.openCustomDialog&#x27;</span><br><br><br>  <span class="hljs-keyword">let</span> uiContext = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>();<br>  <span class="hljs-keyword">let</span> promptAction = uiContext.<span class="hljs-title function_">getPromptAction</span>();<br><br>  <span class="hljs-keyword">let</span> contentNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComponentContent</span>(uiContext, <span class="hljs-title function_">wrapBuilder</span>(glaobleConfirmOrCancelDialogBuilder1), dialogData);<br>  dialogData.<span class="hljs-property">onCancel</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    promptAction.<span class="hljs-title function_">closeCustomDialog</span>(contentNode)<br><br>  &#125;<br>  dialogData.<span class="hljs-property">onConfirm</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    promptAction.<span class="hljs-title function_">closeCustomDialog</span>(contentNode)<br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    promptAction.<span class="hljs-title function_">openCustomDialog</span>(contentNode);<br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">let</span> message = (error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>).<span class="hljs-property">message</span>;<br>    <span class="hljs-keyword">let</span> code = (error <span class="hljs-keyword">as</span> <span class="hljs-title class_">BusinessError</span>).<span class="hljs-property">code</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`OpenCustomDialog args error code is <span class="hljs-subst">$&#123;code&#125;</span>, message is <span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>  &#125;;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>当然，在调用<code>openCustomDialog</code>还有第二个可选参数<code>promptAction.BaseDialogOptions</code>,相应的介绍在<a href="https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-promptaction-V5#basedialogoptions11">这里</a></p>
<h4 id="传入CustomDialogOptions"><a href="#传入CustomDialogOptions" class="headerlink" title="传入CustomDialogOptions"></a>传入<code>CustomDialogOptions</code></h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript">.<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">dialogData</span>: <span class="hljs-title class_">DialogData1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DialogData1</span>()<br>  dialogData.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;推荐方案二&#x27;</span><br>  dialogData.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;使用  promptAction.openCustomDialog&#x27;</span><br>  dialogData.<span class="hljs-property">onCancel</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    promptAction.<span class="hljs-title function_">closeCustomDialog</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogID</span>)<br>  &#125;<br>  dialogData.<span class="hljs-property">onConfirm</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    promptAction.<span class="hljs-title function_">closeCustomDialog</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogID</span>)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getPromptAction</span>().<span class="hljs-title function_">openCustomDialog</span>(&#123;<br>    <span class="hljs-attr">builder</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">confirmOrCancelDialogBuilder1</span>(dialogData)<br>    &#125;,<br><br>  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">dialogID: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dialogID</span> = dialogID<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>这里展示弹窗的时候会返回一个dialogID，我们在关闭弹窗的时候需要传入这个id。</p>
<h2 id="字面量对象与类对象"><a href="#字面量对象与类对象" class="headerlink" title="字面量对象与类对象"></a>字面量对象与类对象</h2><p>对应的英文是plain (literal) objects,class (constructor) objects，但是在不知道该怎么优雅的翻译，就先这么叫吧。<br>在 ArkTS 中，创建的每个字面量对象都必须有对应的类型，比如</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> tmpUser = &#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;123&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>直接这么写会报错，提示：<strong>Object literal must correspond to some explicitly declared class or interface (arkts-no-untyped-obj-literals) <ArkTSCheck></strong><br>也就是说我们必须要先定义一个<code>class</code> 或者 <code>interface</code>,但是这里需要注意一下，我们直接使用字面量语法创建对应的<code>class</code>对象时，要求该<code>class</code>对象中不能声明方法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserInterface</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserWithOutMethod</span>&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span> =<span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserWithMethod</span>&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span> =<span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-title function_">getInfo</span>(<span class="hljs-params"></span>)&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&#x27;UserWithMethod&#x27;</span>,<span class="hljs-string">&#x27;getInfo&#x27;</span>)<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">userInterface</span>: <span class="hljs-title class_">UserInterface</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;123&quot;</span><br>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">userWithOutMethod</span>: <span class="hljs-title class_">UserWithOutMethod</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;123&quot;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">userWithMethod</span>: <span class="hljs-title class_">UserWithMethod</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;123&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>userInterface</code> 和 <code>userWithOutMethod</code>都是正常的，但<code>userWithMethod</code>会报错，提示<code>Property &#39;getInfo&#39; is missing in type &#39;&#123; name: string; &#125;&#39; but required in type &#39;UserWithMethod&#39;</code><br><img src="/image/HarmonyOS/%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E8%B1%A11.png" alt="字面量语法创建含有方法的对象错误信息"><br>即使我们把这个方法补上，也是会提示错误：<code>Object literal must correspond to some explicitly declared class or interface</code><br><img src="/image/HarmonyOS/%E5%AD%97%E9%9D%A2%E9%87%8F%E8%AF%AD%E6%B3%95%E5%88%9B%E5%BB%BA%E5%90%AB%E6%9C%89%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E8%B1%A12.png" alt="字面量语法创建含有方法的对象错误信息">  </p>
<p>不过话又说回来，为啥要用字面量的语法创建类对象嘞？用<code>new</code>关键字它不香么？</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> userWithMethod = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserWithMethod</span>()<br></code></pre></td></tr></table></figure>
<h4 id="小坑"><a href="#小坑" class="headerlink" title="小坑"></a>小坑</h4><p>不过对于上面包含方法的类，也有其他方案，比如通过<code>as</code>关键字强转</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> userStr =  <span class="hljs-string">`&#123;&quot;name&quot;:&quot;123&quot;&#125;`</span><br><span class="hljs-keyword">let</span> userWithMethodJSON = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(userStr) <span class="hljs-keyword">as</span>  <span class="hljs-title class_">UserWithMethod</span><br>hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&#x27;UseASPage&#x27;</span>,userWithMethodJSON.<span class="hljs-property">name</span>)<br></code></pre></td></tr></table></figure>
<p>这样的话，我们是可以获取到对象的<code>name</code>属性，也能正常使用，<br>但是，不能调用这个对象的<code>getInfo()</code>方法，会崩溃，报错提示<code>Error message:is not callable</code>.<br>这个也挺好理解：</p>
<blockquote>
<p>使用<code>JSON.parse(userStr) as  UserWithMethod</code>这种方式得到的对象实际上是字面量对象，这个对象中并没有<code>getInfo()</code>方法，它的原型链上也没有这个方法，所以就会报错。 </p>
</blockquote>
<p>为啥 IDE 不给提示嘞？那就不知道了<br>当然，我们也有方法将字面量对象转为类对象，使得我们可以调用其方法：使用<code>&quot;class-transformer&quot;: &quot;^0.5.1&quot;</code> 这个三方库，github 地址(<a href="https://github.com/typestack/class-transformer)[https://github.com/typestack/class-transformer],%E4%BD%86%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%BA%93%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84ohpm%E5%BA%93%EF%BC%8C%E8%99%BD%E7%84%B6%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%9C%A8">https://github.com/typestack/class-transformer)[https://github.com/typestack/class-transformer],但要注意的是，这个库不是一个标准的ohpm库，虽然它可以在</a> ArkTS 里面使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; plainToClass &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;class-transformer&#x27;</span>;<br><span class="hljs-keyword">let</span> userStr = <span class="hljs-string">`&#123;&quot;name&quot;:&quot;123&quot;&#125;`</span><br><span class="hljs-keyword">let</span> userWithMethodJSON = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(userStr) <span class="hljs-keyword">as</span> <span class="hljs-title class_">UserWithMethod</span><br><span class="hljs-keyword">let</span> tmp = <span class="hljs-title function_">plainToClass</span>(<span class="hljs-title class_">UserWithMethod</span>, userWithMethodJSON)<br>tmp.<span class="hljs-title function_">getInfo</span>()<br></code></pre></td></tr></table></figure>
<p>这样就正常了。</p>
<h3 id="另外一个坑"><a href="#另外一个坑" class="headerlink" title="另外一个坑"></a>另外一个坑</h3><p>还记得上一篇中提到的状态管理装饰器 <code>@Observed装饰器和@ObjectLink装饰器：嵌套类对象属性变化</code>么？<br>这里还有一个小坑，使用<code>as强转</code>或者使用<code>plainToClass</code>方法创建的对象的属性发生变化时，是无法被<code>@ObjectLink装饰器</code>观察到的。<br>举个例子，我们有一个嵌套类，使用<code>@Observed</code>装饰</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstLevel</span> &#123;<br>  <span class="hljs-attr">time</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-attr">secondLevel</span>: <span class="hljs-title class_">SecondLevel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondLevel</span>()<br>&#125;<br><br><span class="hljs-meta">@Observed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondLevel</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>再定义几个赋值的方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@State</span> firstLevel?:<span class="hljs-title class_">FirstLevel</span> = <span class="hljs-literal">undefined</span><br> <span class="hljs-title function_">initWithNew</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FirstLevel</span>()<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">time</span> = systemDateTime.<span class="hljs-title function_">getTime</span>()<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">secondLevel</span>:<span class="hljs-title class_">SecondLevel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondLevel</span>()<br>  secondLevel.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;new SecondLevel&#x27;</span><br>  secondLevel.<span class="hljs-property">age</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span> = secondLevel<br>&#125;<br><br><span class="hljs-title function_">initWithAs</span>(<span class="hljs-params"></span>) &#123;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">secondLevel</span>:<span class="hljs-title class_">SecondLevel</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;as SecondLevel&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span> = &#123;<br>    <span class="hljs-attr">time</span>:systemDateTime.<span class="hljs-title function_">getTime</span>(),<br>    <span class="hljs-attr">secondLevel</span>:secondLevel<br>  &#125;<br>&#125;<br><span class="hljs-title function_">initWithPlainToText</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-string">`&#123;&quot;time&quot;:<span class="hljs-subst">$&#123;systemDateTime.getTime()&#125;</span>,&quot;secondLevel&quot;:&#123;&quot;name&quot;:&quot;PlainToText<span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>)&#125;</span>&quot;,&quot;age&quot;:<span class="hljs-subst">$&#123;<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">100</span>)&#125;</span>&#125;&#125;`</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">tmp</span>:<span class="hljs-title class_">FirstLevel</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str) <span class="hljs-keyword">as</span> <span class="hljs-title class_">FirstLevel</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span> = <span class="hljs-title function_">plainToClass</span>(<span class="hljs-title class_">FirstLevel</span>,tmp)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>两个用于展示数据的自定义组件</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-meta">@Component</span><br>struct  <span class="hljs-title class_">ShowFistLevel</span>&#123;<br>  <span class="hljs-meta">@Watch</span>(<span class="hljs-string">&#x27;onFirstLevelChange&#x27;</span>) <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">firstLevel</span>:<span class="hljs-title class_">FirstLevel</span><br>  <span class="hljs-title function_">onFirstLevelChange</span>(<span class="hljs-params"></span>)&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;UseASPage&#x27;</span>, <span class="hljs-string">&#x27;onFirstLevelChange&#x27;</span>)<br>  &#125;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>()&#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">time</span>.<span class="hljs-title function_">toString</span>())<br>      <span class="hljs-title class_">ShowSecondLevel</span>(&#123;<span class="hljs-attr">secondLevel</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>&#125;)<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">15</span>)<br>    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&quot;#e7e7e7e7&quot;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br>struct  <span class="hljs-title class_">ShowSecondLevel</span>&#123;<br>  <span class="hljs-meta">@Watch</span>(<span class="hljs-string">&#x27;onSecondLevelChange&#x27;</span>) <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">secondLevel</span>:<span class="hljs-title class_">SecondLevel</span><br>  <span class="hljs-title function_">onSecondLevelChange</span>(<span class="hljs-params"></span>)&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;UseASPage&#x27;</span>, <span class="hljs-string">&#x27;onSecondLevelChange&#x27;</span>)<br>  &#125;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>()&#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">name</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">age</span>.<span class="hljs-title function_">toString</span>())<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">15</span>)<br>    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&quot;#e7e7e7e7&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里需要注意的是，渲染嵌套类的组件需要和类对象的层级相同，不然也不会刷新。<br>比如这里<code>FirstLevel</code>类中有<code>SecondLevel</code>类型属性，就需要写成上面这样：拆成两个组件，在<code>ShowFistLevel</code>组件中引用<code>ShowSecondLevel</code>,而不能这样写</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Component</span><br>struct  <span class="hljs-title class_">ShowFistLevel</span>&#123;<br>  <span class="hljs-meta">@Watch</span>(<span class="hljs-string">&#x27;onFirstLevelChange&#x27;</span>) <span class="hljs-meta">@ObjectLink</span> <span class="hljs-attr">firstLevel</span>:<span class="hljs-title class_">FirstLevel</span><br>  <span class="hljs-title function_">onFirstLevelChange</span>(<span class="hljs-params"></span>)&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>, <span class="hljs-string">&#x27;UseASPage&#x27;</span>, <span class="hljs-string">&#x27;onFirstLevelChange&#x27;</span>)<br>  &#125;<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>()&#123;<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">time</span>.<span class="hljs-title function_">toString</span>())<br>      <span class="hljs-comment">//这里</span><br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">name</span>)<br>      <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">age</span>.<span class="hljs-title function_">toString</span>())<br>    &#125;.<span class="hljs-title function_">margin</span>(<span class="hljs-number">15</span>)<br>    .<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-string">&quot;#e7e7e7e7&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样合并成一个组件后，其中的<code>name</code>和<code>age</code>属性发生变化时，<strong>并不能刷新页面</strong></p>
<p>然后我们写个页面测试一下</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Column</span>() &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;使用New&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initWithNew</span>()<br>      &#125;)<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;使用PlainToClass&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initWithPlainToText</span>()<br>      &#125;)<br><br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;使用As&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initWithAs</span>()<br>      &#125;)<br>    &#125;<br><br>    <span class="hljs-title class_">Row</span>() &#123;<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改time属性&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>)&#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">time</span> = systemDateTime.<span class="hljs-title function_">getTime</span>()<br>        &#125;<br>      &#125;)<br><br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;修改 name、age 属性&#x27;</span>).<span class="hljs-title function_">margin</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;新名字 &#x27;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">10</span>)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>.<span class="hljs-property">secondLevel</span>.<span class="hljs-property">age</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>)<br>        &#125;<br>      &#125;)<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>)&#123;<br>      <span class="hljs-title class_">ShowFistLevel</span>(&#123;<span class="hljs-attr">firstLevel</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">firstLevel</span>&#125;)<br>    &#125;<br><br>  &#125;<br>  .<span class="hljs-title function_">height</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>  .<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>点击<code>使用New</code>后，再点击修改属性，可以看到页面刷新了<br>这时候点击<code>使用PlainToClass</code>后，页面也刷新了，但这时候点击<code>修改time属性</code>,页面会刷新，但点击<code>修改 name、age 属性</code>，页面是没有刷新的。但我们多次点击<code>使用PlainToClass</code>时，页面是可以刷新的。<br>点击使用<code>使用As</code>后，页面也刷新了，，但这时候点击<code>修改time属性</code>,页面会刷新，但点击<code>修改 name、age 属性</code>，页面是没有刷新的。但我们多次点击<code>使用As</code>时，页面是可以刷新的。</p>
<p>也就是说我们使用<code>PlainToClass</code>和<code>as</code> 这两种方式创建出来的对象，会使得<code>@Observed装饰器和@ObjectLink装饰器</code>失效。这是开发过程中需要注意的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>使用<code>CustomDialogController</code>做弹窗展示时，需要在组件中创建<code>CustomDialogController</code>对象，至少在 api12 上是这样的。</li>
<li>不想使用<code>CustomDialogController</code>的话，可以使用<code>promptAction.openCustomDialog</code>做弹窗展示，当时，它是依赖<code>UIContext</code>这个上下文。注意不要和<code>Context</code>弄混了</li>
<li>注意字面量对象和类对象。使用<code>as</code>将字面量对象转为类对象时，无法使用类本身的方法，可以使用<strong>class-transformer中的plainToClass</strong>创建类对象，这样可以调用对象的方法</li>
<li>使用<code>PlainToClass</code>和<code>as</code> 这两种方式创建出来的对象，会使得<code>@Observed装饰器和@ObjectLink装饰器</code>失效。</li>
</ol>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-验证码输入框的几种实现方式(上)</title>
    <url>/2024/09/10/%E9%B8%BF%E8%92%99-%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E4%B8%8A/</url>
    <content><![CDATA[<p>最近在做应用鸿蒙化，说白了就是把原来<code>Android</code>、<code>iOS</code>的代码重新用<code>ArkTS</code>写一遍，我负责基础建设和登录模块，有个验证码输入框需要定制一下外观样式。这里详细记录一下探索过程及结果，以及思路和源码。这里给出了三种方案<br>一：多个 InputText 拼接，每个 InputText 只能输入 1 个字符，代码控制焦点移动，<br>二：多个 Text 拼接，通过系统api<code>inputMethod.InputMethodController</code>控制键盘弹起并记录输入内容，刷新到 Text 中展示<br>三：使用 Canvas 自己绘制。<br>由于篇幅较长，这个拆成两篇来介绍。本篇介绍前两种方式，也是最常见的方式。使用Canvas 自己绘制纯粹就是闲着写的东西，后面再介绍。</p>
<span id="more"></span>

<h2 id="效果图、优缺点"><a href="#效果图、优缺点" class="headerlink" title="效果图、优缺点"></a>效果图、优缺点</h2><p>先放一下效果图</p>
<div>
<img src='/image/HarmonyOS/verification_code/four_text_input.gif' width='30%' heigh='30%'/>
<img src='/image/HarmonyOS/verification_code/four_text.gif' width='30%' heigh='30%'/>
<img src='/image/HarmonyOS/verification_code/canvas_input.gif' width='30%' heigh='30%'/>
</div>

<h4 id="多TextInput"><a href="#多TextInput" class="headerlink" title="多TextInput"></a>多TextInput</h4><p><strong>优点</strong>：只需要控制焦点就好，键盘的弹起、收起以及输入的内容我们不需要自己去监听，并且除了边框颜色之外，输入框内会有光标闪烁，也能给用户更强一些的提示<br><strong>缺点：需要控制没有获取到焦点的输入框不能点击、不能长按等。尝试多种方案</strong>(设置 enable、focusable 等)均失败后，决定在输入框上面覆盖一个空白透明且大小和输入框相等的 Text 解决这个问题。有其他方案可以告诉我一下</p>
<h4 id="多-Text"><a href="#多-Text" class="headerlink" title="多 Text"></a>多 Text</h4><p><strong>优点</strong>：不用控制焦点，只需要使用变量控制一下样式就好<br><strong>缺点</strong>：需要自己记录键盘输入的文字，并且没有光标闪烁，当前也可以自己搞个 gif 图或者写个动画来模拟光标</p>
<h4 id="Canvas-绘制"><a href="#Canvas-绘制" class="headerlink" title="Canvas 绘制"></a>Canvas 绘制</h4><p><strong>优点</strong>：我真的没想到有啥优点，可以自由的绘制边框、底色也算么？但现在的 pai 中有各种各样的Modifier来修改各种属性，实现自己绘制<br><strong>缺点</strong>：全都得自己画，挺麻烦的</p>
<h2 id="多个-TextInput-拼接"><a href="#多个-TextInput-拼接" class="headerlink" title="多个 TextInput 拼接"></a>多个 TextInput 拼接</h2><p>这里用四位验证码做例子：<br>思路挺简单的，四个<code>TextInput</code>并排放一块，输入框限制输入 1 个字符，用<code>Flex</code>做父控件也行，用<code>Row</code>做父控件也行,无所谓，这不是重点。<br>组件刚出现时，使用<code>getUIContext().getFocusController().requestFocus(key:string)</code>将焦点放在第一个输入框上，键盘就可以弹出来<br>监听<code>TextInput</code>的<code>onDidDelete</code>和<code>onChange</code>或者<code>onDidInsert</code>事件，来判断下一个焦点放在哪个位置<br>当最后一个<code>TextInput</code>有输入字符时，认为输入完成，进行回调。</p>
<p>下面详细介绍一下每一步怎么做的，以及对应的想法</p>
<h3 id="放置四个输入框"><a href="#放置四个输入框" class="headerlink" title="放置四个输入框"></a>放置四个输入框</h3><p>当前获取到焦点的输入框颜色要明亮一些，没有焦点的输入框颜色要暗淡一些。我们使用<code>@Extend()</code>做一个公用样式，传入当前是否是焦点控件来控制边框颜色</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Extend</span>(<span class="hljs-title class_">TextInput</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">textInputStyle</span>(<span class="hljs-params">enable:<span class="hljs-built_in">boolean</span></span>)&#123;<br>  .<span class="hljs-title function_">border</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">color</span>: enable?<span class="hljs-string">&quot;#1b91e0&quot;</span>:<span class="hljs-string">&quot;#999999&quot;</span>,<br>    <span class="hljs-attr">radius</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-attr">style</span>: <span class="hljs-title class_">BorderStyle</span>.<span class="hljs-property">Solid</span>,<br>  &#125;).<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)<br>  .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">maxLength</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">maxLines</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">type</span>(<span class="hljs-title class_">InputType</span>.<span class="hljs-property">Number</span>)<br>  .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">40</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>为了在焦点变化的时候输入框背景能同步修改，这里用一个<code>@State</code>修饰的布尔数组表示哪个输入框获取焦点。同时为了省事，也定义了另外一个数组，方便使用 <code>ForEach</code>循环渲染。定义另外一个字符串数组来记录每个输入框的内容</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@State</span> <span class="hljs-attr">inputValue</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]<span class="hljs-comment">// 输入框的内容</span><br><span class="hljs-meta">@State</span> <span class="hljs-attr">inputEnable</span>: <span class="hljs-built_in">boolean</span>[] = [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>] <span class="hljs-comment">//输入框是否获取焦点</span><br><span class="hljs-attr">inputIndex</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">//ForEach渲染用</span><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Row</span>() &#123;<span class="hljs-comment">//这里用 Flex 更方便一些，直接设置间距就好，不用这样设置 margin 了</span><br>      <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>, <span class="hljs-function">(<span class="hljs-params">index: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-title class_">TextInput</span>(&#123; <span class="hljs-attr">text</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index] &#125;)<br>          .<span class="hljs-title function_">id</span>(index.<span class="hljs-title function_">toString</span>())<span class="hljs-comment">//这里 id 是给FocusController使用</span><br>          .<span class="hljs-title function_">margin</span>(&#123; <span class="hljs-attr">right</span>: index == <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span> &#125;)<br>          .<span class="hljs-title function_">textInputStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index])<br>      &#125;)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>这样我们就画出来了最基本的布局。但我们会发现进入页面后键盘不能自己弹出来，因为输入框没有获取到焦点。<br>这里有两个方案，一个是给其中<code>TextInput</code>设置<code>defaultFocus</code>为 true，或者在页面展示的时候设置焦点</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">TextInput</span>(&#123; <span class="hljs-attr">text</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index] &#125;).<span class="hljs-title function_">defaultFocus</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index])<br><span class="hljs-comment">//或者</span><br><span class="hljs-title class_">Row</span>()&#123;&#125;.<span class="hljs-title function_">onAppear</span>(<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>(<span class="hljs-string">&quot;0&quot;</span>)&#125;)<br></code></pre></td></tr></table></figure>
<p>注意这里<code>requestFocus()</code>方法传入的参数<code>&quot;0&quot;</code>,也就是上面<code>TextInput</code>的<code>id</code>的值.<br>这样我们就做好的基本的属性，并且页面显示的时候也可以弹出键盘了。<br><img src="/image/HarmonyOS/verification_code/four_textinput_base.png"></p>
<h3 id="焦点移动"><a href="#焦点移动" class="headerlink" title="焦点移动"></a>焦点移动</h3><h4 id="输入时向后移动"><a href="#输入时向后移动" class="headerlink" title="输入时向后移动"></a>输入时向后移动</h4><p>但是这时候我们点击键盘输入的时候，发现光标并不会自动移动到下一个输入框上继续输入。这里需要我们进行控制。这个也比较简单，<code>TextInput</code>有一个输入内容发生变化时，触发的回调：<code>onChange(callback: EditableTextOnChangeCallback)</code>。我们可以在这个方法里面移动焦点</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">TextInput</span>().<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, previewText?: PreviewText</span>) =&gt;</span> &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index] = value <span class="hljs-comment">//记录输入的内容</span><br><span class="hljs-keyword">if</span> (value.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//确认是输入而不是删除</span><br>    <span class="hljs-keyword">if</span> (index != <span class="hljs-number">3</span>) &#123;<span class="hljs-comment">//如果不是最后一个输入框发生的输入事件，就把焦点交给下一个输入框</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index+<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><span class="hljs-comment">//记录下一个输入框获取焦点，改变背景色</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>((index + <span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>())<span class="hljs-comment">//下一个输入框获取焦点</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index] = <span class="hljs-literal">false</span><span class="hljs-comment">//标记当前输入框失去焦点，改变背景色</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果是最后一个输入框发生的输入事件，表示已经输入完了，继续后面流程</span><br>    <span class="hljs-comment">//todo 输入完成，继续后面流程</span><br>    &#125;<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="输入完成回调"><a href="#输入完成回调" class="headerlink" title="输入完成回调"></a>输入完成回调</h4><p>这就很简单了，定义一个函数变量，接收父布局传进来的函数，输入完成时回调这个函数就好</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript">onFinishInput?: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>  <span class="hljs-comment">//函数变量</span><br><span class="hljs-comment">//输入完成，进行回调</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">onFinishInput</span>) &#123;<span class="hljs-comment">//判断一下空值，然后把保存的值拼接成字符串回调</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>.<span class="hljs-property">length</span>; i++) &#123;<br>        result += <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[i]<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onFinishInput</span>(result)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里，我们已经实现了大部分功能：输入字符、保存字符、焦点向后移动、输入完成时回调。<br>下面要解决的就是删除</p>
<h4 id="删除时向前移动"><a href="#删除时向前移动" class="headerlink" title="删除时向前移动"></a>删除时向前移动</h4><p>这里需要注意一下：<br>如果当前输入框有内容，点击删除时删除当前输入框内容，焦点不动：仅在最后一个输入框会有这个情况<br>如果当前输入框没有内容，则删除上一个输入框内容，焦点移动到上一个输入框<br>如果当前时第一个输入框，不做处理</p>
<p>刚开始想着在<code>onChange</code>事件中做处理，但当输入框中没有内容时，点击删除的时是没有回调的。怎么搞，翻翻文档，找到了<code>onWillDelete</code>和<code>onDidDelete</code>,并且这两个回调都是发生在<code>onChange</code>之前。<br>这里我选择了<code>onDidDelete</code>事件中处理，逻辑就是上面说的那样</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">TextInput</span>().<span class="hljs-title function_">onDidDelete</span>(<span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> &#123;<br>  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index].<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//不是第一个输入框 且 输入框内没有文字，则删除上一个输入框内容，并且使上一个输入框获取焦点</span><br>    <span class="hljs-keyword">if</span> (index != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index-<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index] = <span class="hljs-literal">false</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index-<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><br><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>((index - <span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>())<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//如果输入框内有文字，则只删除当前输入框内容</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index] = <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>到这里我们就完成了大部分的工作，一个可以正常工作，随便调整背景的验证码输入框就完成了。<br>但似乎还有一点问题，当点击非当前焦点的输入框时，光标会移动到点击的输入框中。这就不太好了</p>
<h3 id="防止点击"><a href="#防止点击" class="headerlink" title="防止点击"></a>防止点击</h3><p>一开始想法很简单，我们不是有个布尔类型数组保存着当前哪个输入框获取焦点么？没有焦点的输入框设置enable为false就可以了哇，移动焦点的时候先将目标输入框设置enable为true，然后再移动焦点就好了哇。<br>那就给输入框加上这个设置就好了哇</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">TextInput</span>().<span class="hljs-title function_">enabled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index])<br></code></pre></td></tr></table></figure>
<p>我们在上面的代码中，都是先修改<code>inputEnable</code>数组值，然后再设置焦点，<code>完美</code>。<br>运行一下，页面出现时弹出键盘，除了第一个输入框其他输入框点击都没有反映，<code>很好</code>。<br>试着输入一下，崩了。。。。<br>日志提示组件不存在或者时不可用状态</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">Error message:The component doesn&#x27;t exist, is currently invisible, or has been disabled.<br></code></pre></td></tr></table></figure>
<p>难道是因为在请求焦点的时候，输入框的属性还没来得及完成修改？<br>做个测试，延迟1s设置焦点，果然是可以的。但这种效果太难受了，键盘会先收起来再弹出来。缩短延迟时间也很难把握时长。那就再翻翻api，找找下一帧之类的回调。<br>还真有，在UIContext这个类中有一个函数<code>postFrameCallback</code>:注册一个在下一帧进行渲染时执行的回调。按照示例把代码撸好，编译运行，尝试输入，又又又崩了，错误信息也一样。<br>没办法了么？只能用延迟么？太难受了哇，来个曲线救国，我们搞个透明没有内容的控件覆盖在没有焦点的输入框上不就行了么。<br>于是我们得到了这样的代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Row</span>()&#123;<br>  <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>,<span class="hljs-function">(<span class="hljs-params">index:<span class="hljs-built_in">number</span></span>)=&gt;</span>&#123;<br>    <span class="hljs-title class_">RelativeContainer</span>()&#123;<br>      <span class="hljs-title class_">TextInput</span>(&#123;<span class="hljs-attr">text</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index]&#125;)<br>        <br>      <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index])&#123;<span class="hljs-comment">//没有焦点则覆盖一个空白Text</span><br>        <span class="hljs-title class_">Text</span>().<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Transparent</span>)<br>          .<span class="hljs-title function_">alignRules</span>(&#123;<br>          <span class="hljs-attr">left</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">Start</span>&#125;,<br>          <span class="hljs-attr">top</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">VerticalAlign</span>.<span class="hljs-property">Top</span>&#125;,<br>          <span class="hljs-attr">bottom</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">VerticalAlign</span>.<span class="hljs-property">Bottom</span>&#125;,<br>          <span class="hljs-attr">right</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">End</span>&#125;<br>        &#125;)<br>      &#125;<br>    &#125;.<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">40</span>).<span class="hljs-title function_">margin</span>(&#123;<span class="hljs-attr">right</span>:index == <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>?<span class="hljs-number">0</span>:<span class="hljs-number">10</span>&#125;)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里，就解决了点击非焦点输入框的问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看起来挺简单的，实际上一点也不难。<br>还有可以优化的地方：<br>比如输入的内容可以不用数组，直接用字符串就好，删除和添加都是在末尾进行<br>比如焦点也可以不用记录的，直接用输入的字符串长度来判断就好。</p>
<p>遗留下的一个问题：<br>在上面使用enable来控制是否可点击时，为什么先设置enable为true，然后请求焦点会报错？<br>先设置enable为true，在下一帧时请求焦点还是报错。<br>这就留给大佬翻源码解释了。</p>
<hr>
<p>附一个完整代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; hilog &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.PerformanceAnalysisKit&#x27;</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">FourTextInput</span> &#123;<br>  onFinishInput?: <span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">inputValue</span>: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>]<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">inputEnable</span>: <span class="hljs-built_in">boolean</span>[] = [<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>]<br>  <span class="hljs-attr">inputIndex</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title class_">Row</span>()&#123;<br>        <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>,<span class="hljs-function">(<span class="hljs-params">index:<span class="hljs-built_in">number</span></span>)=&gt;</span>&#123;<br>          <span class="hljs-title class_">RelativeContainer</span>()&#123;<br>            <span class="hljs-title class_">TextInput</span>(&#123;<span class="hljs-attr">text</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index]&#125;).<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">textInputStyle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index]).<span class="hljs-title function_">maxLength</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">maxLines</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">id</span>(index.<span class="hljs-title function_">toString</span>()).<span class="hljs-title function_">type</span>(<span class="hljs-title class_">InputType</span>.<span class="hljs-property">Number</span>)<br>              .<span class="hljs-title function_">onDidDelete</span>(<span class="hljs-function">(<span class="hljs-params">_</span>)=&gt;</span>&#123;<br>                hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&quot;InputVerificationCode&quot;</span>,<span class="hljs-string">`第<span class="hljs-subst">$&#123;index&#125;</span>个执行 onDidDelete`</span>)<br>                <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index].<span class="hljs-property">length</span> == <span class="hljs-number">0</span>)&#123;<br>                  <span class="hljs-comment">//不是第一个输入框 且 输入框内没有文字，则删除上一个输入框内容，并且使上一个输入框获取焦点</span><br>                  <span class="hljs-keyword">if</span>(index !=<span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index-<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;&quot;</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index] =<span class="hljs-literal">false</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index-<span class="hljs-number">1</span>] =<span class="hljs-literal">true</span><br><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>((index-<span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>())<br>                  &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">//如果输入框内有文字，则只删除当前输入框内容</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index]=<span class="hljs-string">&quot;&quot;</span><br>                  &#125;<br>                &#125;<br>              &#125;)<br>              .<span class="hljs-title function_">onChange</span>(<span class="hljs-function">(<span class="hljs-params">value: <span class="hljs-built_in">string</span>, previewText?: PreviewText</span>)=&gt;</span>&#123;<br>                hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&quot;InputVerificationCode&quot;</span>,<span class="hljs-string">`第<span class="hljs-subst">$&#123;index&#125;</span>个onChange:  value:<span class="hljs-subst">$&#123;value&#125;</span>  previewText: value-&gt; <span class="hljs-subst">$&#123;previewText?.value&#125;</span>    offset-&gt;<span class="hljs-subst">$&#123;previewText?.offset&#125;</span>`</span>   )<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[index]= value<br>                <span class="hljs-keyword">if</span>(value.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>)&#123;<br>                  <span class="hljs-keyword">if</span>(index != <span class="hljs-number">3</span>)&#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index+<span class="hljs-number">1</span>] =<span class="hljs-literal">true</span><br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>((index+<span class="hljs-number">1</span>).<span class="hljs-title function_">toString</span>())<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index] = <span class="hljs-literal">false</span><br>                    <span class="hljs-comment">// this.inputEnable[index] =false</span><br>                  &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">onFinishInput</span>)&#123;<br>                      <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span><br>                      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>;i&lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>.<span class="hljs-property">length</span>;i++)&#123;<br>                        result += <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputValue</span>[i]<br>                      &#125;<br>                      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onFinishInput</span>(result)<br>                    &#125;<br>                  &#125;<br>                &#125;<br>              &#125;)<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputEnable</span>[index])&#123;<br>              <span class="hljs-title class_">Text</span>().<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Transparent</span>).<span class="hljs-title function_">alignRules</span>(&#123;<br>                <span class="hljs-attr">left</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">Start</span>&#125;,<br>                <span class="hljs-attr">top</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">VerticalAlign</span>.<span class="hljs-property">Top</span>&#125;,<br>                <span class="hljs-attr">bottom</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">VerticalAlign</span>.<span class="hljs-property">Bottom</span>&#125;,<br>                <span class="hljs-attr">right</span>: &#123;<span class="hljs-attr">anchor</span>: index.<span class="hljs-title function_">toString</span>(), <span class="hljs-attr">align</span>: <span class="hljs-title class_">HorizontalAlign</span>.<span class="hljs-property">End</span>&#125;<br>              &#125;)<br>            &#125;<br>          &#125;.<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">40</span>).<span class="hljs-title function_">margin</span>(&#123;<span class="hljs-attr">right</span>:index == <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputIndex</span>.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>?<span class="hljs-number">0</span>:<span class="hljs-number">10</span>&#125;)<br>        &#125;)<br>      &#125;.<span class="hljs-title function_">onAppear</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getUIContext</span>().<span class="hljs-title function_">getFocusController</span>().<span class="hljs-title function_">requestFocus</span>(<span class="hljs-string">&quot;0&quot;</span>)<br>      &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Extend</span>(<span class="hljs-title class_">TextInput</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">textInputStyle</span>(<span class="hljs-params">enable: <span class="hljs-built_in">boolean</span></span>) &#123;<br>  .<span class="hljs-title function_">border</span>(&#123;<br>    <span class="hljs-attr">width</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">color</span>: enable ? <span class="hljs-string">&quot;#1b91e0&quot;</span> : <span class="hljs-string">&quot;#999999&quot;</span>,<br>    <span class="hljs-attr">radius</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-attr">style</span>: <span class="hljs-title class_">BorderStyle</span>.<span class="hljs-property">Solid</span>,<br>  &#125;)<br>  .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)<br>  .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">maxLength</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">maxLines</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">type</span>(<span class="hljs-title class_">InputType</span>.<span class="hljs-property">Number</span>)<br>  .<span class="hljs-title function_">layoutWeight</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">height</span>(<span class="hljs-number">40</span>)<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; <span class="hljs-title class_">FourTextInput</span> &#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙-验证码输入框的几种实现方式(下)</title>
    <url>/2024/09/13/%E9%B8%BF%E8%92%99-%E9%AA%8C%E8%AF%81%E7%A0%81%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E4%B8%8B/</url>
    <content><![CDATA[<p>在上一篇文章<a href="https://juejin.cn/spost/7413607758577106978">鸿蒙-验证码输入框的几种实现方式(上)</a>中介绍了如何使用多个<code>TextInput</code>来实现验证码输入框，<br>本篇文章中介绍另外一种思路：自己代码控制、记录键盘输入内容，使用<code>Text</code>组件展示验证码，当然也可以使用<code>Canvas</code>自己绘制</p>
<span id="more"></span>

<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>先放一下效果图</p>
<div>
<img src='/image/HarmonyOS/verification_code/four_text_input.gif' width='30%' heigh='30%'/>
<img src='/image/HarmonyOS/verification_code/four_text.gif' width='30%' heigh='30%'/>
<img src='/image/HarmonyOS/verification_code/canvas_input.gif' width='30%' heigh='30%'/>
</div>


<h2 id="多个-Text-拼接"><a href="#多个-Text-拼接" class="headerlink" title="多个 Text 拼接"></a>多个 Text 拼接</h2><p>主要难点只有一个，也是最核心的问题：<strong>如何记录键盘输入的内容？</strong>。<br>这个问题解决了，就只剩下样式、展示输入内容这些简单的东西了。另外样式问题在上一篇中也提到过如何处理。</p>
<h3 id="记录输入内容"><a href="#记录输入内容" class="headerlink" title="记录输入内容"></a>记录输入内容</h3><h4 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h4><p>输入的内容我们用字符串记录一下，用 <code>Text</code>来展示，为了方便查看，加一些边框.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-meta">@State</span> inputStr :<span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>).<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;80%&#x27;</span>).<span class="hljs-title function_">margin</span>(&#123;<span class="hljs-attr">left</span>:<span class="hljs-string">&#x27;8%&#x27;</span>,<span class="hljs-attr">right</span>:<span class="hljs-string">&#x27;8%&#x27;</span>&#125;).<span class="hljs-title function_">borderRadius</span>(<span class="hljs-number">20</span>).<span class="hljs-title function_">borderWidth</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">borderColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Red</span>).<span class="hljs-title function_">height</span>(<span class="hljs-number">45</span>)<br>  &#125;<br></code></pre></td></tr></table></figure>

<h4 id="配置输入法"><a href="#配置输入法" class="headerlink" title="配置输入法"></a>配置输入法</h4><p>需要获取到<code>InputMethodController</code>实例，然后设置输入的类型、完成按钮显示的文案等等。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> &#123; inputMethod &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@kit.IMEKit&#x27;</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">inputController</span>: inputMethod.<span class="hljs-property">InputMethodController</span> = inputMethod.<span class="hljs-title function_">getController</span>();<br><span class="hljs-comment">// 软键盘相关设置</span><br><span class="hljs-keyword">private</span> <span class="hljs-attr">textConfig</span>: inputMethod.<span class="hljs-property">TextConfig</span> = &#123;<br><span class="hljs-attr">inputAttribute</span>: &#123;<br>    <span class="hljs-attr">textInputType</span>: inputMethod.<span class="hljs-property">TextInputType</span>.<span class="hljs-property">NUMBER</span>,<br>    <span class="hljs-attr">enterKeyType</span>: inputMethod.<span class="hljs-property">EnterKeyType</span>.<span class="hljs-property">DONE</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="监听输入、删除事件"><a href="#监听输入、删除事件" class="headerlink" title="监听输入、删除事件"></a>监听输入、删除事件</h4><p>文档上给出了各种各样的事件，这里就不再一一列举，选择我们需要的<code>insertText</code>和<code>deleteLeft</code>时间进行监听。对其他事件感兴趣的可以自己试一下。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//订阅键盘输入、删除事件</span><br><span class="hljs-title function_">bindKeyboardEvent</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;insertText&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">text</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span> += text;<br>  &#125;)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;deleteLeft&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">length</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>.<span class="hljs-property">length</span> - length);<br>  &#125;)<br>&#125;<br><br><span class="hljs-title function_">unbindKeyboardEvent</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;insertText&#x27;</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">off</span>(<span class="hljs-string">&#x27;deleteLeft&#x27;</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">detach</span>()<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里需要注意的是，这些时间可以被重复添加监听，添加多次则会回调多次，因此，我们在控件展示的时候添加监听，在控件销毁的时候移除监听。<br><code>inputController.attach()</code>方法的第一个布尔类型的参数表示是否在<code>attch</code>之后弹起软键盘。如果不需要的话可以设置为<code>false</code>,在后续有需要的时候通过<code>inputController.showTextInput()</code>和<code>inputController.hideTextInput()</code>控制软键盘的展示和隐藏。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Text</span>().<span class="hljs-title function_">onAppear</span>(<span class="hljs-keyword">async</span> ()=&gt;&#123;<br>          <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-literal">true</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">textConfig</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bindKeyboardEvent</span>()<br>          &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error:BusinessError</span>)=&gt;</span>&#123;<br>            hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&quot;RecordKeyboardInputPage&quot;</span>,<span class="hljs-string">&quot;输入法绑定出错&quot;</span>)<br>          &#125;)<br>      &#125;)<br>      .<span class="hljs-title function_">onDisAppear</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unbindKeyboardEvent</span>()<br>      &#125;)<br></code></pre></td></tr></table></figure>
<p>到这里我们就已经能够正确的记录下键盘输入的字符，并且展示在一个<code>Text</code>中了。最大的问题解决了，剩下的就是如何拆到多个<code>Text</code>上展示，这个就简单多了</p>
<h3 id="展示-1"><a href="#展示-1" class="headerlink" title="展示"></a>展示</h3><p>记录输入已经搞定了，这次用<code>Flex</code>做父布局，<code>Text</code>做子控件来展示一下:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><br><span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-title class_">Flex</span>(&#123;<br>    <span class="hljs-attr">direction</span>: <span class="hljs-title class_">FlexDirection</span>.<span class="hljs-property">Row</span>,<br>    <span class="hljs-attr">justifyContent</span>: <span class="hljs-title class_">FlexAlign</span>.<span class="hljs-property">SpaceBetween</span>,<br>    <span class="hljs-attr">alignItems</span>: <span class="hljs-title class_">ItemAlign</span>.<span class="hljs-property">End</span>,<br>    <span class="hljs-attr">wrap</span>: <span class="hljs-title class_">FlexWrap</span>.<span class="hljs-property">NoWrap</span>,<br>    <span class="hljs-attr">space</span>: &#123; <span class="hljs-attr">main</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">LengthMetrics</span>(<span class="hljs-number">10</span>) &#125;<br>&#125;) &#123;<br>    <span class="hljs-title class_">ForEach</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeIdx</span>, <span class="hljs-function">(<span class="hljs-params">item: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">Text</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>[item])<br>        .<span class="hljs-title function_">flexGrow</span>(<span class="hljs-number">1</span>)<br>        .<span class="hljs-title function_">flexShrink</span>(<span class="hljs-number">1</span>)<br>        .<span class="hljs-title function_">flexBasis</span>(<span class="hljs-number">1</span>)<br>        .<span class="hljs-title function_">height</span>(<span class="hljs-number">50</span>)<br>        .<span class="hljs-title function_">fontSize</span>(<span class="hljs-number">30</span>)<br>        .<span class="hljs-title function_">fontColor</span>(<span class="hljs-string">&#x27;#323232&#x27;</span>)<br>        .<span class="hljs-title function_">enabled</span>(<span class="hljs-literal">false</span>)<br>        .<span class="hljs-title function_">textAlign</span>(<span class="hljs-title class_">TextAlign</span>.<span class="hljs-property">Center</span>)<br>        .<span class="hljs-title function_">border</span>(&#123;<br>        <span class="hljs-attr">style</span>: <span class="hljs-title class_">BorderStyle</span>.<span class="hljs-property">Solid</span>,<br>        <span class="hljs-attr">width</span>: &#123; <span class="hljs-attr">bottom</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>.<span class="hljs-property">length</span>==item ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span> &#125;,<br>        <span class="hljs-attr">color</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputStr</span>.<span class="hljs-property">length</span>==item ? <span class="hljs-string">&#x27;#018576&#x27;</span> : <span class="hljs-string">&#x27;#bdbdbd&#x27;</span><br>        &#125;);<br>    &#125;);<br>&#125;<br>.<span class="hljs-title function_">width</span>(<span class="hljs-string">&#x27;100%&#x27;</span>) .<span class="hljs-title function_">onAppear</span>(<span class="hljs-keyword">async</span> ()=&gt;&#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">attach</span>(<span class="hljs-literal">true</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">textConfig</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">bindKeyboardEvent</span>()<br>    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error:BusinessError</span>)=&gt;</span>&#123;<br>    hilog.<span class="hljs-title function_">error</span>(<span class="hljs-number">0x01</span>,<span class="hljs-string">&quot;RecordKeyboardInputPage&quot;</span>,<span class="hljs-string">&quot;输入法绑定出错&quot;</span>)<br>    &#125;)<br>&#125;)<br>.<span class="hljs-title function_">onDisAppear</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">unbindKeyboardEvent</span>()<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这样我们就完成了一个基础的验证码输入框的功能。<br>哦，还少一个输入完成的回调，这个简单，就在订阅键盘的<code>insertText</code>事件回调里面判断一个字符串长度仿照上一篇做个回调就好了，这里就不再重复说明了。</p>
<h2 id="使用canvas自绘制"><a href="#使用canvas自绘制" class="headerlink" title="使用canvas自绘制"></a>使用canvas自绘制</h2><p>这个就是闲着写出来的玩的，一般也不会选择这种方案来实现。<br>接着上面的内容，同样的方法记录下键盘的输入内容，在<code>insertText</code>事件回调里面通知 canvas 进行绘制</p>
<h3 id="过程拆解"><a href="#过程拆解" class="headerlink" title="过程拆解"></a>过程拆解</h3><p>大致上分为两步，画文字，画背景。<br>这里背景就简单的设置为下划线，使用不同颜色来区分是不是焦点(当前需要输入的)。还是以 <code>4</code> 位验证码为例，画布宽度减去三个间隔后再除以 4，就是每条下划线的长度。<br>起点坐标为<code>((lineLength+space)*i,canvasHeight-2)</code>,终点坐标为<code>((lineLength+space)*i+lineLength,canvasHeight-2)</code><br>文字的中心 x 坐标应当和下划线的中心坐标 x 相同，这样画出的字才不会偏。<br>我们可以使用<code>CanvasRenderingContext2D.measureText(text:string)</code>来测量文字尺寸，然后计算出来文字的坐标。这里还得提醒一下，<code>CanvasRenderingContext2D.fillText</code>绘制文字时传入的坐标是文字的左下角坐标，别搞错了。</p>
<h4 id="第一步：画布参数、需要的变量"><a href="#第一步：画布参数、需要的变量" class="headerlink" title="第一步：画布参数、需要的变量"></a>第一步：画布参数、需要的变量</h4><p>需要记录画布大小已经绘制需要要的参数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br><span class="hljs-keyword">private</span> canvasWidth = <span class="hljs-number">0</span><br><span class="hljs-keyword">private</span> canvasHeight = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>拆出来画背景和画文字的方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">drawText</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-title function_">drawUnderLine</span>(<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>在输入内容发生变化的时候，我们需要调用<code>drawText()</code>和<code>drawUnderLine()</code>方法进行绘制，并且判断输入的文字长度是否为指定长度，打到指定长度后进行回调。这里抽出来方法</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">onInputChange</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">reset</span>()<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawUnderLine</span>()<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawText</span>()<br>  <span class="hljs-comment">// 输入给定位数后做一些操作</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>.<span class="hljs-property">length</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">codeLength</span>) &#123;<br>    promptAction.<span class="hljs-title function_">showToast</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">`输入的验证码是--&gt;<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.verifyCodeStr&#125;</span>`</span> &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在键盘的的<code>insertText</code>和<code>deleteLeft</code>事件监听中调用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;insertText&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">text: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span> += text;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onInputChange</span>()<br>&#125;);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">inputController</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;deleteLeft&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onInputChange</span>()<br>&#125;);<br></code></pre></td></tr></table></figure>

<h4 id="画背景"><a href="#画背景" class="headerlink" title="画背景"></a>画背景</h4><p>这里就按照上面拆解过程中画线的方法绘制就行了</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">drawUnderLine</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//每个下划线长度</span><br>  <span class="hljs-keyword">let</span> lineWidth = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> - (<span class="hljs-variable language_">this</span>.<span class="hljs-property">codeLength</span> - <span class="hljs-number">1</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span>) / <span class="hljs-number">4</span><br>  <span class="hljs-comment">//画出下划线</span><br>  <span class="hljs-keyword">let</span> y = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> - <span class="hljs-number">2</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">codeLength</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>.<span class="hljs-property">length</span> ==  i) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#39D167&quot;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">3</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">strokeStyle</span> = <span class="hljs-string">&quot;#999999&quot;</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">lineWidth</span> = <span class="hljs-number">2</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> startX = (lineWidth + <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span>) * i<br>    <span class="hljs-keyword">let</span> endX = lineWidth + (lineWidth + <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span>) * i<br>    path.<span class="hljs-title function_">moveTo</span>(startX, y)<br>    path.<span class="hljs-title function_">lineTo</span>(endX, y)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">stroke</span>(path)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里也有需要注意的点，划线时我是用的<code>Path2D</code>路径对象保存的下划线信息而不是直接使用<code>CanvasRenderingContext2D.lineTo(x: number, y: number)</code>这样方法。这是因为后者有一些意想不到的问题：比如调用<code>this.CanvasRenderingContext2D.clearRect()</code>后再调用<br><code>CanvasRenderingContext2D.stroke()</code>,你会发现被 clear 的区域又回来了。<br>在上面这个循环中，虽然我们设置了不同的颜色及宽度，但当我们输入第二个文字时，会发现第一个下划线被绘制了两遍，而且是不同颜色叠加在一起。有兴趣的可以自己试一下，不知道是我的写法有问题还是对文档的理解有问题，还是其他原因就不得而知了</p>
<h4 id="画文字"><a href="#画文字" class="headerlink" title="画文字"></a>画文字</h4><p>这个也不复杂</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">drawText</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//每个下划线长度</span><br>  <span class="hljs-keyword">let</span> lineWidth = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> - (<span class="hljs-variable language_">this</span>.<span class="hljs-property">codeLength</span> - <span class="hljs-number">1</span>) * <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span>) / <span class="hljs-number">4</span><br>  <span class="hljs-comment">//绘制的文字大小和颜色</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">&quot;#666666&quot;</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">font</span> = <span class="hljs-string">&quot;30vp&quot;</span><br>  <span class="hljs-comment">//文字和下划线的距离</span><br>  <span class="hljs-keyword">let</span> y = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> - <span class="hljs-number">6</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">codeLength</span> &amp;&amp; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-comment">//在每个下划线的中心画数字：（线长的一半+线的起点 - 文字宽度的一半)</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">result</span>: <span class="hljs-title class_">TextMetrics</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">measureText</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>[i])<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fillText</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">verifyCodeStr</span>[i],<br>      lineWidth / <span class="hljs-number">2</span> + (lineWidth + <span class="hljs-variable language_">this</span>.<span class="hljs-property">hSpace</span>) * i - result.<span class="hljs-property">width</span> / <span class="hljs-number">2</span>, y)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们就完成了使用 canvas 绘制的验证码输入框</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么样，验证码输入框是不是看上去很简单，实际上一点也不难？<br>只要有了思路，拆解成小步骤，然后又一步步实现就好了。</p>
<p>个人认为常用的就是上一篇的<code>TextInput</code>方案和本篇的<code>Text</code>方法， canvas 自绘制一般真用不到，除非是一些奇形怪状的需求</p>
<hr>
<p><strong>最后还得吐槽一下，鸿蒙的接口参数中有很多很多需要这种硬编码的配置，搞的很烦，就不能用个常量或者枚举值代替一下么???</strong></p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙ArkUI-X 跨平台通信：从入土到复活</title>
    <url>/2024/03/27/%E9%B8%BF%E8%92%99ArkUI-X-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%80%9A%E4%BF%A1%EF%BC%9A%E4%BB%8E%E5%85%A5%E5%9C%9F%E5%88%B0%E5%A4%8D%E6%B4%BB/</url>
    <content><![CDATA[<hr>
<p>2024.01.31 更新<br>在上一篇 <a href="https://juejin.cn/post/7327910163628294154">鸿蒙跨平台 ArkUI-X从入门到入土 </a>中提到创建 Bridge 对象时失败的问题，在本文中提到的问题又重新验证了几次，咨询了一下相关人员，结论是这样的</p>
<ol>
<li>在 Arkui-X 中，如果 Bridge 对象声明为成员变量并且立即创建，这时候 preview 会白屏，是加载界面时就挂了，因为这个bridge对象，是需要 native 侧的文件支持的，比如Android中的libbridge.so(集成产物到 Android 工程时复制过去的)。这时候集成到 Android 工程中是正常运行的。</li>
<li>DevEco 中的 preview 相当于纯鸿蒙系统(HarmonyOS next),在纯鸿蒙系统中是无法使用Bridge 的，因为纯鸿蒙上没有这个 so 库。所以在创建这个 Bridge 对象的时候需要判断一下是不是跨平台，一般从deviceInfo.osFullName判断：<br><code>let osName: string = deviceInfo.osFullName;</code>获取对应OS名字，该接口已支持跨平台，不同平台上其返回值如下:</li>
</ol>
<ul>
<li>OpenHarmony上，osName等于<code>OpenHarmony XXX</code></li>
<li>Android上，osName等于<code>Android XXX</code></li>
<li>iOS上，osName等于<code>iOS XXX</code><br>具体文档在这里 <a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/quick-start/platform-different-introduction.md#%E5%B9%B3%E5%8F%B0%E5%B7%AE%E5%BC%82%E5%8C%96">平台差异化</a></li>
</ul>
<hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>话说前两天刚调研了 ArkUI-X 跨平台方案，最终卡死在了跨平台和 native 通信上，文章在这里<a href="https://juejin.cn/post/7327910163628294154">鸿蒙跨平台 ArkUI-X从入门到入土</a>，今天在社区的帮助下跑通了通信方案，该挖出来复活了。<br><strong>注意文章所说的官方是指社区，并不是指华为公司，更不是其他</strong></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>这里只对 Android 侧进行了实现，iOS 侧因为没有实体机的原因，先放一放，原理都一样，代码也差不多。官方文档先放在这里了 <a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/tutorial/how-to-use-bridge-on-android.md#%E5%B9%B3%E5%8F%B0%E6%A1%A5%E6%8E%A5%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97">平台桥接开发指南</a></p>
<blockquote>
<p>平台桥接用于客户端（ArkUI）和平台（Android或iOS）之间传递消息，即用于ArkUI与平台双向数据传递、ArkUI侧调用平台的方法、平台调用ArkUI侧的方法。本文主要介绍Android平台与ArkUI交互，ArkUI侧具体用法请参考<a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/reference/apis/js-apis-bridge.md">Bridge API</a>，Android侧参考<a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/reference/arkui-for-android/BridgePlugin.md">BridgePlugin</a>。</p>
</blockquote>
<p>官方在 Android 侧提供了一个抽象类<code>BridgePlugin</code>，我们需要继承它实现一些方法来进行通信。在 ArkUI-X 侧同样提供了<code>&#39;@arkui-x.bridge</code>包来进行通信。</p>
<h4 id="ArkUI-X-侧-Bridge"><a href="#ArkUI-X-侧-Bridge" class="headerlink" title="ArkUI-X 侧 Bridge"></a>ArkUI-X 侧 Bridge</h4><p>先看下ArkUI-X 侧提供的方案，官方文档在这里 <a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/reference/apis/js-apis-bridge.md#arkui-xbridgedts-%E5%B9%B3%E5%8F%B0%E6%A1%A5%E6%8E%A5">@arkui-x.bridge.d.ts (平台桥接)</a>。<br>在官方提供的<a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/tutorial/how-to-use-bridge-on-android.md#%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B">场景示例中</a>中，是在页面(也就是被<code>@Entry</code>装饰的类)中创建的，但是在实践中发现不能正常运行，会创建 Bridge 对象时会报错</p>
<blockquote>
<p>Error message: Cannot read property createBridge of undefined</p>
</blockquote>
<p>指向了<code>private bridgeImpl = bridge.createBridge(&#39;Bridge&#39;);</code>这一行代码，向官方提交了 issue，在其帮助下，将创建 Bridge 对象的代码放在了另外的 ets 文件中可以正常运行。</p>
<h5 id="创建-Bridge"><a href="#创建-Bridge" class="headerlink" title="创建 Bridge"></a>创建 Bridge</h5><p>先导包 <code>import Bridge from &#39;@arkui-x.bridge&#39;;</code><br>再创建<code> bridgeObj: BridgeObject = Bridge.createBridge(&#39;Bridge&#39;);</code><br>需要注意的是，这里传入的参数值需要<strong>和 native 侧一致，否则无法调用</strong>。 </p>
<h4 id="Android-侧-BridgePlugin"><a href="#Android-侧-BridgePlugin" class="headerlink" title="Android 侧 BridgePlugin"></a>Android 侧 BridgePlugin</h4><p>看先 Android 侧提供的方案，官方文档在这里 <a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/reference/arkui-for-android/BridgePlugin.md#bridgeplugin-%E5%B9%B3%E5%8F%B0%E6%A1%A5%E6%8E%A5">BridgePlugin (平台桥接)</a> 。<br>暴露的 api 也不多，包括构造方法、callMethod、sendMessage，两个回调监听：setMessageListener和setMethodResultListener。</p>
<h5 id="创建-BridgePlugin"><a href="#创建-BridgePlugin" class="headerlink" title="创建 BridgePlugin"></a>创建 BridgePlugin</h5><p>一般来讲，我们会自己写个类继承<code>BridgePlugin</code>来进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArkUIBridge</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BridgePlugin</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ArkUIBridge&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArkUIBridge</span><span class="hljs-params">(Context context, String bridgeName, <span class="hljs-type">int</span> instanceId)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, bridgeName, instanceId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意这里的<code>bridgeName</code>参数，传入的值<strong>必须</strong>与 ArkUI-X 侧一致，至于 instanceId 则是<code>StageActivity</code>这个用来展示 ArkUI-X 内容的容器提供的方法，其实也就是调用的<code>InstanceIdGenerator.getAndIncrement()</code>，具体实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> ohos.stage.ability.adapter;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceIdGenerator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ID_GENERATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">InstanceIdGenerator</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ID_GENERATOR.getAndIncrement();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ID_GENERATOR.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以在其他位置调用<code>InstanceIdGenerator.get()</code>来获取到 id。但需要注意，每次创建 ArkUI-X 产物的容器页面也就是StageActivity时，该 id 都会自增，如果 id 无法对应则无法互相通信</p>
<h4 id="ArkUI侧向Android侧传递数据"><a href="#ArkUI侧向Android侧传递数据" class="headerlink" title="ArkUI侧向Android侧传递数据"></a>ArkUI侧向Android侧传递数据</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">// xxx.ets</span><br>bridgeImpl.<span class="hljs-title function_">sendMessage</span>(<span class="hljs-string">&#x27;text&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 监听Android侧的回执</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;response: &#x27;</span> + res);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error: &#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(err));<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>在 Android 侧接收消息,在构造方法里面设置一下监听事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//ArkUIBridge extends BridgePlugin</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArkUIBridge</span><span class="hljs-params">(Context context, String bridgeName, <span class="hljs-type">int</span> instanceId)</span> &#123;<br>    <span class="hljs-built_in">super</span>(context, bridgeName, instanceId);<br>    setMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IMessageListener</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">onMessage</span><span class="hljs-params">(Object o)</span> &#123;<br>            Log.e(TAG,<span class="hljs-string">&quot;onMessage--&gt;&quot;</span> + o.toString());<br>            <span class="hljs-type">JSONObject</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>            <span class="hljs-keyword">try</span> &#123;<br>                result.put(<span class="hljs-string">&quot;platform&quot;</span>,<span class="hljs-string">&quot;Android&quot;</span>);<br>                result.put(<span class="hljs-string">&quot;result_code&quot;</span>,<span class="hljs-number">0</span>);<br>            &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> result.toString();<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessageResponse</span><span class="hljs-params">(Object o)</span> &#123;<br>            Log.e(TAG,<span class="hljs-string">&quot;onMessageResponse--&gt;&quot;</span> + o.toString());<br>        &#125;<br>    &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h4 id="Android侧向ArkUI-X侧传递数据"><a href="#Android侧向ArkUI-X侧传递数据" class="headerlink" title="Android侧向ArkUI-X侧传递数据"></a>Android侧向ArkUI-X侧传递数据</h4><p>方式都一样，需要在 ArkUI-X 侧设置一下监听事件</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">bridge</span> = <span class="hljs-title class_">Bridge</span>.<span class="hljs-title function_">createBridge</span>(<span class="hljs-string">&#x27;BridgeCommon&#x27;</span>);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">bridge</span>!.<span class="hljs-title function_">setMessageListener</span>(<span class="hljs-function">(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (message) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`receive message：<span class="hljs-subst">$&#123;message&#125;</span>`</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">scanResult</span> = message<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ArkUI-X setMessageListener&quot;</span>;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>在 Android 侧，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">////ArkUIBridge extends BridgePlugin</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessageToArkUI</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        jsonObject.put(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;扫描结果&quot;</span>);<br>        jsonObject.put(<span class="hljs-string">&quot;data&quot;</span>,<span class="hljs-string">&quot;scan result from Android&quot;</span>);<br><br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    Log.e(TAG,<span class="hljs-string">&quot;toScan before sendMessage&quot;</span> );<br>    sendMessage(jsonObject.toString());<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>需要注意的是，在 Android 中调用 sendMessage 方法是没有返回值的，ArkUI-X 侧收到消息后的返回值是在<code>setMessageListener</code>的<code>onMessageResponse</code>回调中接收的。</p>
<h4 id="ArkUI-X-侧调用-Android-侧的方法"><a href="#ArkUI-X-侧调用-Android-侧的方法" class="headerlink" title="ArkUI-X 侧调用 Android 侧的方法"></a>ArkUI-X 侧调用 Android 侧的方法</h4><p>在 ArkUI-X 中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">async</span> <span class="hljs-title function_">getAppVersion</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt; &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initBridge</span>();<span class="hljs-comment">//创建 bridge 对象</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">params</span>:<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">Parameter</span>&gt; =&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;xuan&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span><br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bridge</span>!.<span class="hljs-title function_">callMethod</span>(<span class="hljs-string">&#x27;getAppVersion&#x27;</span>,params);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;getAppVersion返回值：&#x27;</span> + result)<br>  <span class="hljs-keyword">return</span> result!.<span class="hljs-title function_">toString</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>在 Android</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAppVersion</span><span class="hljs-params">(JSONObject params)</span>&#123;<br>    Log.e(TAG,<span class="hljs-string">&quot;getAppVersion from arkui-x，params--&gt; &quot;</span>  );<br>    <span class="hljs-keyword">if</span>(params == <span class="hljs-literal">null</span>)&#123;<br>        Log.e(TAG,<span class="hljs-string">&quot;is null&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        Log.e(TAG,params.toString());<br>    &#125;<br>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        jsonObject.put(<span class="hljs-string">&quot;version&quot;</span>,BuildConfig.VERSION_NAME);<br>        jsonObject.put(<span class="hljs-string">&quot;buildVersion&quot;</span>,<span class="hljs-string">&quot;getAppVersion(Object params)&quot;</span>);<br><br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> jsonObject.toString();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>需要注意的是，两侧都不支持方法重载，在 Android 侧是通过 HashMap 保存的在 BridgePlugin 中的方法并且是以方法名为 key，java.lang.reflect.Method为值。在 Android 侧的方法会被自动注册，不需要我们调用代码注册。</p>
<h4 id="Android-侧调用-ArkUI-X-侧-的方法"><a href="#Android-侧调用-ArkUI-X-侧-的方法" class="headerlink" title="Android 侧调用 ArkUI-X 侧 的方法"></a>Android 侧调用 ArkUI-X 侧 的方法</h4><p>在 ArkUI-X 中，需要自己调用registerMethod方法来注册供 native 调用的方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-comment">//方法声明</span><br><span class="hljs-title function_">getString</span>(parameters?: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">Message</span>&gt;):<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">ResultValue</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`----调用 getString：parameters--&gt;<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(parameters)&#125;</span>`</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;call js getString success&#x27;</span>;<br>&#125;<br><span class="hljs-comment">//注册方法</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">bridge</span>!.<span class="hljs-title function_">registerMethod</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;getString&quot;</span>,<span class="hljs-attr">method</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">getString</span>&#125;)<br></code></pre></td></tr></table></figure>
<p>在 Android 侧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-type">JSONObject</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    params.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;xuan&quot;</span>);<br>    params.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">18</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br>Object[] paramObject = &#123;params&#125;;<br><span class="hljs-type">MethodData</span> <span class="hljs-variable">methodData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodData</span>(<span class="hljs-string">&quot;getString&quot;</span>, paramObject);<br>callMethod(methodData);<br></code></pre></td></tr></table></figure>
<p>同样的，Android 调用 ArkUI 的方法并没有返回值，需要在<code>setMethodResultListener</code>的<code>onSuccess</code>方法中获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//设置调用 ArkUI-X 方法的结果回调</span><br>setMethodResultListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IMethodResult</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(Object o)</span> &#123;<br>        Log.e(TAG,<span class="hljs-string">&quot;IMethodResult#onSuccess--&gt;&quot;</span> +o.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i, String s1)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMethodCancel</span><span class="hljs-params">(String s)</span> &#123;<br><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>


<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="BridgePlugin-中提供给-ArkUI-X-调用的方法不支持方法重载"><a href="#BridgePlugin-中提供给-ArkUI-X-调用的方法不支持方法重载" class="headerlink" title="BridgePlugin 中提供给 ArkUI-X 调用的方法不支持方法重载"></a>BridgePlugin 中提供给 ArkUI-X 调用的方法不支持方法重载</h4><p>原因上面也说了，是因为保存的时候是用方法名作为 key 保存在 HashMap 中的，重载也没用，虽然写了不报错，但结果不保证。也看一下为啥 Android 不用自己写代码注册供 ArkUI-X调用的方法。<br>在<code>ohos.ace.adapter.capability.bridge.BridgePlugin</code>这个类中，重点关注<code>HashMap&lt;String, Method&gt; methodsMap_</code>这个成员变量和这几个方法：  </p>
<ul>
<li>protected Object jsCallMethod(Object object, MethodData methodData) </li>
<li>private Method findMethod(String methodName)</li>
<li>private void registerMethod(String methodName, Method methods)</li>
</ul>
<p>当 ArkUI-X 调用 Android 方法时，首先调用的是<code>jsCallMethod</code>，在<code>jsCallMethod</code>中首先调用<code>findMethod</code>方法从<code>methodsMap_</code>中获取对应的方法，找了则直接调用。没找到则反射获取 BridgePlugin 实现类中的方法，然后使用方法名做匹配，找到对应的方法。到这里也就解释了为啥不支持方法重载。也解释了为啥方法参数对应不上会有异常。<br>cpp 的源码在 <a href="https://gitee.com/arkui-x/arkui_for_android/tree/master/capability/java/jni/bridge">https://gitee.com/arkui-x/arkui_for_android&#x2F;tree&#x2F;master&#x2F;capability&#x2F;java&#x2F;jni&#x2F;bridge</a><br>Java 源码在 <a href="https://gitee.com/arkui-x/arkui_for_android/tree/master/capability/java/src/ohos/ace/adapter/capability/bridge">https://gitee.com/arkui-x/arkui_for_android&#x2F;tree&#x2F;master&#x2F;capability&#x2F;java&#x2F;src&#x2F;ohos&#x2F;ace&#x2F;adapter&#x2F;capability&#x2F;bridge</a></p>
<p><img src="/image/HarmonyOS/arkui-x_debug.png" alt="image.png"></p>
<h4 id="参数类型对应关系"><a href="#参数类型对应关系" class="headerlink" title="参数类型对应关系"></a>参数类型对应关系</h4><p>Arkui-X 中callMethod是这么声明的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">callMethod</span>(<span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, parameters?: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">Parameter</span>&gt;):<br><span class="hljs-title function_">callMethod</span>(<span class="hljs-attr">methodName</span>: <span class="hljs-built_in">string</span>, ...<span class="hljs-attr">parameters</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">ResultValue</span>&gt;;<br></code></pre></td></tr></table></figure>
<p>sendMessage是这么声明的</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">sendMessage</span>(<span class="hljs-attr">message</span>: <span class="hljs-title class_">Message</span>, <span class="hljs-attr">callback</span>: <span class="hljs-title class_">AsyncCallback</span>&lt;<span class="hljs-title class_">Response</span>&gt;): <span class="hljs-built_in">void</span>;<br><span class="hljs-title function_">sendMessage</span>(<span class="hljs-attr">message</span>: <span class="hljs-title class_">Message</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt;;<br></code></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">type</span> S = <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span> | <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">type</span> T = S | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">boolean</span>&gt; | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Message</span> = T | <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, T&gt;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Parameter</span> = <span class="hljs-title class_">Message</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Response</span> = <span class="hljs-title class_">Message</span>;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">ResultValue</span> = T | <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, T&gt;;<br></code></pre></td></tr></table></figure>
<p>在 Android 中sendMessage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(Object data)</span>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>callMethod</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callMethod</span><span class="hljs-params">(MethodData methodData)</span><br></code></pre></td></tr></table></figure>
<p>而 MethodData 只有两个成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodData</span> &#123;<br>    <span class="hljs-keyword">private</span> String methodName_;<br>    <span class="hljs-keyword">private</span> Object[] Parameters_;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MethodData</span><span class="hljs-params">(String methodName, Object[] parameter)</span> &#123;<br>        <span class="hljs-built_in">this</span>.methodName_ = methodName;<br>        <span class="hljs-built_in">this</span>.Parameters_ = parameter;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMethodName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.methodName_;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object[] getMethodParameter() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.Parameters_;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>那么在使用的时候可以这样:  </p>
<h5 id="ArkUI-X主动调用-Android"><a href="#ArkUI-X主动调用-Android" class="headerlink" title="ArkUI-X主动调用 Android"></a>ArkUI-X主动调用 Android</h5><p>在 ArkUI-X 中调用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">params</span>:<span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">Parameter</span>&gt; =&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;xuan&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">18</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bridge</span>!.<span class="hljs-title function_">callMethod</span>(<span class="hljs-string">&#x27;getAppVersion&#x27;</span>,params);<br><br></code></pre></td></tr></table></figure>
<p>在 Android 端对应参数类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAppVersion</span><span class="hljs-params">(JSONObject params)</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="Android-主动调用-ArkUI-X"><a href="#Android-主动调用-ArkUI-X" class="headerlink" title="Android 主动调用 ArkUI-X"></a>Android 主动调用 ArkUI-X</h5><p>在 Android 中调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-type">JSONObject</span> <span class="hljs-variable">params</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    params.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;xuan&quot;</span>);<br>    params.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">18</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br>Object[] paramObject = &#123;params&#125;;<br><span class="hljs-type">MethodData</span> <span class="hljs-variable">methodData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodData</span>(<span class="hljs-string">&quot;getString&quot;</span>, paramObject);<br>callMethod(methodData);<br></code></pre></td></tr></table></figure>
<p>在 ArkUI-X 中对应类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">getString</span>(parameters?: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>,<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">Message</span>&gt;):<span class="hljs-title class_">Bridge</span>.<span class="hljs-property">ResultValue</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`----调用 getString：parameters--&gt;<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(parameters)&#125;</span>`</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;call js getString success&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="BrigePlugin的bridgeType"><a href="#BrigePlugin的bridgeType" class="headerlink" title="BrigePlugin的bridgeType_"></a>BrigePlugin的bridgeType_</h4><p>BrigePlugin提供了一个可以指定<code>bridgeType_</code>的构造方法，<br><img src="/image/HarmonyOS/arkui-x_bridge_type.png" alt="image.png"><br>如果我们不指定类型的话，默认就是 <code>BridgeType.JSON_TYPE</code>，传一些非二进制的数据。但假如我们需要穿一些二进制数据，比如图片、音视频数据等，可以指定为<code>BridgeType.BINARY_TYPE</code>。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙应用开发使用canvas实现球面运动动画</title>
    <url>/2023/12/24/%E9%B8%BF%E8%92%99%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8canvas%E5%AE%9E%E7%8E%B0%E7%90%83%E9%9D%A2%E8%BF%90%E5%8A%A8%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>习惯了 Android 的 Canvas,用鸿蒙的 canvas 多少有点别扭<br>效果图<br><img src="/image/HarmonyOS/canvas_ball_animation.gif" alt="canvas_ball_animation.gif"><br>上面的图是用 transform 属性做的动画<br>下面的图是用 canvas 画的，参考自<a href="https://mp.weixin.qq.com/s/p_gy8s1SqPUTAa3wCIk7FQ">https://mp.weixin.qq.com/s/p_gy8s1SqPUTAa3wCIk7FQ</a></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>众所周知，我们在手机或者平板上看到的 3D 动画只是在二维的投影，我们只需要计算好运动物体的大小和位置的对应关系，就可以实现类似 3D 的效果。想要了解具体的算法以及映射关系，可以阅读原文。<br>根据参考文章中的计算方式，我们只需要移植一下就行。这里是根据<code>总结</code>中的代码实现的<br>原文中的关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-type">double</span> <span class="hljs-variable">xr</span> <span class="hljs-operator">=</span> Math.toRadians(<span class="hljs-number">5</span>);  <span class="hljs-comment">//绕x轴旋转则把这个值设置为大于 0</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">yr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//绕y轴旋转则把这个值设置为大于 0;  </span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">zr</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//绕z轴旋转则把这个值设置为大于 0;  </span><br><br><span class="hljs-comment">//保存小球的位置、颜色及缩放</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> color;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> x;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> y;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> z;   <br>        <span class="hljs-keyword">private</span> <span class="hljs-type">float</span> <span class="hljs-variable">scale</span> <span class="hljs-operator">=</span> <span class="hljs-number">1f</span>;  <br>    &#125;<br><span class="hljs-comment">//pointList 保存的是随机生成的小球相关信息</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pointList.size(); i++) &#123;  <br>  <br>            <span class="hljs-type">Point</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> pointList.get(i);  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> point.x;  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> point.y;  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> point.z;  <br>  <br>            <span class="hljs-comment">//绕X轴旋转，乘以X轴的旋转矩阵  </span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">rx1</span> <span class="hljs-operator">=</span> x;  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">ry1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (y * Math.cos(xr) + z * -Math.sin(xr));  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">rz1</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (y * Math.sin(xr) + z * Math.cos(xr));  <br>  <br>            <span class="hljs-comment">// 绕Y轴旋转,乘以Y轴的旋转矩阵  </span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">rx2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (rx1 * Math.cos(yr) + rz1 * Math.sin(yr));  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">ry2</span> <span class="hljs-operator">=</span> ry1;  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">rz2</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (rx1 * -Math.sin(yr) + rz1 * Math.cos(yr));  <br>  <br>            <span class="hljs-comment">// 绕Z轴旋转,乘以Z轴的旋转矩阵  </span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">rx3</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (rx2 * Math.cos(zr) + ry2 * -Math.sin(zr));  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">ry3</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>) (rx2 * Math.sin(zr) + ry2 * Math.cos(zr));  <br>            <span class="hljs-type">float</span> <span class="hljs-variable">rz3</span> <span class="hljs-operator">=</span> rz2;  <br>  <br>  <br>            point.x = rx3;  <br>            point.y = ry3;  <br>            point.z = rz3;  <br>  <br>            <span class="hljs-comment">// 透视除法，z轴向内的方向  </span><br>            <span class="hljs-type">float</span> <span class="hljs-variable">scale</span> <span class="hljs-operator">=</span> (<span class="hljs-number">2</span> * radius) / ((<span class="hljs-number">2</span> * radius) + rz3);  <br>            point.scale = scale;  <br>        <span class="hljs-comment">//到这里就完成了小球位置的计算，接下来就是需要定时更新上面xr、yr、zr的值就可以实现小球沿球面运动了</span><br>  <br>        &#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="鸿蒙-transform-实现"><a href="#鸿蒙-transform-实现" class="headerlink" title="鸿蒙 transform 实现"></a>鸿蒙 transform 实现</h3><p>清楚了原理及计算方式，实现起来就简单了<br>先 stack 堆叠两个圆球，小球需要不断运动，x、y、z需要一直变化，使用<code>@State</code>修饰一下。值的变化过程就用上面原文中的计算方法。定时更新就用<code>setInterval</code>,组件的位移变化给我们提供了<code>transform</code>方法，需要一个<code>matrix4</code>对象，移动变化也不需要我们去填充矩阵，有对应的<code>translate</code>方法，组合起来代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">import</span> matrix4 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos.matrix4&#x27;</span><br><br><span class="hljs-meta">@Preview</span><br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">AnimationOfSphericalPaths</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">angleX</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">translateX</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">translateY</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">translateZ</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">ballRadius</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">30</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">timerInterval</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> radius = <span class="hljs-number">200</span><br>  <span class="hljs-keyword">private</span> a = <span class="hljs-number">90</span><br>  <span class="hljs-keyword">private</span> b = <span class="hljs-number">0</span><br><br><br>  <span class="hljs-title function_">toRadians</span>(degrees): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> degrees * (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">changeAngle</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> += <span class="hljs-number">3</span><br>    <span class="hljs-comment">// this.a += 3</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> &gt; <span class="hljs-number">360</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> - <span class="hljs-number">360</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> &gt; <span class="hljs-number">360</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> - <span class="hljs-number">360</span><br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateX</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>)) * <span class="hljs-number">2</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateY</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>)) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>)) * <span class="hljs-number">2</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateZ</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>)) * <span class="hljs-number">2</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ballRadius</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateZ</span> / <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">10</span> + <span class="hljs-number">50</span><br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`translateX-&gt; <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.translateX&#125;</span> ,translateY-&gt; <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.translateY&#125;</span> ,translateZ-&gt; <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.translateZ&#125;</span>`</span>)<br><br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-title class_">Stack</span>() &#123;<br>        <span class="hljs-title class_">Circle</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span>, <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span> &#125;).<span class="hljs-title function_">fill</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Yellow</span>)<br>        <span class="hljs-title class_">Circle</span>(&#123; <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">ballRadius</span>, <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">ballRadius</span> &#125;).<span class="hljs-title function_">fill</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">Pink</span>)<br>          .<span class="hljs-title function_">transform</span>(matrix4.<span class="hljs-title function_">identity</span>().<span class="hljs-title function_">translate</span>(&#123; <span class="hljs-attr">x</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateX</span>, <span class="hljs-attr">y</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateY</span>, <span class="hljs-attr">z</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">translateZ</span> &#125;))<br>      &#125;.<span class="hljs-title function_">alignContent</span>(<span class="hljs-title class_">Alignment</span>.<span class="hljs-property">Center</span>).<span class="hljs-title function_">width</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span>).<span class="hljs-title function_">height</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">radius</span> * <span class="hljs-number">2</span>)<br><br>      <span class="hljs-title class_">Row</span>() &#123;<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;start&quot;</span>)<br>          .<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerInterval</span> &gt; <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">return</span><br>            &#125;<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerInterval</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">changeAngle</span>()<br><br>            &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">20</span>)<br>          &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;stop&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timerInterval</span>)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">timerInterval</span> = <span class="hljs-number">0</span><br>        &#125;).<span class="hljs-title function_">margin</span>(&#123; <span class="hljs-attr">left</span>: <span class="hljs-number">48</span> &#125;)<br>      &#125;.<span class="hljs-title function_">margin</span>(&#123; <span class="hljs-attr">top</span>: <span class="hljs-number">48</span> &#125;)<br><br>    &#125;.<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;100%&quot;</span>).<span class="hljs-title function_">backgroundColor</span>(<span class="hljs-title class_">Color</span>.<span class="hljs-property">White</span>)<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="鸿蒙canvas实现"><a href="#鸿蒙canvas实现" class="headerlink" title="鸿蒙canvas实现"></a>鸿蒙canvas实现</h3><p>需要注意的是，鸿蒙里面的 math 包下没有<code>toRadians</code>方法，需要我们自己实现一下</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title function_">toRadians</span>(degrees): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> degrees * (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>定时更新这里用了<code>setInterval</code><br>鸿蒙的 canvas 中也没有画笔的概念，需要设置<code>RenderingContextSettings</code>实例的填充方式及填充颜色<br>鸿蒙的 canvas 中也没有 drawcircle 方法，这里使用的是<code>Path2D</code>对象中画圆弧方法(arc)然后填充颜色的方式，需要注意是<code>Path2D.arc()</code>中的角度单位  </p>
<p>整体流程如下</p>
<ol>
<li>先生成随机的小球，分布在一个圆上generateBall()</li>
<li>计算小球的缩放比例及位置calculateRotateValue()</li>
<li>对小球排序，z 轴越大，越靠近我们，小球越大，越要遮盖住其他小球，越要最后画</li>
<li>所以先画背面的，再画正面的。这里的正面和背面是相对于中间的大球来说的，为了透视效果，背面的小球加上透明度，正面的小球不透明</li>
<li>定时更新就可以了</li>
</ol>
<p>下面是全部代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-meta">@Preview</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">export</span> struct <span class="hljs-title class_">CanvasBallAnimation</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">settings</span>: <span class="hljs-title class_">RenderingContextSettings</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RenderingContextSettings</span>(<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasRendering</span>: <span class="hljs-title class_">CanvasRenderingContext2D</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanvasRenderingContext2D</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">settings</span>)<br>  <span class="hljs-keyword">private</span> canvasWidth = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> canvasHeight = <span class="hljs-number">0</span><br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">canvasBallRoundRadius</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">canvasBallAnimationTimer</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">startDegree</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">5</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">xr</span>: <span class="hljs-built_in">number</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">toRadians</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">startDegree</span>)<br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">yr</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">zr</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-attr">pointList</span>: <span class="hljs-title class_">Point</span>[] = []<br><br>  <span class="hljs-title function_">toRadians</span>(degrees): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">return</span> degrees * (<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> / <span class="hljs-number">180</span>)<br>  &#125;<br><br>  <span class="hljs-title function_">canvasBallAnimation</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">startDegree</span> += <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">startDegree</span> &gt; <span class="hljs-number">360</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">startDegree</span> -= <span class="hljs-number">360</span><br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">clearRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateRotateValue</span>()<br>    <span class="hljs-comment">//排序，先画背面的，再画正面的</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">comparator</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawFrontBall</span>()<br><br>    <span class="hljs-comment">//在中间画一个大圆</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawCenterBall</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawBackBall</span>()<br><br><br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br><br><br>      <span class="hljs-title class_">Canvas</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>)<br>        .<span class="hljs-title function_">width</span>(<span class="hljs-string">&quot;100%&quot;</span>)<br>        .<span class="hljs-title function_">height</span>(<span class="hljs-string">&quot;40%&quot;</span>)<br>        .<span class="hljs-title function_">onAreaChange</span>(<span class="hljs-function">(<span class="hljs-params">oldValue: Area, newValue: Area</span>) =&gt;</span> &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">width</span>.<span class="hljs-title function_">toString</span>())<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> = <span class="hljs-built_in">parseInt</span>(newValue.<span class="hljs-property">height</span>.<span class="hljs-title function_">toString</span>())<br><br>          <span class="hljs-comment">//小球运动的半径</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>) / <span class="hljs-number">3</span><br>          <span class="hljs-comment">// this.canvasRendering.translate(this.canvasWidth / 2, this.canvasHeight / 2)</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">generateBall</span>()<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateRotateValue</span>()<br>          <span class="hljs-comment">//排序，先画背面的，再画正面的</span><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-title function_">sort</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">comparator</span>)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawFrontBall</span>()<br><br>          <span class="hljs-comment">//在中间画一个大圆</span><br>         <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawCenterBall</span>()<br><br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawBackBall</span>()<br><br><br>        &#125;)<br>      <span class="hljs-title class_">Row</span>() &#123;<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;canvas ball start&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallAnimationTimer</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span><br>          &#125;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallAnimationTimer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">canvasBallAnimation</span>()<br>          &#125;.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">20</span>)<br>        &#125;)<br>        <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;canvas ball end&quot;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallAnimationTimer</span>)<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallAnimationTimer</span> = <span class="hljs-number">0</span><br>        &#125;)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">comparator</span>(<span class="hljs-attr">left</span>: <span class="hljs-title class_">Point</span>, <span class="hljs-attr">right</span>: <span class="hljs-title class_">Point</span>): <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">if</span> (left.<span class="hljs-property">z</span> - right.<span class="hljs-property">z</span> &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (left.<span class="hljs-property">z</span> == right.<span class="hljs-property">z</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br>  &#125;<br><br>  <span class="hljs-title function_">randomColor</span>(): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">r</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">256</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">g</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">256</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">256</span>).<span class="hljs-title function_">toString</span>(<span class="hljs-number">16</span>)<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-string">`<span class="hljs-subst">$&#123;r&#125;</span><span class="hljs-subst">$&#123;g&#125;</span><span class="hljs-subst">$&#123;b&#125;</span>`</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`随机颜色--&gt; <span class="hljs-subst">$&#123;result&#125;</span>`</span>)<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br><br>  <span class="hljs-title function_">generateBall</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-property">length</span> == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">let</span> maxBallCount = <span class="hljs-number">10</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span> = []<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; maxBallCount; i++) &#123;<br><br>        <span class="hljs-keyword">let</span> v = -<span class="hljs-number">1.0</span> + (<span class="hljs-number">2.0</span> * i - <span class="hljs-number">1.0</span>) / maxBallCount;<br>        <span class="hljs-keyword">if</span> (v &lt; -<span class="hljs-number">1.0</span>) &#123;<br>          v = <span class="hljs-number">1.0</span><br>        &#125;<br><br>        <span class="hljs-keyword">let</span> delta = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">acos</span>(v)<br>        <span class="hljs-keyword">let</span> alpha = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sqrt</span>(maxBallCount * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) * delta<br>        <span class="hljs-keyword">let</span> point = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>()<br>        point.<span class="hljs-property">x</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(alpha) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(delta)<br>        point.<span class="hljs-property">y</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(alpha) * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(delta)<br>        point.<span class="hljs-property">z</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(delta)<br>        point.<span class="hljs-property">color</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">randomColor</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-title function_">push</span>(point)<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">calculateRotateValue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-property">length</span>; i++) &#123;<br><br>      <span class="hljs-keyword">let</span> point = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>[i];<br>      <span class="hljs-keyword">let</span> x = point.<span class="hljs-property">x</span>;<br>      <span class="hljs-keyword">let</span> y = point.<span class="hljs-property">y</span>;<br>      <span class="hljs-keyword">let</span> z = point.<span class="hljs-property">z</span>;<br><br>      <span class="hljs-comment">//绕X轴旋转，乘以X轴的旋转矩阵</span><br>      <span class="hljs-keyword">let</span> rx1 = x;<br>      <span class="hljs-keyword">let</span> ry1 = (y * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xr</span>) + z * -<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xr</span>));<br>      <span class="hljs-keyword">let</span> rz1 = (y * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xr</span>) + z * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">xr</span>));<br><br>      <span class="hljs-comment">// 绕Y轴旋转,乘以Y轴的旋转矩阵</span><br>      <span class="hljs-keyword">let</span> rx2 = (rx1 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yr</span>) + rz1 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yr</span>));<br>      <span class="hljs-keyword">let</span> ry2 = ry1;<br>      <span class="hljs-keyword">let</span> rz2 = (rx1 * -<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yr</span>) + rz1 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">yr</span>));<br><br>      <span class="hljs-comment">// 绕Z轴旋转,乘以Z轴的旋转矩阵</span><br>      <span class="hljs-keyword">let</span> rx3 = (rx2 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zr</span>) + ry2 * -<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zr</span>));<br>      <span class="hljs-keyword">let</span> ry3 = (rx2 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zr</span>) + ry2 * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">zr</span>));<br>      <span class="hljs-keyword">let</span> rz3 = rz2;<br><br><br>      point.<span class="hljs-property">x</span> = rx3;<br>      point.<span class="hljs-property">y</span> = ry3;<br>      point.<span class="hljs-property">z</span> = rz3;<br><br>      <span class="hljs-comment">// 透视除法，z轴向内的方向</span><br>      <span class="hljs-keyword">let</span> scale = (<span class="hljs-number">2</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span>) / ((<span class="hljs-number">2</span> * <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span>) + rz3);<br>      point.<span class="hljs-property">scale</span> = scale;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">drawFrontBall</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">let</span> point = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>[i];<br>      <span class="hljs-keyword">if</span> (point.<span class="hljs-property">z</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawBall</span>(point)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title function_">drawBall</span>(<span class="hljs-params">point: Point</span>) &#123;<br>    <span class="hljs-keyword">if</span> (point.<span class="hljs-property">scale</span> &gt; <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">`#FF<span class="hljs-subst">$&#123;point.color&#125;</span>`</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">let</span> fillColor = <span class="hljs-string">`#<span class="hljs-subst">$&#123; <span class="hljs-built_in">Math</span>.round(point.scale * <span class="hljs-number">255</span>).toString(<span class="hljs-number">16</span>)&#125;</span><span class="hljs-subst">$&#123;point.color&#125;</span>`</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span> = fillColor<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;填充颜色--&gt;&quot;</span> +fillColor)<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> ballPath2D = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>    ballPath2D.<span class="hljs-title function_">arc</span>(point.<span class="hljs-property">x</span> * point.<span class="hljs-property">scale</span> +<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span> / <span class="hljs-number">2</span> , point.<span class="hljs-property">y</span> * point.<span class="hljs-property">scale</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span> / <span class="hljs-number">2</span>, <span class="hljs-number">5</span> + <span class="hljs-number">25</span> * point.<span class="hljs-property">scale</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">beginPath</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>(ballPath2D)<br>  &#125;<br><br>  <span class="hljs-title function_">drawBackBall</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      <span class="hljs-keyword">let</span> point = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>[i];<br>      <span class="hljs-keyword">if</span> (point.<span class="hljs-property">z</span> &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">drawBall</span>(point)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">drawCenterBall</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> circlePath2D = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path2D</span>()<br>    circlePath2D.<span class="hljs-title function_">arc</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>/<span class="hljs-number">2</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>/<span class="hljs-number">2</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span>,<span class="hljs-number">0</span>,<span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">beginPath</span>()<br><br>    <span class="hljs-keyword">let</span> radialGradient = <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">createRadialGradient</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>/<span class="hljs-number">2</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>/<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasWidth</span>/<span class="hljs-number">2</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasHeight</span>/<span class="hljs-number">2</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasBallRoundRadius</span>)<br>    radialGradient.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">0.0</span>,<span class="hljs-string">&quot;#ff0000&quot;</span>)<br>    radialGradient.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">0.3</span>,<span class="hljs-string">&quot;#aaec5533&quot;</span>)<br>    radialGradient.<span class="hljs-title function_">addColorStop</span>(<span class="hljs-number">0.9</span>,<span class="hljs-string">&quot;#11000000&quot;</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-property">fillStyle</span>=radialGradient<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">canvasRendering</span>.<span class="hljs-title function_">fill</span>(circlePath2D)<br>  &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">z</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-attr">scale</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙应用开发踩坑记录</title>
    <url>/2023/11/29/%E9%B8%BF%E8%92%99%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>使用HarmonyOS4+ArkUI+Stage模型进行开发的翻译软件，目前只是半成品，代码写的很挫。记录一下开发过程中踩过的坑。<br>项目地址：<br>码云<br><a href="https://gitee.com/huangyuan/HarmonyTranslator">https://gitee.com/huangyuan/HarmonyTranslator</a><br>github<br><a href="https://github.com/huangyuanlove/HarmonyTranslator">https://github.com/huangyuanlove/HarmonyTranslator</a><br>码云项目是从github导入的，偶尔会忘记同步</p>
<h4 id="冻屏、黑屏、假死"><a href="#冻屏、黑屏、假死" class="headerlink" title="冻屏、黑屏、假死"></a>冻屏、黑屏、假死</h4><p>运行环境是MetaPadPro 2019 鸿蒙4.0.0，使用api9+stage模型开发，运行在模拟器上正常，但是运行在该设备上出现冻屏现象，页面轮播图无法轮播，滑动组件无法发滑动，就像卡在了这一帧上一样。点击输入框键盘能弹出，但页面是黑的。可以通过锁屏、解锁或者音量键刷新页面。</p>
<p>感觉上就是屏幕不会主动刷新，需要按物理键让屏幕刷新一次似的。  </p>
<p>询问过朋友后发现，这个现象只会出现在麒麟系列芯片的手机或平板上，看到论坛也有人咨询相同的问题。向官方提工单后官方回复是已知问题，将会在HarmonyOS next系统中修复  </p>
<p>如果只是自己写着玩，可以安装 <a href="https://github.com/Genymobile/scrcpy">scrcpy</a> 将屏幕内容同步到电脑上，在电脑上操作是没有问题的。  </p>
<p>如果是公司用，建议咨询鸿蒙运营，成为合作伙伴，直接上HarmonyOS Next进行开发。或者降低api版本。</p>
<h4 id="PersistentStorage和-StorageLink"><a href="#PersistentStorage和-StorageLink" class="headerlink" title="PersistentStorage和@StorageLink"></a>PersistentStorage和@StorageLink</h4><p>项目中有些设置需要持久化存储，于是选择了PersistentStorage和@StorageLink方式进行存储，大致如下</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>  &#125;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-title class_">PersistentStorage</span>.<span class="hljs-property">PersistProp</span>&lt;<span class="hljs-title class_">User</span>&gt;(<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;xuan&#x27;</span>,<span class="hljs-number">18</span>))<br><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">Tmp</span> &#123;<br>  <span class="hljs-meta">@StorageLink</span>(<span class="hljs-string">&#x27;user&#x27;</span>) <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&#x27;xuan&#x27;</span>, <span class="hljs-number">18</span>)<br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Text</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.user.name&#125;</span> : <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.user.age&#125;</span>`</span>)<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>当我第一运行的时候，页面显示正常，Text显示的内容是<code>xuan : 18</code><br/><br>但是当我重新打开应用(不是重新编译，就是简单的在设备上关掉应用然后点击桌面图标打开应用)的时候，Text显示内容是 <code>undefined : undefined</code><br/><br>打上断点发现重新打开应用的时候 <code>user</code> 是一个字符串类型，值为 {‘name’:’xuan’,’age’:18}，但字符串对象没有name和age属性，所以显示了 undefined.<br/><br>看到文档中有写 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/arkts-state-management-0000001504151156-V3#ZH-CN_TOPIC_0000001523808562__persistprop">https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/arkts-state-management-0000001504151156-V3#ZH-CN_TOPIC_0000001523808562__persistprop</a></p>
<blockquote>
<p>AppStorage的属性向PersistentStorage中持久化的允许的类型是：<br/><br>number，string，boolean，enum基础类型。<br/><br>Object中可序列化的属性。<br/><br>不允许undefined和null。</p>
</blockquote>
<p>但同样的，在指南中同样有PersistentStorage描述 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-persiststorage-0000001474017166-V3#section610120319595">https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-persiststorage-0000001474017166-V3#section610120319595</a></p>
<blockquote>
<p>PersistentStorage允许的类型和值有：<br/><br>number, string, boolean, enum 等简单类型。<br/><br>可以被JSON.stringify()和JSON.parse()重构的对象。例如Date, Map, Set等内置类型则不支持，以及对象的属性方法不支持持久化。<br/></p>
</blockquote>
<p>看到论坛有同样的求助，有开发者回复说他是将对象转成字符串保存的，使用的时候再parse一下。</p>
<h4 id="剪贴板-pasteboard-getSystemPasteboard"><a href="#剪贴板-pasteboard-getSystemPasteboard" class="headerlink" title="剪贴板 pasteboard.getSystemPasteboard()"></a>剪贴板 pasteboard.getSystemPasteboard()</h4><p>在使用剪贴板时需要先创建剪贴板数据，<br>创建方法如下 </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">createData</span>(<span class="hljs-attr">mimeType</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">ValueType</span>): <span class="hljs-title class_">PasteData</span>  <br><span class="hljs-title function_">createRecord</span>(<span class="hljs-attr">mimeType</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-title class_">ValueType</span>):<span class="hljs-title class_">PasteDataRecord</span><br></code></pre></td></tr></table></figure>

<p>第一个参数含义为：自定义数据的MIME类型。 文档中 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-pasteboard-0000001544384177-V3#ZH-CN_TOPIC_0000001523648478__pasteboardcreatedata9">鸿蒙开发api参考</a><br>中写的示例</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> pasteboard <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@ohos.pasteboard&#x27;</span>;<br><span class="hljs-keyword">let</span> dataXml = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br><span class="hljs-keyword">let</span> pasteDataRecord = pasteboard.<span class="hljs-title function_">createRecord</span>(<span class="hljs-string">&#x27;app/xml&#x27;</span>, dataXml);<br></code></pre></td></tr></table></figure>
<p>实际中发现时不能使用这自定义的<code>app/xml</code>值，会崩溃，只能使用pasteboard中预定义的MIME类型</p>
<h4 id="对象属性从有值变为空，应用会崩溃"><a href="#对象属性从有值变为空，应用会崩溃" class="headerlink" title="对象属性从有值变为空，应用会崩溃"></a>对象属性从有值变为空，应用会崩溃</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Entry</span><br><span class="hljs-meta">@Component</span><br>struct <span class="hljs-title class_">PlayGround</span> &#123;<br>  <span class="hljs-meta">@State</span> <span class="hljs-attr">people</span>:<span class="hljs-title class_">People</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">log</span>(<span class="hljs-attr">log</span>:<span class="hljs-built_in">string</span>):<span class="hljs-built_in">boolean</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`---------<span class="hljs-subst">$&#123;log&#125;</span>---------`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br><br>  <span class="hljs-title function_">build</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Column</span>() &#123;<br>      <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">people</span>)&#123;<br>        <span class="hljs-title class_">Text</span>(<span class="hljs-string">`姓名： <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.people.name&#125;</span>  年龄：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.people.age&#125;</span>`</span>)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">people</span>.<span class="hljs-property">address</span>)&#123;<br>          <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;address 有值&#x27;</span>))&#123;<br>            <span class="hljs-title class_">Text</span>( <span class="hljs-string">`地址： <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.people.address.name&#125;</span>  邮编：<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.people.address.zipCode&#125;</span>`</span>)<br>          &#125;<br>          <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;address 为空 内部&#x27;</span>)<br>          &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;address 为空 最外层&#x27;</span>))&#123;<br>            <span class="hljs-title class_">Text</span>(<span class="hljs-string">&#x27;address 为空 最外层&#x27;</span>)<br>          &#125;<br>        &#125;<br>      &#125;<br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;网络请求返回一个有地址的对象&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> tmpPeople = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>        <span class="hljs-keyword">let</span> tmpAddress = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>()<br>        tmpAddress.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;测试地址&#x27;</span><br>        tmpAddress.<span class="hljs-property">zipCode</span> = -<span class="hljs-number">1000</span><br>        tmpPeople.<span class="hljs-property">address</span> = tmpAddress<br><br>        tmpPeople.<span class="hljs-property">age</span> = <span class="hljs-number">10</span><br>        tmpPeople.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;有地址&#x27;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">people</span> = tmpPeople<br>      &#125;)<br><br>      <span class="hljs-title class_">Button</span>(<span class="hljs-string">&#x27;网络请求返回一个没有地址的对象&#x27;</span>).<span class="hljs-title function_">onClick</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> tmpPeople = <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>()<br>        tmpPeople.<span class="hljs-property">age</span> = <span class="hljs-number">10</span><br>        tmpPeople.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;没有地址&#x27;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">people</span> = tmpPeople<br>      &#125;)<br>    &#125;.<span class="hljs-title function_">margin</span>(&#123;<span class="hljs-attr">top</span>:<span class="hljs-number">48</span>&#125;)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Address</span>&#123;<br>  <span class="hljs-attr">zipCode</span>:<span class="hljs-built_in">number</span><br>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">People</span>&#123;<br>  <span class="hljs-attr">name</span>:<span class="hljs-built_in">string</span><br>  <span class="hljs-attr">age</span>:<span class="hljs-built_in">number</span><br>  address :<span class="hljs-title class_">Address</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>很简单的页面，展示对象属性，<br>刚开始运行，一切正常。点击返回有地址的对象，页面正常刷新并且展示。然后点击返回没有地址的对象，这时候会崩溃。<br>日志指向了 Text( <code>地址： $&#123;this.people.address.name&#125;  邮编：$&#123;this.people.address.zipCode&#125;</code>)<br>说是<code>不能从undefined对象中读取name属性</code> 具体可以看这里：<a href="https://developer.huawei.com/consumer/cn/forum/topic/0204136377582311317?fid=0102683795438680754">开发这论坛</a><br>规避方案：我有一个朋友，尝试出了使用 <code>?.</code>来规避的方法。 取对象属性除了要用if判断来控制渲染之外，需要用 <code>?.</code>来取值，防崩溃，将上面的代码修改为<br>Text( <code>地址： $&#123;this.people.address?.name&#125;  邮编：$&#123;this.people.address?.zipCode&#125;</code>)<br>应用不会崩溃，这个对象也不会渲染在页面上<br/><br>但根据文档描述，既然if条件不成立，下面的Text组件就不应该被渲染，也不应该读取address的name属性。同样提工单，回复说是双框架问题，将在HarmonyOS Next版本解决</p>
<p>需要注意的是，文档上写的被状态管理装饰器修饰的变量，基本上都不支持any、undefined、null值，但实际写代码的过程中是没有校验的，目前来看即使是这些类型或者值，也是没什么大问题的，但还是建议大家按文档写，有问题咨询相关技术人员或者论坛、提工单。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
  <entry>
    <title>鸿蒙跨平台 ArkUI-X从入门到入土</title>
    <url>/2024/03/27/%E9%B8%BF%E8%92%99%E8%B7%A8%E5%B9%B3%E5%8F%B0-ArkUI-X%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</url>
    <content><![CDATA[<hr>
<p>2024.01.31 更新<br>码完了<br><a href="https://juejin.cn/post/7329310941106421811">鸿蒙ArkUI-X 跨平台通信：从入土到复活</a><br>在本文中提到的问题又重新验证了几次，咨询了一下相关人员，结论是这样的</p>
<ol>
<li>在 Arkui-X 中，如果 Bridge 对象声明为成员变量并且立即创建，这时候 preview 会白屏，是加载界面时就挂了，因为这个bridge对象，是需要 native 侧的文件支持的，比如Android中的libbridge.so(集成产物到 Android 工程时复制过去的)。这时候集成到 Android 工程中是正常运行的。</li>
<li>DevEco 中的 preview 相当于纯鸿蒙系统(HarmonyOS next),在纯鸿蒙系统中是无法使用Bridge 的，因为纯鸿蒙上没有这个 so 库。所以在创建这个 Bridge 对象的时候需要判断一下是不是跨平台，一般从deviceInfo.osFullName判断：<br><code>let osName: string = deviceInfo.osFullName;</code>获取对应OS名字，该接口已支持跨平台，不同平台上其返回值如下:</li>
</ol>
<ul>
<li>OpenHarmony上，osName等于<code>OpenHarmony XXX</code></li>
<li>Android上，osName等于<code>Android XXX</code></li>
<li>iOS上，osName等于<code>iOS XXX</code><br>具体文档在这里 <a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/quick-start/platform-different-introduction.md#%E5%B9%B3%E5%8F%B0%E5%B7%AE%E5%BC%82%E5%8C%96">平台差异化</a></li>
</ul>
<hr>
<p>2024.01.28 更新<br><del>上面</del>文章中提到跨平台通信(Bridge)的问题在社区的帮助下解决了，方案就不要在页面(也就是@Entry修饰)中进行初始化，可以写个工具类，在工具类中初始化，虽然 debug 也是提示 undefined，但运行的时候可以正常工作。<br>新的博客记录已经在码了。。。。</p>
<hr>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>喊了好长时间要做鸿蒙应用，自己也写了一点，但要同时照顾三个移动平台有点恶心，大致看了一下鸿蒙社区的 arkui-x 跨平台方案 <a href="https://gitee.com/arkui-x">https://gitee.com/arkui-x</a> ,先调研一下试试水<br><strong>注意文章所说的官方是指社区，并不是指华为公司，更不是其他</strong></p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>丑话说在前头，先说限制，按照官方文档说法，忘记在哪里看到了<br>Android系统版本8+ 且仅 arm 设备支持<br>iOS系统版本 10+ 且仅 arm 设备支持</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>官方文档看这里：<a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/README.md">https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/README.md</a></p>
<p>官方仓库在这里：<a href="https://gitee.com/arkui-x">https://gitee.com/arkui-x</a></p>
<p>使用官方的套件还是需要申请，方式和之前一样，就是找商务谈合作，签协议。然后给账号开通下载权限然后去下载。</p>
<h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>这里我们可以使用 OpenHarmony 社区提供的开发套件</p>
<p><img src="/image/HarmonyOS/deveco.png" alt="image.png"><br>下载链接：</p>
<p><a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/release-notes/OpenHarmony-v4.0-release.md#%E9%85%8D%E5%A5%97%E5%85%B3%E7%B3%BB">https://gitee.com/openharmony/docs/blob/master/zh-cn/release-notes/OpenHarmony-v4.0-release.md#%E9%85%8D%E5%A5%97%E5%85%B3%E7%B3%BB</a></p>
<p>安装步骤都一样，<strong>注意 node 和ohpm版本</strong>，选择ide建议的版本，可以重新下载，也可以使用本机上已经安装好的，我这里用的 node是 16.20.0，不要头铁搞个 18.x.x 20.x.x的版本，可能会有一些诡异的问题</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>启动 IDE，页面左侧有diagnose可以检测一些基础配置和网络连接情况。点击左侧Customize，在右侧底部点击”All settings”进入首选项配置</p>
<p><img src="/image/HarmonyOS/deveco_customize.png" alt="image.png"></p>
<p>选择 SDK，安装 OpenHarmony SDK api 10，安装完成之后再安装 ArkUI-X</p>
<p><img src="/image/HarmonyOS/deveco_sdk.png" alt="image.png"></p>
<p>安装完成后就可以了，没有其他需要安装的了</p>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>没有提供直接创建跨平台应用的地方，目前只能用 import 的形式</p>
<p><img src="/image/HarmonyOS/deveco_import_project.png" alt="image.png"></p>
<p>找到 import Sample,新页面左上角选择 OpenHarmony，下面会出现 ArkUI-X，这里用 HelloWorld 来做示例。</p>
<p><img src="/image/HarmonyOS/select_sample_to_improt.png" alt="image.png"></p>
<p>打开工程后开始自动同步，但这里会失败，因为各种插件版本不适配，点一下蓝色的文字，会帮你全部修改好，重新同步，到这里就已经全部准备好了。</p>
<p><img src="/image/HarmonyOS/sync_failed.png" alt="image.png"></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>窗口顶部菜单 Build–&gt; Build Hap(s)&#x2F;APP(s)–&gt;Build APP(s)。会同时构建 Android 和 iOS 产物</p>
<p><img src="/image/HarmonyOS/build_result.png" alt="image.png"></p>
<p>不出意外的话出意外了，打包失败，但这时对应的资源都已经复制到相应的文件夹中了。对应的说明可以看这里</p>
<p><a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/quick-start/package-structure-guide.md">https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/quick-start/package-structure-guide.md</a></p>
<p>这时候我们进入到项目工程的 .arkui-x&#x2F;android目录下，执行 <strong>.&#x2F;gradlew assembleDebug</strong> 来编译 android 安装包。注意这里 gradlew 可能没有执行权限，<strong>chmod +x gradlew</strong> 给一下执行权限就好了。</p>
<p>对于 iOS 工程，可以用 Xcode 打开之后配置一下签名然后打包。</p>
<p>到这里，新建工程编译多平台就已经完成了。但我们有很多项目不是从头开始，部分新增内容需要使用 add-on方式，这里以 Android 为例</p>
<h3 id="添加到现有工程"><a href="#添加到现有工程" class="headerlink" title="添加到现有工程"></a>添加到现有工程</h3><p>接上面 <strong>窗口顶部菜单 Build–&gt; Build Hap(s)&#x2F;APP(s)–&gt;Build APP(s)。会同时构建 Android 和 iOS 产物</strong> 之后，对应资源文件已经复制到对相应文件夹了。</p>
<p>先准备一个 Android 项目，注意一个 ArkUI-x 跨平台的版本要求，Android 系统 8 以上，只支持 arm 设备。</p>
<p>看一下 .arkui-x&#x2F;android的代码，就一个<strong>继承自StageApplication的MyApplication</strong>和一个继承自 <strong>Activity 的EntryEntryAbilityActivity，</strong> 该类名通过通过module名和ability名拼接而得，一个ability对应一个Android工程侧的Activity类。</p>
<h4 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h4><ol>
<li>libs 下面的 jar 包和so 文件复制到 Android 工程中，注意arkui-x 的 Android 工程中指定了存放 so 文件的文件夹就是 libs，复制到 Android 工程中的时候别整错了</li>
<li>assets文件夹下的文件也原封不动的复制到 Android 工程的 assets 文件夹中</li>
<li>Android 工程中的 Application改造，这里提供了三种方式<br>  3.1 继承StageApplication</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> ohos.stage.ability.adapter.StageApplication;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HiStageApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StageApplication</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>   3.2 在 Application 中使用StageApplicationDelegate</p>
<p>这个方法和 StageApplication 源码一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Application</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StageApplicationDelegate</span> <span class="hljs-variable">appDelegate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StageApplication</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        Log.i(<span class="hljs-string">&quot;StageApplication&quot;</span>, <span class="hljs-string">&quot;StageApplication onCreate called&quot;</span>);<br>        <span class="hljs-built_in">super</span>.onCreate();<br>        <span class="hljs-built_in">this</span>.appDelegate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StageApplicationDelegate</span>();<br>        <span class="hljs-built_in">this</span>.appDelegate.initApplication(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onConfigurationChanged</span><span class="hljs-params">(Configuration newConfig)</span> &#123;<br>        Log.i(<span class="hljs-string">&quot;StageApplication&quot;</span>, <span class="hljs-string">&quot;StageApplication onConfigurationChanged called&quot;</span>);<br>        <span class="hljs-built_in">super</span>.onConfigurationChanged(newConfig);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.appDelegate == <span class="hljs-literal">null</span>) &#123;<br>            Log.e(<span class="hljs-string">&quot;StageApplication&quot;</span>, <span class="hljs-string">&quot;appDelegate is null&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.appDelegate.onConfigurationChanged(newConfig);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3.3 在 Activity 中使用 StageApplicationDelegat</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> android.app.Activity;<br><span class="hljs-keyword">import</span> ohos.stage.ability.adapter.StageApplicationDelegate;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryEntryAbilityActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StageApplicationDelegate</span> <span class="hljs-variable">appDelegate_</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        appDelegate_ = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StageApplicationDelegate</span>();<br>        appDelegate_.initApplication(<span class="hljs-built_in">this</span>.getApplication());<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<ol start="4">
<li>用于展示内容的 Activity</li>
</ol>
<p>直接复制也行，自己创建一个同名 Activity 把内容复制过来，清单文件中注册一下也行。</p>
<ol>
<li>原生拉起 arkui-x 跨平台页面并传参</li>
</ol>
<p>使用原生Activity拉起Ability时，需使用原生应用的startActivity方法，参数的传递需要通过Intent中的putExtra()进行设置，规则如下：</p>
<p>key值为params</p>
<p>value为json格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        intent.setClass(<span class="hljs-built_in">this</span>, EntryEntryAbilityTwoActivity.class);<br>        intent.putExtra(<span class="hljs-string">&quot;params&quot;</span>,<br>                <span class="hljs-string">&quot;&#123;&quot;</span>params<span class="hljs-string">&quot;:[&#123;&quot;</span>key<span class="hljs-string">&quot;:&quot;</span>bool<span class="hljs-string">&quot;,&quot;</span>type<span class="hljs-string">&quot;:1,&quot;</span>value<span class="hljs-string">&quot;:&quot;</span><span class="hljs-literal">true</span><span class="hljs-string">&quot;&#125;,&quot;</span> +<br>                <span class="hljs-string">&quot;&#123;&quot;</span>key<span class="hljs-string">&quot;:&quot;</span><span class="hljs-type">double</span><span class="hljs-string">&quot;,&quot;</span>type<span class="hljs-string">&quot;:9,&quot;</span>value<span class="hljs-string">&quot;:&quot;</span><span class="hljs-number">2.3</span><span class="hljs-string">&quot;&#125;,&quot;</span> +<br>                <span class="hljs-string">&quot;&#123;&quot;</span>key<span class="hljs-string">&quot;:&quot;</span><span class="hljs-type">int</span><span class="hljs-string">&quot;,&quot;</span>type<span class="hljs-string">&quot;:5,&quot;</span>value<span class="hljs-string">&quot;:&quot;</span><span class="hljs-number">2</span><span class="hljs-string">&quot;&#125;,&quot;</span> +<br>                <span class="hljs-string">&quot;&#123;&quot;</span>key<span class="hljs-string">&quot;:&quot;</span>string<span class="hljs-string">&quot;,&quot;</span>type<span class="hljs-string">&quot;:10,&quot;</span>value<span class="hljs-string">&quot;:&quot;</span>test<span class="hljs-string">&quot;&#125;]&#125;&quot;</span>);<br>        startActivity(intent);<br></code></pre></td></tr></table></figure>


<p>至此，集成完成。<br>在 Android 项目中调用一下就可以看到页面了</p>
<h3 id="arkui-x-和-native-通信"><a href="#arkui-x-和-native-通信" class="headerlink" title="arkui-x 和 native 通信"></a>arkui-x 和 native 通信</h3><p>原生和跨平台通信是非常重要的一个功能，也是不可或缺的一部分，官方给出了桥接平台 Bridge，在 Android、iOS 和 arkui-x 侧都有配套说明：</p>
<blockquote>
<p>平台桥接用于客户端（ArkUI）和平台（Android或iOS）之间传递消息，即用于ArkUI与平台双向数据传递、ArkUI侧调用平台的方法、平台调用ArkUI侧的方法。本文主要介绍Android平台与ArkUI交互，ArkUI侧具体用法请参考Bridge API，Android侧参考BridgePlugin。  </p>
</blockquote>
<p>这里也给出了一个<br><a href="https://gitee.com/arkui-x/docs/blob/master/zh-cn/application-dev/tutorial/how-to-use-bridge-on-android.md#%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B">场景示例</a>，但奇怪的是不能正常运行，复现步骤和现象放在这个 <a href="https://gitee.com/arkui-x/docs/issues/I8YWM2?from=project-issue">issue</a> 中了。目前是待确认状态。</p>
<p>到这里也没有需要继续下去的东西，就先入土吧，上面这个问题有答案了再挖出来继续。</p>
<hr>
<p>以上</p>
]]></content>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
</search>
